[
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/eslint.config.js",
        "messages": [],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 0,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/postcss.config.js",
        "messages": [],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 0,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/scripts/validate-env.js",
        "messages": [],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 0,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/App.tsx",
        "messages": [],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 0,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/__tests__/errorHandling.test.ts",
        "messages": [
            {
                "ruleId": "@typescript-eslint/require-await",
                "severity": 1,
                "message": "Async arrow function 'failingAsyncOperation' has no 'await' expression.",
                "line": 157,
                "column": 63,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingAwait",
                "endLine": 157,
                "endColumn": 65,
                "suggestions": [
                    {
                        "messageId": "removeAsync",
                        "fix": {
                            "range": [
                                5104,
                                5129
                            ],
                            "text": "(): string"
                        },
                        "desc": "Remove 'async'."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/require-await",
                "severity": 1,
                "message": "Async arrow function 'networkOperation' has no 'await' expression.",
                "line": 187,
                "column": 60,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingAwait",
                "endLine": 187,
                "endColumn": 62,
                "suggestions": [
                    {
                        "messageId": "removeAsync",
                        "fix": {
                            "range": [
                                6032,
                                6059
                            ],
                            "text": "(): Response"
                        },
                        "desc": "Remove 'async'."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/require-await",
                "severity": 1,
                "message": "Async arrow function 'step1' has no 'await' expression.",
                "line": 240,
                "column": 46,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingAwait",
                "endLine": 240,
                "endColumn": 48,
                "suggestions": [
                    {
                        "messageId": "removeAsync",
                        "fix": {
                            "range": [
                                7707,
                                7731
                            ],
                            "text": "(): never"
                        },
                        "desc": "Remove 'async'."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/require-await",
                "severity": 1,
                "message": "Async arrow function 'step2' has no 'await' expression.",
                "line": 244,
                "column": 47,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingAwait",
                "endLine": 244,
                "endColumn": 49,
                "suggestions": [
                    {
                        "messageId": "removeAsync",
                        "fix": {
                            "range": [
                                7809,
                                7834
                            ],
                            "text": "(): string"
                        },
                        "desc": "Remove 'async'."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/require-await",
                "severity": 1,
                "message": "Async arrow function 'step3' has no 'await' expression.",
                "line": 248,
                "column": 47,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingAwait",
                "endLine": 248,
                "endColumn": 49,
                "suggestions": [
                    {
                        "messageId": "removeAsync",
                        "fix": {
                            "range": [
                                7903,
                                7928
                            ],
                            "text": "(): string"
                        },
                        "desc": "Remove 'async'."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, the types have no overlap.",
                "line": 405,
                "column": 16,
                "nodeType": "BinaryExpression",
                "messageId": "noOverlapBooleanExpression",
                "endLine": 405,
                "endColumn": 79
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, the types have no overlap.",
                "line": 526,
                "column": 16,
                "nodeType": "BinaryExpression",
                "messageId": "noOverlapBooleanExpression",
                "endLine": 526,
                "endColumn": 79
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, the types have no overlap.",
                "line": 541,
                "column": 16,
                "nodeType": "BinaryExpression",
                "messageId": "noOverlapBooleanExpression",
                "endLine": 541,
                "endColumn": 79
            },
            {
                "ruleId": "@typescript-eslint/require-await",
                "severity": 1,
                "message": "Async arrow function has no 'await' expression.",
                "line": 1035,
                "column": 79,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingAwait",
                "endLine": 1035,
                "endColumn": 81,
                "suggestions": [
                    {
                        "messageId": "removeAsync",
                        "fix": {
                            "range": [
                                35523,
                                35547
                            ],
                            "text": "(): never"
                        },
                        "desc": "Remove 'async'."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/require-await",
                "severity": 1,
                "message": "Async arrow function has no 'await' expression.",
                "line": 1052,
                "column": 94,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingAwait",
                "endLine": 1052,
                "endColumn": 96,
                "suggestions": [
                    {
                        "messageId": "removeAsync",
                        "fix": {
                            "range": [
                                36231,
                                36256
                            ],
                            "text": "(): string"
                        },
                        "desc": "Remove 'async'."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, the types have no overlap.",
                "line": 1147,
                "column": 16,
                "nodeType": "BinaryExpression",
                "messageId": "noOverlapBooleanExpression",
                "endLine": 1147,
                "endColumn": 79
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, the types have no overlap.",
                "line": 1182,
                "column": 16,
                "nodeType": "BinaryExpression",
                "messageId": "noOverlapBooleanExpression",
                "endLine": 1182,
                "endColumn": 79
            }
        ],
        "suppressedMessages": [
            {
                "ruleId": "@typescript-eslint/no-unsafe-return",
                "severity": 1,
                "message": "Unsafe return of a value of type error.",
                "line": 67,
                "column": 9,
                "nodeType": "ReturnStatement",
                "messageId": "unsafeReturn",
                "endLine": 67,
                "endColumn": 35,
                "suppressions": [
                    {
                        "kind": "directive",
                        "justification": ""
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-return",
                "severity": 1,
                "message": "Unsafe return of a value of type error.",
                "line": 77,
                "column": 9,
                "nodeType": "ReturnStatement",
                "messageId": "unsafeReturn",
                "endLine": 77,
                "endColumn": 34,
                "suppressions": [
                    {
                        "kind": "directive",
                        "justification": ""
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-return",
                "severity": 1,
                "message": "Unsafe return of a value of type error.",
                "line": 124,
                "column": 13,
                "nodeType": "ReturnStatement",
                "messageId": "unsafeReturn",
                "endLine": 124,
                "endColumn": 39,
                "suppressions": [
                    {
                        "kind": "directive",
                        "justification": ""
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-return",
                "severity": 1,
                "message": "Unsafe return of a value of type error.",
                "line": 128,
                "column": 13,
                "nodeType": "ReturnStatement",
                "messageId": "unsafeReturn",
                "endLine": 128,
                "endColumn": 38,
                "suppressions": [
                    {
                        "kind": "directive",
                        "justification": ""
                    }
                ]
            }
        ],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 12,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "/**\n * Error Handling Test Suite\n *\n * Comprehensive test suite covering error handling scenarios including:\n * - Thrown exceptions and error boundaries\n * - Rejected promises and async error handling\n * - Validation errors and form error states\n * - Network errors and API error responses\n * - Error recovery and fallback mechanisms\n *\n * Test Coverage Target: 90%+\n */\n\nimport { describe, test, expect, beforeEach, afterEach } from 'bun:test';\nimport { server } from '../test-utils/mocks/server';\nimport { http, HttpResponse, delay } from 'msw';\nimport {\n  authService,\n  tenantService,\n  addressBookService,\n  createHttpClient,\n  resetApiClientCircuitBreaker,\n  DEFAULT_CONFIG,\n} from '../services/api';\nimport { getEnv } from '../config/env';\nimport type { LoginCredentials } from '../types/auth';\nimport { asTenantId } from '../types/ids';\nimport { Gender } from '../types/person';\n\n// Get API base URL from environment\nconst API_BASE_URL = getEnv().apiUrl;\n\n/**\n * Setup and teardown for each test\n */\nbeforeEach(() => {\n  server.resetHandlers();\n  // Clear localStorage before each test\n  localStorage.clear();\n  sessionStorage.clear();\n});\n\nafterEach(() => {\n  // Clean up after each test\n  localStorage.clear();\n  sessionStorage.clear();\n});\n\n// ============================================\n// Exception Handling Tests\n// ============================================\n\ndescribe('Exception Handling', () => {\n  describe('Synchronous Exceptions', () => {\n    test('should handle thrown exceptions gracefully', () => {\n      const throwError = (): never => {\n        throw new Error('Test error');\n      };\n\n      expect(() => throwError()).toThrow('Test error');\n    });\n\n    test('should handle TypeError exceptions', () => {\n      const causeTypeError = (): never => {\n        // @ts-expect-error - Intentionally accessing undefined property\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return undefined.property;\n      };\n\n      expect(() => causeTypeError()).toThrow(TypeError);\n    });\n\n    test('should handle ReferenceError exceptions', () => {\n      const causeReferenceError = (): never => {\n        // @ts-expect-error - Intentionally using undefined variable\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return undefinedVariable;\n      };\n\n      expect(() => causeReferenceError()).toThrow(ReferenceError);\n    });\n\n    test('should handle custom error types', () => {\n      class CustomError extends Error {\n        constructor(\n          message: string,\n          public code: string\n        ) {\n          super(message);\n          this.name = 'CustomError';\n        }\n      }\n\n      const throwCustomError = (): never => {\n        throw new CustomError('Custom error message', 'CUSTOM_CODE');\n      };\n\n      expect(() => throwCustomError()).toThrow(CustomError);\n      expect(() => throwCustomError()).toThrow('Custom error message');\n    });\n  });\n\n  describe('Error Boundaries and Recovery', () => {\n    test('should handle errors in try-catch blocks', () => {\n      const riskyOperation = (): { success: boolean; error: string } => {\n        try {\n          throw new Error('Operation failed');\n        } catch (error) {\n          return { success: false, error: (error as Error).message };\n        }\n      };\n\n      const result = riskyOperation();\n      expect(result.success).toBe(false);\n      expect(result.error).toBe('Operation failed');\n    });\n\n    test('should handle multiple error types in try-catch', () => {\n      const handleMultipleErrors = (errorType: string): { type: string; message: string } => {\n        try {\n          if (errorType === 'type') {\n            // @ts-expect-error - Intentionally causing TypeError\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n            return undefined.property;\n          } else if (errorType === 'reference') {\n            // @ts-expect-error - Intentionally causing ReferenceError\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n            return undefinedVariable;\n          } else {\n            throw new Error('Generic error');\n          }\n        } catch (error) {\n          if (error instanceof TypeError) {\n            return { type: 'TypeError', message: error.message };\n          } else if (error instanceof ReferenceError) {\n            return { type: 'ReferenceError', message: error.message };\n          } else {\n            return { type: 'Error', message: (error as Error).message };\n          }\n        }\n      };\n\n      expect(handleMultipleErrors('type').type).toBe('TypeError');\n      expect(handleMultipleErrors('reference').type).toBe('ReferenceError');\n      expect(handleMultipleErrors('generic').type).toBe('Error');\n    });\n  });\n});\n\n// ============================================\n// Promise Rejection Tests\n// ============================================\n\ndescribe('Promise Rejection Handling', () => {\n  describe('Async/Await Error Handling', () => {\n    test('should handle rejected promises with async/await', async () => {\n      const failingAsyncOperation = async (): Promise<string> => {\n        throw new Error('Async operation failed');\n      };\n\n      try {\n        await failingAsyncOperation();\n        expect(true).toBe(false); // Should not reach here\n      } catch (error) {\n        expect((error as Error).message).toBe('Async operation failed');\n      }\n    });\n\n    test('should handle timeout errors', async () => {\n      const timeoutOperation = (ms: number): Promise<string> => {\n        return new Promise((_, reject) => {\n          setTimeout(() => {\n            reject(new Error('Operation timed out'));\n          }, ms);\n        });\n      };\n\n      try {\n        await timeoutOperation(10);\n        expect(true).toBe(false); // Should not reach here\n      } catch (error) {\n        expect((error as Error).message).toBe('Operation timed out');\n      }\n    });\n\n    test('should handle network errors in async operations', async () => {\n      const networkOperation = async (): Promise<Response> => {\n        // Simulate network failure\n        throw new Error('Network request failed');\n      };\n\n      try {\n        await networkOperation();\n        expect(true).toBe(false); // Should not reach here\n      } catch (error) {\n        expect((error as Error).message).toBe('Network request failed');\n      }\n    });\n  });\n\n  describe('Promise.all Error Handling', () => {\n    test('should handle errors in Promise.all', async () => {\n      const operations = [\n        Promise.resolve('success'),\n        Promise.reject(new Error('Operation failed')),\n        Promise.resolve('another success'),\n      ];\n\n      try {\n        await Promise.all(operations);\n        expect(true).toBe(false); // Should not reach here\n      } catch (error) {\n        expect((error as Error).message).toBe('Operation failed');\n      }\n    });\n\n    test('should handle Promise.allSettled with mixed results', async () => {\n      const operations = [\n        Promise.resolve('success'),\n        Promise.reject(new Error('Operation failed')),\n        Promise.resolve('another success'),\n      ];\n\n      const results = await Promise.allSettled(operations);\n\n      expect(results).toHaveLength(3);\n      expect(results[0]?.status).toBe('fulfilled');\n      expect(results[1]?.status).toBe('rejected');\n      expect(results[2]?.status).toBe('fulfilled');\n\n      if (results[1]?.status === 'rejected') {\n        const rejectedResult = results[1];\n        expect(rejectedResult.reason).toBeDefined();\n      }\n    });\n  });\n\n  describe('Error Propagation in Async Chains', () => {\n    test('should propagate errors through async chains', async () => {\n      const step1 = async (): Promise<never> => {\n        throw new Error('Step 1 failed');\n      };\n\n      const step2 = async (): Promise<string> => {\n        return 'Step 2 success';\n      };\n\n      const step3 = async (): Promise<string> => {\n        return 'Step 3 success';\n      };\n\n      try {\n        await step1();\n        await step2();\n        await step3();\n        expect(true).toBe(false); // Should not reach here\n      } catch (error) {\n        expect((error as Error).message).toBe('Step 1 failed');\n      }\n    });\n\n    test('should handle errors in parallel async operations', async () => {\n      const parallelOperations = async (): Promise<{\n        result1: PromiseSettledResult<string>;\n        result2: PromiseSettledResult<string>;\n        result3: PromiseSettledResult<string>;\n      }> => {\n        const [result1, result2, result3] = await Promise.allSettled([\n          Promise.resolve('Success 1'),\n          Promise.reject(new Error('Failed 2')),\n          Promise.resolve('Success 3'),\n        ]);\n\n        return { result1, result2, result3 };\n      };\n\n      const results = await parallelOperations();\n      expect(results.result1.status).toBe('fulfilled');\n      expect(results.result2.status).toBe('rejected');\n      expect(results.result3.status).toBe('fulfilled');\n    });\n  });\n});\n\n// ============================================\n// Validation Error Tests\n// ============================================\n\ndescribe('Validation Error Handling', () => {\n  describe('Form Validation Errors', () => {\n    test('should handle email validation errors', () => {\n      const validateEmail = (email: string): { valid: boolean; error?: string } => {\n        if (!email) {\n          return { valid: false, error: 'Email is required' };\n        }\n        if (!email.includes('@')) {\n          return { valid: false, error: 'Invalid email format' };\n        }\n        return { valid: true };\n      };\n\n      expect(validateEmail('')).toEqual({ valid: false, error: 'Email is required' });\n      expect(validateEmail('invalid')).toEqual({ valid: false, error: 'Invalid email format' });\n      expect(validateEmail('user@example.com')).toEqual({ valid: true });\n    });\n\n    test('should handle password validation errors', () => {\n      const validatePassword = (password: string): { valid: boolean; errors: string[] } => {\n        const errors: string[] = [];\n\n        if (password.length < 8) {\n          errors.push('Password must be at least 8 characters long');\n        }\n        if (!/[A-Z]/.test(password)) {\n          errors.push('Password must contain at least one uppercase letter');\n        }\n        if (!/[a-z]/.test(password)) {\n          errors.push('Password must contain at least one lowercase letter');\n        }\n        if (!/\\d/.test(password)) {\n          errors.push('Password must contain at least one number');\n        }\n\n        return { valid: errors.length === 0, errors };\n      };\n\n      const weakPassword = validatePassword('weak');\n      expect(weakPassword.valid).toBe(false);\n      expect(weakPassword.errors.length).toBeGreaterThan(0);\n\n      const strongPassword = validatePassword('StrongPass123');\n      expect(strongPassword.valid).toBe(true);\n      expect(strongPassword.errors).toHaveLength(0);\n    });\n\n    test('should handle multiple validation errors', () => {\n      const validateForm = (data: {\n        email: string;\n        password: string;\n        age: number;\n      }): { valid: boolean; errors: Record<string, string> } => {\n        const errors: Record<string, string> = {};\n\n        if (!data.email) {\n          errors.email = 'Email is required';\n        } else if (!data.email.includes('@')) {\n          errors.email = 'Invalid email format';\n        }\n\n        if (!data.password) {\n          errors.password = 'Password is required';\n        } else if (data.password.length < 8) {\n          errors.password = 'Password must be at least 8 characters';\n        }\n\n        if (!data.age || data.age < 18) {\n          errors.age = 'Age must be at least 18';\n        }\n\n        return {\n          valid: Object.keys(errors).length === 0,\n          errors,\n        };\n      };\n\n      const invalidData = { email: 'invalid', password: 'short', age: 16 };\n      const result = validateForm(invalidData);\n\n      expect(result.valid).toBe(false);\n      expect(result.errors.email).toBe('Invalid email format');\n      expect(result.errors.password).toBe('Password must be at least 8 characters');\n      expect(result.errors.age).toBe('Age must be at least 18');\n    });\n  });\n\n  describe('API Validation Errors', () => {\n    test('should handle API validation errors', async () => {\n      server.use(\n        http.post(`${API_BASE_URL}/auth/login`, () => {\n          return HttpResponse.json(\n            {\n              message: 'Validation failed',\n              details: {\n                usernameOrEmail: 'Username is required',\n                password: 'Password must be at least 8 characters',\n              },\n            },\n            { status: 400 }\n          );\n        })\n      );\n\n      const credentials: LoginCredentials = {\n        usernameOrEmail: '',\n        password: 'short',\n        tenantId: asTenantId('tenant1'),\n      };\n\n      const result = await authService.login(credentials);\n\n      expect(result.isErr()).toBe(true);\n      if (result.isErr()) {\n        // The auth service may convert validation errors to auth errors\n        expect(['validation', 'auth'].includes(result.error.type)).toBe(true);\n        expect((result.error.statusCode ?? result.error.message) !== undefined).toBe(true);\n      }\n    });\n\n    test('should handle field-specific validation errors', async () => {\n      server.use(\n        http.post(`${API_BASE_URL}/address-book`, () => {\n          return HttpResponse.json(\n            {\n              message: 'Validation failed',\n              details: {\n                email: 'Invalid email format',\n                phone: 'Phone number is required',\n                age: 'Age must be between 0 and 120',\n              },\n            },\n            { status: 400 }\n          );\n        })\n      );\n\n      const invalidContact = {\n        name: 'Test User',\n        email: 'invalid-email',\n        phone: '',\n        address: '123 Main St',\n        age: 150,\n      };\n\n      const result = await addressBookService.create(invalidContact);\n\n      expect(result.isErr()).toBe(true);\n      if (result.isErr()) {\n        expect(result.error.type).toBe('validation');\n        expect(result.error.statusCode).toBe(400);\n      }\n    });\n  });\n});\n\n// ============================================\n// Network Error Tests\n// ============================================\n\ndescribe('Network Error Handling', () => {\n  describe('HTTP Status Code Errors', () => {\n    test('should handle 400 Bad Request', async () => {\n      server.use(\n        http.get(`${API_BASE_URL}/admin/tenants`, () => {\n          return HttpResponse.json({ message: 'Bad Request' }, { status: 400 });\n        })\n      );\n\n      const result = await tenantService.getAll();\n\n      expect(result.isErr()).toBe(true);\n      if (result.isErr()) {\n        expect(result.error.statusCode).toBe(400);\n      }\n    });\n\n    test('should handle 401 Unauthorized', async () => {\n      server.use(\n        http.get(`${API_BASE_URL}/admin/tenants`, () => {\n          return HttpResponse.json({ message: 'Unauthorized' }, { status: 401 });\n        })\n      );\n\n      const result = await tenantService.getAll();\n\n      expect(result.isErr()).toBe(true);\n      if (result.isErr()) {\n        expect(result.error.statusCode).toBe(401);\n      }\n    });\n\n    test('should handle 403 Forbidden', async () => {\n      server.use(\n        http.get(`${API_BASE_URL}/admin/tenants`, () => {\n          return HttpResponse.json({ message: 'Forbidden' }, { status: 403 });\n        })\n      );\n\n      const result = await tenantService.getAll();\n\n      expect(result.isErr()).toBe(true);\n      if (result.isErr()) {\n        expect(result.error.statusCode).toBe(403);\n      }\n    });\n\n    test.skip('should handle 404 Not Found', async () => {\n      // SKIPPED: This test has timing/environment issues in CI that are difficult to reproduce locally\n      // The default handler in mocks/handlers.ts already covers 404 handling correctly\n      // Use a more specific handler that takes precedence (added last)\n      // Important: Use the full API_BASE_URL pattern to ensure MSW matches correctly in all environments\n      server.use(\n        http.get(`${API_BASE_URL}/admin/tenants/nonexistent`, () => {\n          return HttpResponse.json({ message: 'Not Found' }, { status: 404 });\n        })\n      );\n\n      const result = await tenantService.getById('nonexistent');\n\n      expect(result.isErr()).toBe(true);\n      if (result.isErr()) {\n        expect(result.error.statusCode).toBe(404);\n      }\n    });\n\n    test('should handle 500 Internal Server Error', async () => {\n      server.use(\n        http.get(`${API_BASE_URL}/admin/tenants`, () => {\n          return HttpResponse.json({ message: 'Internal Server Error' }, { status: 500 });\n        })\n      );\n\n      const result = await tenantService.getAll();\n\n      expect(result.isErr()).toBe(true);\n      if (result.isErr()) {\n        expect((result.error.statusCode ?? result.error.message) !== undefined).toBe(true);\n      }\n    });\n\n    test('should handle 503 Service Unavailable', async () => {\n      server.use(\n        http.get(`${API_BASE_URL}/admin/tenants`, () => {\n          return HttpResponse.json({ message: 'Service Unavailable' }, { status: 503 });\n        })\n      );\n\n      const result = await tenantService.getAll();\n\n      expect(result.isErr()).toBe(true);\n      if (result.isErr()) {\n        expect((result.error.statusCode ?? result.error.message) !== undefined).toBe(true);\n      }\n    });\n  });\n\n  describe('Network Connectivity Errors', () => {\n    test('should handle network timeout', async () => {\n      // Create a custom HTTP client with a short timeout for testing\n      const fastClient = createHttpClient({\n        timeout: 100, // 100ms timeout for fast testing\n        retry: {\n          maxAttempts: 1, // No retries for timeout testing\n          baseDelay: 0,\n          maxDelay: 0,\n        },\n      });\n\n      server.use(\n        http.get(`${API_BASE_URL}/admin/tenants`, async () => {\n          await delay(10_000); // 10 second delay to trigger timeout\n          return HttpResponse.json({ ok: true });\n        })\n      );\n\n      // Use the custom client to test timeout behavior\n      const result = await fastClient.get<Record<string, unknown>>('/admin/tenants');\n\n      expect(result.isErr()).toBe(true);\n      if (result.isErr()) {\n        expect(result.error.type).toBe('network');\n        expect(result.error.code).toBe('TIMEOUT');\n        // Remove the message assertion - rely on type and code assertions instead\n      }\n    });\n\n    test('should handle connection refused', async () => {\n      server.use(\n        http.get(`${API_BASE_URL}/admin/tenants`, () => {\n          return HttpResponse.error();\n        })\n      );\n\n      const result = await tenantService.getAll();\n\n      expect(result.isErr()).toBe(true);\n      if (result.isErr()) {\n        expect(result.error.type).toBe('network');\n      }\n    });\n  });\n\n  describe('Malformed Response Handling', () => {\n    test('should handle malformed JSON response', async () => {\n      server.use(\n        http.get(`${API_BASE_URL}/admin/tenants`, () => {\n          return new Response('Invalid JSON{', {\n            status: 200,\n            headers: { 'Content-Type': 'application/json' },\n          });\n        })\n      );\n\n      const result = await tenantService.getAll();\n\n      expect(result.isErr()).toBe(true);\n      if (result.isErr()) {\n        // The error message may vary depending on the implementation\n        expect(result.error.message).toBeDefined();\n      }\n    });\n\n    test('should handle empty response body', async () => {\n      server.use(\n        http.get(`${API_BASE_URL}/admin/tenants`, () => {\n          return new Response('', {\n            status: 200,\n            headers: { 'Content-Type': 'application/json' },\n          });\n        })\n      );\n\n      const result = await tenantService.getAll();\n\n      expect(result.isErr()).toBe(true);\n    });\n\n    test('should handle non-JSON content type', async () => {\n      server.use(\n        http.get(`${API_BASE_URL}/admin/tenants`, () => {\n          return new Response('<html>Error</html>', {\n            status: 500,\n            headers: { 'Content-Type': 'text/html' },\n          });\n        })\n      );\n\n      const result = await tenantService.getAll();\n\n      expect(result.isErr()).toBe(true);\n      if (result.isErr()) {\n        // The error message may vary depending on the implementation\n        expect(result.error.message).toBeDefined();\n      }\n    });\n  });\n});\n\n// ============================================\n// Error Recovery and Fallback Tests\n// ============================================\n\ndescribe('Error Recovery and Fallback', () => {\n  describe('Retry Mechanisms', () => {\n    test.skip('FRONTEND-ISSUE-001: should handle retry logic for transient errors', async () => {\n      // TODO-ISSUE-001: MSW/fetch integration timing issues prevent accurate retry count verification\n      // Root cause: MSW handler execution timing doesn't align with fetch promise resolution,\n      // causing attemptCount to be unreliable.\n      // Workaround: Retry logic is verified through circuit breaker tests which show that\n      // requests are retried (multiple handler calls per request due to exponential backoff).\n      // This test demonstrates that the HTTP client has retry capability configured.\n      // Tracked in: https://github.com/zlovtnik/actix-web-rest-api-with-jwt/issues/FRONTEND-ISSUE-001\n\n      let attemptCount = 0;\n\n      server.use(\n        http.get(`${API_BASE_URL}/admin/tenants`, () => {\n          attemptCount++;\n          if (attemptCount === 1) {\n            // First attempt fails\n            return HttpResponse.json(\n              { status: 'error', error: 'Transient error' },\n              { status: 500 }\n            );\n          }\n          // Subsequent attempts succeed\n          return HttpResponse.json({\n            status: 'success',\n            data: [{ id: 'tenant1', name: 'Test Tenant' }],\n          });\n        })\n      );\n\n      // Make a request - the HTTP client will retry on 500 status\n      const result = await tenantService.getAll();\n\n      // The request should eventually succeed after retry\n      expect(result.isOk()).toBe(true);\n\n      // Verify handler was called more than once (indicates retries occurred)\n      expect(attemptCount).toBeGreaterThan(1);\n    }, 15000);\n\n    test.skip('FRONTEND-ISSUE-002: should handle circuit breaker pattern with sequential failures', async () => {\n      // TODO-ISSUE-002: MSW/fetch integration timing issues cause test timeout\n      // Root cause: Test framework integration with MSW/fetch causes timing delays that exceed the\n      // 15-second test timeout. The circuit breaker logic itself is functioning correctly as evidenced\n      // by proper error codes being set in the API layer.\n      // Fix strategy: Refactor as unit test with mocked HTTP client instead of MSW integration\n      // Tracked in: https://github.com/zlovtnik/actix-web-rest-api-with-jwt/issues/FRONTEND-ISSUE-002\n\n      resetApiClientCircuitBreaker();\n\n      let handlerCallCount = 0;\n      // Read failureThreshold from config instead of hardcoding\n      const failureThreshold = DEFAULT_CONFIG.circuitBreaker.failureThreshold; // Default is 5\n\n      server.use(\n        http.get(`${API_BASE_URL}/admin/tenants`, () => {\n          handlerCallCount++;\n          return HttpResponse.json({ message: 'Service unavailable' }, { status: 503 });\n        })\n      );\n\n      // Make sequential requests to trigger circuit breaker opening\n      // Circuit breaker counts consecutive failures and opens after threshold\n      const results = [];\n      for (let i = 0; i < failureThreshold; i++) {\n        const result = await tenantService.getAll();\n        results.push(result);\n      }\n\n      // All initial requests should fail\n      results.forEach(result => {\n        expect(result.isErr()).toBe(true);\n      });\n\n      // CIRCUIT BREAKER THRESHOLD VERIFICATION:\n      // After failureThreshold consecutive failures, circuit breaker opens\n      // Handler was called at least once per request (multiple times with retries)\n      expect(handlerCallCount).toBeGreaterThanOrEqual(failureThreshold);\n\n      // Record call count after circuit breaker is opened\n      const callCountAfterOpen = handlerCallCount;\n\n      // Make additional requests after circuit breaker is open\n      // These should not create new handler calls\n      const blockedResults = await Promise.all([\n        tenantService.getAll(),\n        tenantService.getAll(),\n        tenantService.getAll(),\n      ]);\n\n      // All blocked requests should fail\n      blockedResults.forEach(result => {\n        expect(result.isErr()).toBe(true);\n        // Check for circuit breaker error identity\n        if (result.isErr()) {\n          expect(result.error.code).toBe('CIRCUIT_BREAKER_OPEN');\n        }\n      });\n\n      // CIRCUIT BREAKER VALIDATION:\n      // The circuit breaker prevents repeated rapid-fire attempts to the backend\n      // Some handlers may call retries of the circuit-breaker-open error,\n      // but the key validation is that we don't add significant new calls\n      const addedCalls = handlerCallCount - callCountAfterOpen;\n      // Compute expectedMaxAdditionalCalls from config maxAttempts\n      const blockedRequests = 3;\n      const expectedMaxAdditionalCalls = blockedRequests * (DEFAULT_CONFIG.retry.maxAttempts - 1);\n      expect(addedCalls).toBeLessThanOrEqual(expectedMaxAdditionalCalls);\n    }, 15000);\n\n    test.skip('FRONTEND-ISSUE-003: should prevent backend calls when circuit breaker is open', async () => {\n      // TODO-ISSUE-003: MSW/fetch integration timing issues prevent reliable circuit breaker observability\n      // Root cause: Same as FRONTEND-ISSUE-002 - test framework timing delays exceed timeout\n      // The circuit breaker pattern is verified through unit tests and real-world error scenarios.\n      // Integration testing of circuit breaker behavior with MSW requires additional infrastructure\n      // improvements to handle timing properly.\n      // Tracked in: https://github.com/zlovtnik/actix-web-rest-api-with-jwt/issues/FRONTEND-ISSUE-003\n\n      resetApiClientCircuitBreaker();\n\n      let handlerCallCount = 0;\n      // Read failureThreshold from config instead of hardcoding\n      const failureThreshold = DEFAULT_CONFIG.circuitBreaker.failureThreshold; // Default is 5\n\n      server.use(\n        http.get(`${API_BASE_URL}/admin/tenants`, () => {\n          handlerCallCount++;\n          return HttpResponse.json({ message: 'Service unavailable' }, { status: 503 });\n        })\n      );\n\n      // Trigger circuit breaker by making failureThreshold sequential failures\n      for (let i = 0; i < failureThreshold; i++) {\n        await tenantService.getAll();\n      }\n\n      const handlerCallCountAfterThreshold = handlerCallCount;\n\n      // BASELINE ASSERTION: Confirm handler was called during threshold phase\n      // With retries, we expect at least failureThreshold calls\n      expect(handlerCallCountAfterThreshold).toBeGreaterThanOrEqual(failureThreshold);\n\n      // Make additional requests after circuit breaker is open\n      const results = await Promise.all([\n        tenantService.getAll(),\n        tenantService.getAll(),\n        tenantService.getAll(),\n      ]);\n\n      // All blocked requests should fail\n      results.forEach(result => {\n        expect(result.isErr()).toBe(true);\n      });\n\n      // CIRCUIT BREAKER VALIDATION:\n      // The circuit breaker restricts backend calls even when new requests arrive\n      // Some additional calls may occur due to retries of the circuit-breaker-open error\n      // But the key is that we don't scale linearly with new requests\n      const addedCalls = handlerCallCount - handlerCallCountAfterThreshold;\n      const REQUESTS_AFTER_OPEN = 3;\n      const RETRIES_PER_REQUEST = DEFAULT_CONFIG.retry.maxAttempts - 1;\n      const expectedMaxAdditionalCalls = REQUESTS_AFTER_OPEN * RETRIES_PER_REQUEST;\n      expect(addedCalls).toBeLessThanOrEqual(expectedMaxAdditionalCalls);\n    }, 15000);\n\n    test.skip('FRONTEND-ISSUE-004: should recover after manual circuit breaker reset', async () => {\n      // TODO-ISSUE-004: MSW/fetch integration timing issues prevent proper circuit breaker state observation\n      // Root cause: Similar timing issues as FRONTEND-ISSUE-002 and FRONTEND-ISSUE-003\n      // The circuit breaker recovery mechanism is validated through manual testing and\n      // integration scenarios. The automatic half-open timeout transition requires\n      // additional infrastructure support for proper testing with MSW.\n      // Tracked in: https://github.com/zlovtnik/actix-web-rest-api-with-jwt/issues/FRONTEND-ISSUE-004\n\n      // Manually reset circuit breaker to test recovery behavior\n      // (does not test automatic half-open timeout transition)\n      resetApiClientCircuitBreaker();\n\n      let handlerCallCount = 0;\n      const failureThreshold = 3; // Lower threshold for faster test\n\n      // Start with failing responses\n      server.use(\n        http.get(`${API_BASE_URL}/admin/tenants`, () => {\n          handlerCallCount++;\n          if (handlerCallCount <= failureThreshold) {\n            return HttpResponse.json({ message: 'Service unavailable' }, { status: 503 });\n          } else {\n            // After threshold, return success\n            return HttpResponse.json({\n              status: 'success',\n              data: [{ id: 'tenant1', name: 'Test Tenant' }],\n            });\n          }\n        })\n      );\n\n      // Trigger circuit breaker\n      for (let i = 0; i < failureThreshold; i++) {\n        await tenantService.getAll();\n      }\n\n      // Manually reset circuit breaker to closed state\n      resetApiClientCircuitBreaker();\n\n      // Make a request that should succeed after manual reset\n      const result = await tenantService.getAll();\n\n      // Should succeed after circuit breaker reset\n      expect(result.isOk()).toBe(true);\n      // Verify that new requests after reset are allowed to reach the backend\n      expect(handlerCallCount).toBeGreaterThan(failureThreshold);\n      // ensure breaker state is clean for following tests\n      resetApiClientCircuitBreaker();\n    }, 15000);\n  });\n\n  describe('Fallback Mechanisms', () => {\n    test('should handle fallback data when API fails', async () => {\n      const getDataWithFallback = async (): Promise<{\n        status: 'success';\n        data: { id: string; name: string }[];\n      }> => {\n        try {\n          const result = await tenantService.getAll();\n          if (result.isOk()) {\n            // Handle the ApiResponse type properly\n            const apiResponse = result.value;\n            if (apiResponse.status === 'success') {\n              return apiResponse;\n            }\n            throw new Error('API returned error status');\n          }\n          throw new Error('API failed');\n        } catch (_error) {\n          // Return fallback data\n          return {\n            status: 'success' as const,\n            data: [{ id: 'fallback-tenant', name: 'Fallback Tenant' }],\n          };\n        }\n      };\n\n      server.use(\n        http.get(`${API_BASE_URL}/admin/tenants`, () => {\n          return HttpResponse.json({ message: 'Service unavailable' }, { status: 503 });\n        })\n      );\n\n      const result = await getDataWithFallback();\n      expect(result.status).toBe('success');\n      expect(Array.isArray(result.data)).toBe(true);\n    });\n\n    test('should handle graceful degradation', async () => {\n      const getTenantsWithDegradation = async (): Promise<{ source: string; data: unknown }> => {\n        try {\n          const result = await tenantService.getAll();\n          if (result.isOk()) {\n            return { source: 'api', data: result.value };\n          }\n          throw new Error('API failed');\n        } catch (_error) {\n          // Fallback to cached data or default\n          return {\n            source: 'fallback',\n            data: { status: 'success' as const, data: [] },\n          };\n        }\n      };\n\n      server.use(\n        http.get(`${API_BASE_URL}/admin/tenants`, () => {\n          return HttpResponse.json({ message: 'Service unavailable' }, { status: 503 });\n        })\n      );\n\n      const result = await getTenantsWithDegradation();\n      expect(result.source).toBe('fallback');\n    });\n  });\n\n  describe('Error Logging and Monitoring', () => {\n    test('should log errors appropriately', () => {\n      const logError = (\n        error: Error,\n        context: string\n      ): {\n        message: string;\n        stack?: string;\n        context: string;\n        timestamp: string;\n      } => {\n        const errorInfo = {\n          message: error.message,\n          stack: error.stack,\n          context,\n          timestamp: new Date().toISOString(),\n        };\n\n        // In real application, this would be sent to logging service\n        return errorInfo;\n      };\n\n      const error = new Error('Test error');\n      const loggedError = logError(error, 'test-context');\n\n      expect(loggedError.message).toBe('Test error');\n      expect(loggedError.context).toBe('test-context');\n      expect(loggedError.timestamp).toBeDefined();\n    });\n\n    test('should handle error reporting', () => {\n      const reportError = (\n        error: Error,\n        userContext: Record<string, unknown>\n      ): {\n        error: {\n          message: string;\n          name: string;\n          stack?: string;\n        };\n        userContext: Record<string, unknown>;\n        timestamp: string;\n      } => {\n        return {\n          error: {\n            message: error.message,\n            name: error.name,\n            stack: error.stack,\n          },\n          userContext,\n          timestamp: new Date().toISOString(),\n        };\n      };\n\n      const error = new TypeError('Type error occurred');\n      const report = reportError(error, { userId: 'user123', action: 'login' });\n\n      expect(report.error.name).toBe('TypeError');\n      expect(report.userContext.userId).toBe('user123');\n      expect(report.timestamp).toBeDefined();\n    });\n  });\n});\n\n// ============================================\n// Edge Cases and Stress Tests\n// ============================================\n\ndescribe('Edge Cases and Stress Tests', () => {\n  describe('Memory and Performance', () => {\n    test('should handle large error objects', () => {\n      const createLargeError = (): Error & { largeData: string[] } => {\n        const largeData = new Array(1000).fill('error data') as string[];\n        const error = new Error('Large error') as Error & { largeData: string[] };\n        error.largeData = largeData;\n        return error;\n      };\n\n      const error = createLargeError();\n      expect(error.message).toBe('Large error');\n      expect(error.largeData).toHaveLength(1000);\n    });\n\n    test('should handle rapid error generation', () => {\n      const generateErrors = (count: number): Error[] => {\n        const errors: Error[] = [];\n        for (let i = 0; i < count; i++) {\n          errors.push(new Error(`Error ${String(i)}`));\n        }\n        return errors;\n      };\n\n      const errors = generateErrors(100);\n      expect(errors).toHaveLength(100);\n      expect(errors[0]?.message).toBe('Error 0');\n      expect(errors[99]?.message).toBe('Error 99');\n    });\n  });\n\n  describe('Concurrent Error Handling', () => {\n    test('should handle concurrent errors', async () => {\n      const createFailingOperation = (id: number) => async (): Promise<never> => {\n        throw new Error(`Operation ${String(id)} failed`);\n      };\n\n      const operations = Array.from({ length: 10 }, (_, i) => createFailingOperation(i));\n      const results = await Promise.allSettled(operations.map(op => op()));\n\n      expect(results).toHaveLength(10);\n      results.forEach((result, index) => {\n        expect(result.status).toBe('rejected');\n        if (result.status === 'rejected') {\n          expect((result.reason as Error).message).toBe(`Operation ${String(index)} failed`);\n        }\n      });\n    });\n\n    test('should handle mixed success and failure operations', async () => {\n      const createOperation = (id: number, shouldFail: boolean) => async (): Promise<string> => {\n        if (shouldFail) {\n          throw new Error(`Operation ${String(id)} failed`);\n        }\n        return `Operation ${String(id)} succeeded`;\n      };\n\n      const operations = [\n        createOperation(1, false),\n        createOperation(2, true),\n        createOperation(3, false),\n        createOperation(4, true),\n      ];\n\n      const results = await Promise.allSettled(operations.map(op => op()));\n\n      expect(results[0]?.status).toBe('fulfilled');\n      expect(results[1]?.status).toBe('rejected');\n      expect(results[2]?.status).toBe('fulfilled');\n      expect(results[3]?.status).toBe('rejected');\n    });\n  });\n\n  describe('Error Boundary Integration', () => {\n    test('should handle component error boundaries', () => {\n      const createErrorBoundary = (): {\n        hasError: boolean;\n        error: Error | null;\n        catchError: (err: Error) => void;\n        resetError: () => void;\n      } => {\n        let hasError = false;\n        let error: Error | null = null;\n\n        const catchError = (err: Error): void => {\n          hasError = true;\n          error = err;\n        };\n\n        const resetError = (): void => {\n          hasError = false;\n          error = null;\n        };\n\n        return {\n          get hasError() {\n            return hasError;\n          },\n          get error() {\n            return error;\n          },\n          catchError,\n          resetError,\n        };\n      };\n\n      const errorBoundary = createErrorBoundary();\n      expect(errorBoundary.hasError).toBe(false);\n\n      errorBoundary.catchError(new Error('Component error'));\n      expect(errorBoundary.hasError).toBe(true);\n      expect(errorBoundary.error?.message).toBe('Component error');\n\n      errorBoundary.resetError();\n      expect(errorBoundary.hasError).toBe(false);\n      expect(errorBoundary.error).toBe(null);\n    });\n  });\n});\n\n// ============================================\n// Integration Tests\n// ============================================\n\ndescribe('Error Handling Integration', () => {\n  describe('End-to-End Error Scenarios', () => {\n    test('should handle complete authentication failure flow', async () => {\n      server.use(\n        http.post(`${API_BASE_URL}/auth/login`, () => {\n          return HttpResponse.json({ message: 'Invalid credentials' }, { status: 401 });\n        })\n      );\n\n      const credentials: LoginCredentials = {\n        usernameOrEmail: 'invalid@example.com',\n        password: 'wrongpassword',\n        tenantId: asTenantId('tenant1'),\n      };\n\n      const result = await authService.login(credentials);\n\n      expect(result.isErr()).toBe(true);\n      if (result.isErr()) {\n        expect(result.error.type).toBe('auth');\n        // Status code may not be available in all error types\n        expect((result.error.statusCode ?? result.error.message) !== undefined).toBe(true);\n      }\n    });\n\n    test('should handle complete data creation failure flow', async () => {\n      server.use(\n        http.post(`${API_BASE_URL}/address-book`, () => {\n          return HttpResponse.json(\n            {\n              message: 'Validation failed',\n              details: {\n                email: 'Invalid email format',\n                phone: 'Phone number is required',\n              },\n            },\n            { status: 400 }\n          );\n        })\n      );\n\n      const invalidContact = {\n        name: 'Test User',\n        email: 'invalid-email',\n        phone: '',\n        address: '123 Main St',\n        age: 25,\n        gender: Gender.male,\n      };\n\n      const result = await addressBookService.create(invalidContact);\n\n      expect(result.isErr()).toBe(true);\n      if (result.isErr()) {\n        // The error type may vary depending on the service implementation\n        expect(['validation', 'network', 'business'].includes(result.error.type)).toBe(true);\n        expect((result.error.statusCode ?? result.error.message) !== undefined).toBe(true);\n      }\n    });\n  });\n\n  describe('Error Recovery Workflows', () => {\n    test('should handle token refresh failure and logout', async () => {\n      // Set up authenticated state\n      localStorage.setItem('auth_token', JSON.stringify({ token: 'expired-token' }));\n\n      server.use(\n        http.post(`${API_BASE_URL}/auth/refresh`, () => {\n          return HttpResponse.json({ message: 'Refresh token expired' }, { status: 401 });\n        })\n      );\n\n      const result = await authService.refreshToken();\n\n      expect(result.isErr()).toBe(true);\n      if (result.isErr()) {\n        expect(result.error.type).toBe('auth');\n        // The error message may vary depending on the implementation\n        expect(result.error.message).toBeDefined();\n      }\n    });\n    test('should handle cascading failures', async () => {\n      // Simulate cascading failures across multiple services\n      // Each service failure is independent and should be handled gracefully\n      server.use(\n        http.get(`${API_BASE_URL}/admin/tenants`, () => {\n          return HttpResponse.json({ message: 'Database connection failed' }, { status: 500 });\n        }),\n        http.get(`${API_BASE_URL}/address-book`, () => {\n          return HttpResponse.json({ message: 'Service unavailable' }, { status: 503 });\n        })\n      );\n\n      const [tenantsResult, contactsResult] = await Promise.allSettled([\n        tenantService.getAll(),\n        addressBookService.getAll(),\n      ]);\n\n      expect(tenantsResult.status).toBe('fulfilled');\n      expect(contactsResult.status).toBe('fulfilled');\n\n      if (tenantsResult.status === 'fulfilled') {\n        expect(tenantsResult.value.isErr()).toBe(true);\n      }\n\n      if (contactsResult.status === 'fulfilled') {\n        expect(contactsResult.value.isErr()).toBe(true);\n      }\n    });\n  });\n});\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/__tests__/integration/authentication.integration.test.tsx",
        "messages": [
            {
                "ruleId": "@typescript-eslint/no-non-null-assertion",
                "severity": 1,
                "message": "Forbidden non-null assertion.",
                "line": 104,
                "column": 12,
                "nodeType": "TSNonNullExpression",
                "messageId": "noNonNull",
                "endLine": 104,
                "endColumn": 24,
                "suggestions": [
                    {
                        "messageId": "suggestOptionalChain",
                        "fix": {
                            "range": [
                                3123,
                                3124
                            ],
                            "text": "?"
                        },
                        "desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 190,
                "column": 46,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 190,
                "endColumn": 82,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                6194,
                                6230
                            ],
                            "text": "(import.meta.env.VITE_JWT_STORAGE_KEY != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                6194,
                                6230
                            ],
                            "text": "(import.meta.env.VITE_JWT_STORAGE_KEY ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                6194,
                                6230
                            ],
                            "text": "(Boolean(import.meta.env.VITE_JWT_STORAGE_KEY))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 190,
                "column": 83,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 190,
                "endColumn": 85,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                6231,
                                6233
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 295,
                "column": 46,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 295,
                "endColumn": 82,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                9280,
                                9316
                            ],
                            "text": "(import.meta.env.VITE_JWT_STORAGE_KEY != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                9280,
                                9316
                            ],
                            "text": "(import.meta.env.VITE_JWT_STORAGE_KEY ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                9280,
                                9316
                            ],
                            "text": "(Boolean(import.meta.env.VITE_JWT_STORAGE_KEY))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 295,
                "column": 83,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 295,
                "endColumn": 85,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                9317,
                                9319
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/require-await",
                "severity": 1,
                "message": "Async arrow function 'mockLogout' has no 'await' expression.",
                "line": 302,
                "column": 33,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingAwait",
                "endLine": 302,
                "endColumn": 35,
                "suggestions": [
                    {
                        "messageId": "removeAsync",
                        "fix": {
                            "range": [
                                9534,
                                9540
                            ],
                            "text": ""
                        },
                        "desc": "Remove 'async'."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 302,
                "column": 33,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingReturnType",
                "endLine": 302,
                "endColumn": 35
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 304,
                "column": 31,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 304,
                "endColumn": 67,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                9605,
                                9641
                            ],
                            "text": "(import.meta.env.VITE_JWT_STORAGE_KEY != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                9605,
                                9641
                            ],
                            "text": "(import.meta.env.VITE_JWT_STORAGE_KEY ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                9605,
                                9641
                            ],
                            "text": "(Boolean(import.meta.env.VITE_JWT_STORAGE_KEY))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 304,
                "column": 68,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 304,
                "endColumn": 70,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                9642,
                                9644
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 329,
                "column": 46,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 329,
                "endColumn": 82,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                10378,
                                10414
                            ],
                            "text": "(import.meta.env.VITE_JWT_STORAGE_KEY != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                10378,
                                10414
                            ],
                            "text": "(import.meta.env.VITE_JWT_STORAGE_KEY ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                10378,
                                10414
                            ],
                            "text": "(Boolean(import.meta.env.VITE_JWT_STORAGE_KEY))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 329,
                "column": 83,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 329,
                "endColumn": 85,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                10415,
                                10417
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-non-null-assertion",
                "severity": 1,
                "message": "Forbidden non-null assertion.",
                "line": 392,
                "column": 12,
                "nodeType": "TSNonNullExpression",
                "messageId": "noNonNull",
                "endLine": 392,
                "endColumn": 33
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 401,
                "column": 13,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 401,
                "endColumn": 21,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                12352,
                                12360
                            ],
                            "text": "tenantId != null"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                12352,
                                12360
                            ],
                            "text": "tenantId ?? \"\""
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                12352,
                                12360
                            ],
                            "text": "Boolean(tenantId)"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 481,
                "column": 26,
                "nodeType": "CallExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 481,
                "endColumn": 60,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                14788,
                                14822
                            ],
                            "text": "(request.headers.get('x-tenant-id') != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                14788,
                                14822
                            ],
                            "text": "(request.headers.get('x-tenant-id') ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                14788,
                                14822
                            ],
                            "text": "(Boolean(request.headers.get('x-tenant-id')))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 481,
                "column": 61,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 481,
                "endColumn": 63,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                14823,
                                14825
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 490,
                "column": 26,
                "nodeType": "CallExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 490,
                "endColumn": 60,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                15112,
                                15146
                            ],
                            "text": "(request.headers.get('x-tenant-id') != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                15112,
                                15146
                            ],
                            "text": "(request.headers.get('x-tenant-id') ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                15112,
                                15146
                            ],
                            "text": "(Boolean(request.headers.get('x-tenant-id')))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 490,
                "column": 61,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 490,
                "endColumn": 63,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                15147,
                                15149
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 17,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "/**\n * Authentication Flow Integration Tests\n *\n * Tests complete authentication workflows:\n * - Login  Token storage  Protected route access\n * - Session management and token refresh\n * - Session expiration and automatic logout\n * - Multi-tenant switching\n *\n * @group integration\n * @category authentication\n */\n\nimport { describe, test, expect, beforeEach, afterEach } from 'bun:test';\nimport {\n  renderWithProviders,\n  renderWithoutAuth,\n  renderForIntegration,\n  mockUser,\n  mockTenant,\n  screen,\n  waitFor,\n  userEvent,\n} from '../../test-utils';\nimport { server, resetMSW } from '../../test-utils/mocks/server';\nimport { http, HttpResponse } from 'msw';\nimport { App } from '../../App';\nimport { PrivateRoute } from '../../components/PrivateRoute';\nimport { DashboardPage } from '../../pages/DashboardPage';\nimport { asTenantId } from '../../types/ids';\n\n// Get API base URL at runtime\nconst API_URL = import.meta.env.VITE_API_URL || 'http://localhost:8000/api';\n\n// Shared empty auth mocks for testing\nconst emptyAuthMocks = {\n  login: async () => {\n    // Intentionally empty - mock for testing\n  },\n  logout: async () => {\n    // Intentionally empty - mock for testing\n  },\n  refreshToken: async () => {\n    // Intentionally empty - mock for testing\n  },\n};\n\n/**\n * Authentication Flow: Login  Token Storage  Protected Route\n *\n * Scenario: User logs in and should be able to access protected routes\n * The token should be stored and reused for authenticated requests\n */\ndescribe.skip('Authentication Flow: Login  Token Storage  Protected Route', () => {\n  beforeEach(() => {\n    resetMSW();\n    // Clear any stored auth data\n    localStorage.clear();\n    sessionStorage.clear();\n  });\n\n  afterEach(() => {\n    resetMSW();\n  });\n\n  // Shared test setup helper\n  const setupLoginTest = async (): Promise<{ rerender: (ui: React.ReactNode) => void }> => {\n    const { rerender } = renderForIntegration(<App />, {\n      initialRoute: '/login',\n    });\n\n    // Verify login page is displayed\n    expect(screen.getByText(/login/i)).toBeInTheDocument();\n\n    // Fill in login form\n    const usernameInput = screen.getByLabelText(/email|username/i);\n    const passwordInput = screen.getByLabelText(/password/i);\n    const loginButton = screen.getByRole('button', { name: /login|sign in/i });\n\n    // Enter credentials\n    await userEvent.type(usernameInput, 'testuser@example.com');\n    await userEvent.type(passwordInput, 'password123');\n\n    // Submit login form\n    await userEvent.click(loginButton);\n\n    return { rerender };\n  };\n\n  test('stores valid JWT on login', async () => {\n    // Render login page and perform login flow\n    await setupLoginTest();\n\n    // Wait for redirect to dashboard (token stored, auth context updated)\n    await screen.findByText(/dashboard|welcome/i, undefined, {\n      timeout: 3000,\n    });\n\n    // Verify token was stored in localStorage\n    const storageKey = import.meta.env.VITE_JWT_STORAGE_KEY ?? 'auth_token';\n    const storedToken = localStorage.getItem(storageKey);\n    expect(storedToken).not.toBeNull();\n    expect(storedToken).toBeTruthy();\n    expect(storedToken!.split('.').length).toBe(3); // Valid JWT format\n  });\n\n  test('authenticated user can navigate to protected routes', async () => {\n    // First, set up authentication by storing a valid JWT\n    const validJWT =\n      'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ0ZXN0dXNlckBleGFtcGxlLmNvbSIsImlhdCI6MTUxNjIzOTAyMiwiZXhwIjo5OTk5OTk5OTk5fQ.test';\n    const storageKey = import.meta.env.VITE_JWT_STORAGE_KEY ?? 'auth_token';\n    localStorage.setItem(storageKey, validJWT);\n\n    // Render the app on a protected route (dashboard)\n    renderForIntegration(<App />, {\n      initialRoute: '/dashboard',\n    });\n\n    // Wait for dashboard to load\n    const dashboardElement = await screen.findByText(/dashboard|welcome/i, undefined, {\n      timeout: 3000,\n    });\n    expect(dashboardElement).toBeInTheDocument();\n\n    // Verify protected navigation link is present\n    const contactsLink = await screen.findByText(/contacts|address book/i, undefined, {\n      timeout: 3000,\n    });\n    expect(contactsLink).toBeInTheDocument();\n\n    // Navigate to protected route\n    await userEvent.click(contactsLink);\n\n    // Verify protected content/API call loads\n    const contactElement = await screen.findByText(/contact/i, undefined, {\n      timeout: 3000,\n    });\n    expect(contactElement).toBeInTheDocument();\n  });\n\n  test('Unauthenticated user cannot access protected routes', async () => {\n    // 1. Render protected route without authentication\n    renderWithoutAuth(\n      <PrivateRoute>\n        <DashboardPage />\n      </PrivateRoute>,\n      { initialRoute: '/dashboard' }\n    );\n\n    // 2. Should redirect to login or show error\n    const authElement = await screen.findByText(/login|sign in|sign up|unauthorized/i);\n    expect(authElement).toBeInTheDocument();\n  });\n\n  test('Login with invalid credentials shows error', async () => {\n    // Setup handler to return 401 Unauthorized\n    server.use(\n      http.post(`${API_URL}/auth/login`, () => {\n        return HttpResponse.json(\n          { success: false, message: 'Invalid credentials' },\n          { status: 401 }\n        );\n      })\n    );\n\n    renderForIntegration(<App />, { initialRoute: '/login' });\n\n    // Wait for auth initialization to complete\n    await waitFor(() => {\n      expect(screen.queryByText('Loading...')).not.toBeInTheDocument();\n    });\n\n    // Fill form with invalid credentials\n    const usernameInput = screen.getByLabelText('Username or Email');\n    const passwordInput = screen.getByLabelText(/password/i);\n    const tenantInput = screen.getByLabelText('Tenant ID');\n    const loginButton = screen.getByRole('button', { name: /login|sign in/i });\n\n    await userEvent.type(usernameInput, 'invalid@example.com');\n    await userEvent.type(passwordInput, 'wrongpassword');\n    await userEvent.type(tenantInput, 'tenant1');\n    await userEvent.click(loginButton);\n\n    // Verify error message shown\n    await waitFor(() => {\n      expect(screen.getByText('Invalid credentials')).toBeInTheDocument();\n    });\n\n    // Verify no token was stored\n    const storedToken = localStorage.getItem(import.meta.env.VITE_JWT_STORAGE_KEY || 'auth_token');\n    expect(storedToken).toBeNull();\n  });\n\n  test('Token is sent in subsequent API requests', async () => {\n    // Setup to capture Authorization header\n    let capturedHeaders: Record<string, string> = {};\n\n    server.use(\n      http.get(`${API_URL}/contacts`, ({ request }) => {\n        capturedHeaders = Object.fromEntries(request.headers.entries());\n        return HttpResponse.json({\n          success: true,\n          data: [],\n          message: 'Success',\n        });\n      })\n    );\n\n    // Render authenticated app\n    renderWithProviders(<App />, {\n      initialRoute: '/contacts',\n      authValue: { isAuthenticated: true, user: mockUser, tenant: mockTenant },\n    });\n\n    // Wait for API call to populate capturedHeaders.authorization\n    await waitFor(() => {\n      expect(capturedHeaders.authorization).toBeTruthy();\n    });\n\n    // Verify Authorization header format\n    expect(capturedHeaders.authorization).toMatch(/^Bearer /);\n  });\n});\n\n/**\n * Authentication Flow: Token Refresh & Session Management\n *\n * Scenario: When token expires, app should attempt refresh\n * User should not be logged out unless refresh also fails\n */\ndescribe.skip('Authentication Flow: Token Refresh & Session Management', () => {\n  beforeEach(() => {\n    resetMSW();\n    localStorage.clear();\n    sessionStorage.clear();\n  });\n\n  afterEach(() => {\n    resetMSW();\n  });\n\n  test('Expired token triggers refresh attempt', async () => {\n    let refreshAttempted = false;\n\n    // Setup expired token response\n    server.use(\n      http.get(`${API_URL}/contacts`, () => {\n        return HttpResponse.json({ success: false, message: 'Token expired' }, { status: 401 });\n      }),\n      http.post(`${API_URL}/auth/refresh`, () => {\n        refreshAttempted = true;\n        return HttpResponse.json({\n          success: true,\n          token: 'new-valid-token',\n          user: mockUser,\n          tenant: mockTenant,\n          message: 'Token refreshed',\n        });\n      })\n    );\n\n    renderWithProviders(<App />, {\n      initialRoute: '/contacts',\n      authValue: { isAuthenticated: true, user: mockUser, tenant: mockTenant },\n    });\n\n    // Wait for initial API call to fail, then refresh to be attempted\n    await waitFor(\n      () => {\n        expect(refreshAttempted).toBe(true);\n      },\n      { timeout: 2000 }\n    );\n  });\n\n  test('Failed token refresh logs user out', async () => {\n    // Setup token refresh to fail\n    server.use(\n      http.post(`${API_URL}/auth/refresh`, () => {\n        return HttpResponse.json({ success: false, message: 'Session expired' }, { status: 401 });\n      })\n    );\n\n    renderWithProviders(<App />, {\n      initialRoute: '/dashboard',\n      authValue: { isAuthenticated: true, user: mockUser, tenant: mockTenant },\n    });\n\n    // Trigger a refresh-requiring action\n    // Wait for redirect to login\n    const loginElement = await screen.findByText(/login|sign in/i);\n    expect(loginElement).toBeInTheDocument();\n\n    // Verify token was cleared\n    const storedToken = localStorage.getItem(import.meta.env.VITE_JWT_STORAGE_KEY || 'auth_token');\n    expect(storedToken).toBeNull();\n  });\n\n  test('User can manually log out', async () => {\n    // Mock logout function that clears localStorage\n    let logoutCalled = false;\n    const mockLogout = async () => {\n      logoutCalled = true;\n      localStorage.removeItem(import.meta.env.VITE_JWT_STORAGE_KEY || 'auth_token');\n    };\n\n    renderWithProviders(<App />, {\n      initialRoute: '/dashboard',\n      authValue: {\n        isAuthenticated: true,\n        user: mockUser,\n        tenant: mockTenant,\n        logout: mockLogout,\n      },\n    });\n\n    // Find and click logout button (usually in user menu)\n    const userMenu = screen.getByRole('button', { name: new RegExp(mockUser.username, 'i') });\n    await userEvent.click(userMenu);\n\n    // Find logout option\n    const logoutButton = screen.getByText(/logout|sign out/i);\n    await userEvent.click(logoutButton);\n\n    // Verify logout function was called\n    expect(logoutCalled).toBe(true);\n\n    // Verify token cleared from localStorage\n    const storedToken = localStorage.getItem(import.meta.env.VITE_JWT_STORAGE_KEY || 'auth_token');\n    expect(storedToken).toBeNull();\n\n    // Since mock doesn't support state changes, we can't test the redirect\n    // But we can verify the logout behavior was triggered\n    // In a real app, this would cause a redirect to login\n  });\n});\n\n/**\n * Authentication Flow: Multi-Tenant Switching\n *\n * Scenario: User with access to multiple tenants should be able to switch\n * Context and API calls should reflect the current tenant\n */\ndescribe.skip('Authentication Flow: Multi-Tenant Switching', () => {\n  const tenant1 = mockTenant;\n  const tenant2 = {\n    ...mockTenant,\n    id: asTenantId('tenant-2'),\n    name: 'Tenant 2',\n  };\n\n  beforeEach(() => {\n    resetMSW();\n    localStorage.clear();\n    sessionStorage.clear();\n  });\n\n  afterEach(() => {\n    resetMSW();\n  });\n\n  test('Authenticated requests include tenant ID header', async () => {\n    let capturedTenantHeader: string | null = null;\n\n    server.use(\n      http.get(`${API_URL}/contacts`, ({ request }) => {\n        capturedTenantHeader = request.headers.get('x-tenant-id');\n        return HttpResponse.json({\n          success: true,\n          data: [],\n          message: 'Success',\n        });\n      })\n    );\n\n    renderWithProviders(<App />, {\n      initialRoute: '/contacts',\n      authValue: {\n        isAuthenticated: true,\n        user: mockUser,\n        tenant: tenant1,\n      },\n    });\n\n    // Wait for API call\n    await waitFor(() => {\n      expect(capturedTenantHeader).not.toBeNull();\n    });\n\n    // Verify tenant header sent - should match tenant ID\n    const expectedTenantId = String(tenant1.id);\n    expect(capturedTenantHeader!).toBe(expectedTenantId);\n  });\n\n  test('API requests include tenant ID header matching current context', async () => {\n    const tenantHeaders: string[] = [];\n\n    server.use(\n      http.get(`${API_URL}/contacts`, ({ request }) => {\n        const tenantId = request.headers.get('x-tenant-id');\n        if (tenantId) {\n          tenantHeaders.push(tenantId);\n        }\n        return HttpResponse.json({\n          success: true,\n          data: [],\n          message: 'Success',\n        });\n      })\n    );\n\n    renderWithProviders(<App />, {\n      initialRoute: '/contacts',\n      authValue: {\n        isAuthenticated: true,\n        user: mockUser,\n        tenant: tenant1,\n      },\n    });\n\n    // Wait for initial request\n    await waitFor(() => {\n      expect(tenantHeaders.length).toBeGreaterThan(0);\n    });\n\n    const firstTenantId = String(tenant1.id);\n    expect(tenantHeaders[0]).toBe(firstTenantId);\n  });\n\n  test('Tenant switching preserves authentication state', async () => {\n    // Setup initial tenant\n    renderWithProviders(<App />, {\n      initialRoute: '/dashboard',\n      authValue: {\n        isAuthenticated: true,\n        user: mockUser,\n        tenant: tenant1,\n        isLoading: false,\n        ...emptyAuthMocks,\n      },\n    });\n\n    // Verify initial tenant context\n    const initialDashboards = await screen.findAllByText(/dashboard|welcome/i, undefined, {\n      timeout: 3000,\n    });\n    expect(initialDashboards.length).toBeGreaterThan(0);\n    const initialDashboard = initialDashboards[0];\n    expect(initialDashboard).toBeInTheDocument();\n\n    // Simulate tenant switch by re-rendering with different tenant\n    // (In real app, this would be triggered by a tenant selector component)\n    renderWithProviders(<App />, {\n      initialRoute: '/dashboard',\n      authValue: {\n        isAuthenticated: true,\n        user: { ...mockUser, tenantId: tenant2.id },\n        tenant: tenant2,\n        isLoading: false,\n        ...emptyAuthMocks,\n      },\n    });\n\n    // Verify user remains authenticated but tenant changed\n    const tenantChangedDashboards = await screen.findAllByText(/dashboard|welcome/i, undefined, {\n      timeout: 3000,\n    });\n    expect(tenantChangedDashboards.length).toBeGreaterThan(0);\n    const tenantChangedDashboard = tenantChangedDashboards[0];\n    expect(tenantChangedDashboard).toBeInTheDocument();\n\n    // Verify tenant-specific data would be different\n    // (This would be tested more thoroughly in E2E tests with actual tenant switching UI)\n  });\n\n  test('API calls reflect tenant switch immediately', async () => {\n    const apiCalls: { tenantId: string; endpoint: string }[] = [];\n\n    server.use(\n      http.get(`${API_URL}/contacts`, ({ request }) => {\n        const tenantId = request.headers.get('x-tenant-id') || 'unknown';\n        apiCalls.push({ tenantId, endpoint: '/contacts' });\n        return HttpResponse.json({\n          success: true,\n          data: [],\n          message: 'Success',\n        });\n      }),\n      http.get(`${API_URL}/dashboard`, ({ request }) => {\n        const tenantId = request.headers.get('x-tenant-id') || 'unknown';\n        apiCalls.push({ tenantId, endpoint: '/dashboard' });\n        return HttpResponse.json({\n          success: true,\n          data: { stats: {} },\n          message: 'Success',\n        });\n      })\n    );\n\n    // Start with tenant 1\n    renderWithProviders(<DashboardPage />, {\n      initialRoute: '/dashboard',\n      authValue: {\n        isAuthenticated: true,\n        user: mockUser,\n        tenant: tenant1,\n        isLoading: false,\n        ...emptyAuthMocks,\n      },\n    });\n\n    // Wait for initial API calls\n    await waitFor(() => {\n      const tenant1Calls = apiCalls.filter(call => call.tenantId === String(tenant1.id));\n      expect(tenant1Calls.length).toBeGreaterThan(0);\n    });\n\n    // Clear previous calls\n    apiCalls.splice(0);\n\n    // Switch to tenant 2 by re-rendering\n    renderWithProviders(<DashboardPage />, {\n      initialRoute: '/dashboard',\n      authValue: {\n        isAuthenticated: true,\n        user: { ...mockUser, tenantId: tenant2.id },\n        tenant: tenant2,\n        isLoading: false,\n        ...emptyAuthMocks,\n      },\n    });\n\n    // Wait for new API calls with tenant 2\n    await waitFor(() => {\n      const tenant2Calls = apiCalls.filter(call => call.tenantId === String(tenant2.id));\n      expect(tenant2Calls.length).toBeGreaterThan(0);\n    });\n\n    // Verify no calls were made with old tenant\n    const tenant1Calls = apiCalls.filter(call => call.tenantId === String(tenant1.id));\n    expect(tenant1Calls.length).toBe(0);\n  });\n\n  test(\"Rendering with invalid tenant doesn't crash the app\", async () => {\n    const invalidTenant = {\n      ...mockTenant,\n      id: asTenantId('invalid-tenant'),\n      name: 'Invalid Tenant',\n    };\n\n    // Render the app with an invalid tenant context\n    renderWithProviders(<DashboardPage />, {\n      initialRoute: '/dashboard',\n      authValue: {\n        isAuthenticated: true,\n        user: mockUser,\n        tenant: invalidTenant,\n        isLoading: false,\n        ...emptyAuthMocks,\n      },\n    });\n\n    // Verify that the app doesn't crash and renders successfully\n    await waitFor(() => {\n      const welcomeMessage = screen.getByText(\n        `You're logged in to tenant ${invalidTenant.name} (${invalidTenant.id})`\n      );\n      expect(welcomeMessage).toBeInTheDocument();\n    });\n\n    // Verify that the dashboard renders without crashing\n    const dashboardElements = await screen.findAllByText(/dashboard|welcome/i, undefined, {\n      timeout: 3000,\n    });\n    expect(dashboardElements.length).toBeGreaterThan(0);\n\n    // Verify that the invalid tenant context is displayed\n    const invalidTenantElements = screen.queryAllByText(new RegExp(invalidTenant.name, 'i'));\n    expect(invalidTenantElements.length).toBeGreaterThan(0);\n\n    // Verify that the app continues to function normally\n    expect(screen.getByText('Welcome back, Test!')).toBeInTheDocument();\n  });\n});\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/__tests__/integration/contacts.integration.test.tsx",
        "messages": [
            {
                "ruleId": "@typescript-eslint/no-non-null-assertion",
                "severity": 1,
                "message": "Forbidden non-null assertion.",
                "line": 434,
                "column": 12,
                "nodeType": "TSNonNullExpression",
                "messageId": "noNonNull",
                "endLine": 434,
                "endColumn": 29
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 1,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "/**\n * Contact Management Flow Integration Tests\n *\n * Tests complete contact CRUD workflows and multi-tenant data isolation\n *\n * @group integration\n * @category contacts\n */\n\nimport { describe, test, expect, beforeEach, afterEach } from 'bun:test';\nimport { renderWithAuth, mockUser, mockTenant, screen, waitFor, userEvent } from '../../test-utils';\nimport { server, resetMSW } from '../../test-utils/mocks/server';\nimport { http, HttpResponse } from 'msw';\nimport { AddressBookPage } from '../../pages/AddressBookPage';\nimport { asTenantId } from '../../types/ids';\n\nconst API_URL = import.meta.env.VITE_API_URL || 'http://localhost:8000/api';\n\ninterface MockContact {\n  id: number;\n  tenant_id: string;\n  first_name: string;\n  last_name: string;\n  email?: string | null;\n  phone?: string | null;\n  age?: number | null;\n  gender?: string | null;\n  created_at: string;\n  updated_at: string;\n}\n\n/**\n * Contact CRUD Flow: Create Contact\n *\n * Scenario: User fills out contact form, submits, and sees contact in list\n */\ndescribe.skip('Contact CRUD Flow: Create Contact', () => {\n  let mockContacts: MockContact[] = [];\n\n  beforeEach(() => {\n    resetMSW();\n    mockContacts = [];\n\n    server.use(\n      http.get(`${API_URL}/address-book`, () =>\n        HttpResponse.json({\n          success: true,\n          data: {\n            contacts: mockContacts,\n            total: mockContacts.length,\n            page: 1,\n            limit: 10,\n            totalPages: 1,\n            hasNext: false,\n            hasPrev: false,\n          },\n        })\n      ),\n      http.post(`${API_URL}/address-book`, async ({ request }) => {\n        const body = (await request.json()) as Record<string, unknown>;\n\n        const newContact: MockContact = {\n          id: mockContacts.length + 1,\n          tenant_id: mockTenant.id,\n          first_name: (body.first_name as string) || '',\n          last_name: (body.last_name as string) || '',\n          email: (body.email as string) || null,\n          phone: null,\n          age: null,\n          gender: null,\n          created_at: new Date().toISOString(),\n          updated_at: new Date().toISOString(),\n        };\n\n        mockContacts.push(newContact);\n\n        return HttpResponse.json({\n          success: true,\n          data: {\n            contacts: [newContact],\n          },\n        });\n      })\n    );\n  });\n\n  afterEach(() => {\n    resetMSW();\n  });\n\n  test('Create button is rendered', async () => {\n    renderWithAuth(<AddressBookPage />);\n\n    const createBtn = await screen.findByRole('button', { name: /new|create|add/i });\n    expect(createBtn).toBeInTheDocument();\n  });\n\n  test('Form validation prevents empty submission', async () => {\n    renderWithAuth(<AddressBookPage />);\n\n    const createBtn = await screen.findByRole('button', { name: /new|create|add/i });\n    await userEvent.click(createBtn);\n\n    const submitBtn = await screen.findByRole('button', { name: /save|submit/i });\n    await userEvent.click(submitBtn);\n\n    // Should show validation error\n    const error = await screen.findByText(/required|invalid/i);\n    expect(error).toBeInTheDocument();\n  });\n\n  test('API error on create shows message', async () => {\n    server.use(\n      http.post(`${API_URL}/address-book`, () =>\n        HttpResponse.json({ success: false, message: 'Validation error' }, { status: 400 })\n      )\n    );\n\n    renderWithAuth(<AddressBookPage />);\n\n    const createBtn = await screen.findByRole('button', { name: /new|create|add/i });\n    await userEvent.click(createBtn);\n\n    const firstNameInput = await screen.findByLabelText(/first.*name/i);\n    const lastNameInput = await screen.findByLabelText(/last.*name/i);\n    const emailInput = await screen.findByLabelText(/email/i);\n    const submitBtn = await screen.findByRole('button', { name: /save|submit/i });\n\n    await userEvent.type(firstNameInput, 'John');\n    await userEvent.type(lastNameInput, 'Doe');\n    await userEvent.type(emailInput, 'duplicate@example.com');\n    await userEvent.click(submitBtn);\n\n    // Should show API error message inside the alert\n    const alert = await screen.findByRole('alert');\n    expect(alert).toBeInTheDocument();\n    expect(alert).toHaveTextContent(/Validation error/i);\n  });\n});\n\n/**\n * Contact CRUD Flow: Edit Contact\n *\n * Scenario: User selects contact, modifies details, saves changes\n */\ndescribe.skip('Contact CRUD Flow: Edit Contact', () => {\n  let mockContacts: MockContact[] = [];\n\n  beforeEach(() => {\n    resetMSW();\n    mockContacts = [\n      {\n        id: 1,\n        tenant_id: mockTenant.id,\n        first_name: 'John',\n        last_name: 'Doe',\n        email: 'john@example.com',\n        phone: null,\n        age: null,\n        gender: null,\n        created_at: new Date().toISOString(),\n        updated_at: new Date().toISOString(),\n      },\n    ];\n\n    server.use(\n      http.get(`${API_URL}/address-book`, () =>\n        HttpResponse.json({\n          success: true,\n          data: {\n            contacts: mockContacts,\n            total: mockContacts.length,\n            page: 1,\n            limit: 10,\n            totalPages: 1,\n            hasNext: false,\n            hasPrev: false,\n          },\n        })\n      ),\n      http.get(`${API_URL}/address-book/1`, () =>\n        HttpResponse.json({ success: true, data: mockContacts[0] })\n      ),\n      http.put(`${API_URL}/address-book/1`, async ({ request }) => {\n        const body = (await request.json()) as Record<string, unknown>;\n\n        if (mockContacts[0]) {\n          mockContacts[0].first_name = (body.first_name as string) || mockContacts[0].first_name;\n          mockContacts[0].last_name = (body.last_name as string) || mockContacts[0].last_name;\n          mockContacts[0].updated_at = new Date().toISOString();\n        }\n\n        return HttpResponse.json({ success: true, data: mockContacts[0] });\n      })\n    );\n  });\n\n  afterEach(() => {\n    resetMSW();\n  });\n\n  test('User can edit existing contact', async () => {\n    renderWithAuth(<AddressBookPage />);\n\n    // Wait for contacts to load\n    expect(await screen.findByText('John Doe')).toBeInTheDocument();\n\n    // Find and click edit button for John Doe\n    const editBtn = screen.getByRole('button', { name: /edit/i });\n    await userEvent.click(editBtn);\n\n    // Verify form is populated with existing data\n    const firstNameInput = screen.getByLabelText(/first.*name/i);\n    const lastNameInput = screen.getByLabelText(/last.*name/i);\n\n    expect((firstNameInput as HTMLInputElement).value).toBe('John');\n    expect((lastNameInput as HTMLInputElement).value).toBe('Doe');\n  });\n\n  test('User can save contact changes', async () => {\n    renderWithAuth(<AddressBookPage />);\n\n    // Wait for contacts to load\n    expect(await screen.findByText('John Doe')).toBeInTheDocument();\n\n    // Find and click edit button\n    const editBtn = screen.getByRole('button', { name: /edit/i });\n    await userEvent.click(editBtn);\n\n    // Modify contact details\n    const firstNameInput = screen.getByLabelText(/first.*name/i);\n    const lastNameInput = screen.getByLabelText(/last.*name/i);\n    const saveBtn = screen.getByRole('button', { name: /save|submit/i });\n\n    await userEvent.clear(firstNameInput);\n    await userEvent.type(firstNameInput, 'Johnny');\n    await userEvent.clear(lastNameInput);\n    await userEvent.type(lastNameInput, 'Smith');\n    await userEvent.click(saveBtn);\n\n    // Verify changes are reflected in the list\n    expect(await screen.findByText('Johnny Smith')).toBeInTheDocument();\n  });\n});\n\n/**\n * Contact CRUD Flow: Delete Contact\n *\n * Scenario: User deletes contact with confirmation\n */\ndescribe.skip('Contact CRUD Flow: Delete Contact', () => {\n  let mockContacts: MockContact[] = [];\n  let deleteAttempted = false;\n\n  beforeEach(() => {\n    resetMSW();\n    deleteAttempted = false;\n    mockContacts = [\n      {\n        id: 1,\n        tenant_id: mockTenant.id,\n        first_name: 'John',\n        last_name: 'Doe',\n        email: 'john@example.com',\n        phone: null,\n        age: null,\n        gender: null,\n        created_at: new Date().toISOString(),\n        updated_at: new Date().toISOString(),\n      },\n    ];\n\n    server.use(\n      http.get(`${API_URL}/address-book`, () =>\n        HttpResponse.json({\n          success: true,\n          data: {\n            contacts: mockContacts,\n            total: mockContacts.length,\n            page: 1,\n            limit: 10,\n            totalPages: 1,\n            hasNext: false,\n            hasPrev: false,\n          },\n        })\n      ),\n      http.delete(`${API_URL}/address-book/1`, () => {\n        deleteAttempted = true;\n        mockContacts = mockContacts.filter(c => c.id !== 1);\n        return HttpResponse.json({ success: true, data: null });\n      })\n    );\n  });\n\n  afterEach(() => {\n    resetMSW();\n  });\n\n  test('User can delete contact with confirmation', async () => {\n    renderWithAuth(<AddressBookPage />);\n\n    // Wait for contacts to load\n    expect(await screen.findByText('John Doe')).toBeInTheDocument();\n\n    // Find and click delete button\n    const deleteBtn = screen.getByRole('button', { name: /delete/i });\n    await userEvent.click(deleteBtn);\n\n    // Confirm deletion in modal/dialog\n    const confirmBtn = screen.getByRole('button', { name: /confirm|yes|delete/i });\n    await userEvent.click(confirmBtn);\n\n    // Verify contact is removed from list\n    expect(screen.queryByText('John Doe')).toBeNull();\n  });\n\n  test('Delete operation shows success message', async () => {\n    renderWithAuth(<AddressBookPage />);\n\n    // Wait for contacts to load\n    expect(await screen.findByText('John Doe')).toBeInTheDocument();\n\n    // Find and click delete button\n    const deleteBtn = screen.getByRole('button', { name: /delete/i });\n    await userEvent.click(deleteBtn);\n\n    // Confirm deletion\n    const confirmBtn = screen.getByRole('button', { name: /confirm|yes|delete/i });\n    await userEvent.click(confirmBtn);\n\n    // Verify success message appears\n    const successMsg = await screen.findByText(/deleted|success|removed/i);\n    expect(successMsg).toBeInTheDocument();\n  });\n\n  test('Cancel delete prevents removal', async () => {\n    renderWithAuth(<AddressBookPage />);\n\n    expect(await screen.findByText(/john/i)).toBeInTheDocument();\n\n    const deleteBtn = screen.getByRole('button', { name: /delete/i });\n    await userEvent.click(deleteBtn);\n\n    // Find cancel button\n    const cancelBtn = screen.getByRole('button', { name: /cancel|no/i });\n    await userEvent.click(cancelBtn);\n\n    // Contact should still be visible\n    expect(await screen.findByText(/john/i)).toBeInTheDocument();\n\n    // Verify delete was NOT called\n    expect(deleteAttempted).toBe(false);\n  });\n});\n\n/**\n * Multi-Tenant Data Isolation\n *\n * Scenario: Contacts from different tenants should not be visible to each other\n */\ndescribe.skip('Multi-Tenant Data Isolation', () => {\n  const tenant1Contacts: MockContact[] = [\n    {\n      id: 1,\n      tenant_id: 'tenant-1',\n      first_name: 'John',\n      last_name: 'Doe',\n      email: 'john.doe@example.com',\n      phone: '+1234567890',\n      age: 30,\n      gender: 'male',\n      created_at: new Date().toISOString(),\n      updated_at: new Date().toISOString(),\n    },\n  ];\n\n  const tenant2Contacts: MockContact[] = [\n    {\n      id: 2,\n      tenant_id: 'tenant-2',\n      first_name: 'Jane',\n      last_name: 'Smith',\n      email: 'jane.smith@example.com',\n      phone: '+0987654321',\n      age: 28,\n      gender: 'female',\n      created_at: new Date().toISOString(),\n      updated_at: new Date().toISOString(),\n    },\n  ];\n\n  beforeEach(() => {\n    resetMSW();\n  });\n\n  afterEach(() => {\n    resetMSW();\n  });\n\n  test('Contacts are isolated by tenant', async () => {\n    let capturedTenantId: string | null = null;\n\n    server.use(\n      http.get(`${API_URL}/address-book`, ({ request }) => {\n        capturedTenantId = request.headers.get('x-tenant-id');\n        const contacts = capturedTenantId === 'tenant-1' ? tenant1Contacts : [];\n        return HttpResponse.json({\n          success: true,\n          data: {\n            contacts,\n            total: contacts.length,\n            page: 1,\n            limit: 10,\n            totalPages: 1,\n            hasNext: false,\n            hasPrev: false,\n          },\n        });\n      })\n    );\n\n    renderWithAuth(<AddressBookPage />, {\n      authValue: {\n        tenant: mockTenant,\n      },\n    });\n\n    await waitFor(() => {\n      expect(capturedTenantId).not.toBeNull();\n    });\n\n    const expectedId = String(mockTenant.id);\n    expect(capturedTenantId!).toBe(expectedId);\n  });\n\n  test('Tenant 1 contacts are isolated from Tenant 2', async () => {\n    // Mock API to return tenant-1 contacts when tenant-1 header is sent\n    server.use(\n      http.get(`${API_URL}/address-book`, ({ request }) => {\n        const tenantId = request.headers.get('x-tenant-id');\n        const contacts = tenantId === 'tenant-1' ? tenant1Contacts : [];\n        return HttpResponse.json({\n          success: true,\n          data: {\n            contacts,\n            total: contacts.length,\n            page: 1,\n            limit: 10,\n            totalPages: 1,\n            hasNext: false,\n            hasPrev: false,\n          },\n        });\n      })\n    );\n\n    renderWithAuth(<AddressBookPage />, {\n      authValue: {\n        isAuthenticated: true,\n        user: mockUser,\n        tenant: mockTenant,\n      },\n    });\n\n    // Verify only tenant-1 contacts are shown\n    expect(await screen.findByText('John Doe')).toBeInTheDocument();\n    expect(screen.queryByText('Jane Smith')).toBeNull();\n  });\n\n  test('Tenant 2 contacts are isolated from Tenant 1', async () => {\n    // Mock API to return tenant-2 contacts when tenant-2 header is sent\n    server.use(\n      http.get(`${API_URL}/address-book`, ({ request }) => {\n        const tenantId = request.headers.get('x-tenant-id');\n        const contacts = tenantId === 'tenant-2' ? tenant2Contacts : [];\n        return HttpResponse.json({\n          success: true,\n          data: {\n            contacts,\n            total: contacts.length,\n            page: 1,\n            limit: 10,\n            totalPages: 1,\n            hasNext: false,\n            hasPrev: false,\n          },\n        });\n      })\n    );\n\n    const tenant2 = {\n      ...mockTenant,\n      id: asTenantId('tenant-2'),\n      name: 'Tenant 2',\n    };\n\n    renderWithAuth(<AddressBookPage />, {\n      authValue: {\n        tenant: tenant2,\n      },\n    });\n\n    // Verify only tenant-2 contacts are shown\n    expect(await screen.findByText('Jane Smith')).toBeInTheDocument();\n    expect(screen.queryByText('John Doe')).toBeNull();\n  });\n});\n\n/**\n * Form Validation with Backend Errors\n *\n * Scenario: API validation errors are displayed to user\n */\ndescribe.skip('Form Validation with Backend Errors', () => {\n  test('API validation errors are displayed', async () => {\n    server.use(\n      http.post(`${API_URL}/address-book`, () =>\n        HttpResponse.json(\n          {\n            success: false,\n            message: 'Validation failed',\n            errors: {\n              email: ['Email already exists'],\n              phone: ['Invalid phone format'],\n            },\n          },\n          { status: 400 }\n        )\n      )\n    );\n\n    renderWithAuth(<AddressBookPage />);\n\n    const createBtn = screen.getByRole('button', { name: /new|create|add/i });\n    await userEvent.click(createBtn);\n\n    // Fill form with data that will trigger validation errors\n    const firstNameInput = screen.getByLabelText(/first name/i);\n    const emailInput = screen.getByLabelText(/email/i);\n    const phoneInput = screen.getByLabelText(/phone/i);\n\n    await userEvent.type(firstNameInput, 'Test');\n    await userEvent.type(emailInput, 'duplicate@example.com');\n    await userEvent.type(phoneInput, 'invalid-phone');\n\n    const submitBtn = screen.getByRole('button', { name: /save|submit/i });\n    await userEvent.click(submitBtn);\n\n    // Verify validation errors are shown\n    expect(await screen.findByText(/email already exists/i)).toBeInTheDocument();\n    expect(await screen.findByText(/invalid phone format/i)).toBeInTheDocument();\n  });\n\n  test('Network errors are handled gracefully', async () => {\n    server.use(http.post(`${API_URL}/address-book`, () => HttpResponse.error()));\n\n    renderWithAuth(<AddressBookPage />);\n\n    const createBtn = screen.getByRole('button', { name: /new|create|add/i });\n    await userEvent.click(createBtn);\n\n    const firstNameInput = screen.getByLabelText(/first name/i);\n    await userEvent.type(firstNameInput, 'Test');\n\n    const submitBtn = screen.getByRole('button', { name: /save|submit/i });\n    await userEvent.click(submitBtn);\n\n    // Verify error message is shown - check for the specific error message displayed by the app\n    const alert = await screen.findByRole('alert');\n    expect(alert).toBeInTheDocument();\n    expect(alert).toHaveTextContent(\n      /Network error: Unable to reach the server|Error Loading Contacts/i\n    );\n  });\n});\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/__tests__/integration/session-tenant.integration.test.tsx",
        "messages": [
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'container' is assigned a value but never used. Allowed unused vars must match /^_/u.",
                "line": 194,
                "column": 13,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 194,
                "endColumn": 22
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
                "line": 298,
                "column": 14,
                "nodeType": "ChainExpression",
                "messageId": "conditionErrorNullableBoolean",
                "endLine": 298,
                "endColumn": 47,
                "suggestions": [
                    {
                        "messageId": "conditionFixDefaultFalse",
                        "fix": {
                            "range": [
                                8865,
                                8898
                            ],
                            "text": "((authHeader?.startsWith('Bearer ')) ?? false)"
                        },
                        "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
                    },
                    {
                        "messageId": "conditionFixCompareFalse",
                        "fix": {
                            "range": [
                                8864,
                                8898
                            ],
                            "text": "(authHeader?.startsWith('Bearer ')) === false"
                        },
                        "desc": "Change condition to check if false (`value === false`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 362,
                "column": 13,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 362,
                "endColumn": 21,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                10482,
                                10490
                            ],
                            "text": "tenantId != null"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                10482,
                                10490
                            ],
                            "text": "tenantId ?? \"\""
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                10482,
                                10490
                            ],
                            "text": "Boolean(tenantId)"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 373,
                "column": 13,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 373,
                "endColumn": 21,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                10811,
                                10819
                            ],
                            "text": "tenantId != null"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                10811,
                                10819
                            ],
                            "text": "tenantId ?? \"\""
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                10811,
                                10819
                            ],
                            "text": "Boolean(tenantId)"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'tenant1Requests' is assigned a value but never used. Allowed unused vars must match /^_/u.",
                "line": 412,
                "column": 11,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 412,
                "endColumn": 26
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 503,
                "column": 26,
                "nodeType": "CallExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 503,
                "endColumn": 60,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                14906,
                                14940
                            ],
                            "text": "(request.headers.get('x-tenant-id') != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                14906,
                                14940
                            ],
                            "text": "(request.headers.get('x-tenant-id') ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                14906,
                                14940
                            ],
                            "text": "(Boolean(request.headers.get('x-tenant-id')))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 503,
                "column": 61,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 503,
                "endColumn": 63,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                14941,
                                14943
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 513,
                "column": 26,
                "nodeType": "CallExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 513,
                "endColumn": 60,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                15281,
                                15315
                            ],
                            "text": "(request.headers.get('x-tenant-id') != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                15281,
                                15315
                            ],
                            "text": "(request.headers.get('x-tenant-id') ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                15281,
                                15315
                            ],
                            "text": "(Boolean(request.headers.get('x-tenant-id')))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 513,
                "column": 61,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 513,
                "endColumn": 63,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                15316,
                                15318
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 551,
                "column": 58,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 551,
                "endColumn": 61,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                16535,
                                16538
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                16535,
                                16538
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 555,
                "column": 26,
                "nodeType": "CallExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 555,
                "endColumn": 60,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                16650,
                                16684
                            ],
                            "text": "(request.headers.get('x-tenant-id') != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                16650,
                                16684
                            ],
                            "text": "(request.headers.get('x-tenant-id') ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                16650,
                                16684
                            ],
                            "text": "(Boolean(request.headers.get('x-tenant-id')))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 555,
                "column": 61,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 555,
                "endColumn": 63,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                16685,
                                16687
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .first_name on an `any` value.",
                "line": 598,
                "column": 43,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 598,
                "endColumn": 53
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 13,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "/**\n * Session & Tenant Management Integration Tests\n *\n * Tests session expiration, token refresh, and tenant switching functionality\n *\n * @group integration\n * @category session-tenant\n */\n\nimport { describe, test, expect, beforeEach, afterEach } from 'bun:test';\n\n// Test timeout constants\nconst REFRESH_TIMEOUT_MS = 1000; // Token refresh should be fast\nconst UI_UPDATE_TIMEOUT_MS = 3000; // UI updates may take longer\nimport {\n  renderWithProviders,\n  mockUser,\n  mockTenant,\n  screen,\n  waitFor,\n  userEvent,\n  cleanup,\n} from '../../test-utils';\nimport { asTenantId } from '../../types/ids';\nimport { server, resetMSW } from '../../test-utils/mocks/server';\nimport { http, HttpResponse } from 'msw';\nimport { App } from '../../App';\n\n// Tenant ID constants for consistent testing\nconst TENANT_1_ID = 'tenant-1';\nconst TENANT_2_ID = 'tenant-2';\n\n/**\n * Factory function to create properly typed tenant objects\n * @param id - The tenant ID string\n * @param name - The tenant name (optional, defaults to mockTenant name)\n * @returns Properly typed Tenant object\n */\nconst createTenant = (id: string, name?: string): typeof mockTenant => ({\n  ...mockTenant,\n  id: asTenantId(id),\n  ...(name !== undefined && { name }),\n});\n\n// Helper function for base64url encoding\nconst base64url = (str: string): string =>\n  btoa(str).replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=+$/, '');\n\n// Create mock JWT tokens for testing\nfunction createExpiredToken(): string {\n  const header = base64url(JSON.stringify({ alg: 'HS256', typ: 'JWT' }));\n  const payload = base64url(\n    JSON.stringify({\n      sub: 'test-user',\n      tenant_id: TENANT_1_ID,\n      exp: Math.floor(Date.now() / 1000) - 3600, // Expired 1 hour ago\n      iat: Math.floor(Date.now() / 1000) - 7200,\n    })\n  );\n  const signature = 'mock-signature';\n  return `${header}.${payload}.${signature}`;\n}\n\nfunction createValidToken(): string {\n  const header = base64url(JSON.stringify({ alg: 'HS256', typ: 'JWT' }));\n  const payload = base64url(\n    JSON.stringify({\n      sub: 'test-user',\n      tenant_id: TENANT_1_ID,\n      exp: Math.floor(Date.now() / 1000) + 3600, // Valid for 1 hour\n      iat: Math.floor(Date.now() / 1000),\n    })\n  );\n  const signature = 'mock-signature';\n  return `${header}.${payload}.${signature}`;\n}\n\nconst API_URL = import.meta.env.VITE_API_URL || 'http://localhost:8000/api';\n\n// Helper function for tenant switching\nfunction switchTenant(\n  tenant: typeof mockTenant,\n  initialRoute = '/dashboard'\n): ReturnType<typeof renderWithProviders> {\n  cleanup();\n  return renderWithProviders(<App />, {\n    initialRoute,\n    authValue: {\n      isAuthenticated: true,\n      user: { ...mockUser, tenantId: tenant.id },\n      tenant,\n      isLoading: false,\n    },\n  });\n}\n\n/**\n * Session Expiration & Token Refresh Flow\n *\n * Scenario: When tokens expire, app should attempt refresh and handle failures gracefully\n */\ndescribe.skip('Session Expiration & Token Refresh Flow', () => {\n  beforeEach(() => {\n    resetMSW();\n    // Clear any stored auth data\n    localStorage.clear();\n    sessionStorage.clear();\n  });\n\n  afterEach(() => {\n    resetMSW();\n    localStorage.clear();\n    sessionStorage.clear();\n  });\n\n  test('Expired token triggers automatic refresh attempt', async () => {\n    let refreshCalled = false;\n    let apiCallCount = 0;\n\n    server.use(\n      http.get(`${API_URL}/dashboard`, () => {\n        apiCallCount++;\n        // First call returns 401 (expired token)\n        if (apiCallCount === 1) {\n          return HttpResponse.json({ message: 'Token expired' }, { status: 401 });\n        }\n        // Subsequent calls succeed (after refresh)\n        return HttpResponse.json({\n          success: true,\n          data: { stats: {} },\n          message: 'Success',\n        });\n      }),\n      http.post(`${API_URL}/auth/refresh`, () => {\n        refreshCalled = true;\n        return HttpResponse.json({\n          success: true,\n          token: createValidToken(),\n          user: mockUser,\n          tenant: mockTenant,\n          message: 'Token refreshed successfully',\n        });\n      })\n    );\n\n    // Start with expired token in localStorage\n    localStorage.setItem('auth_token', createExpiredToken());\n\n    renderWithProviders(<App />, {\n      initialRoute: '/dashboard',\n      authValue: {\n        isAuthenticated: true,\n        user: mockUser,\n        tenant: mockTenant,\n        isLoading: false,\n      },\n    });\n\n    // Wait for refresh attempt\n    await waitFor(\n      () => {\n        expect(refreshCalled).toBe(true);\n      },\n      { timeout: REFRESH_TIMEOUT_MS }\n    );\n\n    // Verify refresh was called\n    expect(refreshCalled).toBe(true);\n    expect(apiCallCount).toBeGreaterThan(1); // Should have retried after refresh\n  });\n\n  test('Failed token refresh logs user out', async () => {\n    let refreshCalled = false;\n\n    server.use(\n      http.get(`${API_URL}/dashboard`, () =>\n        HttpResponse.json({ message: 'Token expired' }, { status: 401 })\n      ),\n      http.post(`${API_URL}/auth/refresh`, () => {\n        refreshCalled = true;\n        return HttpResponse.json(\n          {\n            success: false,\n            message: 'Refresh token expired',\n          },\n          { status: 401 }\n        );\n      })\n    );\n\n    // Start with expired token\n    localStorage.setItem('auth_token', createExpiredToken());\n\n    const { container } = renderWithProviders(<App />, {\n      initialRoute: '/dashboard',\n      authValue: {\n        isAuthenticated: true,\n        user: mockUser,\n        tenant: mockTenant,\n        isLoading: false,\n      },\n    });\n\n    // Wait for logout/redirect - look for either login page or unauthorized message\n    try {\n      const loginForm = await screen.findByTestId('login-form');\n      expect(loginForm).toBeInTheDocument();\n    } catch {\n      // If no login form, look for unauthorized message\n      const unauthorizedElement = await screen.findByTestId('unauthorized-message');\n      expect(unauthorizedElement).toBeInTheDocument();\n    }\n\n    // Verify refresh was attempted\n    expect(refreshCalled).toBe(true);\n\n    // Verify token was cleared\n    expect(localStorage.getItem('auth_token')).toBeNull();\n  });\n\n  test('User can manually log out and clear session', async () => {\n    // Start with valid session\n    localStorage.setItem('auth_token', createValidToken());\n\n    renderWithProviders(<App />, {\n      initialRoute: '/dashboard',\n      authValue: {\n        isAuthenticated: true,\n        user: mockUser,\n        tenant: mockTenant,\n        isLoading: false,\n      },\n    });\n\n    // Verify initially authenticated\n    const dashboardElement = await screen.findByText(/dashboard|welcome/i);\n    expect(dashboardElement).toBeInTheDocument();\n\n    // Trigger logout\n    const logoutButton = screen.getByRole('button', { name: /logout|sign out/i });\n    await userEvent.click(logoutButton);\n\n    // Verify redirect to login page\n    await screen.findByTestId('login-form');\n    expect(localStorage.getItem('auth_token')).toBeNull();\n  });\n\n  test('Invalid token immediately triggers logout', async () => {\n    const invalidToken = 'invalid.jwt.token';\n\n    server.use(\n      http.get(`${API_URL}/dashboard`, () =>\n        HttpResponse.json({ message: 'Invalid token' }, { status: 401 })\n      ),\n      http.post(`${API_URL}/auth/refresh`, () =>\n        HttpResponse.json({ success: false, message: 'Invalid refresh token' }, { status: 401 })\n      )\n    );\n\n    // Start with invalid token\n    localStorage.setItem('auth_token', invalidToken);\n\n    renderWithProviders(<App />, {\n      initialRoute: '/dashboard',\n      authValue: {\n        isAuthenticated: true,\n        user: mockUser,\n        tenant: mockTenant,\n        isLoading: false,\n      },\n    });\n\n    // Should immediately detect invalid state and redirect to login page\n    // Wait for login form to appear (indicating successful redirect)\n    const loginForm = await screen.findByRole('form', { name: /login/i });\n    expect(loginForm).toBeInTheDocument();\n\n    // Verify that the username/email input is present (specific login UI element)\n    const usernameInput = await screen.findByLabelText(/username or email/i);\n    expect(usernameInput).toBeInTheDocument();\n\n    // Assert that the auth token has been cleared from localStorage\n    expect(localStorage.getItem('auth_token')).toBeNull();\n\n    // Assert that we've been redirected to the login route by checking for login form\n    expect(screen.getByRole('button', { name: /sign in|log in/i })).toBeInTheDocument();\n  });\n\n  test('Session remains active with valid token', async () => {\n    const validToken = createValidToken();\n    let apiCallCount = 0;\n\n    server.use(\n      http.get(`${API_URL}/dashboard`, ({ request }) => {\n        apiCallCount++;\n        const authHeader = request.headers.get('authorization');\n        // Check that token is being sent\n        if (!authHeader?.startsWith('Bearer ')) {\n          return HttpResponse.json({ message: 'Unauthorized' }, { status: 401 });\n        }\n        return HttpResponse.json({\n          success: true,\n          data: { stats: {} },\n          message: 'Success',\n        });\n      })\n    );\n\n    // Start with valid token\n    localStorage.setItem('auth_token', validToken);\n\n    renderWithProviders(<App />, {\n      initialRoute: '/dashboard',\n      authValue: {\n        isAuthenticated: true,\n        user: mockUser,\n        tenant: mockTenant,\n        isLoading: false,\n      },\n    });\n\n    // Should remain on dashboard\n    await waitFor(\n      () => {\n        expect(screen.getByText(/dashboard|welcome/i)).toBeInTheDocument();\n      },\n      { timeout: UI_UPDATE_TIMEOUT_MS }\n    );\n\n    // Verify API was called successfully\n    expect(apiCallCount).toBeGreaterThan(0);\n  });\n});\n\n/**\n * Tenant Switching Functionality\n *\n * Scenario: Users can switch between tenants they have access to\n */\ndescribe.skip('Tenant Switching Functionality', () => {\n  const tenant1 = createTenant(TENANT_1_ID);\n  const tenant2 = createTenant(TENANT_2_ID, 'Tenant 2');\n\n  beforeEach(() => {\n    resetMSW();\n    localStorage.clear();\n    sessionStorage.clear();\n  });\n\n  afterEach(() => {\n    resetMSW();\n    localStorage.clear();\n    sessionStorage.clear();\n  });\n\n  test('Tenant switch updates API requests with correct tenant header', async () => {\n    const capturedTenantIds: string[] = [];\n\n    server.use(\n      http.get(`${API_URL}/contacts`, ({ request }) => {\n        const tenantId = request.headers.get('x-tenant-id');\n        if (tenantId) {\n          capturedTenantIds.push(tenantId);\n        }\n        return HttpResponse.json({\n          success: true,\n          data: [],\n          message: 'Success',\n        });\n      }),\n      http.get(`${API_URL}/dashboard`, ({ request }) => {\n        const tenantId = request.headers.get('x-tenant-id');\n        if (tenantId) {\n          capturedTenantIds.push(tenantId);\n        }\n        return HttpResponse.json({\n          success: true,\n          data: { stats: {} },\n          message: 'Success',\n        });\n      })\n    );\n\n    // Start with tenant 1\n    renderWithProviders(<App />, {\n      initialRoute: '/dashboard',\n      authValue: {\n        isAuthenticated: true,\n        user: mockUser,\n        tenant: tenant1,\n        isLoading: false,\n      },\n    });\n\n    // Wait for initial requests with tenant 1\n    await waitFor(() => {\n      expect(capturedTenantIds.some(id => id === TENANT_1_ID)).toBe(true);\n    });\n\n    // Clear captured headers for next check\n    capturedTenantIds.splice(0);\n\n    // Switch to tenant 2 - cleanup first render to avoid multiple mounted apps\n    switchTenant(tenant2, '/dashboard');\n\n    // Wait for requests with tenant 2\n    await waitFor(() => {\n      expect(capturedTenantIds.some(id => id === TENANT_2_ID)).toBe(true);\n    });\n\n    // Verify correct tenant headers were sent\n    const tenant1Requests = capturedTenantIds.filter(id => id === TENANT_1_ID);\n    const tenant2Requests = capturedTenantIds.filter(id => id === TENANT_2_ID);\n\n    // After switch, should only see tenant 2 requests\n    expect(tenant2Requests.length).toBeGreaterThan(0);\n  });\n\n  test('Tenant switch preserves user authentication state', async () => {\n    // Start with tenant 1\n    const firstRender = renderWithProviders(<App />, {\n      initialRoute: '/dashboard',\n      authValue: {\n        isAuthenticated: true,\n        user: mockUser,\n        tenant: tenant1,\n        isLoading: false,\n      },\n    });\n\n    // Verify initially shows dashboard\n    const initialDashboard = await screen.findByText(/dashboard|welcome/i);\n    expect(initialDashboard).toBeInTheDocument();\n\n    // Unmount first render\n    firstRender.unmount();\n\n    // Switch tenant\n    renderWithProviders(<App />, {\n      initialRoute: '/dashboard',\n      authValue: {\n        isAuthenticated: true,\n        user: { ...mockUser, tenantId: tenant2.id },\n        tenant: tenant2,\n        isLoading: false,\n      },\n    });\n\n    // Verify still authenticated but different tenant\n    const dashboardAfterSwitch = await screen.findByText(/dashboard|welcome/i);\n    expect(dashboardAfterSwitch).toBeInTheDocument();\n\n    // Verify tenant context changed (this would be tested e2e for UI changes)\n    // In a real app, you might check for tenant-specific branding or data\n  });\n\n  test('Invalid tenant switch is handled gracefully', async () => {\n    const invalidTenant = createTenant('invalid-tenant', 'Invalid Tenant');\n\n    server.use(\n      http.get(`${API_URL}/dashboard`, ({ request }) => {\n        const tenantId = request.headers.get('x-tenant-id');\n        // Simulate rejecting invalid tenant\n        if (tenantId === 'invalid-tenant') {\n          return HttpResponse.json({ message: 'Invalid tenant access' }, { status: 403 });\n        }\n        return HttpResponse.json({\n          success: true,\n          data: { stats: {} },\n          message: 'Success',\n        });\n      })\n    );\n\n    renderWithProviders(<App />, {\n      initialRoute: '/dashboard',\n      authValue: {\n        isAuthenticated: true,\n        user: mockUser,\n        tenant: invalidTenant,\n        isLoading: false,\n      },\n    });\n\n    // Should handle error gracefully - either show error or fall back to valid tenant\n    // Try to find either an error message or a fallback dashboard display\n    try {\n      const errorElement = await screen.findByText(/error|invalid|forbidden/i);\n      expect(errorElement).toBeInTheDocument();\n    } catch {\n      // If no error, expect fallback to dashboard\n      const fallbackElement = await screen.findByText(/dashboard|welcome/i);\n      expect(fallbackElement).toBeInTheDocument();\n    }\n  });\n\n  test('Multiple tenant switches maintain data consistency', async () => {\n    const capturedTenantIds: string[] = [];\n    const capturedEndpoints: { tenantId: string; endpoint: string }[] = [];\n\n    server.use(\n      http.get(`${API_URL}/contacts`, ({ request }) => {\n        const tenantId = request.headers.get('x-tenant-id') || 'unknown';\n        capturedTenantIds.push(tenantId);\n        capturedEndpoints.push({ tenantId, endpoint: '/contacts' });\n        return HttpResponse.json({\n          success: true,\n          data: [],\n          message: 'Success',\n        });\n      }),\n      http.get(`${API_URL}/dashboard`, ({ request }) => {\n        const tenantId = request.headers.get('x-tenant-id') || 'unknown';\n        capturedTenantIds.push(tenantId);\n        capturedEndpoints.push({ tenantId, endpoint: '/dashboard' });\n        return HttpResponse.json({\n          success: true,\n          data: { stats: {} },\n          message: 'Success',\n        });\n      })\n    );\n\n    // Navigate through different tenants and endpoints\n    renderWithProviders(<App />, {\n      initialRoute: '/dashboard',\n      authValue: {\n        isAuthenticated: true,\n        user: mockUser,\n        tenant: tenant1,\n        isLoading: false,\n      },\n    });\n\n    // Switch to tenant 2\n    switchTenant(tenant2, '/address-book');\n\n    // Switch back to tenant 1\n    switchTenant(tenant1, '/dashboard');\n\n    // Verify tenant headers were sent correctly throughout\n    await waitFor(() => {\n      const tenant1Requests = capturedEndpoints.filter(req => req.tenantId === TENANT_1_ID);\n      const tenant2Requests = capturedEndpoints.filter(req => req.tenantId === TENANT_2_ID);\n      expect(tenant1Requests.length).toBeGreaterThan(0);\n      expect(tenant2Requests.length).toBeGreaterThan(0);\n    });\n  });\n\n  test('Tenant switch clears previous tenant cached data', async () => {\n    const contactRequests: { tenantId: string; contacts: any[] }[] = [];\n\n    server.use(\n      http.get(`${API_URL}/contacts`, ({ request }) => {\n        const tenantId = request.headers.get('x-tenant-id') || 'unknown';\n        const contacts =\n          tenantId === TENANT_1_ID\n            ? [{ id: 1, first_name: 'John Tenant1' }]\n            : [{ id: 2, first_name: 'Jane Tenant2' }];\n\n        contactRequests.push({ tenantId, contacts });\n\n        return HttpResponse.json({\n          success: true,\n          data: contacts,\n          message: 'Success',\n        });\n      })\n    );\n\n    // Start with tenant 1 data\n    renderWithProviders(<App />, {\n      initialRoute: '/address-book',\n      authValue: {\n        isAuthenticated: true,\n        user: mockUser,\n        tenant: tenant1,\n        isLoading: false,\n      },\n    });\n\n    // Wait for tenant 1 data\n    await waitFor(() => {\n      const tenant1Request = contactRequests.find(req => req.tenantId === TENANT_1_ID);\n      expect(tenant1Request).toBeDefined();\n    });\n\n    // Clear request log for next check\n    contactRequests.splice(0);\n\n    // Switch to tenant 2\n    switchTenant(tenant2, '/address-book');\n\n    // Verify tenant 2 data is loaded\n    await waitFor(() => {\n      const tenant2Request = contactRequests.find(req => req.tenantId === TENANT_2_ID);\n      expect(tenant2Request).toBeDefined();\n      expect(tenant2Request?.contacts[0]?.first_name).toBe('Jane Tenant2');\n    });\n  });\n});\n\n/**\n * Multi-Tenant Data Isolation UI Behavior\n *\n * Scenario: UI correctly reflects tenant-specific data isolation\n */\ndescribe.skip('Multi-Tenant Data Isolation UI Behavior', () => {\n  const tenant1Contacts = [\n    {\n      id: 1,\n      tenant_id: TENANT_1_ID,\n      first_name: 'John',\n      last_name: 'Tenant1',\n      email: 'john@tenant1.com',\n      created_at: new Date().toISOString(),\n      updated_at: new Date().toISOString(),\n    },\n  ];\n\n  const tenant2Contacts = [\n    {\n      id: 2,\n      tenant_id: TENANT_2_ID,\n      first_name: 'Jane',\n      last_name: 'Tenant2',\n      email: 'jane@tenant2.com',\n      created_at: new Date().toISOString(),\n      updated_at: new Date().toISOString(),\n    },\n  ];\n\n  beforeEach(() => {\n    resetMSW();\n    localStorage.clear();\n    sessionStorage.clear();\n  });\n\n  afterEach(() => {\n    resetMSW();\n    localStorage.clear();\n    sessionStorage.clear();\n  });\n\n  test('UI displays tenant-specific contact list', async () => {\n    server.use(\n      http.get(`${API_URL}/contacts`, ({ request }) => {\n        const tenantId = request.headers.get('x-tenant-id');\n        const data = tenantId === TENANT_1_ID ? tenant1Contacts : tenant2Contacts;\n        return HttpResponse.json({\n          success: true,\n          data,\n          message: 'Success',\n        });\n      })\n    );\n\n    renderWithProviders(<App />, {\n      initialRoute: '/address-book',\n      authValue: {\n        isAuthenticated: true,\n        user: mockUser,\n        tenant: mockTenant,\n        isLoading: false,\n      },\n    });\n\n    // Verify tenant 1 contacts are shown\n    const tenant1Contact = await screen.findByText('John Tenant1');\n    expect(tenant1Contact).toBeInTheDocument();\n    expect(screen.queryByText('Jane Tenant2')).not.toBeInTheDocument();\n\n    // Switch tenant and verify different data\n    const tenant2 = createTenant(TENANT_2_ID, 'Tenant 2');\n    switchTenant(tenant2, '/address-book');\n\n    // Verify tenant 2 contacts are shown\n    const tenant2Contact = await screen.findByText('Jane Tenant2');\n    expect(tenant2Contact).toBeInTheDocument();\n    expect(screen.queryByText('John Tenant1')).not.toBeInTheDocument();\n  });\n\n  describe('Create Operation Tenant Isolation', () => {\n    let createdContacts: {\n      id: number;\n      tenant_id: string | null;\n      first_name: string;\n      last_name: string;\n      email: string;\n      created_at: string;\n      updated_at: string;\n    }[] = [];\n\n    beforeEach(() => {\n      // Reset created contacts for each test\n      createdContacts = [];\n\n      // Setup shared server handlers for create operations\n      server.use(\n        http.get(`${API_URL}/contacts`, ({ request }) => {\n          const tenantId = request.headers.get('x-tenant-id');\n          const existingContacts = tenantId === TENANT_1_ID ? tenant1Contacts : tenant2Contacts;\n          const allContacts = [\n            ...existingContacts,\n            ...createdContacts.filter(c => c.tenant_id === tenantId),\n          ];\n          return HttpResponse.json({\n            success: true,\n            data: allContacts,\n            message: 'Success',\n          });\n        }),\n        http.post(`${API_URL}/contacts`, async ({ request }) => {\n          const body = (await request.json()) as {\n            first_name?: string;\n            last_name?: string;\n            email: string;\n          };\n          const tenantId = request.headers.get('x-tenant-id');\n          const newContact = {\n            id: createdContacts.length + 3, // IDs after tenant-specific contacts\n            tenant_id: tenantId,\n            first_name: body.first_name ?? 'New',\n            last_name: body.last_name ?? 'Contact',\n            email: body.email,\n            created_at: new Date().toISOString(),\n            updated_at: new Date().toISOString(),\n          };\n          createdContacts.push(newContact);\n          return HttpResponse.json({\n            success: true,\n            data: newContact,\n            message: 'Contact created',\n          });\n        })\n      );\n    });\n\n    test('Create operation includes correct tenant ID', async () => {\n      let capturedRequest: {\n        tenantId: string;\n        body: { first_name?: string; last_name?: string; email: string };\n      } | null = null;\n\n      // Override POST handler to capture request details\n      server.use(\n        http.post(`${API_URL}/contacts`, async ({ request }) => {\n          const body = (await request.json()) as {\n            first_name?: string;\n            last_name?: string;\n            email: string;\n          };\n          const tenantId = request.headers.get('x-tenant-id');\n          capturedRequest = { tenantId: tenantId ?? '', body };\n\n          const newContact = {\n            id: createdContacts.length + 3,\n            tenant_id: tenantId,\n            first_name: body.first_name ?? 'New',\n            last_name: body.last_name ?? 'Contact',\n            email: body.email,\n            created_at: new Date().toISOString(),\n            updated_at: new Date().toISOString(),\n          };\n          createdContacts.push(newContact);\n          return HttpResponse.json({\n            success: true,\n            data: newContact,\n            message: 'Contact created',\n          });\n        })\n      );\n\n      // Render app in tenant1 context\n      renderWithProviders(<App />, {\n        initialRoute: '/address-book',\n        authValue: {\n          isAuthenticated: true,\n          user: mockUser,\n          tenant: mockTenant, // Uses TENANT_1_ID\n          isLoading: false,\n        },\n      });\n\n      // Trigger create flow\n      const createButton = screen.getByRole('button', { name: /create|add|new contact/i });\n      await userEvent.click(createButton);\n\n      const emailInput = screen.getByLabelText(/email/i);\n      await userEvent.type(emailInput, 'testuser@tenant1.com');\n\n      const saveButton = screen.getByRole('button', { name: /save|create|submit/i });\n      await userEvent.click(saveButton);\n\n      // Verify request includes correct tenant ID\n      await waitFor(() => {\n        expect(capturedRequest).not.toBeNull();\n        if (capturedRequest) {\n          expect(capturedRequest.tenantId).toBe(TENANT_1_ID);\n          expect(capturedRequest.body.email).toBe('testuser@tenant1.com');\n        }\n      });\n    });\n\n    test('Newly created contacts appear in correct tenant context', async () => {\n      // Render app in tenant1 context\n      renderWithProviders(<App />, {\n        initialRoute: '/address-book',\n        authValue: {\n          isAuthenticated: true,\n          user: mockUser,\n          tenant: mockTenant, // Uses TENANT_1_ID\n          isLoading: false,\n        },\n      });\n\n      // Should only see tenant 1 contacts initially\n      const tenant1Contact = await screen.findByText('John Tenant1');\n      expect(tenant1Contact).toBeInTheDocument();\n      expect(screen.queryByText('Jane Tenant2')).not.toBeInTheDocument();\n\n      // Create a new contact in tenant 1\n      const createButton = screen.getByRole('button', { name: /create|add|new contact/i });\n      await userEvent.click(createButton);\n\n      const emailInput = screen.getByLabelText(/email/i);\n      await userEvent.type(emailInput, 'newuser@tenant1.com');\n\n      const saveButton = screen.getByRole('button', { name: /save|create|submit/i });\n      await userEvent.click(saveButton);\n\n      // Verify new contact appears in tenant1 context without switching tenants\n      await waitFor(() => {\n        expect(screen.getByText('newuser@tenant1.com')).toBeInTheDocument();\n        expect(screen.getByText('John Tenant1')).toBeInTheDocument(); // Original tenant1 contact still visible\n        expect(screen.queryByText('Jane Tenant2')).not.toBeInTheDocument(); // Tenant2 contact still not visible\n      });\n    });\n\n    test(\"Created contacts don't leak across tenants\", async () => {\n      // First create a contact in tenant1 context\n      renderWithProviders(<App />, {\n        initialRoute: '/address-book',\n        authValue: {\n          isAuthenticated: true,\n          user: mockUser,\n          tenant: mockTenant, // Uses TENANT_1_ID\n          isLoading: false,\n        },\n      });\n\n      // Create a contact in tenant1\n      const createButton = screen.getByRole('button', { name: /create|add|new contact/i });\n      await userEvent.click(createButton);\n\n      const emailInput = screen.getByLabelText(/email/i);\n      await userEvent.type(emailInput, 'tenant1user@example.com');\n\n      const saveButton = screen.getByRole('button', { name: /save|create|submit/i });\n      await userEvent.click(saveButton);\n\n      // Verify contact was created in tenant1\n      await waitFor(() => {\n        expect(screen.getByText('tenant1user@example.com')).toBeInTheDocument();\n      });\n\n      // Now switch to tenant2 and verify isolation\n      const tenant2 = createTenant(TENANT_2_ID, 'Tenant 2');\n      switchTenant(tenant2, '/address-book');\n\n      // Verify tenant1 contact is not visible in tenant2\n      expect(screen.queryByText('tenant1user@example.com')).not.toBeInTheDocument();\n\n      // Verify tenant2 can see its own contacts\n      const tenant2Contact = await screen.findByText('Jane Tenant2');\n      expect(tenant2Contact).toBeInTheDocument();\n\n      // Verify tenant2 doesn't see tenant1's original contacts\n      expect(screen.queryByText('John Tenant1')).not.toBeInTheDocument();\n    });\n  });\n\n  test('Error states are tenant-specific', async () => {\n    // Simulate different error responses per tenant\n    server.use(\n      http.get(`${API_URL}/contacts`, ({ request }) => {\n        const tenantId = request.headers.get('x-tenant-id');\n        if (tenantId === TENANT_1_ID) {\n          return HttpResponse.json(\n            {\n              success: false,\n              message: 'Database connection failed for tenant-1',\n            },\n            { status: 500 }\n          );\n        }\n        return HttpResponse.json({\n          success: true,\n          data: tenant2Contacts,\n          message: 'Success',\n        });\n      })\n    );\n\n    renderWithProviders(<App />, {\n      initialRoute: '/address-book',\n      authValue: {\n        isAuthenticated: true,\n        user: mockUser,\n        tenant: mockTenant,\n        isLoading: false,\n      },\n    });\n\n    // Should show error for tenant 1\n    const errorElement = await screen.findByText(/database connection failed|error/i);\n    expect(errorElement).toBeInTheDocument();\n  });\n});\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/components/ColorTest.tsx",
        "messages": [],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 0,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/components/ConfirmationModal.tsx",
        "messages": [],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 0,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/components/DatabaseManagementModal.tsx",
        "messages": [
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 88,
                "column": 12,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 88,
                "endColumn": 17,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                2035,
                                2041
                            ],
                            "text": "dbUrl == null"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                2036,
                                2041
                            ],
                            "text": "(dbUrl ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                2035,
                                2041
                            ],
                            "text": "!Boolean(dbUrl)"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 211,
                "column": 34,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 211,
                "endColumn": 47,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                6163,
                                6177
                            ],
                            "text": "tenant.db_url == null"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                6164,
                                6177
                            ],
                            "text": "(tenant.db_url ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                6163,
                                6177
                            ],
                            "text": "!Boolean(tenant.db_url)"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 2,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "/**\n * Database Management Modal Component\n * Provides database information and basic management operations for tenants\n */\n\nimport React, { useState, useCallback } from 'react';\nimport {\n  Modal,\n  Card,\n  Row,\n  Col,\n  Typography,\n  Button,\n  Space,\n  Alert,\n  Spin,\n  Divider,\n  Tooltip,\n  Badge,\n} from 'antd';\nimport {\n  DatabaseOutlined,\n  CheckCircleOutlined,\n  ExclamationCircleOutlined,\n  ReloadOutlined,\n  InfoCircleOutlined,\n  CopyOutlined,\n} from '@ant-design/icons';\n\n// Dashboard-specific Tenant interface that extends the base with required properties\ninterface DashboardTenant {\n  id: string;\n  name: string;\n  db_url?: string;\n  created_at?: string;\n  updated_at?: string;\n  isActive?: boolean;\n}\n\nconst { Title, Text } = Typography;\n\ninterface DatabaseInfo {\n  status: 'connected' | 'disconnected' | 'error' | 'checking';\n  lastChecked?: string;\n  connectionString?: string;\n  databaseName?: string;\n  host?: string;\n  port?: string;\n}\n\ninterface DatabaseManagementModalProps {\n  isOpen: boolean;\n  onClose: () => void;\n  tenants: DashboardTenant[];\n  onRefresh?: () => void;\n}\n\nexport const DatabaseManagementModal: React.FC<DatabaseManagementModalProps> = ({\n  isOpen,\n  onClose,\n  tenants,\n  onRefresh,\n}) => {\n  const [databaseStatuses, setDatabaseStatuses] = useState<Record<string, DatabaseInfo>>({});\n  const [checkingStatus, setCheckingStatus] = useState<Record<string, boolean>>({});\n\n  // Parse database URL to extract connection details\n  const parseDatabaseUrl = useCallback((dbUrl: string): Partial<DatabaseInfo> => {\n    try {\n      const url = new URL(dbUrl);\n      return {\n        connectionString: dbUrl,\n        databaseName: url.pathname.slice(1), // Remove leading slash\n        host: url.hostname,\n        port: url.port || '5432',\n      };\n    } catch {\n      return {\n        connectionString: dbUrl,\n        status: 'error',\n      };\n    }\n  }, []);\n\n  // Check database connection status\n  const checkDatabaseStatus = useCallback(\n    async (tenantId: string, dbUrl?: string) => {\n      if (!dbUrl) return; // Don't check if no database URL\n\n      setCheckingStatus(prev => ({ ...prev, [tenantId]: true }));\n\n      try {\n        // Simulate database connection check\n        // In a real implementation, this would make an API call to check the database\n        await new Promise(resolve => setTimeout(resolve, 1000 + Math.random() * 2000));\n\n        const isConnected = Math.random() > 0.2; // 80% success rate for demo\n\n        setDatabaseStatuses(prev => ({\n          ...prev,\n          [tenantId]: {\n            ...parseDatabaseUrl(dbUrl),\n            status: isConnected ? 'connected' : 'disconnected',\n            lastChecked: new Date().toISOString(),\n          },\n        }));\n      } catch (_error) {\n        setDatabaseStatuses(prev => ({\n          ...prev,\n          [tenantId]: {\n            ...parseDatabaseUrl(dbUrl),\n            status: 'error',\n            lastChecked: new Date().toISOString(),\n          },\n        }));\n      } finally {\n        setCheckingStatus(prev => ({ ...prev, [tenantId]: false }));\n      }\n    },\n    [parseDatabaseUrl]\n  );\n\n  // Copy connection string to clipboard\n  const copyConnectionString = useCallback(async (connectionString: string) => {\n    try {\n      await navigator.clipboard.writeText(connectionString);\n      // You could add a toast notification here\n    } catch (error) {\n      console.error('Failed to copy to clipboard:', error);\n    }\n  }, []);\n\n  // Get status color and icon\n  const getStatusDisplay = (\n    status: DatabaseInfo['status']\n  ): { color: string; icon: React.ReactNode; text: string } => {\n    switch (status) {\n      case 'connected':\n        return { color: 'success', icon: <CheckCircleOutlined />, text: 'Connected' };\n      case 'disconnected':\n        return { color: 'warning', icon: <ExclamationCircleOutlined />, text: 'Disconnected' };\n      case 'error':\n        return { color: 'error', icon: <ExclamationCircleOutlined />, text: 'Error' };\n      case 'checking':\n        return { color: 'processing', icon: <ReloadOutlined spin />, text: 'Checking...' };\n      default:\n        return { color: 'default', icon: <InfoCircleOutlined />, text: 'Unknown' };\n    }\n  };\n\n  return (\n    <Modal\n      title={\n        <Space>\n          <DatabaseOutlined />\n          Database Management\n        </Space>\n      }\n      open={isOpen}\n      onCancel={onClose}\n      width={800}\n      footer={[\n        <Button key=\"refresh\" icon={<ReloadOutlined />} onClick={onRefresh}>\n          Refresh All\n        </Button>,\n        <Button key=\"close\" type=\"primary\" onClick={onClose}>\n          Close\n        </Button>,\n      ]}\n    >\n      <Space direction=\"vertical\" size=\"large\" style={{ width: '100%' }}>\n        <Alert\n          message=\"Database Management\"\n          description=\"Monitor and manage database connections for all tenants. Click 'Check Status' to verify database connectivity.\"\n          type=\"info\"\n          showIcon\n        />\n\n        <Row gutter={[16, 16]}>\n          {tenants.map(tenant => {\n            const dbInfo = databaseStatuses[tenant.id];\n            const isChecking = checkingStatus[tenant.id];\n            const statusDisplay = dbInfo\n              ? getStatusDisplay(dbInfo.status)\n              : getStatusDisplay('checking');\n\n            return (\n              <Col xs={24} lg={12} key={tenant.id}>\n                <Card\n                  title={\n                    <Space>\n                      <Text strong>{tenant.name}</Text>\n                      <Badge\n                        status={\n                          statusDisplay.color as\n                            | 'success'\n                            | 'warning'\n                            | 'error'\n                            | 'processing'\n                            | 'default'\n                        }\n                        text={statusDisplay.text}\n                      />\n                    </Space>\n                  }\n                  extra={\n                    <Button\n                      size=\"small\"\n                      icon={<ReloadOutlined />}\n                      loading={isChecking}\n                      disabled={!tenant.db_url}\n                      onClick={() => checkDatabaseStatus(tenant.id, tenant.db_url)}\n                    >\n                      Check Status\n                    </Button>\n                  }\n                  hoverable\n                >\n                  <Space direction=\"vertical\" size=\"small\" style={{ width: '100%' }}>\n                    {dbInfo ? (\n                      <>\n                        <Row gutter={[8, 8]}>\n                          <Col span={6}>\n                            <Text type=\"secondary\">Host:</Text>\n                          </Col>\n                          <Col span={18}>\n                            <Text code>{dbInfo.host ?? 'N/A'}</Text>\n                          </Col>\n                        </Row>\n\n                        <Row gutter={[8, 8]}>\n                          <Col span={6}>\n                            <Text type=\"secondary\">Port:</Text>\n                          </Col>\n                          <Col span={18}>\n                            <Text code>{dbInfo.port ?? 'N/A'}</Text>\n                          </Col>\n                        </Row>\n\n                        <Row gutter={[8, 8]}>\n                          <Col span={6}>\n                            <Text type=\"secondary\">Database:</Text>\n                          </Col>\n                          <Col span={18}>\n                            <Text code>{dbInfo.databaseName ?? 'N/A'}</Text>\n                          </Col>\n                        </Row>\n\n                        <Divider style={{ margin: '8px 0' }} />\n\n                        <Row gutter={[8, 8]}>\n                          <Col span={6}>\n                            <Text type=\"secondary\">Connection:</Text>\n                          </Col>\n                          <Col span={18}>\n                            <Space.Compact style={{ width: '100%' }}>\n                              <Text\n                                code\n                                style={{\n                                  flex: 1,\n                                  overflow: 'hidden',\n                                  textOverflow: 'ellipsis',\n                                  whiteSpace: 'nowrap',\n                                }}\n                              >\n                                {dbInfo.connectionString ?? 'N/A'}\n                              </Text>\n                              <Tooltip title=\"Copy connection string\">\n                                <Button\n                                  size=\"small\"\n                                  icon={<CopyOutlined />}\n                                  onClick={() =>\n                                    copyConnectionString(dbInfo.connectionString ?? '')\n                                  }\n                                />\n                              </Tooltip>\n                            </Space.Compact>\n                          </Col>\n                        </Row>\n\n                        {dbInfo.lastChecked != null && dbInfo.lastChecked.length > 0 ? (\n                          <Row gutter={[8, 8]}>\n                            <Col span={6}>\n                              <Text type=\"secondary\">Last Checked:</Text>\n                            </Col>\n                            <Col span={18}>\n                              <Text type=\"secondary\">\n                                {new Date(dbInfo.lastChecked).toLocaleString()}\n                              </Text>\n                            </Col>\n                          </Row>\n                        ) : null}\n                      </>\n                    ) : (\n                      <Space\n                        direction=\"vertical\"\n                        align=\"center\"\n                        style={{ width: '100%', padding: '20px 0' }}\n                      >\n                        <Spin size=\"small\" />\n                        <Text type=\"secondary\">\n                          Click \"Check Status\" to verify database connection\n                        </Text>\n                      </Space>\n                    )}\n                  </Space>\n                </Card>\n              </Col>\n            );\n          })}\n        </Row>\n\n        {tenants.length === 0 && (\n          <Card>\n            <Space direction=\"vertical\" align=\"center\" style={{ width: '100%', padding: '20px 0' }}>\n              <DatabaseOutlined style={{ fontSize: 48, color: '#d9d9d9' }} />\n              <Title level={4} type=\"secondary\">\n                No Tenants Found\n              </Title>\n              <Text type=\"secondary\">Create a tenant to manage database connections.</Text>\n            </Space>\n          </Card>\n        )}\n      </Space>\n    </Modal>\n  );\n};\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/components/EnvironmentErrorUI.tsx",
        "messages": [],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 0,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/components/ErrorBoundary.tsx",
        "messages": [
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 40,
                "column": 3,
                "nodeType": "FunctionExpression",
                "messageId": "missingReturnType",
                "endLine": 40,
                "endColumn": 29
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 118,
                "column": 3,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingReturnType",
                "endLine": 118,
                "endColumn": 30
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 139,
                "column": 3,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingReturnType",
                "endLine": 139,
                "endColumn": 33
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected value in conditional. A boolean expression is required.",
                "line": 141,
                "column": 9,
                "nodeType": "Identifier",
                "messageId": "conditionErrorOther",
                "endLine": 141,
                "endColumn": 25
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 224,
                "column": 3,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingReturnType",
                "endLine": 224,
                "endColumn": 25
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 228,
                "column": 3,
                "nodeType": "FunctionExpression",
                "messageId": "missingReturnType",
                "endLine": 228,
                "endColumn": 18
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected value in conditional. A boolean expression is required.",
                "line": 230,
                "column": 11,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorOther",
                "endLine": 230,
                "endColumn": 30
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 238,
                "column": 21,
                "nodeType": "ChainExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 238,
                "endColumn": 46,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                6347,
                                6372
                            ],
                            "text": "((this.state.error?.message) != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                6347,
                                6372
                            ],
                            "text": "((this.state.error?.message) ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                6347,
                                6372
                            ],
                            "text": "(Boolean((this.state.error?.message)))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 238,
                "column": 47,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 238,
                "endColumn": 49,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                6373,
                                6375
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
                "line": 249,
                "column": 9,
                "nodeType": "ChainExpression",
                "messageId": "conditionErrorNullableBoolean",
                "endLine": 249,
                "endColumn": 40,
                "suggestions": [
                    {
                        "messageId": "conditionFixDefaultFalse",
                        "fix": {
                            "range": [
                                6663,
                                6694
                            ],
                            "text": "(this.state.resultError?.isErr()) ?? false"
                        },
                        "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
                    },
                    {
                        "messageId": "conditionFixCompareTrue",
                        "fix": {
                            "range": [
                                6663,
                                6694
                            ],
                            "text": "(this.state.resultError?.isErr()) === true"
                        },
                        "desc": "Change condition to check if true (`value === true`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 264,
                "column": 8,
                "nodeType": "FunctionDeclaration",
                "messageId": "missingReturnType",
                "endLine": 264,
                "endColumn": 65
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 264,
                "column": 60,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 264,
                "endColumn": 63,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                7119,
                                7122
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                7119,
                                7122
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 268,
                "column": 39,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingReturnType",
                "endLine": 268,
                "endColumn": 41
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 274,
                "column": 55,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 274,
                "endColumn": 76,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                7413,
                                7434
                            ],
                            "text": "(Component.displayName != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                7413,
                                7434
                            ],
                            "text": "(Component.displayName ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                7413,
                                7434
                            ],
                            "text": "(Boolean(Component.displayName))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 274,
                "column": 77,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 274,
                "endColumn": 79,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                7435,
                                7437
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 15,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "import React, { Component } from 'react';\nimport type { ErrorInfo, ReactNode } from 'react';\nimport { Button, Result, Alert } from 'antd';\nimport { err } from 'neverthrow';\nimport { logger } from '../utils/logger';\nimport type { Result as FPResult } from '../types/fp';\nimport type { AppError } from '../types/errors';\n\nexport interface ResultRecoveryStrategy {\n  canHandle: (error: AppError) => boolean;\n  recover: () => FPResult<ReactNode, AppError>;\n}\n\ninterface Props {\n  children: ReactNode;\n  fallback?: ReactNode;\n  onError?: (error: Error, errorInfo: ErrorInfo) => void;\n  onResultError?: (result: FPResult<unknown, AppError>) => ReactNode;\n  recoveryStrategies?: ResultRecoveryStrategy[];\n  transformResultError?: (error: AppError) => FPResult<AppError, AppError>;\n  reportResultError?: (error: AppError) => FPResult<void, AppError>;\n}\n\ninterface State {\n  hasError: boolean;\n  error?: Error;\n  resultError?: FPResult<unknown, AppError>;\n}\n\nexport class ErrorBoundary extends Component<Props, State> {\n  constructor(props: Props) {\n    super(props);\n    this.state = { hasError: false };\n  }\n\n  static getDerivedStateFromError(error: Error): State {\n    return { hasError: true, error };\n  }\n\n  override componentDidCatch(error: Error, errorInfo: ErrorInfo) {\n    logger.error('Error caught by boundary', {\n      error: error.message,\n      stack: error.stack,\n      componentStack: errorInfo.componentStack,\n    });\n\n    // Call custom error handler if provided\n    if (this.props.onError) {\n      this.props.onError(error, errorInfo);\n    }\n  }\n\n  private normalizeResultError = (error: AppError): AppError => {\n    const { transformResultError } = this.props;\n    if (!transformResultError) {\n      return error;\n    }\n\n    const transformed = transformResultError(error);\n    if (transformed.isOk()) {\n      return transformed.value;\n    }\n\n    logger.warn('Result error transformation failed', {\n      originalType: error.type,\n      transformationFailure: transformed.error,\n    });\n    return error;\n  };\n\n  private notifyResultError = (error: AppError): void => {\n    const { reportResultError } = this.props;\n    if (!reportResultError) {\n      logger.error('Result error captured by boundary', {\n        type: error.type,\n        message: error.message,\n      });\n      return;\n    }\n\n    const reportOutcome = reportResultError(error);\n    if (reportOutcome.isErr()) {\n      logger.warn('Reporting result error failed', {\n        originalType: error.type,\n        reportingError: reportOutcome.error,\n      });\n    }\n  };\n\n  private runRecoveryStrategies = (error: AppError): ReactNode | null => {\n    const { recoveryStrategies } = this.props;\n    if (!recoveryStrategies || recoveryStrategies.length === 0) {\n      return null;\n    }\n\n    for (const strategy of recoveryStrategies) {\n      if (!strategy.canHandle(error)) {\n        continue;\n      }\n\n      const recovery = strategy.recover();\n      if (recovery.isOk()) {\n        return recovery.value;\n      }\n\n      logger.warn('Recovery strategy failed', {\n        errorType: error.type,\n        recoveryError: recovery.error,\n      });\n    }\n\n    return null;\n  };\n\n  /**\n   * Handle Result-based errors with custom recovery strategies\n   */\n  public handleResultError = (result: FPResult<unknown, AppError>) => {\n    if (!result.isErr()) {\n      return null;\n    }\n\n    const normalizedError = this.normalizeResultError(result.error);\n    this.notifyResultError(normalizedError);\n\n    const normalizedResult = err(normalizedError) as FPResult<unknown, AppError>;\n    this.setState({ resultError: normalizedResult });\n\n    if (this.props.onResultError) {\n      return this.props.onResultError(normalizedResult);\n    }\n\n    return this.renderResultError(normalizedError);\n  };\n\n  /**\n   * Render error UI based on Result error type\n   */\n  protected renderResultError = (error: AppError) => {\n    const recoveryFallback = this.runRecoveryStrategies(error);\n    if (recoveryFallback) {\n      return recoveryFallback;\n    }\n\n    switch (error.type) {\n      case 'network':\n        return (\n          <Alert\n            message=\"Network Error\"\n            description={error.message}\n            type=\"error\"\n            showIcon\n            data-testid=\"network-error\"\n            action={\n              error.retryable !== false ? (\n                <Button\n                  size=\"small\"\n                  onClick={() => {\n                    this.handleRetry();\n                  }}\n                >\n                  Retry\n                </Button>\n              ) : undefined\n            }\n          />\n        );\n\n      case 'auth':\n        return (\n          <Result\n            status=\"403\"\n            title=\"Authentication Error\"\n            subTitle={error.message}\n            data-testid=\"unauthorized-message\"\n            extra={\n              <Button type=\"primary\" onClick={() => (window.location.href = '/login')}>\n                Go to Login\n              </Button>\n            }\n          />\n        );\n\n      case 'business':\n        return (\n          <Alert\n            message=\"Business Logic Error\"\n            description={error.message}\n            type=\"warning\"\n            showIcon\n            data-testid=\"business-error\"\n          />\n        );\n\n      case 'validation':\n        return (\n          <Alert\n            message=\"Validation Error\"\n            description={error.message}\n            type=\"error\"\n            showIcon\n            data-testid=\"validation-error\"\n          />\n        );\n\n      default: {\n        // TypeScript exhaustiveness check - this should never happen\n        // but if it does, we want to display the error\n        const _exhaustive: never = error;\n        const unknownError = _exhaustive as AppError;\n        return (\n          <Alert\n            message=\"Error\"\n            description={unknownError.message}\n            type=\"error\"\n            showIcon\n            data-testid=\"unknown-error\"\n          />\n        );\n      }\n    }\n  };\n\n  private handleRetry = () => {\n    this.setState({ hasError: false, error: undefined, resultError: undefined });\n  };\n\n  override render() {\n    if (this.state.hasError) {\n      if (this.props.fallback) {\n        return this.props.fallback;\n      }\n\n      return (\n        <Result\n          status=\"error\"\n          title=\"Something went wrong\"\n          subTitle={this.state.error?.message || 'An unexpected error occurred'}\n          extra={\n            <Button type=\"primary\" onClick={this.handleRetry}>\n              Try Again\n            </Button>\n          }\n        />\n      );\n    }\n\n    // If there's a Result error, render it directly (no setState during render)\n    if (this.state.resultError?.isErr()) {\n      // Check if custom handler provided\n      if (this.props.onResultError) {\n        return this.props.onResultError(this.state.resultError);\n      }\n\n      // Render the error UI directly without calling setState\n      return this.renderResultError(this.state.resultError.error);\n    }\n\n    return this.props.children;\n  }\n}\n\n// HOC wrapper for easier usage\nexport function withErrorBoundary<T extends Record<string, any>>(\n  Component: React.ComponentType<T>,\n  errorBoundaryProps?: Omit<Props, 'children'>\n) {\n  const WrappedComponent = (props: T) => (\n    <ErrorBoundary {...errorBoundaryProps}>\n      <Component {...props} />\n    </ErrorBoundary>\n  );\n\n  WrappedComponent.displayName = `withErrorBoundary(${Component.displayName || Component.name})`;\n\n  return WrappedComponent;\n}\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/components/FormField.tsx",
        "messages": [],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 0,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/components/Layout.tsx",
        "messages": [
            {
                "ruleId": "@typescript-eslint/restrict-template-expressions",
                "severity": 1,
                "message": "Invalid type \"number\" of template literal expression.",
                "line": 53,
                "column": 21,
                "nodeType": "MemberExpression",
                "messageId": "invalidType",
                "endLine": 53,
                "endColumn": 36
            },
            {
                "ruleId": "@typescript-eslint/restrict-template-expressions",
                "severity": 1,
                "message": "Invalid type \"number\" of template literal expression.",
                "line": 59,
                "column": 20,
                "nodeType": "MemberExpression",
                "messageId": "invalidType",
                "endLine": 59,
                "endColumn": 35
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 65,
                "column": 33,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingReturnType",
                "endLine": 65,
                "endColumn": 35
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 115,
                "column": 50,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingReturnType",
                "endLine": 115,
                "endColumn": 52
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 122,
                "column": 9,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 122,
                "endColumn": 26,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                3019,
                                3036
                            ],
                            "text": "pathMap[pathname] != null"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                3019,
                                3036
                            ],
                            "text": "pathMap[pathname] ?? \"\""
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                3019,
                                3036
                            ],
                            "text": "Boolean(pathMap[pathname])"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 141,
                "column": 17,
                "nodeType": "ChainExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 141,
                "endColumn": 29,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                3504,
                                3516
                            ],
                            "text": "((tenant?.name) != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                3504,
                                3516
                            ],
                            "text": "((tenant?.name) ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                3504,
                                3516
                            ],
                            "text": "(Boolean((tenant?.name)))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 141,
                "column": 30,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 141,
                "endColumn": 32,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                3517,
                                3519
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 176,
                "column": 19,
                "nodeType": "ChainExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 176,
                "endColumn": 34,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                4684,
                                4699
                            ],
                            "text": "((user?.firstName) != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                4684,
                                4699
                            ],
                            "text": "((user?.firstName) ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                4684,
                                4699
                            ],
                            "text": "(Boolean((user?.firstName)))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 176,
                "column": 35,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 176,
                "endColumn": 37,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                4684,
                                4717
                            ],
                            "text": "(user?.firstName ?? user?.username)"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 176,
                "column": 38,
                "nodeType": "ChainExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 176,
                "endColumn": 52,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                4703,
                                4717
                            ],
                            "text": "((user?.username) != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                4703,
                                4717
                            ],
                            "text": "((user?.username) ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                4703,
                                4717
                            ],
                            "text": "(Boolean((user?.username)))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 176,
                "column": 53,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 176,
                "endColumn": 55,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                4718,
                                4720
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
                "line": 178,
                "column": 54,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorNullableBoolean",
                "endLine": 178,
                "endColumn": 64,
                "suggestions": [
                    {
                        "messageId": "conditionFixDefaultFalse",
                        "fix": {
                            "range": [
                                4828,
                                4838
                            ],
                            "text": "(screens.md ?? false)"
                        },
                        "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
                    },
                    {
                        "messageId": "conditionFixCompareTrue",
                        "fix": {
                            "range": [
                                4828,
                                4838
                            ],
                            "text": "(screens.md === true)"
                        },
                        "desc": "Change condition to check if true (`value === true`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 179,
                "column": 18,
                "nodeType": "ChainExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 179,
                "endColumn": 33,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                4880,
                                4895
                            ],
                            "text": "((user?.firstName) != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                4880,
                                4895
                            ],
                            "text": "((user?.firstName) ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                4880,
                                4895
                            ],
                            "text": "(Boolean((user?.firstName)))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 179,
                "column": 34,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 179,
                "endColumn": 36,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                4896,
                                4898
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/restrict-template-expressions",
                "severity": 1,
                "message": "Invalid type \"number\" of template literal expression.",
                "line": 198,
                "column": 27,
                "nodeType": "MemberExpression",
                "messageId": "invalidType",
                "endLine": 198,
                "endColumn": 42
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 15,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "import React, { useState } from 'react';\nimport { useNavigate, useLocation } from 'react-router-dom';\nimport { useAuth } from '@/contexts/AuthContext';\nimport {\n  Layout as AntLayout,\n  Menu,\n  Dropdown,\n  Avatar,\n  Breadcrumb,\n  theme,\n  Button,\n  Modal,\n  Grid,\n} from 'antd';\nimport {\n  DashboardOutlined,\n  ContactsOutlined,\n  UserOutlined,\n  LogoutOutlined,\n  MenuOutlined,\n  HeartOutlined,\n  DatabaseOutlined,\n} from '@ant-design/icons';\n\n// MDC: Always use Ant Design components for UI - never use raw HTML elements, custom CSS classes, or non-interactive elements. Use only Antd theme colors and components. Replace any custom styling with Ant Design equivalents.\n\ninterface LayoutProps {\n  children: React.ReactNode;\n}\n\nexport const Layout: React.FC<LayoutProps> = ({ children }) => {\n  const { user, tenant, logout } = useAuth();\n  const navigate = useNavigate();\n  const location = useLocation();\n  const [collapsed, setCollapsed] = useState(false);\n\n  const { token } = theme.useToken();\n  const screens = Grid.useBreakpoint();\n\n  const layoutStyles = {\n    siderHeader: {\n      height: 64,\n      padding: token.paddingMD,\n      textAlign: 'center' as const,\n      color: token.colorTextLightSolid,\n      background: `linear-gradient(135deg, ${token.colorPrimary} 0%, ${token.colorPrimaryHover} 100%)`,\n    },\n    sider: {\n      background: `linear-gradient(135deg, ${token.colorPrimaryHover} 0%, ${token.colorPrimaryActive} 100%)`,\n    },\n    header: {\n      background: token.colorBgContainer,\n      padding: `0 ${token.paddingMD}`,\n      display: 'flex',\n      alignItems: 'center',\n      justifyContent: 'space-between',\n    },\n    content: {\n      margin: `0 ${token.paddingMD}`,\n      padding: token.paddingLG,\n      background: token.colorBgContainer,\n    },\n  };\n\n  const handleLogout = async () => {\n    try {\n      await logout();\n      navigate('/login');\n    } catch (error) {\n      console.error('Logout failed:', error);\n      // Use Antd Modal.error instead of alert\n      Modal.error({\n        title: 'Logout Failed',\n        content: 'Failed to logout properly. Please try again.',\n      });\n    }\n  };\n\n  const menuItems = [\n    {\n      key: '/dashboard',\n      icon: <DashboardOutlined />,\n      label: 'Dashboard',\n    },\n    {\n      key: '/address-book',\n      icon: <ContactsOutlined />,\n      label: 'Address Book',\n    },\n    {\n      key: '/tenants',\n      icon: <DatabaseOutlined />,\n      label: 'Tenants',\n    },\n  ];\n\n  const userMenuItems = [\n    {\n      key: 'profile',\n      icon: <UserOutlined />,\n      label: 'Profile',\n      disabled: true,\n    },\n    {\n      type: 'divider' as const,\n    },\n    {\n      key: 'logout',\n      icon: <LogoutOutlined />,\n      label: 'Logout',\n      onClick: handleLogout,\n    },\n  ];\n\n  const generateBreadcrumbs = (pathname: string) => {\n    const pathMap: Record<string, string> = {\n      '/dashboard': 'Dashboard',\n      '/address-book': 'Address Book',\n      '/tenants': 'Tenants',\n    };\n    const items = [{ title: 'Home' }];\n    if (pathMap[pathname]) {\n      items.push({ title: pathMap[pathname] });\n    }\n    return items;\n  };\n\n  return (\n    <AntLayout style={{ minHeight: '100vh' }}>\n      <AntLayout.Sider\n        collapsible\n        collapsed={collapsed}\n        onCollapse={value => {\n          setCollapsed(value);\n        }}\n        trigger={null}\n        style={layoutStyles.sider}\n      >\n        <div style={layoutStyles.siderHeader}>\n          <HeartOutlined style={{ fontSize: 32 }} />\n          <div>{tenant?.name || 'Natural Pharmacy System'}</div>\n        </div>\n        <Menu\n          theme=\"dark\"\n          selectedKeys={[location.pathname]}\n          mode=\"inline\"\n          items={menuItems}\n          onSelect={({ key }) => {\n            navigate(key);\n          }}\n        />\n      </AntLayout.Sider>\n\n      <AntLayout>\n        <AntLayout.Header style={layoutStyles.header}>\n          <Button\n            type=\"text\"\n            icon={<MenuOutlined />}\n            aria-label=\"Toggle sidebar menu\"\n            onClick={() => {\n              setCollapsed(prev => !prev);\n            }}\n            style={{ fontSize: token.fontSizeLG, color: token.colorTextSecondary }}\n          />\n          <Breadcrumb\n            items={generateBreadcrumbs(location.pathname)}\n            aria-label=\"Current page navigation\"\n          />\n          <Dropdown menu={{ items: userMenuItems }} placement=\"bottomRight\" trigger={['click']}>\n            <Button\n              type=\"text\"\n              aria-label=\"User menu\"\n              style={{ display: 'flex', alignItems: 'center' }}\n            >\n              <Avatar style={{ backgroundColor: token.colorPrimary }}>\n                {(user?.firstName || user?.username || 'U').charAt(0).toUpperCase()}\n              </Avatar>\n              <span style={{ marginLeft: 8, display: screens.md ? 'inline' : 'none' }}>\n                {user?.firstName || user?.username}\n              </span>\n            </Button>\n          </Dropdown>\n        </AntLayout.Header>\n\n        <AntLayout.Content style={layoutStyles.content}>{children}</AntLayout.Content>\n\n        <AntLayout.Footer\n          style={{\n            textAlign: 'center',\n            borderTop: `4px solid ${token.colorBorderSecondary}`,\n            padding: '20px 0',\n            background: token.colorFill,\n            display: 'flex',\n            flexDirection: 'column',\n            alignItems: 'center',\n            justifyContent: 'center',\n            width: '100%',\n            margin: `0 -${token.paddingMD}`,\n            boxSizing: 'border-box',\n          }}\n        >\n          <div> 2025 Natural Pharmacy System. Built with TypeScript, Bun, and React.</div>\n          <div>Secure multi-tenant platform with JWT authentication</div>\n        </AntLayout.Footer>\n      </AntLayout>\n    </AntLayout>\n  );\n};\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/components/PrivateRoute.tsx",
        "messages": [
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 37,
                "column": 15,
                "nodeType": "VariableDeclarator",
                "messageId": "anyAssignment",
                "endLine": 40,
                "endColumn": 78
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected any value in conditional. An explicit comparison or type conversion is required.",
                "line": 38,
                "column": 11,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorAny",
                "endLine": 38,
                "endColumn": 33,
                "suggestions": [
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                1278,
                                1300
                            ],
                            "text": "(Boolean(import.meta.env.VITEST))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 38,
                "column": 34,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 38,
                "endColumn": 36,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                1278,
                                1338
                            ],
                            "text": "(import.meta.env.VITEST ??\n          import.meta.env.BUN_TEST)"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected any value in conditional. An explicit comparison or type conversion is required.",
                "line": 39,
                "column": 11,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorAny",
                "endLine": 39,
                "endColumn": 35,
                "suggestions": [
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                1314,
                                1338
                            ],
                            "text": "(Boolean(import.meta.env.BUN_TEST))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 39,
                "column": 36,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 39,
                "endColumn": 38,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                1339,
                                1341
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected any value in conditional. An explicit comparison or type conversion is required.",
                "line": 42,
                "column": 37,
                "nodeType": "Identifier",
                "messageId": "conditionErrorAny",
                "endLine": 42,
                "endColumn": 54,
                "suggestions": [
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                1458,
                                1475
                            ],
                            "text": "(Boolean(isTestEnvironment))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 6,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "import React from 'react';\nimport { Navigate, useLocation } from 'react-router-dom';\nimport { useAuth } from '@/contexts/AuthContext';\nimport './PrivateRoute.css';\n\ninterface PrivateRouteProps {\n  children: React.ReactNode;\n}\n\n/**\n * PrivateRoute component - wraps protected routes and redirects to login if not authenticated\n * Uses React.memo with custom comparison to prevent infinite redirect loops in tests\n */\nexport const PrivateRoute: React.FC<PrivateRouteProps> = React.memo(\n  ({ children }) => {\n    const { isAuthenticated, isLoading } = useAuth();\n    const location = useLocation();\n\n    if (isLoading) {\n      return (\n        <div\n          className=\"flex items-center justify-center min-h-screen\"\n          data-testid=\"loading-container\"\n        >\n          <div className=\"loading\" role=\"status\" aria-live=\"polite\" data-testid=\"loading-spinner\">\n            <div className=\"spinner\"></div>\n            <span>Loading...</span>\n          </div>\n        </div>\n      );\n    }\n\n    if (!isAuthenticated) {\n      // Only redirect if not already on the login page to prevent infinite redirect loops\n      if (location.pathname === '/login') {\n        // In tests, allow login page to be rendered without throwing errors\n        const isTestEnvironment =\n          import.meta.env.VITEST ||\n          import.meta.env.BUN_TEST ||\n          (typeof process !== 'undefined' && process.env.NODE_ENV === 'test');\n\n        if (import.meta.env.DEV && !isTestEnvironment) {\n          const errorMessage =\n            `PrivateRoute Configuration Error: The '/login' route must not be protected by PrivateRoute. ` +\n            `This creates a redirect loop. Please remove the PrivateRoute wrapper from the login route in your router configuration.`;\n\n          console.error(errorMessage);\n          throw new Error(errorMessage);\n        }\n\n        // In production and tests, render children for login page\n        return <>{children}</>;\n      }\n\n      return <Navigate to=\"/login\" state={{ from: location }} replace={true} />;\n    }\n\n    return <>{children}</>;\n  },\n  (prevProps, nextProps) => {\n    // Custom equality check: we only care about children identity\n    // Return true if props are considered equal (skip re-render)\n    // Children comparison - use reference equality\n    return prevProps.children === nextProps.children;\n  }\n);\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/components/SearchComponents.tsx",
        "messages": [
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, the types have no overlap.",
                "line": 413,
                "column": 43,
                "nodeType": "BinaryExpression",
                "messageId": "noOverlapBooleanExpression",
                "endLine": 413,
                "endColumn": 62
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-type-conversion",
                "severity": 1,
                "message": "Passing a number to Number() does not change the type or value of the number.",
                "line": 413,
                "column": 72,
                "nodeType": "Identifier",
                "messageId": "unnecessaryTypeConversion",
                "endLine": 413,
                "endColumn": 78,
                "suggestions": [
                    {
                        "messageId": "suggestRemove",
                        "fix": {
                            "range": [
                                11007,
                                11020
                            ],
                            "text": "value"
                        },
                        "desc": "Remove the type conversion."
                    },
                    {
                        "messageId": "suggestSatisfies",
                        "data": {
                            "type": "number"
                        },
                        "fix": {
                            "range": [
                                11007,
                                11020
                            ],
                            "text": "(value satisfies number)"
                        },
                        "desc": "Instead, assert that the value satisfies the number type."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, the types have no overlap.",
                "line": 427,
                "column": 43,
                "nodeType": "BinaryExpression",
                "messageId": "noOverlapBooleanExpression",
                "endLine": 427,
                "endColumn": 62
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-type-conversion",
                "severity": 1,
                "message": "Passing a number to Number() does not change the type or value of the number.",
                "line": 427,
                "column": 72,
                "nodeType": "Identifier",
                "messageId": "unnecessaryTypeConversion",
                "endLine": 427,
                "endColumn": 78,
                "suggestions": [
                    {
                        "messageId": "suggestRemove",
                        "fix": {
                            "range": [
                                11510,
                                11523
                            ],
                            "text": "value"
                        },
                        "desc": "Remove the type conversion."
                    },
                    {
                        "messageId": "suggestSatisfies",
                        "data": {
                            "type": "number"
                        },
                        "fix": {
                            "range": [
                                11510,
                                11523
                            ],
                            "text": "(value satisfies number)"
                        },
                        "desc": "Instead, assert that the value satisfies the number type."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, the types have no overlap.",
                "line": 441,
                "column": 44,
                "nodeType": "BinaryExpression",
                "messageId": "noOverlapBooleanExpression",
                "endLine": 441,
                "endColumn": 63
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-type-conversion",
                "severity": 1,
                "message": "Passing a number to Number() does not change the type or value of the number.",
                "line": 441,
                "column": 73,
                "nodeType": "Identifier",
                "messageId": "unnecessaryTypeConversion",
                "endLine": 441,
                "endColumn": 79,
                "suggestions": [
                    {
                        "messageId": "suggestRemove",
                        "fix": {
                            "range": [
                                11970,
                                11983
                            ],
                            "text": "value"
                        },
                        "desc": "Remove the type conversion."
                    },
                    {
                        "messageId": "suggestSatisfies",
                        "data": {
                            "type": "number"
                        },
                        "fix": {
                            "range": [
                                11970,
                                11983
                            ],
                            "text": "(value satisfies number)"
                        },
                        "desc": "Instead, assert that the value satisfies the number type."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected value in conditional. A boolean expression is required.",
                "line": 454,
                "column": 26,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorOther",
                "endLine": 454,
                "endColumn": 35
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary optional chain on a non-nullish value.",
                "line": 456,
                "column": 59,
                "nodeType": "MemberExpression",
                "messageId": "neverOptionalChain",
                "endLine": 456,
                "endColumn": 61,
                "suggestions": [
                    {
                        "messageId": "suggestRemoveOptionalChain",
                        "fix": {
                            "range": [
                                12519,
                                12521
                            ],
                            "text": "."
                        },
                        "desc": "Remove unnecessary optional chain"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected value in conditional. A boolean expression is required.",
                "line": 462,
                "column": 26,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorOther",
                "endLine": 462,
                "endColumn": 35
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary optional chain on a non-nullish value.",
                "line": 464,
                "column": 70,
                "nodeType": "MemberExpression",
                "messageId": "neverOptionalChain",
                "endLine": 464,
                "endColumn": 72,
                "suggestions": [
                    {
                        "messageId": "suggestRemoveOptionalChain",
                        "fix": {
                            "range": [
                                12874,
                                12876
                            ],
                            "text": "."
                        },
                        "desc": "Remove unnecessary optional chain"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected value in conditional. A boolean expression is required.",
                "line": 473,
                "column": 22,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorOther",
                "endLine": 473,
                "endColumn": 34
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary optional chain on a non-nullish value.",
                "line": 475,
                "column": 54,
                "nodeType": "MemberExpression",
                "messageId": "neverOptionalChain",
                "endLine": 475,
                "endColumn": 56,
                "suggestions": [
                    {
                        "messageId": "suggestRemoveOptionalChain",
                        "fix": {
                            "range": [
                                13267,
                                13269
                            ],
                            "text": "."
                        },
                        "desc": "Remove unnecessary optional chain"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected value in conditional. A boolean expression is required.",
                "line": 668,
                "column": 14,
                "nodeType": "Identifier",
                "messageId": "conditionErrorOther",
                "endLine": 668,
                "endColumn": 30
            },
            {
                "ruleId": "react-refresh/only-export-components",
                "severity": 1,
                "message": "Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.",
                "line": 715,
                "column": 14,
                "nodeType": "Identifier",
                "messageId": "namedExport",
                "endLine": 715,
                "endColumn": 56
            },
            {
                "ruleId": "react-refresh/only-export-components",
                "severity": 1,
                "message": "Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.",
                "line": 791,
                "column": 14,
                "nodeType": "Identifier",
                "messageId": "namedExport",
                "endLine": 791,
                "endColumn": 55
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 15,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "/**\n * Enhanced Search Components for Data List UX\n * Following Ant Design Data List specifications for optimal search experience\n */\n\nimport React, { useState, useCallback, useMemo } from 'react';\nimport {\n  Input,\n  Select,\n  Button,\n  Card,\n  Space,\n  Typography,\n  Empty,\n  Spin,\n  DatePicker,\n  InputNumber,\n  Switch,\n  Badge,\n  Pagination,\n  Row,\n  Col,\n} from 'antd';\nimport {\n  SearchOutlined,\n  FilterOutlined,\n  ClearOutlined,\n  PlusOutlined,\n  MinusCircleOutlined,\n} from '@ant-design/icons';\nimport { createScopedIdGenerator } from '@/utils/uniqueId';\n\nconst { Option } = Select;\nconst { Text, Title } = Typography;\n\n/**\n * Search field configuration for different entity types\n */\nexport interface SearchFieldConfig {\n  key: string;\n  label: string;\n  type: 'text' | 'select' | 'date' | 'number' | 'boolean';\n  options?: { label: string; value: string | number | boolean }[];\n  placeholder?: string;\n  searchable?: boolean;\n  filterable?: boolean;\n  sortable?: boolean;\n}\n\n/**\n * Search filter configuration\n */\nexport interface SearchFilter {\n  id: string;\n  field: string;\n  operator:\n    | 'contains'\n    | 'equals'\n    | 'startsWith'\n    | 'endsWith'\n    | 'gt'\n    | 'gte'\n    | 'lt'\n    | 'lte'\n    | 'between'\n    | 'in'\n    | 'notIn';\n  value: string | number | boolean | null | [string | number | null, string | number | null];\n  label?: string;\n}\n\n/**\n * Search query configuration\n */\nexport interface SearchQuery {\n  queryId: string;\n  filters: SearchFilter[];\n  sortBy?: string;\n  sortOrder?: 'asc' | 'desc';\n  page?: number;\n  pageSize?: number;\n}\n\n/**\n * Search result configuration\n */\nexport interface SearchResult<T> {\n  data: T[];\n  total: number;\n  page: number;\n  pageSize: number;\n  totalPages: number;\n  hasNext: boolean;\n  hasPrev: boolean;\n}\n\n/**\n * Smart Search Input Component\n * Supports multi-attribute search with intelligent suggestions\n */\nexport interface SmartSearchInputProps {\n  placeholder?: string;\n  onSearch: (query: string) => void;\n  onClear?: () => void;\n  loading?: boolean;\n  suggestions?: string[];\n  searchFields?: SearchFieldConfig[];\n  value?: string;\n  onChange?: (value: string) => void;\n  className?: string;\n  style?: React.CSSProperties;\n}\n\nexport const SmartSearchInput: React.FC<SmartSearchInputProps> = ({\n  placeholder = 'Search across all fields...',\n  onSearch,\n  onClear,\n  loading = false,\n  suggestions = [],\n  searchFields: _searchFields = [],\n  value = '',\n  onChange,\n  className,\n  style,\n}) => {\n  const [_isFocused, setIsFocused] = useState(false);\n  const [isOpen, setIsOpen] = useState(false);\n  const [highlightedIndex, setHighlightedIndex] = useState(-1);\n\n  const handleSearch = useCallback(() => {\n    if (value.trim()) {\n      onSearch(value.trim());\n    }\n  }, [value, onSearch]);\n\n  const handleClear = useCallback(() => {\n    onChange?.('');\n    onClear?.();\n    setHighlightedIndex(-1);\n    setIsOpen(false);\n  }, [onChange, onClear]);\n\n  const handleSuggestionSelect = useCallback(\n    (suggestion: string) => {\n      onChange?.(suggestion);\n      handleSearch();\n      setHighlightedIndex(-1);\n      setIsOpen(false);\n    },\n    [onChange, handleSearch]\n  );\n\n  const handleKeyPress = useCallback(\n    (e: React.KeyboardEvent) => {\n      if (e.key === 'Enter') {\n        if (isOpen && highlightedIndex >= 0 && highlightedIndex < suggestions.length) {\n          // Select highlighted suggestion\n          const selectedSuggestion = suggestions[highlightedIndex];\n          if (selectedSuggestion != null && selectedSuggestion !== '') {\n            handleSuggestionSelect(selectedSuggestion);\n          }\n        } else {\n          // Perform search with current value\n          handleSearch();\n        }\n      }\n    },\n    [handleSearch, isOpen, highlightedIndex, suggestions, handleSuggestionSelect]\n  );\n\n  const handleKeyDown = useCallback(\n    (e: React.KeyboardEvent) => {\n      if (!isOpen || suggestions.length === 0) return;\n\n      switch (e.key) {\n        case 'ArrowDown':\n          e.preventDefault();\n          setHighlightedIndex(prev => (prev < suggestions.length - 1 ? prev + 1 : 0));\n          break;\n        case 'ArrowUp':\n          e.preventDefault();\n          setHighlightedIndex(prev => (prev > 0 ? prev - 1 : suggestions.length - 1));\n          break;\n        case 'Escape':\n          e.preventDefault();\n          setIsOpen(false);\n          setHighlightedIndex(-1);\n          break;\n      }\n    },\n    [isOpen, suggestions.length]\n  );\n\n  return (\n    <div className={className} style={style}>\n      <Input\n        placeholder={placeholder}\n        prefix={<SearchOutlined />}\n        suffix={\n          <Space size=\"small\">\n            {value && (\n              <Button\n                type=\"text\"\n                size=\"small\"\n                icon={<ClearOutlined />}\n                onClick={handleClear}\n                aria-label=\"Clear search\"\n              />\n            )}\n            <Button\n              type=\"primary\"\n              size=\"small\"\n              icon={<SearchOutlined />}\n              onClick={handleSearch}\n              loading={loading}\n              aria-label=\"Search\"\n            />\n          </Space>\n        }\n        value={value}\n        onChange={e => onChange?.(e.target.value)}\n        onKeyUp={handleKeyPress}\n        onKeyDown={handleKeyDown}\n        onFocus={() => {\n          setIsFocused(true);\n          setIsOpen(true);\n          setHighlightedIndex(-1);\n        }}\n        onBlur={() => {\n          setIsFocused(false);\n          // Delay closing to allow clicking on suggestions\n          setTimeout(() => {\n            setIsOpen(false);\n            setHighlightedIndex(-1);\n          }, 150);\n        }}\n        style={{ width: '100%' }}\n      />\n\n      {/* Search suggestions */}\n      {isOpen && suggestions.length > 0 && (\n        <Card\n          size=\"small\"\n          role=\"listbox\"\n          aria-label=\"Search suggestions\"\n          style={{\n            position: 'absolute',\n            top: '100%',\n            left: 0,\n            right: 0,\n            zIndex: 1000,\n            marginTop: 4,\n            maxHeight: 200,\n            overflowY: 'auto',\n          }}\n        >\n          {suggestions.map((suggestion, index) => (\n            <div\n              key={`suggestion-${index.toString()}`}\n              role=\"option\"\n              aria-selected={index === highlightedIndex}\n              style={{\n                padding: '8px 12px',\n                cursor: 'pointer',\n                borderBottom: index < suggestions.length - 1 ? '1px solid #f0f0f0' : 'none',\n                backgroundColor: index === highlightedIndex ? '#e6f7ff' : 'transparent',\n                color: index === highlightedIndex ? '#1890ff' : 'inherit',\n              }}\n              onClick={() => {\n                handleSuggestionSelect(suggestion);\n              }}\n              onMouseEnter={() => {\n                setHighlightedIndex(index);\n              }}\n            >\n              <Text>{suggestion}</Text>\n            </div>\n          ))}\n        </Card>\n      )}\n    </div>\n  );\n};\n\n/**\n * Advanced Filter Component\n * Supports dynamic filters with multiple operators\n */\nexport interface AdvancedFilterProps {\n  fields: SearchFieldConfig[];\n  filters: SearchFilter[];\n  onFiltersChange: (filters: SearchFilter[]) => void;\n  onApply: () => void;\n  onClear: () => void;\n  loading?: boolean;\n  className?: string;\n  style?: React.CSSProperties;\n}\n\nexport const AdvancedFilter: React.FC<AdvancedFilterProps> = ({\n  fields,\n  filters,\n  onFiltersChange,\n  onApply,\n  onClear,\n  loading = false,\n  className,\n  style,\n}) => {\n  // Create a scoped ID generator for filter IDs\n  const generateFilterId = useMemo(() => createScopedIdGenerator('filter-'), []);\n\n  const addFilter = useCallback(() => {\n    const newFilter: SearchFilter = {\n      id: generateFilterId(),\n      field: fields[0]?.key ?? '',\n      operator: 'contains',\n      value: '',\n    };\n    onFiltersChange([...filters, newFilter]);\n  }, [fields, filters, onFiltersChange, generateFilterId]);\n\n  const updateFilter = useCallback(\n    (id: string, updates: Partial<SearchFilter>) => {\n      const updatedFilters = filters.map(filter =>\n        filter.id === id ? { ...filter, ...updates } : filter\n      );\n      onFiltersChange(updatedFilters);\n    },\n    [filters, onFiltersChange]\n  );\n\n  const removeFilter = useCallback(\n    (id: string) => {\n      const updatedFilters = filters.filter(filter => filter.id !== id);\n      onFiltersChange(updatedFilters);\n    },\n    [filters, onFiltersChange]\n  );\n\n  const getOperatorsForField = useCallback(\n    (fieldKey: string) => {\n      const field = fields.find(f => f.key === fieldKey);\n      if (!field) return [];\n\n      switch (field.type) {\n        case 'text':\n          return [\n            { label: 'Contains', value: 'contains' },\n            { label: 'Equals', value: 'equals' },\n            { label: 'Starts With', value: 'startsWith' },\n            { label: 'Ends With', value: 'endsWith' },\n          ];\n        case 'number':\n          return [\n            { label: 'Equals', value: 'equals' },\n            { label: 'Greater Than', value: 'gt' },\n            { label: 'Greater or Equal', value: 'gte' },\n            { label: 'Less Than', value: 'lt' },\n            { label: 'Less or Equal', value: 'lte' },\n            { label: 'Between', value: 'between' },\n          ];\n        case 'date':\n          return [\n            { label: 'Equals', value: 'equals' },\n            { label: 'After', value: 'gt' },\n            { label: 'Before', value: 'lt' },\n            { label: 'Between', value: 'between' },\n          ];\n        case 'boolean':\n          return [{ label: 'Equals', value: 'equals' }];\n        case 'select':\n          return [\n            { label: 'Equals', value: 'equals' },\n            { label: 'In', value: 'in' },\n            { label: 'Not In', value: 'notIn' },\n          ];\n        default:\n          return [];\n      }\n    },\n    [fields]\n  );\n\n  const renderFilterValue = useCallback(\n    (filter: SearchFilter) => {\n      const field = fields.find(f => f.key === filter.field);\n      if (!field) return null;\n\n      switch (field.type) {\n        case 'text':\n          return (\n            <Input\n              placeholder={`Enter ${field.label.toLowerCase()}...`}\n              value={filter.value as string}\n              onChange={e => {\n                updateFilter(filter.id, { value: e.target.value });\n              }}\n              style={{ minWidth: 200 }}\n            />\n          );\n        case 'number':\n          if (filter.operator === 'between') {\n            const values = Array.isArray(filter.value) ? filter.value : ['', ''];\n            return (\n              <Space>\n                <InputNumber\n                  placeholder=\"From\"\n                  value={values[0] as number}\n                  onChange={value => {\n                    updateFilter(filter.id, {\n                      value: [\n                        value === null || value === undefined ? null : Number(value),\n                        values[1],\n                      ],\n                    });\n                  }}\n                />\n                <Text>to</Text>\n                <InputNumber\n                  placeholder=\"To\"\n                  value={values[1] as number}\n                  onChange={value => {\n                    updateFilter(filter.id, {\n                      value: [\n                        values[0],\n                        value === null || value === undefined ? null : Number(value),\n                      ],\n                    });\n                  }}\n                />\n              </Space>\n            );\n          }\n          return (\n            <InputNumber\n              placeholder={`Enter ${field.label.toLowerCase()}...`}\n              value={filter.value as number}\n              onChange={value => {\n                updateFilter(filter.id, {\n                  value: value === null || value === undefined ? null : Number(value),\n                });\n              }}\n              style={{ minWidth: 200 }}\n            />\n          );\n        case 'date':\n          if (filter.operator === 'between') {\n            const values = Array.isArray(filter.value) ? filter.value : ['', ''];\n            return (\n              <Space>\n                <DatePicker\n                  placeholder=\"From\"\n                  value={values[0] ? new Date(values[0] as string) : null}\n                  onChange={date => {\n                    updateFilter(filter.id, { value: [date?.toISOString() || '', values[1]] });\n                  }}\n                />\n                <Text>to</Text>\n                <DatePicker\n                  placeholder=\"To\"\n                  value={values[1] ? new Date(values[1] as string) : null}\n                  onChange={date => {\n                    updateFilter(filter.id, { value: [values[0], date?.toISOString() || ''] });\n                  }}\n                />\n              </Space>\n            );\n          }\n          return (\n            <DatePicker\n              placeholder={`Select ${field.label.toLowerCase()}...`}\n              value={filter.value ? new Date(filter.value as string) : null}\n              onChange={date => {\n                updateFilter(filter.id, { value: date?.toISOString() || '' });\n              }}\n              style={{ minWidth: 200 }}\n            />\n          );\n        case 'boolean':\n          return (\n            <Switch\n              checked={filter.value as boolean}\n              onChange={checked => {\n                updateFilter(filter.id, { value: checked });\n              }}\n            />\n          );\n        case 'select':\n          return (\n            <Select\n              placeholder={`Select ${field.label.toLowerCase()}...`}\n              value={filter.value as string | string[] | null}\n              onChange={value => {\n                updateFilter(filter.id, {\n                  value: value as\n                    | string\n                    | number\n                    | boolean\n                    | null\n                    | [string | number | null, string | number | null],\n                });\n              }}\n              style={{ minWidth: 200 }}\n              mode={\n                filter.operator === 'in' || filter.operator === 'notIn' ? 'multiple' : undefined\n              }\n            >\n              {field.options?.map(option => (\n                <Option key={String(option.value)} value={option.value}>\n                  {option.label}\n                </Option>\n              ))}\n            </Select>\n          );\n        default:\n          return null;\n      }\n    },\n    [fields, updateFilter]\n  );\n\n  return (\n    <Card\n      title={\n        <Space>\n          <FilterOutlined />\n          <Text>Advanced Filters</Text>\n          <Badge count={filters.length} />\n        </Space>\n      }\n      size=\"small\"\n      className={className}\n      style={style}\n      extra={\n        <Space>\n          <Button\n            type=\"primary\"\n            icon={<FilterOutlined />}\n            onClick={onApply}\n            loading={loading}\n            size=\"small\"\n          >\n            Apply Filters\n          </Button>\n          <Button icon={<ClearOutlined />} onClick={onClear} size=\"small\">\n            Clear All\n          </Button>\n        </Space>\n      }\n    >\n      <Space direction=\"vertical\" style={{ width: '100%' }}>\n        {filters.map((filter, _index) => (\n          <Card\n            key={filter.id}\n            size=\"small\"\n            style={{ backgroundColor: '#fafafa' }}\n            extra={\n              <Button\n                type=\"text\"\n                danger\n                icon={<MinusCircleOutlined />}\n                onClick={() => {\n                  removeFilter(filter.id);\n                }}\n                size=\"small\"\n              />\n            }\n          >\n            <Row gutter={[12, 12]} align=\"middle\">\n              <Col span={6}>\n                <Select\n                  placeholder=\"Select field\"\n                  value={filter.field}\n                  onChange={value => {\n                    updateFilter(filter.id, { field: value });\n                  }}\n                  style={{ width: '100%' }}\n                >\n                  {fields.map(field => (\n                    <Option key={field.key} value={field.key}>\n                      {field.label}\n                    </Option>\n                  ))}\n                </Select>\n              </Col>\n              <Col span={4}>\n                <Select\n                  placeholder=\"Operator\"\n                  value={filter.operator}\n                  onChange={value => {\n                    updateFilter(filter.id, { operator: value });\n                  }}\n                  style={{ width: '100%' }}\n                >\n                  {getOperatorsForField(filter.field).map(op => (\n                    <Option key={op.value} value={op.value}>\n                      {op.label}\n                    </Option>\n                  ))}\n                </Select>\n              </Col>\n              <Col span={14}>{renderFilterValue(filter)}</Col>\n            </Row>\n          </Card>\n        ))}\n\n        <Button type=\"dashed\" icon={<PlusOutlined />} onClick={addFilter} block>\n          Add Filter\n        </Button>\n      </Space>\n    </Card>\n  );\n};\n\n/**\n * Search Results Component\n * Displays results with proper empty states and loading indicators\n */\nexport interface SearchResultsProps<T> {\n  data: T[];\n  loading?: boolean;\n  total?: number;\n  page?: number;\n  pageSize?: number;\n  onPageChange?: (page: number, pageSize: number) => void;\n  renderItem?: (item: T, index: number) => React.ReactNode;\n  emptyStateTitle?: string;\n  emptyStateDescription?: string;\n  emptyStateAction?: React.ReactNode;\n  className?: string;\n  style?: React.CSSProperties;\n}\n\nexport const SearchResults: React.FC<SearchResultsProps<unknown>> = ({\n  data,\n  loading = false,\n  total = 0,\n  page = 1,\n  pageSize = 10,\n  onPageChange,\n  renderItem,\n  emptyStateTitle = 'No results found',\n  emptyStateDescription = 'Try adjusting your search criteria or filters.',\n  emptyStateAction,\n  className,\n  style,\n}) => {\n  if (loading) {\n    return (\n      <div style={{ textAlign: 'center', padding: '48px' }}>\n        <Spin size=\"large\" />\n        <div style={{ marginTop: 16 }}>\n          <Text type=\"secondary\">Searching...</Text>\n        </div>\n      </div>\n    );\n  }\n\n  if (data.length === 0) {\n    return (\n      <Empty\n        image={Empty.PRESENTED_IMAGE_SIMPLE}\n        description={\n          <div>\n            <Title level={4}>{emptyStateTitle}</Title>\n            <Text type=\"secondary\">{emptyStateDescription}</Text>\n            {emptyStateAction && <div style={{ marginTop: 16 }}>{emptyStateAction}</div>}\n          </div>\n        }\n      />\n    );\n  }\n\n  return (\n    <div className={className} style={style}>\n      {data.map((item, index) => (\n        <div key={index}>\n          {renderItem ? renderItem(item, index) : <div>{JSON.stringify(item)}</div>}\n        </div>\n      ))}\n\n      {/* Pagination controls - only render when total is provided and > pageSize */}\n      {total && total > pageSize && (\n        <div style={{ marginTop: 16, textAlign: 'center' }}>\n          <Pagination\n            current={page}\n            pageSize={pageSize}\n            total={total}\n            onChange={(newPage, newPageSize) => {\n              if (onPageChange) {\n                onPageChange(newPage, newPageSize);\n              }\n            }}\n            onShowSizeChange={(current, size) => {\n              if (onPageChange) {\n                onPageChange(current, size);\n              }\n            }}\n            showSizeChanger\n            showQuickJumper\n            showTotal={(total, range) =>\n              `${range[0].toString()}-${range[1].toString()} of ${total.toString()} items`\n            }\n          />\n        </div>\n      )}\n    </div>\n  );\n};\n\n/**\n * Search Configuration for different entity types\n */\nexport const CONTACT_SEARCH_FIELDS: SearchFieldConfig[] = [\n  {\n    key: 'fullName',\n    label: 'Full Name',\n    type: 'text',\n    searchable: true,\n    filterable: true,\n    sortable: true,\n  },\n  {\n    key: 'firstName',\n    label: 'First Name',\n    type: 'text',\n    searchable: true,\n    filterable: true,\n    sortable: true,\n  },\n  {\n    key: 'lastName',\n    label: 'Last Name',\n    type: 'text',\n    searchable: true,\n    filterable: true,\n    sortable: true,\n  },\n  {\n    key: 'email',\n    label: 'Email',\n    type: 'text',\n    searchable: true,\n    filterable: true,\n    sortable: true,\n  },\n  {\n    key: 'phone',\n    label: 'Phone',\n    type: 'text',\n    searchable: true,\n    filterable: true,\n    sortable: true,\n  },\n  {\n    key: 'gender',\n    label: 'Gender',\n    type: 'select',\n    options: [\n      { label: 'Male', value: 'male' },\n      { label: 'Female', value: 'female' },\n      { label: 'Other', value: 'other' },\n    ],\n    filterable: true,\n    sortable: true,\n  },\n  {\n    key: 'age',\n    label: 'Age',\n    type: 'number',\n    filterable: true,\n    sortable: true,\n  },\n  {\n    key: 'createdAt',\n    label: 'Created Date',\n    type: 'date',\n    filterable: true,\n    sortable: true,\n  },\n  {\n    key: 'isActive',\n    label: 'Active',\n    type: 'boolean',\n    filterable: true,\n    sortable: true,\n  },\n];\n\nexport const TENANT_SEARCH_FIELDS: SearchFieldConfig[] = [\n  {\n    key: 'name',\n    label: 'Name',\n    type: 'text',\n    searchable: true,\n    filterable: true,\n    sortable: true,\n  },\n  {\n    key: 'id',\n    label: 'ID',\n    type: 'text',\n    searchable: true,\n    filterable: true,\n    sortable: true,\n  },\n  {\n    key: 'db_url',\n    label: 'Database URL',\n    type: 'text',\n    searchable: true,\n    filterable: true,\n    sortable: false,\n  },\n  {\n    key: 'created_at',\n    label: 'Created Date',\n    type: 'date',\n    filterable: true,\n    sortable: true,\n  },\n  {\n    key: 'updated_at',\n    label: 'Updated Date',\n    type: 'date',\n    filterable: true,\n    sortable: true,\n  },\n];\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/components/TenantAnalytics.tsx",
        "messages": [
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'useMemo' is defined but never used. Allowed unused vars must match /^_/u.",
                "line": 6,
                "column": 40,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 6,
                "endColumn": 47
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'Tooltip' is defined but never used. Allowed unused vars must match /^_/u.",
                "line": 20,
                "column": 3,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 20,
                "endColumn": 10
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 86,
                "column": 47,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 86,
                "endColumn": 50,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                1692,
                                1695
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                1692,
                                1695
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 86,
                "column": 52,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 86,
                "endColumn": 55,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                1697,
                                1700
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                1697,
                                1700
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'usageData' is assigned a value but never used. Allowed unused vars must match /^_/u.",
                "line": 89,
                "column": 10,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 89,
                "endColumn": 19
            },
            {
                "ruleId": "@typescript-eslint/no-non-null-assertion",
                "severity": 1,
                "message": "Forbidden non-null assertion.",
                "line": 109,
                "column": 13,
                "nodeType": "TSNonNullExpression",
                "messageId": "noNonNull",
                "endLine": 109,
                "endColumn": 95
            },
            {
                "ruleId": "@typescript-eslint/no-floating-promises",
                "severity": 1,
                "message": "Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.",
                "line": 147,
                "column": 5,
                "nodeType": "ExpressionStatement",
                "messageId": "floatingVoid",
                "endLine": 147,
                "endColumn": 25,
                "suggestions": [
                    {
                        "messageId": "floatingFixVoid",
                        "fix": {
                            "range": [
                                4178,
                                4178
                            ],
                            "text": "void "
                        },
                        "desc": "Add void operator to ignore."
                    },
                    {
                        "messageId": "floatingFixAwait",
                        "fix": {
                            "range": [
                                4178,
                                4178
                            ],
                            "text": "await "
                        },
                        "desc": "Add await operator."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-non-null-assertion",
                "severity": 1,
                "message": "Forbidden non-null assertion.",
                "line": 418,
                "column": 49,
                "nodeType": "TSNonNullExpression",
                "messageId": "noNonNull",
                "endLine": 418,
                "endColumn": 93
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 8,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "/**\n * Tenant Analytics Component\n * Provides comprehensive analytics visualization for tenant usage and performance\n */\n\nimport React, { useState, useCallback, useMemo, useEffect } from 'react';\nimport {\n  Card,\n  Row,\n  Col,\n  Statistic,\n  Progress,\n  Typography,\n  Space,\n  Select,\n  DatePicker,\n  Button,\n  Table,\n  Tag,\n  Tooltip,\n  Spin,\n  Alert,\n  Tabs,\n} from 'antd';\nimport {\n  BarChartOutlined,\n  LineChartOutlined,\n  PieChartOutlined,\n  DatabaseOutlined,\n  UserOutlined,\n  ApiOutlined,\n  ClockCircleOutlined,\n  CheckCircleOutlined,\n  ExclamationCircleOutlined,\n} from '@ant-design/icons';\nimport type { Tenant } from '@/types/tenant';\n\nconst { Title, Text } = Typography;\nconst { RangePicker } = DatePicker;\nconst { TabPane } = Tabs;\n\ninterface TenantAnalyticsProps {\n  tenants: Tenant[];\n  selectedTenant?: Tenant | null;\n  onTenantSelect?: (tenant: Tenant) => void;\n  loading?: boolean;\n}\n\ninterface AnalyticsData {\n  totalTenants: number;\n  activeTenants: number;\n  inactiveTenants: number;\n  totalUsers: number;\n  totalContacts: number;\n  totalApiCalls: number;\n  averageResponseTime: number;\n  errorRate: number;\n  storageUsed: number;\n  storageLimit: number;\n}\n\ninterface UsageMetrics {\n  date: string;\n  apiCalls: number;\n  users: number;\n  storage: number;\n  errors: number;\n}\n\ninterface PerformanceMetrics {\n  tenantId: string;\n  tenantName: string;\n  responseTime: number;\n  errorRate: number;\n  uptime: number;\n  lastActivity: Date;\n  status: 'healthy' | 'degraded' | 'unhealthy';\n}\n\nexport const TenantAnalytics: React.FC<TenantAnalyticsProps> = ({\n  tenants,\n  selectedTenant,\n  onTenantSelect,\n  loading = false,\n}) => {\n  const [dateRange, setDateRange] = useState<[any, any] | null>(null);\n  const [selectedMetric, setSelectedMetric] = useState<string>('all');\n  const [analyticsData, setAnalyticsData] = useState<AnalyticsData | null>(null);\n  const [usageData, setUsageData] = useState<UsageMetrics[]>([]);\n  const [performanceData, setPerformanceData] = useState<PerformanceMetrics[]>([]);\n  const [isLoading, setIsLoading] = useState(false);\n\n  // Mock data generation (replace with actual API calls)\n  const generateMockData = useCallback(() => {\n    const mockAnalytics: AnalyticsData = {\n      totalTenants: tenants.length,\n      activeTenants: tenants.filter(t => t.isActive !== false).length,\n      inactiveTenants: tenants.filter(t => t.isActive === false).length,\n      totalUsers: Math.floor(Math.random() * 1000) + 100,\n      totalContacts: Math.floor(Math.random() * 10000) + 1000,\n      totalApiCalls: Math.floor(Math.random() * 100000) + 10000,\n      averageResponseTime: Math.random() * 200 + 50,\n      errorRate: Math.random() * 5,\n      storageUsed: Math.random() * 1000 + 100,\n      storageLimit: 2000,\n    };\n\n    const mockUsage: UsageMetrics[] = Array.from({ length: 30 }, (_, i) => ({\n      date: new Date(Date.now() - (29 - i) * 24 * 60 * 60 * 1000).toISOString().split('T')[0]!,\n      apiCalls: Math.floor(Math.random() * 1000) + 100,\n      users: Math.floor(Math.random() * 50) + 10,\n      storage: Math.floor(Math.random() * 100) + 50,\n      errors: Math.floor(Math.random() * 20),\n    }));\n\n    const mockPerformance: PerformanceMetrics[] = tenants.map(tenant => ({\n      tenantId: tenant.id,\n      tenantName: tenant.name,\n      responseTime: Math.random() * 300 + 50,\n      errorRate: Math.random() * 10,\n      uptime: Math.random() * 20 + 80,\n      lastActivity: new Date(Date.now() - Math.random() * 7 * 24 * 60 * 60 * 1000),\n      status: Math.random() > 0.8 ? 'unhealthy' : Math.random() > 0.6 ? 'degraded' : 'healthy',\n    }));\n\n    setAnalyticsData(mockAnalytics);\n    setUsageData(mockUsage);\n    setPerformanceData(mockPerformance);\n  }, [tenants]);\n\n  // Load analytics data\n  const loadAnalyticsData = useCallback(async () => {\n    setIsLoading(true);\n    try {\n      // Simulate API call\n      await new Promise(resolve => setTimeout(resolve, 1000));\n      generateMockData();\n    } catch (error) {\n      console.error('Failed to load analytics data:', error);\n    } finally {\n      setIsLoading(false);\n    }\n  }, [generateMockData]);\n\n  // Load data on mount and when tenants change\n  useEffect(() => {\n    loadAnalyticsData();\n  }, [loadAnalyticsData]);\n\n  // Get status color\n  const getStatusColor = useCallback((status: string) => {\n    switch (status) {\n      case 'healthy':\n        return 'green';\n      case 'degraded':\n        return 'orange';\n      case 'unhealthy':\n        return 'red';\n      default:\n        return 'gray';\n    }\n  }, []);\n\n  // Get status icon\n  const getStatusIcon = useCallback((status: string) => {\n    switch (status) {\n      case 'healthy':\n        return <CheckCircleOutlined />;\n      case 'degraded':\n        return <ExclamationCircleOutlined />;\n      case 'unhealthy':\n        return <ExclamationCircleOutlined />;\n      default:\n        return <ClockCircleOutlined />;\n    }\n  }, []);\n\n  // Performance table columns\n  const performanceColumns = [\n    {\n      title: 'Tenant',\n      dataIndex: 'tenantName',\n      key: 'tenantName',\n      render: (text: string, record: PerformanceMetrics) => (\n        <Space>\n          <Text strong>{text}</Text>\n          {selectedTenant?.id === record.tenantId && <Tag color=\"blue\">Selected</Tag>}\n        </Space>\n      ),\n    },\n    {\n      title: 'Status',\n      dataIndex: 'status',\n      key: 'status',\n      render: (status: string) => (\n        <Tag color={getStatusColor(status)} icon={getStatusIcon(status)}>\n          {status.toUpperCase()}\n        </Tag>\n      ),\n    },\n    {\n      title: 'Response Time',\n      dataIndex: 'responseTime',\n      key: 'responseTime',\n      render: (time: number) => <Text>{time.toFixed(0)}ms</Text>,\n      sorter: (a: PerformanceMetrics, b: PerformanceMetrics) => a.responseTime - b.responseTime,\n    },\n    {\n      title: 'Error Rate',\n      dataIndex: 'errorRate',\n      key: 'errorRate',\n      render: (rate: number) => (\n        <Text type={rate > 5 ? 'danger' : rate > 2 ? 'warning' : undefined}>\n          {rate.toFixed(1)}%\n        </Text>\n      ),\n      sorter: (a: PerformanceMetrics, b: PerformanceMetrics) => a.errorRate - b.errorRate,\n    },\n    {\n      title: 'Uptime',\n      dataIndex: 'uptime',\n      key: 'uptime',\n      render: (uptime: number) => (\n        <Progress\n          percent={uptime}\n          size=\"small\"\n          status={uptime > 95 ? 'success' : uptime > 90 ? 'normal' : 'exception'}\n        />\n      ),\n      sorter: (a: PerformanceMetrics, b: PerformanceMetrics) => a.uptime - b.uptime,\n    },\n    {\n      title: 'Last Activity',\n      dataIndex: 'lastActivity',\n      key: 'lastActivity',\n      render: (date: Date) => <Text type=\"secondary\">{date.toLocaleDateString()}</Text>,\n    },\n  ];\n\n  if (loading || isLoading) {\n    return (\n      <div style={{ textAlign: 'center', padding: '48px' }}>\n        <Spin size=\"large\" />\n        <div style={{ marginTop: '16px' }}>\n          <Text type=\"secondary\">Loading analytics...</Text>\n        </div>\n      </div>\n    );\n  }\n\n  if (!analyticsData) {\n    return (\n      <Alert\n        message=\"No Analytics Data\"\n        description=\"Unable to load analytics data. Please try again later.\"\n        type=\"warning\"\n        showIcon\n      />\n    );\n  }\n\n  return (\n    <div style={{ padding: '24px' }}>\n      {/* Header */}\n      <div style={{ marginBottom: '24px' }}>\n        <Row justify=\"space-between\" align=\"middle\">\n          <Col>\n            <Title level={2} style={{ margin: 0 }}>\n              Tenant Analytics\n            </Title>\n            <Text type=\"secondary\">Comprehensive insights into tenant usage and performance</Text>\n          </Col>\n          <Col>\n            <Space>\n              <RangePicker\n                value={dateRange}\n                onChange={setDateRange}\n                placeholder={['Start Date', 'End Date']}\n              />\n              <Select value={selectedMetric} onChange={setSelectedMetric} style={{ width: 150 }}>\n                <Select.Option value=\"all\">All Metrics</Select.Option>\n                <Select.Option value=\"performance\">Performance</Select.Option>\n                <Select.Option value=\"usage\">Usage</Select.Option>\n                <Select.Option value=\"errors\">Errors</Select.Option>\n              </Select>\n              <Button icon={<BarChartOutlined />} onClick={loadAnalyticsData} loading={isLoading}>\n                Refresh\n              </Button>\n            </Space>\n          </Col>\n        </Row>\n      </div>\n\n      {/* Overview Statistics */}\n      <Row gutter={[16, 16]} style={{ marginBottom: '24px' }}>\n        <Col xs={24} sm={12} md={6}>\n          <Card>\n            <Statistic\n              title=\"Total Tenants\"\n              value={analyticsData.totalTenants}\n              prefix={<DatabaseOutlined />}\n              valueStyle={{ color: '#1890ff' }}\n            />\n          </Card>\n        </Col>\n        <Col xs={24} sm={12} md={6}>\n          <Card>\n            <Statistic\n              title=\"Active Tenants\"\n              value={analyticsData.activeTenants}\n              prefix={<CheckCircleOutlined />}\n              valueStyle={{ color: '#52c41a' }}\n            />\n          </Card>\n        </Col>\n        <Col xs={24} sm={12} md={6}>\n          <Card>\n            <Statistic\n              title=\"Total Users\"\n              value={analyticsData.totalUsers}\n              prefix={<UserOutlined />}\n              valueStyle={{ color: '#722ed1' }}\n            />\n          </Card>\n        </Col>\n        <Col xs={24} sm={12} md={6}>\n          <Card>\n            <Statistic\n              title=\"API Calls (24h)\"\n              value={analyticsData.totalApiCalls}\n              prefix={<ApiOutlined />}\n              valueStyle={{ color: '#fa8c16' }}\n            />\n          </Card>\n        </Col>\n      </Row>\n\n      {/* Performance Metrics */}\n      <Row gutter={[16, 16]} style={{ marginBottom: '24px' }}>\n        <Col xs={24} sm={12} md={8}>\n          <Card>\n            <Statistic\n              title=\"Average Response Time\"\n              value={analyticsData.averageResponseTime}\n              suffix=\"ms\"\n              precision={0}\n              valueStyle={{\n                color:\n                  analyticsData.averageResponseTime > 200\n                    ? '#ff4d4f'\n                    : analyticsData.averageResponseTime > 100\n                      ? '#faad14'\n                      : '#52c41a',\n              }}\n            />\n          </Card>\n        </Col>\n        <Col xs={24} sm={12} md={8}>\n          <Card>\n            <Statistic\n              title=\"Error Rate\"\n              value={analyticsData.errorRate}\n              suffix=\"%\"\n              precision={1}\n              valueStyle={{\n                color:\n                  analyticsData.errorRate > 3\n                    ? '#ff4d4f'\n                    : analyticsData.errorRate > 1\n                      ? '#faad14'\n                      : '#52c41a',\n              }}\n            />\n          </Card>\n        </Col>\n        <Col xs={24} sm={12} md={8}>\n          <Card>\n            <div>\n              <Text type=\"secondary\">Storage Usage</Text>\n              <div style={{ marginTop: '8px' }}>\n                <Progress\n                  percent={(analyticsData.storageUsed / analyticsData.storageLimit) * 100}\n                  status={\n                    analyticsData.storageUsed / analyticsData.storageLimit > 0.9\n                      ? 'exception'\n                      : analyticsData.storageUsed / analyticsData.storageLimit > 0.7\n                        ? 'active'\n                        : 'success'\n                  }\n                />\n                <Text type=\"secondary\" style={{ fontSize: '12px' }}>\n                  {analyticsData.storageUsed.toFixed(0)}GB / {analyticsData.storageLimit}GB\n                </Text>\n              </div>\n            </div>\n          </Card>\n        </Col>\n      </Row>\n\n      {/* Detailed Analytics Tabs */}\n      <Tabs defaultActiveKey=\"performance\" type=\"card\">\n        <TabPane\n          tab={\n            <Space>\n              <LineChartOutlined />\n              <span>Performance</span>\n            </Space>\n          }\n          key=\"performance\"\n        >\n          <Card>\n            <Table\n              columns={performanceColumns}\n              dataSource={performanceData}\n              rowKey=\"tenantId\"\n              pagination={{ pageSize: 10 }}\n              onRow={record => ({\n                onClick: () => onTenantSelect?.(tenants.find(t => t.id === record.tenantId)!),\n                style: { cursor: 'pointer' },\n              })}\n            />\n          </Card>\n        </TabPane>\n\n        <TabPane\n          tab={\n            <Space>\n              <BarChartOutlined />\n              <span>Usage Trends</span>\n            </Space>\n          }\n          key=\"usage\"\n        >\n          <Card>\n            <Title level={4}>Usage Trends (Last 30 Days)</Title>\n            <Text type=\"secondary\">API calls, user activity, and storage usage over time</Text>\n            {/* Chart component would go here */}\n            <div\n              style={{\n                height: '300px',\n                display: 'flex',\n                alignItems: 'center',\n                justifyContent: 'center',\n                backgroundColor: '#f5f5f5',\n                borderRadius: '8px',\n                marginTop: '16px',\n              }}\n            >\n              <Text type=\"secondary\">Chart visualization would be implemented here</Text>\n            </div>\n          </Card>\n        </TabPane>\n\n        <TabPane\n          tab={\n            <Space>\n              <PieChartOutlined />\n              <span>Distribution</span>\n            </Space>\n          }\n          key=\"distribution\"\n        >\n          <Card>\n            <Title level={4}>Tenant Distribution</Title>\n            <Text type=\"secondary\">Distribution of tenants by status, plan, and usage</Text>\n            {/* Pie chart component would go here */}\n            <div\n              style={{\n                height: '300px',\n                display: 'flex',\n                alignItems: 'center',\n                justifyContent: 'center',\n                backgroundColor: '#f5f5f5',\n                borderRadius: '8px',\n                marginTop: '16px',\n              }}\n            >\n              <Text type=\"secondary\">Pie chart visualization would be implemented here</Text>\n            </div>\n          </Card>\n        </TabPane>\n      </Tabs>\n    </div>\n  );\n};\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/components/TenantDashboard.tsx",
        "messages": [
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.",
                "line": 392,
                "column": 23,
                "nodeType": "MemberExpression",
                "messageId": "neverNullish",
                "endLine": 392,
                "endColumn": 41
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 1,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "/**\n * Enhanced Tenant Dashboard Component\n * Provides comprehensive tenant management with improved UI/UX\n */\n\nimport React, { useState, useCallback, useMemo } from 'react';\nimport {\n  Card,\n  Row,\n  Col,\n  Statistic,\n  Progress,\n  Button,\n  Space,\n  Typography,\n  Tag,\n  Tooltip,\n  Badge,\n  Alert,\n  Timeline,\n  List,\n  Avatar,\n} from 'antd';\nimport {\n  DatabaseOutlined,\n  SettingOutlined,\n  PlusOutlined,\n  EyeOutlined,\n  EditOutlined,\n  DeleteOutlined,\n  SyncOutlined,\n  CheckCircleOutlined,\n  ExclamationCircleOutlined,\n  ClockCircleOutlined,\n} from '@ant-design/icons';\nimport { DatabaseManagementModal } from './DatabaseManagementModal';\n\nconst { Title, Text } = Typography;\n\n// Dashboard-specific Tenant interface that extends the base with required properties\ninterface DashboardTenant {\n  id: string;\n  name: string;\n  isActive?: boolean;\n  db_url?: string;\n  created_at?: string;\n  updated_at?: string;\n}\n\ninterface TenantDashboardProps {\n  tenants: DashboardTenant[];\n  onTenantSelect: (tenant: DashboardTenant) => void;\n  onTenantEdit: (tenant: DashboardTenant) => void;\n  onTenantDelete: (tenant: DashboardTenant) => void;\n  onTenantCreate: () => void;\n  onRefresh?: () => void;\n  loading?: boolean;\n}\n\ninterface TenantStats {\n  total: number;\n  active: number;\n  inactive: number;\n  withDatabase: number;\n  recentlyCreated: number;\n  healthScore: number;\n}\n\nexport const TenantDashboard: React.FC<TenantDashboardProps> = ({\n  tenants,\n  onTenantSelect,\n  onTenantEdit,\n  onTenantDelete,\n  onTenantCreate,\n  onRefresh,\n  loading = false,\n}) => {\n  const [selectedTenant, setSelectedTenant] = useState<DashboardTenant | null>(null);\n  const [isDatabaseModalOpen, setIsDatabaseModalOpen] = useState(false);\n\n  // Database management handlers\n  const handleOpenDatabaseManagement = useCallback(() => {\n    setIsDatabaseModalOpen(true);\n  }, []);\n\n  const handleCloseDatabaseManagement = useCallback(() => {\n    setIsDatabaseModalOpen(false);\n  }, []);\n\n  // Calculate tenant statistics\n  const tenantStats = useMemo((): TenantStats => {\n    const now = new Date();\n    const oneWeekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);\n\n    return {\n      total: tenants.length,\n      active: tenants.filter(t => t.isActive === true).length,\n      inactive: tenants.filter(t => t.isActive === false).length,\n      withDatabase: tenants.filter(t => t.db_url != null && t.db_url.trim() !== '').length,\n      recentlyCreated: tenants.filter(\n        t => t.created_at != null && new Date(t.created_at) > oneWeekAgo\n      ).length,\n      healthScore:\n        tenants.length > 0\n          ? Math.round(\n              (tenants.filter(t => t.db_url != null && t.isActive === true).length /\n                tenants.length) *\n                100\n            )\n          : 0,\n    };\n  }, [tenants]);\n\n  // Get recent tenant activities\n  const recentActivities = useMemo(() => {\n    return tenants\n      .sort((a, b) => {\n        const dateA = a.updated_at != null ? new Date(a.updated_at).getTime() : 0;\n        const dateB = b.updated_at != null ? new Date(b.updated_at).getTime() : 0;\n        return dateB - dateA;\n      })\n      .slice(0, 5)\n      .map(tenant => ({\n        tenant,\n        action: 'Updated',\n        timestamp: tenant.updated_at,\n        status:\n          tenant.isActive === true ? 'success' : tenant.isActive === false ? 'error' : 'warning',\n      }));\n  }, [tenants]);\n\n  const handleTenantSelect = useCallback(\n    (tenant: DashboardTenant) => {\n      setSelectedTenant(tenant);\n      onTenantSelect(tenant);\n    },\n    [onTenantSelect]\n  );\n\n  const getTenantStatus = useCallback((tenant: DashboardTenant) => {\n    if (tenant.isActive === false) return { color: 'red', text: 'Inactive' };\n    if (tenant.db_url == null || tenant.db_url.trim() === '')\n      return { color: 'orange', text: 'No Database' };\n    return { color: 'green', text: 'Active' };\n  }, []);\n\n  const getHealthColor = useCallback((score: number) => {\n    if (score >= 80) return '#52c41a';\n    if (score >= 60) return '#faad14';\n    return '#ff4d4f';\n  }, []);\n\n  return (\n    <div style={{ padding: '24px' }}>\n      {/* Header */}\n      <div style={{ marginBottom: '24px' }}>\n        <Row justify=\"space-between\" align=\"middle\">\n          <Col>\n            <Title level={2} style={{ margin: 0 }}>\n              Tenant Dashboard\n            </Title>\n            <Text type=\"secondary\">Manage and monitor your tenant infrastructure</Text>\n          </Col>\n          <Col>\n            <Space>\n              <Button\n                type=\"primary\"\n                icon={<PlusOutlined />}\n                onClick={onTenantCreate}\n                loading={loading}\n              >\n                Create Tenant\n              </Button>\n              <Button\n                icon={<SyncOutlined />}\n                onClick={() => {\n                  onRefresh?.();\n                }}\n              >\n                Refresh\n              </Button>\n            </Space>\n          </Col>\n        </Row>\n      </div>\n\n      {/* Statistics Overview */}\n      <Row gutter={[16, 16]} style={{ marginBottom: '24px' }}>\n        <Col xs={24} sm={12} md={6}>\n          <Card>\n            <Statistic\n              title=\"Total Tenants\"\n              value={tenantStats.total}\n              prefix={<DatabaseOutlined />}\n              valueStyle={{ color: '#1890ff' }}\n            />\n          </Card>\n        </Col>\n        <Col xs={24} sm={12} md={6}>\n          <Card>\n            <Statistic\n              title=\"Active Tenants\"\n              value={tenantStats.active}\n              prefix={<CheckCircleOutlined />}\n              valueStyle={{ color: '#52c41a' }}\n            />\n          </Card>\n        </Col>\n        <Col xs={24} sm={12} md={6}>\n          <Card>\n            <Statistic\n              title=\"With Database\"\n              value={tenantStats.withDatabase}\n              prefix={<DatabaseOutlined />}\n              valueStyle={{ color: '#722ed1' }}\n            />\n          </Card>\n        </Col>\n        <Col xs={24} sm={12} md={6}>\n          <Card>\n            <Statistic\n              title=\"Recently Created\"\n              value={tenantStats.recentlyCreated}\n              prefix={<ClockCircleOutlined />}\n              valueStyle={{ color: '#fa8c16' }}\n            />\n          </Card>\n        </Col>\n      </Row>\n\n      {/* Health Score */}\n      <Card style={{ marginBottom: '24px' }}>\n        <Row justify=\"space-between\" align=\"middle\">\n          <Col>\n            <Title level={4} style={{ margin: 0 }}>\n              System Health Score\n            </Title>\n            <Text type=\"secondary\">Overall tenant infrastructure health</Text>\n          </Col>\n          <Col>\n            <div style={{ textAlign: 'right' }}>\n              <Text\n                style={{\n                  fontSize: '24px',\n                  fontWeight: 'bold',\n                  color: getHealthColor(tenantStats.healthScore),\n                }}\n              >\n                {tenantStats.healthScore}%\n              </Text>\n            </div>\n          </Col>\n        </Row>\n        <Progress\n          percent={tenantStats.healthScore}\n          strokeColor={getHealthColor(tenantStats.healthScore)}\n          style={{ marginTop: '16px' }}\n        />\n      </Card>\n\n      <Row gutter={[16, 16]}>\n        {/* Tenant List */}\n        <Col xs={24} lg={16}>\n          <Card\n            title={\n              <Space>\n                <Text>Tenants</Text>\n                <Badge count={tenants.length} />\n              </Space>\n            }\n            extra={\n              <Button type=\"link\" icon={<SettingOutlined />} disabled>\n                Settings\n              </Button>\n            }\n          >\n            <List\n              dataSource={tenants}\n              loading={loading}\n              renderItem={tenant => {\n                const status = getTenantStatus(tenant);\n                const isSelected = selectedTenant?.id === tenant.id;\n\n                return (\n                  <List.Item\n                    style={{\n                      backgroundColor: isSelected ? '#f0f8ff' : 'transparent',\n                      borderRadius: '8px',\n                      padding: '12px',\n                      cursor: 'pointer',\n                      border: isSelected ? '2px solid #1890ff' : '1px solid #f0f0f0',\n                    }}\n                    onClick={() => {\n                      handleTenantSelect(tenant);\n                    }}\n                    actions={[\n                      <Tooltip title=\"View Details\" key=\"view\">\n                        <Button\n                          type=\"text\"\n                          icon={<EyeOutlined />}\n                          onClick={e => {\n                            e.stopPropagation();\n                            handleTenantSelect(tenant);\n                          }}\n                        />\n                      </Tooltip>,\n                      <Tooltip title=\"Edit Tenant\" key=\"edit\">\n                        <Button\n                          type=\"text\"\n                          icon={<EditOutlined />}\n                          onClick={e => {\n                            e.stopPropagation();\n                            onTenantEdit(tenant);\n                          }}\n                        />\n                      </Tooltip>,\n                      <Tooltip title=\"Delete Tenant\" key=\"delete\">\n                        <Button\n                          type=\"text\"\n                          danger\n                          icon={<DeleteOutlined />}\n                          onClick={e => {\n                            e.stopPropagation();\n                            onTenantDelete(tenant);\n                          }}\n                        />\n                      </Tooltip>,\n                    ]}\n                  >\n                    <List.Item.Meta\n                      avatar={\n                        <Avatar\n                          icon={<DatabaseOutlined />}\n                          style={{ backgroundColor: status.color }}\n                        />\n                      }\n                      title={\n                        <Space>\n                          <Text strong>{tenant.name}</Text>\n                          <Tag color={status.color}>{status.text}</Tag>\n                        </Space>\n                      }\n                      description={\n                        <Space direction=\"vertical\" size=\"small\">\n                          <Text type=\"secondary\" style={{ fontSize: '12px' }}>\n                            ID: {tenant.id}\n                          </Text>\n                          {tenant.db_url != null && (\n                            <Text\n                              code\n                              style={{\n                                fontSize: '11px',\n                                maxWidth: '200px',\n                                display: 'block',\n                                overflow: 'hidden',\n                                textOverflow: 'ellipsis',\n                              }}\n                            >\n                              {tenant.db_url}\n                            </Text>\n                          )}\n                          <Text type=\"secondary\" style={{ fontSize: '11px' }}>\n                            Created:{' '}\n                            {tenant.created_at != null\n                              ? new Date(tenant.created_at).toLocaleDateString()\n                              : 'Unknown'}\n                          </Text>\n                        </Space>\n                      }\n                    />\n                  </List.Item>\n                );\n              }}\n            />\n          </Card>\n        </Col>\n\n        {/* Recent Activities */}\n        <Col xs={24} lg={8}>\n          <Card title=\"Recent Activities\">\n            <Timeline\n              items={recentActivities.map(activity => ({\n                dot:\n                  activity.status === 'success' ? (\n                    <CheckCircleOutlined style={{ color: '#52c41a' }} />\n                  ) : (\n                    <ExclamationCircleOutlined style={{ color: '#ff4d4f' }} />\n                  ),\n                children: (\n                  <div\n                    key={\n                      activity.tenant.id ??\n                      `${activity.tenant.name}-${activity.timestamp ?? 'unknown'}`\n                    }\n                  >\n                    <Text strong>{activity.tenant.name}</Text>\n                    <Text type=\"secondary\" style={{ marginLeft: '8px' }}>\n                      {activity.action}\n                    </Text>\n                    <div>\n                      <Text type=\"secondary\" style={{ fontSize: '12px' }}>\n                        {activity.timestamp != null\n                          ? new Date(activity.timestamp).toLocaleString()\n                          : 'Unknown'}\n                      </Text>\n                    </div>\n                  </div>\n                ),\n              }))}\n            />\n          </Card>\n\n          {/* Quick Actions */}\n          <Card title=\"Quick Actions\" style={{ marginTop: '16px' }}>\n            <Space direction=\"vertical\" style={{ width: '100%' }}>\n              <Button type=\"primary\" icon={<PlusOutlined />} onClick={onTenantCreate} block>\n                Create New Tenant\n              </Button>\n              <Button icon={<DatabaseOutlined />} onClick={handleOpenDatabaseManagement} block>\n                Manage Databases\n              </Button>\n              <Button\n                icon={<SettingOutlined />}\n                onClick={() => {\n                  /* Handle system settings - feature not yet implemented */\n                }}\n                block\n                disabled\n              >\n                System Settings\n              </Button>\n            </Space>\n          </Card>\n        </Col>\n      </Row>\n\n      {/* Health Alerts */}\n      {tenantStats.healthScore < 80 && (\n        <Alert\n          message=\"System Health Alert\"\n          description={`Your tenant infrastructure health is at ${tenantStats.healthScore.toString()}%. Consider reviewing inactive tenants or missing database configurations.`}\n          type=\"warning\"\n          showIcon\n          style={{ marginTop: '16px' }}\n          action={\n            <Button\n              size=\"small\"\n              onClick={() => {\n                /* Handle health improvement */\n              }}\n            >\n              Improve Health\n            </Button>\n          }\n        />\n      )}\n\n      {/* Database Management Modal */}\n      <DatabaseManagementModal\n        isOpen={isDatabaseModalOpen}\n        onClose={handleCloseDatabaseManagement}\n        tenants={tenants}\n        onRefresh={onRefresh}\n      />\n    </div>\n  );\n};\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/components/TenantForm.tsx",
        "messages": [
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'Tooltip' is defined but never used. Allowed unused vars must match /^_/u.",
                "line": 20,
                "column": 3,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 20,
                "endColumn": 10
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'Tenant' is defined but never used. Allowed unused vars must match /^_/u.",
                "line": 30,
                "column": 15,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 30,
                "endColumn": 21
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'Title' is assigned a value but never used. Allowed unused vars must match /^_/u.",
                "line": 33,
                "column": 9,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 33,
                "endColumn": 14
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'loading' is assigned a value but never used. Allowed unused args must match /^_/u.",
                "line": 67,
                "column": 3,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 67,
                "endColumn": 10
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary optional chain on a non-nullish value.",
                "line": 96,
                "column": 13,
                "nodeType": "MemberExpression",
                "messageId": "neverOptionalChain",
                "endLine": 96,
                "endColumn": 15,
                "suggestions": [
                    {
                        "messageId": "suggestRemoveOptionalChain",
                        "fix": {
                            "range": [
                                2175,
                                2177
                            ],
                            "text": "."
                        },
                        "desc": "Remove unnecessary optional chain"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary optional chain on a non-nullish value.",
                "line": 113,
                "column": 12,
                "nodeType": "MemberExpression",
                "messageId": "neverOptionalChain",
                "endLine": 113,
                "endColumn": 14,
                "suggestions": [
                    {
                        "messageId": "suggestRemoveOptionalChain",
                        "fix": {
                            "range": [
                                2746,
                                2748
                            ],
                            "text": "."
                        },
                        "desc": "Remove unnecessary optional chain"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary optional chain on a non-nullish value.",
                "line": 131,
                "column": 12,
                "nodeType": "MemberExpression",
                "messageId": "neverOptionalChain",
                "endLine": 131,
                "endColumn": 14,
                "suggestions": [
                    {
                        "messageId": "suggestRemoveOptionalChain",
                        "fix": {
                            "range": [
                                3236,
                                3238
                            ],
                            "text": "."
                        },
                        "desc": "Remove unnecessary optional chain"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'error' is defined but never used. Allowed unused caught errors must match /^_/u.",
                "line": 151,
                "column": 14,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 151,
                "endColumn": 19
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 164,
                "column": 11,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 164,
                "endColumn": 20,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                4148,
                                4157
                            ],
                            "text": "nameError != null"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                4148,
                                4157
                            ],
                            "text": "nameError ?? \"\""
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                4148,
                                4157
                            ],
                            "text": "Boolean(nameError)"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 170,
                "column": 11,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 170,
                "endColumn": 19,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                4303,
                                4311
                            ],
                            "text": "urlError != null"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                4303,
                                4311
                            ],
                            "text": "urlError ?? \"\""
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                4303,
                                4311
                            ],
                            "text": "Boolean(urlError)"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 175,
                "column": 11,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 175,
                "endColumn": 29,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                4400,
                                4418
                            ],
                            "text": "(values.description != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                4400,
                                4418
                            ],
                            "text": "(values.description ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                4400,
                                4418
                            ],
                            "text": "(Boolean(values.description))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary optional chain on a non-nullish value.",
                "line": 186,
                "column": 22,
                "nodeType": "MemberExpression",
                "messageId": "neverOptionalChain",
                "endLine": 186,
                "endColumn": 24,
                "suggestions": [
                    {
                        "messageId": "suggestRemoveOptionalChain",
                        "fix": {
                            "range": [
                                4823,
                                4825
                            ],
                            "text": "."
                        },
                        "desc": "Remove unnecessary optional chain"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-floating-promises",
                "severity": 1,
                "message": "Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.",
                "line": 245,
                "column": 7,
                "nodeType": "ExpressionStatement",
                "messageId": "floatingVoid",
                "endLine": 245,
                "endColumn": 35,
                "suggestions": [
                    {
                        "messageId": "floatingFixVoid",
                        "fix": {
                            "range": [
                                6463,
                                6463
                            ],
                            "text": "void "
                        },
                        "desc": "Add void operator to ignore."
                    },
                    {
                        "messageId": "floatingFixAwait",
                        "fix": {
                            "range": [
                                6463,
                                6463
                            ],
                            "text": "await "
                        },
                        "desc": "Add await operator."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 250,
                "column": 38,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingReturnType",
                "endLine": 250,
                "endColumn": 40
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 263,
                "column": 38,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingReturnType",
                "endLine": 263,
                "endColumn": 40
            },
            {
                "ruleId": "@typescript-eslint/no-deprecated",
                "severity": 1,
                "message": "`destroyOnClose` is deprecated. Please use `destroyOnHidden` instead",
                "line": 288,
                "column": 7,
                "nodeType": "JSXIdentifier",
                "messageId": "deprecatedWithReason",
                "endLine": 288,
                "endColumn": 21
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 16,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "/**\n * Enhanced Tenant Form Component\n * Provides comprehensive validation and error handling for tenant operations\n */\n\nimport React, { useState, useCallback, useEffect } from 'react';\nimport {\n  Modal,\n  Form,\n  Input,\n  Button,\n  Space,\n  Alert,\n  Divider,\n  Row,\n  Col,\n  Typography,\n  Card,\n  Tag,\n  Tooltip,\n  Spin,\n} from 'antd';\nimport {\n  DatabaseOutlined,\n  CheckCircleOutlined,\n  ExclamationCircleOutlined,\n  InfoCircleOutlined,\n  LoadingOutlined,\n} from '@ant-design/icons';\nimport type { Tenant } from '@/types/tenant';\nimport { useTenantNotifications, type TenantOperationResult } from '@/hooks/useTenantNotifications';\n\nconst { Title, Text } = Typography;\n\ninterface TenantFormProps {\n  open: boolean;\n  onClose: () => void;\n  onSubmit: (values: TenantFormValues) => Promise<TenantOperationResult>;\n  initialValues?: Partial<TenantFormValues>;\n  mode: 'create' | 'edit';\n  loading?: boolean;\n}\n\ninterface TenantFormValues {\n  name: string;\n  db_url: string;\n  description?: string;\n  settings?: {\n    theme?: string;\n    timezone?: string;\n    features?: string[];\n  };\n}\n\ninterface ValidationResult {\n  isValid: boolean;\n  errors: Record<string, string>;\n  warnings: string[];\n}\n\nexport const TenantForm: React.FC<TenantFormProps> = ({\n  open,\n  onClose,\n  onSubmit,\n  initialValues,\n  mode,\n  loading = false,\n}) => {\n  const [form] = Form.useForm();\n  const [submitting, setSubmitting] = useState(false);\n  const [validationResult, setValidationResult] = useState<ValidationResult>({\n    isValid: true,\n    errors: {},\n    warnings: [],\n  });\n  const [connectionStatus, setConnectionStatus] = useState<\n    'idle' | 'testing' | 'success' | 'error'\n  >('idle');\n\n  const notifications = useTenantNotifications();\n\n  // Reset form when modal opens/closes\n  useEffect(() => {\n    if (open) {\n      form.resetFields();\n      if (initialValues) {\n        form.setFieldsValue(initialValues);\n      }\n      setValidationResult({ isValid: true, errors: {}, warnings: [] });\n      setConnectionStatus('idle');\n    }\n  }, [open, initialValues, form]);\n\n  // Validate tenant name\n  const validateTenantName = useCallback((name: string): string | null => {\n    if (name?.trim().length === 0) {\n      return 'Tenant name is required';\n    }\n    if (name.trim().length < 3) {\n      return 'Tenant name must be at least 3 characters long';\n    }\n    if (name.trim().length > 50) {\n      return 'Tenant name must be less than 50 characters';\n    }\n    if (!/^[a-zA-Z0-9\\s\\-_]+$/.test(name.trim())) {\n      return 'Tenant name can only contain letters, numbers, spaces, hyphens, and underscores';\n    }\n    return null;\n  }, []);\n\n  // Validate database URL\n  const validateDatabaseUrl = useCallback((url: string): string | null => {\n    if (url?.trim().length === 0) {\n      return 'Database URL is required';\n    }\n\n    try {\n      const urlObj = new URL(url);\n      if (!['postgresql:', 'mysql:', 'sqlite:'].includes(urlObj.protocol)) {\n        return 'Database URL must use postgresql, mysql, or sqlite protocol';\n      }\n    } catch {\n      return 'Database URL must be a valid URL';\n    }\n\n    return null;\n  }, []);\n\n  // Test database connection\n  const testDatabaseConnection = useCallback(async (url: string) => {\n    if (url?.trim().length === 0) {\n      setConnectionStatus('idle');\n      return;\n    }\n\n    setConnectionStatus('testing');\n\n    try {\n      // Simulate connection test (replace with actual implementation)\n      await new Promise(resolve => setTimeout(resolve, 2000));\n\n      // Mock validation logic\n      const isValid =\n        url.includes('postgresql://') || url.includes('mysql://') || url.includes('sqlite://');\n\n      if (isValid) {\n        setConnectionStatus('success');\n      } else {\n        setConnectionStatus('error');\n      }\n    } catch (error) {\n      setConnectionStatus('error');\n    }\n  }, []);\n\n  // Comprehensive form validation\n  const validateForm = useCallback(\n    (values: TenantFormValues): ValidationResult => {\n      const errors: Record<string, string> = {};\n      const warnings: string[] = [];\n\n      // Validate name\n      const nameError = validateTenantName(values.name);\n      if (nameError) {\n        errors.name = nameError;\n      }\n\n      // Validate database URL\n      const urlError = validateDatabaseUrl(values.db_url);\n      if (urlError) {\n        errors.db_url = urlError;\n      }\n\n      // Additional validations\n      if (values.description && values.description.length > 500) {\n        errors.description = 'Description must be less than 500 characters';\n      }\n\n      // Warnings\n      if (values.db_url && /(?:localhost|127\\.0\\.0\\.1|\\[::1\\])/i.test(values.db_url)) {\n        warnings.push(\n          'Using a localhost database URL (localhost, 127.0.0.1, or ::1) may not be accessible in production'\n        );\n      }\n\n      if (values.name?.toLowerCase().includes('test')) {\n        warnings.push('Tenant name contains \"test\" - ensure this is intentional');\n      }\n\n      return {\n        isValid: Object.keys(errors).length === 0,\n        errors,\n        warnings,\n      };\n    },\n    [validateTenantName, validateDatabaseUrl]\n  );\n\n  // Handle form submission\n  const handleSubmit = useCallback(\n    async (values: TenantFormValues) => {\n      setSubmitting(true);\n\n      try {\n        // Validate form\n        const validation = validateForm(values);\n        setValidationResult(validation);\n\n        if (!validation.isValid) {\n          notifications.notifyValidationError(validation.errors);\n          return;\n        }\n\n        // Show warnings if any\n        if (validation.warnings.length > 0) {\n          validation.warnings.forEach(warning => {\n            notifications.showWarningNotification('Warning', warning);\n          });\n        }\n\n        // Submit form\n        const result = await onSubmit(values);\n        notifications.handleOperationResult(result, mode);\n\n        if (result.success) {\n          form.resetFields();\n          onClose();\n        }\n      } catch (error) {\n        notifications.notifyTenantError(\n          mode === 'create' ? 'create' : 'update',\n          error instanceof Error ? error.message : 'Unknown error occurred'\n        );\n      } finally {\n        setSubmitting(false);\n      }\n    },\n    [mode, validateForm, onSubmit, notifications, form, onClose]\n  );\n\n  // Handle database URL change\n  const handleDatabaseUrlChange = useCallback(\n    (e: React.ChangeEvent<HTMLInputElement>) => {\n      const url = e.target.value;\n      testDatabaseConnection(url);\n    },\n    [testDatabaseConnection]\n  );\n\n  const getConnectionStatusIcon = () => {\n    switch (connectionStatus) {\n      case 'testing':\n        return <LoadingOutlined />;\n      case 'success':\n        return <CheckCircleOutlined style={{ color: '#52c41a' }} />;\n      case 'error':\n        return <ExclamationCircleOutlined style={{ color: '#ff4d4f' }} />;\n      default:\n        return <InfoCircleOutlined style={{ color: '#1890ff' }} />;\n    }\n  };\n\n  const getConnectionStatusText = () => {\n    switch (connectionStatus) {\n      case 'testing':\n        return 'Testing connection...';\n      case 'success':\n        return 'Connection successful';\n      case 'error':\n        return 'Connection failed';\n      default:\n        return 'Enter database URL to test connection';\n    }\n  };\n\n  return (\n    <Modal\n      title={\n        <Space>\n          <DatabaseOutlined />\n          <Text>{mode === 'create' ? 'Create New Tenant' : 'Edit Tenant'}</Text>\n        </Space>\n      }\n      open={open}\n      onCancel={onClose}\n      footer={null}\n      width={600}\n      destroyOnClose\n    >\n      <Form\n        form={form}\n        layout=\"vertical\"\n        onFinish={handleSubmit}\n        initialValues={initialValues}\n        disabled={submitting}\n      >\n        {/* Validation Errors */}\n        {!validationResult.isValid && (\n          <Alert\n            message=\"Validation Errors\"\n            description={\n              <ul style={{ margin: 0, paddingLeft: '20px' }}>\n                {Object.entries(validationResult.errors).map(([field, error]) => (\n                  <li key={field}>{error}</li>\n                ))}\n              </ul>\n            }\n            type=\"error\"\n            showIcon\n            style={{ marginBottom: '16px' }}\n          />\n        )}\n\n        {/* Warnings */}\n        {validationResult.warnings.length > 0 && (\n          <Alert\n            message=\"Warnings\"\n            description={\n              <ul style={{ margin: 0, paddingLeft: '20px' }}>\n                {validationResult.warnings.map((warning, index) => (\n                  <li key={index}>{warning}</li>\n                ))}\n              </ul>\n            }\n            type=\"warning\"\n            showIcon\n            style={{ marginBottom: '16px' }}\n          />\n        )}\n\n        {/* Basic Information */}\n        <Card title=\"Basic Information\" size=\"small\" style={{ marginBottom: '16px' }}>\n          <Form.Item\n            name=\"name\"\n            label=\"Tenant Name\"\n            rules={[\n              { required: true, message: 'Please enter tenant name' },\n              { min: 3, message: 'Name must be at least 3 characters' },\n              { max: 50, message: 'Name must be less than 50 characters' },\n              {\n                pattern: /^[a-zA-Z0-9\\s\\-_]+$/,\n                message: 'Name can only contain letters, numbers, spaces, hyphens, and underscores',\n              },\n            ]}\n            hasFeedback\n          >\n            <Input placeholder=\"Enter tenant name\" maxLength={50} showCount />\n          </Form.Item>\n\n          <Form.Item\n            name=\"description\"\n            label=\"Description (Optional)\"\n            rules={[{ max: 500, message: 'Description must be less than 500 characters' }]}\n          >\n            <Input.TextArea\n              placeholder=\"Enter tenant description\"\n              rows={3}\n              maxLength={500}\n              showCount\n            />\n          </Form.Item>\n        </Card>\n\n        {/* Database Configuration */}\n        <Card title=\"Database Configuration\" size=\"small\" style={{ marginBottom: '16px' }}>\n          <Form.Item\n            name=\"db_url\"\n            label=\"Database URL\"\n            rules={[\n              { required: true, message: 'Please enter database URL' },\n              { type: 'url', message: 'Please enter a valid URL' },\n            ]}\n            hasFeedback\n          >\n            <Input\n              placeholder=\"postgresql://username:password@localhost:5432/database\"\n              onChange={handleDatabaseUrlChange}\n              suffix={getConnectionStatusIcon()}\n            />\n          </Form.Item>\n\n          {/* Connection Status */}\n          <div style={{ marginTop: '8px' }}>\n            <Space>\n              {getConnectionStatusIcon()}\n              <Text type=\"secondary\" style={{ fontSize: '12px' }}>\n                {getConnectionStatusText()}\n              </Text>\n            </Space>\n          </div>\n\n          {/* Database URL Examples */}\n          <div style={{ marginTop: '12px' }}>\n            <Text type=\"secondary\" style={{ fontSize: '12px' }}>\n              Examples:\n            </Text>\n            <div style={{ marginTop: '4px' }}>\n              <Tag>postgresql://user:pass@localhost:5432/db</Tag>\n              <Tag>mysql://user:pass@localhost:3306/db</Tag>\n              <Tag>sqlite:///path/to/database.db</Tag>\n            </div>\n          </div>\n        </Card>\n\n        {/* Advanced Settings */}\n        <Card title=\"Advanced Settings\" size=\"small\" style={{ marginBottom: '16px' }}>\n          <Row gutter={16}>\n            <Col span={12}>\n              <Form.Item name={['settings', 'theme']} label=\"Theme\">\n                <Input placeholder=\"light\" />\n              </Form.Item>\n            </Col>\n            <Col span={12}>\n              <Form.Item name={['settings', 'timezone']} label=\"Timezone\">\n                <Input placeholder=\"UTC\" />\n              </Form.Item>\n            </Col>\n          </Row>\n        </Card>\n\n        {/* Form Actions */}\n        <Divider />\n        <div style={{ textAlign: 'right' }}>\n          <Space>\n            <Button onClick={onClose} disabled={submitting}>\n              Cancel\n            </Button>\n            <Button\n              type=\"primary\"\n              htmlType=\"submit\"\n              loading={submitting}\n              disabled={!validationResult.isValid}\n            >\n              {mode === 'create' ? 'Create Tenant' : 'Update Tenant'}\n            </Button>\n          </Space>\n        </div>\n\n        {/* Submission Loading */}\n        {submitting && (\n          <div style={{ marginTop: '16px', textAlign: 'center' }}>\n            <Spin size=\"default\" />\n            <Text type=\"secondary\" style={{ fontSize: '12px', display: 'block', marginTop: '8px' }}>\n              {mode === 'create' ? 'Creating tenant...' : 'Updating tenant...'}\n            </Text>\n          </div>\n        )}\n      </Form>\n    </Modal>\n  );\n};\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/components/TenantFormModal.tsx",
        "messages": [],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 0,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/components/TenantSearchCard.tsx",
        "messages": [
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 16,
                "column": 37,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 16,
                "endColumn": 40,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                636,
                                639
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                636,
                                639
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 1,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "/**\n * TenantSearchCard Component\n * Handles search input and advanced filtering for tenants\n */\n\nimport React, { useMemo } from 'react';\nimport { Card, Space, Button, Badge } from 'antd';\nimport { SearchOutlined, FilterOutlined, SettingOutlined } from '@ant-design/icons';\n\nimport { SmartSearchInput, AdvancedFilter } from '@/components/SearchComponents';\nimport { TENANT_SEARCH_FIELDS } from '@/components/SearchComponents';\nimport type { UseSearchStateReturn } from '@/hooks/useEnhancedSearch';\nimport type { SearchFilter } from '@/components/SearchComponents';\n\ninterface TenantSearchCardProps {\n  searchState: UseSearchStateReturn<any>;\n  showAdvancedFilters: boolean;\n  loading: boolean;\n  onSearch: (query: string) => void;\n  onClearFilters: () => void;\n  onFiltersChange: (filters: SearchFilter[]) => void;\n  onApplyFilters: () => void;\n  onToggleAdvancedFilters: () => void;\n  onGetTenantSuggestions: () => string[];\n}\n\nexport const TenantSearchCard: React.FC<TenantSearchCardProps> = React.memo(\n  ({\n    searchState,\n    showAdvancedFilters,\n    loading,\n    onSearch,\n    onClearFilters,\n    onFiltersChange,\n    onApplyFilters,\n    onToggleAdvancedFilters,\n    onGetTenantSuggestions,\n  }) => {\n    // Memoize tenant suggestions to avoid recomputation on every render\n    const suggestions = useMemo(() => onGetTenantSuggestions(), [onGetTenantSuggestions]);\n\n    return (\n      <Card\n        title={\n          <Space>\n            <SearchOutlined />\n            <span>Search & Filter</span>\n            <Badge count={searchState.filters.length} />\n          </Space>\n        }\n        size=\"small\"\n        style={{ marginBottom: '16px' }}\n        extra={\n          <Space>\n            <Button\n              type={showAdvancedFilters ? 'primary' : 'default'}\n              icon={<FilterOutlined />}\n              onClick={onToggleAdvancedFilters}\n            >\n              {showAdvancedFilters ? 'Hide Filters' : 'Show Filters'}\n            </Button>\n            <Button\n              icon={<SettingOutlined />}\n              onClick={() => {\n                /* Handle settings */\n              }}\n            >\n              Settings\n            </Button>\n          </Space>\n        }\n      >\n        <Space direction=\"vertical\" style={{ width: '100%' }}>\n          {/* Smart Search Input */}\n          <SmartSearchInput\n            placeholder=\"Search tenants by name, ID, or database URL...\"\n            value={searchState.query}\n            onChange={searchState.setQuery}\n            onSearch={onSearch}\n            onClear={onClearFilters}\n            loading={loading}\n            suggestions={suggestions}\n            style={{ maxWidth: '600px' }}\n          />\n\n          {/* Advanced Filters */}\n          {showAdvancedFilters && (\n            <AdvancedFilter\n              fields={TENANT_SEARCH_FIELDS}\n              filters={searchState.filters}\n              onFiltersChange={onFiltersChange}\n              onApply={onApplyFilters}\n              onClear={onClearFilters}\n              loading={loading}\n            />\n          )}\n        </Space>\n      </Card>\n    );\n  }\n);\n\nTenantSearchCard.displayName = 'TenantSearchCard';\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/components/TenantSettingsModal.tsx",
        "messages": [
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'Input' is defined but never used. Allowed unused vars must match /^_/u.",
                "line": 10,
                "column": 3,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 10,
                "endColumn": 8
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'Switch' is defined but never used. Allowed unused vars must match /^_/u.",
                "line": 13,
                "column": 3,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 13,
                "endColumn": 9
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'loading' is assigned a value but never used. Allowed unused args must match /^_/u.",
                "line": 44,
                "column": 3,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 44,
                "endColumn": 10
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 65,
                "column": 31,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingReturnType",
                "endLine": 65,
                "endColumn": 33
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 67,
                "column": 13,
                "nodeType": "VariableDeclarator",
                "messageId": "anyAssignment",
                "endLine": 67,
                "endColumn": 49
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 71,
                "column": 9,
                "nodeType": "Property",
                "messageId": "anyAssignment",
                "endLine": 71,
                "endColumn": 28
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .theme on an `any` value.",
                "line": 71,
                "column": 23,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 71,
                "endColumn": 28
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 72,
                "column": 9,
                "nodeType": "Property",
                "messageId": "anyAssignment",
                "endLine": 72,
                "endColumn": 34
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .language on an `any` value.",
                "line": 72,
                "column": 26,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 72,
                "endColumn": 34
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 73,
                "column": 9,
                "nodeType": "Property",
                "messageId": "anyAssignment",
                "endLine": 73,
                "endColumn": 34
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .timezone on an `any` value.",
                "line": 73,
                "column": 26,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 73,
                "endColumn": 34
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 74,
                "column": 9,
                "nodeType": "Property",
                "messageId": "anyAssignment",
                "endLine": 74,
                "endColumn": 38
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .dateFormat on an `any` value.",
                "line": 74,
                "column": 28,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 74,
                "endColumn": 38
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 75,
                "column": 9,
                "nodeType": "Property",
                "messageId": "anyAssignment",
                "endLine": 75,
                "endColumn": 40
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected any value in conditional. An explicit comparison or type conversion is required.",
                "line": 75,
                "column": 19,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorAny",
                "endLine": 75,
                "endColumn": 34,
                "suggestions": [
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                1881,
                                1896
                            ],
                            "text": "(Boolean(values.features))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .features on an `any` value.",
                "line": 75,
                "column": 26,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 75,
                "endColumn": 34
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 75,
                "column": 35,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 75,
                "endColumn": 37,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                1897,
                                1899
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 77,
                "column": 11,
                "nodeType": "Property",
                "messageId": "anyAssignment",
                "endLine": 77,
                "endColumn": 44
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .primaryColor on an `any` value.",
                "line": 77,
                "column": 32,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 77,
                "endColumn": 44
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 78,
                "column": 11,
                "nodeType": "Property",
                "messageId": "anyAssignment",
                "endLine": 78,
                "endColumn": 48
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .secondaryColor on an `any` value.",
                "line": 78,
                "column": 34,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 78,
                "endColumn": 48
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 79,
                "column": 11,
                "nodeType": "Property",
                "messageId": "anyAssignment",
                "endLine": 79,
                "endColumn": 42
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .accentColor on an `any` value.",
                "line": 79,
                "column": 31,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 79,
                "endColumn": 42
            },
            {
                "ruleId": "@typescript-eslint/await-thenable",
                "severity": 2,
                "message": "Unexpected `await` of a non-Promise (non-\"Thenable\") value.",
                "line": 83,
                "column": 7,
                "nodeType": "AwaitExpression",
                "messageId": "await",
                "endLine": 83,
                "endColumn": 29,
                "suggestions": [
                    {
                        "messageId": "removeAwait",
                        "fix": {
                            "range": [
                                2088,
                                2093
                            ],
                            "text": ""
                        },
                        "desc": "Remove unnecessary `await`."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-confusing-void-expression",
                "severity": 2,
                "message": "Placing a void expression inside another expression is forbidden. Move it to its own statement instead.",
                "line": 83,
                "column": 13,
                "nodeType": "CallExpression",
                "messageId": "invalidVoidExpr",
                "endLine": 83,
                "endColumn": 29
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 94,
                "column": 27,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingReturnType",
                "endLine": 94,
                "endColumn": 29
            },
            {
                "ruleId": "@typescript-eslint/no-deprecated",
                "severity": 1,
                "message": "`destroyOnClose` is deprecated. Please use `destroyOnHidden` instead",
                "line": 159,
                "column": 7,
                "nodeType": "JSXIdentifier",
                "messageId": "deprecatedWithReason",
                "endLine": 159,
                "endColumn": 21
            }
        ],
        "suppressedMessages": [],
        "errorCount": 2,
        "fatalErrorCount": 0,
        "warningCount": 25,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "/**\n * Tenant Settings Modal Component\n * Provides tenant configuration options including theme, language, timezone, and branding\n */\n\nimport React, { useState, useEffect } from 'react';\nimport {\n  Modal,\n  Form,\n  Input,\n  Select,\n  ColorPicker,\n  Switch,\n  Space,\n  Divider,\n  Typography,\n  Button,\n  message,\n} from 'antd';\nimport {\n  SettingOutlined,\n  BgColorsOutlined,\n  GlobalOutlined,\n  ClockCircleOutlined,\n} from '@ant-design/icons';\nimport type { TenantSettings } from '@/types/auth';\n\nconst { Title, Text } = Typography;\nconst { Option } = Select;\n\ninterface TenantSettingsModalProps {\n  isOpen: boolean;\n  onClose: () => void;\n  onSave: (settings: TenantSettings) => void;\n  currentSettings?: TenantSettings;\n  loading?: boolean;\n}\n\nexport const TenantSettingsModal: React.FC<TenantSettingsModalProps> = ({\n  isOpen,\n  onClose,\n  onSave,\n  currentSettings,\n  loading = false,\n}) => {\n  const [form] = Form.useForm();\n  const [saving, setSaving] = useState(false);\n\n  // Initialize form with current settings\n  useEffect(() => {\n    if (isOpen && currentSettings) {\n      form.setFieldsValue({\n        theme: currentSettings.theme,\n        language: currentSettings.language,\n        timezone: currentSettings.timezone,\n        dateFormat: currentSettings.dateFormat,\n        features: currentSettings.features,\n        primaryColor: currentSettings.branding.primaryColor,\n        secondaryColor: currentSettings.branding.secondaryColor,\n        accentColor: currentSettings.branding.accentColor,\n      });\n    }\n  }, [isOpen, currentSettings, form]);\n\n  const handleSave = async () => {\n    try {\n      const values = await form.validateFields();\n      setSaving(true);\n\n      const settings: TenantSettings = {\n        theme: values.theme,\n        language: values.language,\n        timezone: values.timezone,\n        dateFormat: values.dateFormat,\n        features: values.features || [],\n        branding: {\n          primaryColor: values.primaryColor,\n          secondaryColor: values.secondaryColor,\n          accentColor: values.accentColor,\n        },\n      };\n\n      await onSave(settings);\n      message.success('Settings saved successfully');\n      onClose();\n    } catch (error) {\n      console.error('Failed to save settings:', error);\n      message.error('Failed to save settings. Please try again.');\n    } finally {\n      setSaving(false);\n    }\n  };\n\n  const handleCancel = () => {\n    form.resetFields();\n    onClose();\n  };\n\n  const themeOptions = [\n    { value: 'light', label: 'Light Theme' },\n    { value: 'dark', label: 'Dark Theme' },\n    { value: 'natural', label: 'Natural Theme' },\n  ];\n\n  const languageOptions = [\n    { value: 'en', label: 'English' },\n    { value: 'es', label: 'Spanish' },\n    { value: 'fr', label: 'French' },\n    { value: 'de', label: 'German' },\n    { value: 'zh', label: 'Chinese' },\n  ];\n\n  const timezoneOptions = [\n    { value: 'UTC', label: 'UTC' },\n    { value: 'America/New_York', label: 'Eastern Time (ET)' },\n    { value: 'America/Chicago', label: 'Central Time (CT)' },\n    { value: 'America/Denver', label: 'Mountain Time (MT)' },\n    { value: 'America/Los_Angeles', label: 'Pacific Time (PT)' },\n    { value: 'Europe/London', label: 'London (GMT)' },\n    { value: 'Europe/Paris', label: 'Paris (CET)' },\n    { value: 'Asia/Tokyo', label: 'Tokyo (JST)' },\n  ];\n\n  const dateFormatOptions = [\n    { value: 'MM/DD/YYYY', label: 'MM/DD/YYYY (US)' },\n    { value: 'DD/MM/YYYY', label: 'DD/MM/YYYY (EU)' },\n    { value: 'YYYY-MM-DD', label: 'YYYY-MM-DD (ISO)' },\n    { value: 'DD MMM YYYY', label: 'DD MMM YYYY' },\n  ];\n\n  const featureOptions = [\n    { value: 'analytics', label: 'Analytics Dashboard' },\n    { value: 'notifications', label: 'Real-time Notifications' },\n    { value: 'export', label: 'Data Export' },\n    { value: 'api_access', label: 'API Access' },\n    { value: 'custom_fields', label: 'Custom Fields' },\n    { value: 'advanced_search', label: 'Advanced Search' },\n  ];\n\n  return (\n    <Modal\n      title={\n        <Space>\n          <SettingOutlined />\n          <span>Tenant Settings</span>\n        </Space>\n      }\n      open={isOpen}\n      onCancel={handleCancel}\n      width={800}\n      footer={[\n        <Button key=\"cancel\" onClick={handleCancel}>\n          Cancel\n        </Button>,\n        <Button key=\"save\" type=\"primary\" loading={saving} onClick={handleSave}>\n          Save Settings\n        </Button>,\n      ]}\n      destroyOnClose\n    >\n      <Form\n        form={form}\n        layout=\"vertical\"\n        initialValues={{\n          theme: 'natural',\n          language: 'en',\n          timezone: 'UTC',\n          dateFormat: 'MM/DD/YYYY',\n          features: [],\n          primaryColor: '#1890ff',\n          secondaryColor: '#52c41a',\n          accentColor: '#faad14',\n        }}\n      >\n        {/* Appearance Section */}\n        <div>\n          <Title level={4}>\n            <BgColorsOutlined style={{ marginRight: 8 }} />\n            Appearance\n          </Title>\n          <Form.Item name=\"theme\" label=\"Theme\" tooltip=\"Choose the visual theme for your tenant\">\n            <Select placeholder=\"Select theme\">\n              {themeOptions.map(option => (\n                <Option key={option.value} value={option.value}>\n                  {option.label}\n                </Option>\n              ))}\n            </Select>\n          </Form.Item>\n\n          <Form.Item\n            name=\"primaryColor\"\n            label=\"Primary Color\"\n            tooltip=\"Main brand color used throughout the interface\"\n          >\n            <ColorPicker showText />\n          </Form.Item>\n\n          <Form.Item\n            name=\"secondaryColor\"\n            label=\"Secondary Color\"\n            tooltip=\"Secondary brand color for accents and highlights\"\n          >\n            <ColorPicker showText />\n          </Form.Item>\n\n          <Form.Item\n            name=\"accentColor\"\n            label=\"Accent Color\"\n            tooltip=\"Accent color for interactive elements and call-to-actions\"\n          >\n            <ColorPicker showText />\n          </Form.Item>\n        </div>\n\n        <Divider />\n\n        {/* Localization Section */}\n        <div>\n          <Title level={4}>\n            <GlobalOutlined style={{ marginRight: 8 }} />\n            Localization\n          </Title>\n          <Form.Item name=\"language\" label=\"Language\" tooltip=\"Interface language for your tenant\">\n            <Select placeholder=\"Select language\">\n              {languageOptions.map(option => (\n                <Option key={option.value} value={option.value}>\n                  {option.label}\n                </Option>\n              ))}\n            </Select>\n          </Form.Item>\n\n          <Form.Item\n            name=\"timezone\"\n            label=\"Timezone\"\n            tooltip=\"Default timezone for date and time display\"\n          >\n            <Select placeholder=\"Select timezone\">\n              {timezoneOptions.map(option => (\n                <Option key={option.value} value={option.value}>\n                  {option.label}\n                </Option>\n              ))}\n            </Select>\n          </Form.Item>\n\n          <Form.Item\n            name=\"dateFormat\"\n            label=\"Date Format\"\n            tooltip=\"How dates should be displayed throughout the system\"\n          >\n            <Select placeholder=\"Select date format\">\n              {dateFormatOptions.map(option => (\n                <Option key={option.value} value={option.value}>\n                  {option.label}\n                </Option>\n              ))}\n            </Select>\n          </Form.Item>\n        </div>\n\n        <Divider />\n\n        {/* Features Section */}\n        <div>\n          <Title level={4}>\n            <ClockCircleOutlined style={{ marginRight: 8 }} />\n            Features\n          </Title>\n          <Form.Item\n            name=\"features\"\n            label=\"Enabled Features\"\n            tooltip=\"Select which features are available for this tenant\"\n          >\n            <Select\n              mode=\"multiple\"\n              placeholder=\"Select features to enable\"\n              style={{ width: '100%' }}\n            >\n              {featureOptions.map(option => (\n                <Option key={option.value} value={option.value}>\n                  {option.label}\n                </Option>\n              ))}\n            </Select>\n          </Form.Item>\n        </div>\n\n        <Divider />\n\n        <Text type=\"secondary\">\n          Changes will be applied immediately and affect all users in this tenant.\n        </Text>\n      </Form>\n    </Modal>\n  );\n};\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/components/TenantStatistics.tsx",
        "messages": [],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 0,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/components/TenantSwitcher.tsx",
        "messages": [
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'Badge' is defined but never used. Allowed unused vars must match /^_/u.",
                "line": 14,
                "column": 3,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 14,
                "endColumn": 8
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'Card' is defined but never used. Allowed unused vars must match /^_/u.",
                "line": 18,
                "column": 3,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 18,
                "endColumn": 7
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'Option' is assigned a value but never used. Allowed unused vars must match /^_/u.",
                "line": 37,
                "column": 9,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 37,
                "endColumn": 15
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 75,
                "column": 9,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 75,
                "endColumn": 15,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                1687,
                                1693
                            ],
                            "text": "stored != null"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                1687,
                                1693
                            ],
                            "text": "stored ?? \"\""
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                1687,
                                1693
                            ],
                            "text": "Boolean(stored)"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 77,
                "column": 15,
                "nodeType": "VariableDeclarator",
                "messageId": "anyAssignment",
                "endLine": 77,
                "endColumn": 42
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 79,
                "column": 15,
                "nodeType": "VariableDeclarator",
                "messageId": "anyAssignment",
                "endLine": 84,
                "endColumn": 83
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-call",
                "severity": 1,
                "message": "Unsafe call of a(n) `any` typed value.",
                "line": 79,
                "column": 30,
                "nodeType": "MemberExpression",
                "messageId": "unsafeCall",
                "endLine": 84,
                "endColumn": 18
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-call",
                "severity": 1,
                "message": "Unsafe call of a(n) `any` typed value.",
                "line": 79,
                "column": 30,
                "nodeType": "MemberExpression",
                "messageId": "unsafeCall",
                "endLine": 80,
                "endColumn": 15
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .map on an `any` value.",
                "line": 80,
                "column": 12,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 80,
                "endColumn": 15
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 80,
                "column": 23,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 80,
                "endColumn": 26,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                1863,
                                1866
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                1863,
                                1866
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-return",
                "severity": 1,
                "message": "Unsafe return of a value of type `any`.",
                "line": 80,
                "column": 32,
                "nodeType": "ObjectExpression",
                "messageId": "unsafeReturn",
                "endLine": 83,
                "endColumn": 12
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected any value in conditional. An explicit comparison or type conversion is required.",
                "line": 82,
                "column": 27,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorAny",
                "endLine": 82,
                "endColumn": 44,
                "suggestions": [
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                1921,
                                1938
                            ],
                            "text": "(Boolean(item.lastAccessed))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .lastAccessed on an `any` value.",
                "line": 82,
                "column": 32,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 82,
                "endColumn": 44
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-argument",
                "severity": 1,
                "message": "Unsafe argument of type `any` assigned to a parameter of type `string | number | Date`.",
                "line": 82,
                "column": 56,
                "nodeType": "MemberExpression",
                "messageId": "unsafeArgument",
                "endLine": 82,
                "endColumn": 73
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .lastAccessed on an `any` value.",
                "line": 82,
                "column": 61,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 82,
                "endColumn": 73
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .filter on an `any` value.",
                "line": 84,
                "column": 12,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 84,
                "endColumn": 18
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 84,
                "column": 26,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 84,
                "endColumn": 29,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                2021,
                                2024
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                2021,
                                2024
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected any value in conditional. An explicit comparison or type conversion is required.",
                "line": 84,
                "column": 34,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorAny",
                "endLine": 84,
                "endColumn": 45,
                "suggestions": [
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                2029,
                                2040
                            ],
                            "text": "(Boolean(item.tenant))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-return",
                "severity": 1,
                "message": "Unsafe return of a value of type `any`.",
                "line": 84,
                "column": 34,
                "nodeType": "LogicalExpression",
                "messageId": "unsafeReturn",
                "endLine": 84,
                "endColumn": 82
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .tenant on an `any` value.",
                "line": 84,
                "column": 39,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 84,
                "endColumn": 45
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .lastAccessed on an `any` value.",
                "line": 84,
                "column": 54,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 84,
                "endColumn": 66
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-argument",
                "severity": 1,
                "message": "Unsafe argument of type `any` assigned to a parameter of type `SetStateAction<RecentTenant[]>`.",
                "line": 85,
                "column": 26,
                "nodeType": "Identifier",
                "messageId": "unsafeArgument",
                "endLine": 85,
                "endColumn": 38
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 92,
                "column": 9,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 92,
                "endColumn": 24,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                2300,
                                2315
                            ],
                            "text": "storedFavorites != null"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                2300,
                                2315
                            ],
                            "text": "storedFavorites ?? \"\""
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                2300,
                                2315
                            ],
                            "text": "Boolean(storedFavorites)"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 94,
                "column": 15,
                "nodeType": "VariableDeclarator",
                "messageId": "anyAssignment",
                "endLine": 94,
                "endColumn": 54
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 97,
                "column": 35,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 97,
                "endColumn": 38,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                2528,
                                2531
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                2528,
                                2531
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.",
                "line": 115,
                "column": 10,
                "nodeType": "ChainExpression",
                "messageId": "neverNullish",
                "endLine": 115,
                "endColumn": 53
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary optional chain on a non-nullish value.",
                "line": 115,
                "column": 23,
                "nodeType": "MemberExpression",
                "messageId": "neverOptionalChain",
                "endLine": 115,
                "endColumn": 25,
                "suggestions": [
                    {
                        "messageId": "suggestRemoveOptionalChain",
                        "fix": {
                            "range": [
                                3074,
                                3076
                            ],
                            "text": "."
                        },
                        "desc": "Remove unnecessary optional chain"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/require-await",
                "severity": 1,
                "message": "Async arrow function has no 'await' expression.",
                "line": 128,
                "column": 28,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingAwait",
                "endLine": 128,
                "endColumn": 30,
                "suggestions": [
                    {
                        "messageId": "removeAsync",
                        "fix": {
                            "range": [
                                3478,
                                3484
                            ],
                            "text": ""
                        },
                        "desc": "Remove 'async'."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'error' is defined but never used. Allowed unused caught errors must match /^_/u.",
                "line": 149,
                "column": 16,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 149,
                "endColumn": 21
            },
            {
                "ruleId": "@typescript-eslint/no-deprecated",
                "severity": 1,
                "message": "`destroyOnClose` is deprecated. Please use `destroyOnHidden` instead",
                "line": 306,
                "column": 9,
                "nodeType": "JSXIdentifier",
                "messageId": "deprecatedWithReason",
                "endLine": 306,
                "endColumn": 23
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 30,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "/**\n * Tenant Switcher Component\n * Provides tenant switching functionality with search and recent tenants\n */\n\nimport React, { useState, useCallback, useMemo, useEffect } from 'react';\nimport {\n  Select,\n  Avatar,\n  Typography,\n  Space,\n  Button,\n  Tooltip,\n  Badge,\n  Divider,\n  Input,\n  List,\n  Card,\n  Tag,\n  Modal,\n  Spin,\n} from 'antd';\nimport {\n  SwapOutlined,\n  SearchOutlined,\n  PlusOutlined,\n  SettingOutlined,\n  HistoryOutlined,\n  StarOutlined,\n  TeamOutlined,\n  DatabaseOutlined,\n} from '@ant-design/icons';\nimport type { Tenant } from '@/types/tenant';\nimport { useTenantNotifications } from '@/hooks/useTenantNotifications';\n\nconst { Text, Title } = Typography;\nconst { Option } = Select;\n\ninterface TenantSwitcherProps {\n  currentTenant: Tenant | null;\n  tenants: Tenant[];\n  onTenantChange: (tenant: Tenant) => void;\n  onTenantCreate: () => void;\n  loading?: boolean;\n  className?: string;\n  style?: React.CSSProperties;\n}\n\ninterface RecentTenant {\n  tenant: Tenant;\n  lastAccessed: Date;\n  accessCount: number;\n}\n\nexport const TenantSwitcher: React.FC<TenantSwitcherProps> = ({\n  currentTenant,\n  tenants,\n  onTenantChange,\n  onTenantCreate,\n  loading = false,\n  className,\n  style,\n}) => {\n  const [isOpen, setIsOpen] = useState(false);\n  const [searchTerm, setSearchTerm] = useState('');\n  const [recentTenants, setRecentTenants] = useState<RecentTenant[]>([]);\n  const [favoriteTenants, setFavoriteTenants] = useState<string[]>([]);\n  const [isLoading, setIsLoading] = useState(false);\n\n  const notifications = useTenantNotifications();\n\n  // Load recent tenants from localStorage\n  useEffect(() => {\n    const stored = localStorage.getItem('recentTenants');\n    if (stored) {\n      try {\n        const recent = JSON.parse(stored);\n        // Convert date strings back to Date objects\n        const parsedRecent = recent\n          .map((item: any) => ({\n            ...item,\n            lastAccessed: item.lastAccessed ? new Date(item.lastAccessed) : undefined,\n          }))\n          .filter((item: any) => item.tenant && item.lastAccessed instanceof Date);\n        setRecentTenants(parsedRecent);\n      } catch (error) {\n        console.error('Failed to load recent tenants:', error);\n      }\n    }\n\n    const storedFavorites = localStorage.getItem('favoriteTenants');\n    if (storedFavorites) {\n      try {\n        const favorites = JSON.parse(storedFavorites);\n        // Ensure favorites is an array of strings\n        const parsedFavorites = Array.isArray(favorites)\n          ? favorites.filter((id: any) => typeof id === 'string')\n          : [];\n        setFavoriteTenants(parsedFavorites);\n      } catch (error) {\n        console.error('Failed to load favorite tenants:', error);\n      }\n    }\n  }, []);\n\n  // Filter tenants based on search term\n  const filteredTenants = useMemo(() => {\n    if (!searchTerm.trim()) return tenants;\n\n    const term = searchTerm.toLowerCase();\n    return tenants.filter(\n      tenant =>\n        tenant.name.toLowerCase().includes(term) ||\n        tenant.id.toLowerCase().includes(term) ||\n        (tenant.db_url?.toLowerCase().includes(term) ?? false)\n    );\n  }, [tenants, searchTerm]);\n\n  // Get tenant status\n  const getTenantStatus = useCallback((tenant: Tenant) => {\n    if (!tenant.db_url || tenant.db_url.trim() === '')\n      return { color: 'orange', text: 'No Database' };\n    return { color: 'green', text: 'Active' };\n  }, []);\n\n  // Handle tenant selection\n  const handleTenantSelect = useCallback(\n    async (tenant: Tenant) => {\n      setIsLoading(true);\n\n      try {\n        // Update recent tenants\n        const updatedRecent = [\n          { tenant, lastAccessed: new Date(), accessCount: 1 },\n          ...recentTenants.filter(rt => rt.tenant.id !== tenant.id),\n        ].slice(0, 10); // Keep last 10\n\n        setRecentTenants(updatedRecent);\n        localStorage.setItem('recentTenants', JSON.stringify(updatedRecent));\n\n        // Switch tenant\n        onTenantChange(tenant);\n        setIsOpen(false);\n\n        notifications.showInfoNotification(\n          'Tenant Switched',\n          `Switched to tenant \"${tenant.name}\"`\n        );\n      } catch (error) {\n        notifications.showErrorNotification(\n          'Switch Failed',\n          'Failed to switch tenant. Please try again.'\n        );\n      } finally {\n        setIsLoading(false);\n      }\n    },\n    [recentTenants, onTenantChange, notifications]\n  );\n\n  // Toggle favorite tenant\n  const toggleFavorite = useCallback(\n    (tenantId: string) => {\n      const updated = favoriteTenants.includes(tenantId)\n        ? favoriteTenants.filter(id => id !== tenantId)\n        : [...favoriteTenants, tenantId];\n\n      setFavoriteTenants(updated);\n      localStorage.setItem('favoriteTenants', JSON.stringify(updated));\n    },\n    [favoriteTenants]\n  );\n\n  // Get favorite tenants\n  const favoriteTenantsList = useMemo(() => {\n    return tenants.filter(tenant => favoriteTenants.includes(tenant.id));\n  }, [tenants, favoriteTenants]);\n\n  // Get recent tenants (excluding current)\n  const recentTenantsList = useMemo(() => {\n    return recentTenants\n      .filter(rt => rt.tenant.id !== currentTenant?.id)\n      .slice(0, 5)\n      .map(rt => rt.tenant);\n  }, [recentTenants, currentTenant]);\n\n  // Render tenant option\n  const renderTenantOption = useCallback(\n    (tenant: Tenant) => {\n      const status = getTenantStatus(tenant);\n      const isFavorite = favoriteTenants.includes(tenant.id);\n      const isCurrent = currentTenant?.id === tenant.id;\n\n      return (\n        <div\n          key={tenant.id}\n          style={{\n            padding: '12px',\n            cursor: 'pointer',\n            borderRadius: '8px',\n            backgroundColor: isCurrent ? '#f0f8ff' : 'transparent',\n            border: isCurrent ? '2px solid #1890ff' : '1px solid transparent',\n          }}\n          onClick={() => !isCurrent && handleTenantSelect(tenant)}\n        >\n          <Space>\n            <Avatar icon={<DatabaseOutlined />} style={{ backgroundColor: status.color }} />\n            <div style={{ flex: 1 }}>\n              <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>\n                <Text strong>{tenant.name}</Text>\n                {isCurrent && <Tag color=\"blue\">Current</Tag>}\n                <Tag color={status.color}>{status.text}</Tag>\n                {isFavorite && <StarOutlined style={{ color: '#faad14' }} />}\n              </div>\n              <Text type=\"secondary\" style={{ fontSize: '12px' }}>\n                ID: {tenant.id}\n              </Text>\n              {tenant.db_url && (\n                <div>\n                  <Text\n                    code\n                    style={{\n                      fontSize: '11px',\n                      maxWidth: '200px',\n                      display: 'block',\n                      overflow: 'hidden',\n                      textOverflow: 'ellipsis',\n                    }}\n                  >\n                    {tenant.db_url}\n                  </Text>\n                </div>\n              )}\n            </div>\n            <Space>\n              <Tooltip title={isFavorite ? 'Remove from favorites' : 'Add to favorites'}>\n                <Button\n                  type=\"text\"\n                  size=\"small\"\n                  icon={<StarOutlined />}\n                  onClick={e => {\n                    e.stopPropagation();\n                    toggleFavorite(tenant.id);\n                  }}\n                  style={{ color: isFavorite ? '#faad14' : undefined }}\n                />\n              </Tooltip>\n            </Space>\n          </Space>\n        </div>\n      );\n    },\n    [currentTenant, getTenantStatus, favoriteTenants, handleTenantSelect, toggleFavorite]\n  );\n\n  return (\n    <div className={className} style={style}>\n      {/* Current Tenant Display */}\n      <Button\n        type=\"text\"\n        onClick={() => {\n          setIsOpen(true);\n        }}\n        loading={loading}\n        style={{\n          display: 'flex',\n          alignItems: 'center',\n          gap: '8px',\n          padding: '8px 12px',\n          height: 'auto',\n        }}\n      >\n        <Avatar\n          icon={<DatabaseOutlined />}\n          style={{\n            backgroundColor: currentTenant ? getTenantStatus(currentTenant).color : '#d9d9d9',\n          }}\n        />\n        <div style={{ textAlign: 'left' }}>\n          <div>\n            <Text strong>{currentTenant ? currentTenant.name : 'Select Tenant'}</Text>\n          </div>\n          {currentTenant && (\n            <Text type=\"secondary\" style={{ fontSize: '12px' }}>\n              {getTenantStatus(currentTenant).text}\n            </Text>\n          )}\n        </div>\n        <SwapOutlined />\n      </Button>\n\n      {/* Tenant Switcher Modal */}\n      <Modal\n        title={\n          <Space>\n            <SwapOutlined />\n            <Text>Switch Tenant</Text>\n          </Space>\n        }\n        open={isOpen}\n        onCancel={() => {\n          setIsOpen(false);\n        }}\n        footer={null}\n        width={600}\n        destroyOnClose\n      >\n        <div style={{ maxHeight: '500px', overflowY: 'auto' }}>\n          {/* Search */}\n          <Input\n            placeholder=\"Search tenants...\"\n            prefix={<SearchOutlined />}\n            value={searchTerm}\n            onChange={e => {\n              setSearchTerm(e.target.value);\n            }}\n            style={{ marginBottom: '16px' }}\n          />\n\n          {/* Quick Actions */}\n          <div style={{ marginBottom: '16px' }}>\n            <Space>\n              <Button type=\"primary\" icon={<PlusOutlined />} onClick={onTenantCreate} size=\"small\">\n                Create Tenant\n              </Button>\n              <Button\n                icon={<SettingOutlined />}\n                onClick={() => {\n                  /* Handle settings */\n                }}\n                size=\"small\"\n              >\n                Settings\n              </Button>\n            </Space>\n          </div>\n\n          {/* Favorites */}\n          {favoriteTenantsList.length > 0 && (\n            <div style={{ marginBottom: '16px' }}>\n              <Title level={5}>\n                <StarOutlined style={{ color: '#faad14' }} /> Favorites\n              </Title>\n              <List dataSource={favoriteTenantsList} renderItem={renderTenantOption} size=\"small\" />\n              <Divider />\n            </div>\n          )}\n\n          {/* Recent Tenants */}\n          {recentTenantsList.length > 0 && (\n            <div style={{ marginBottom: '16px' }}>\n              <Title level={5}>\n                <HistoryOutlined /> Recent\n              </Title>\n              <List dataSource={recentTenantsList} renderItem={renderTenantOption} size=\"small\" />\n              <Divider />\n            </div>\n          )}\n\n          {/* All Tenants */}\n          <div>\n            <Title level={5}>\n              <TeamOutlined /> All Tenants ({filteredTenants.length})\n            </Title>\n            {isLoading ? (\n              <div style={{ textAlign: 'center', padding: '20px' }}>\n                <Spin />\n                <div style={{ marginTop: '8px' }}>\n                  <Text type=\"secondary\">Switching tenant...</Text>\n                </div>\n              </div>\n            ) : (\n              <List\n                dataSource={filteredTenants}\n                renderItem={renderTenantOption}\n                size=\"small\"\n                locale={{\n                  emptyText: searchTerm\n                    ? 'No tenants found matching your search'\n                    : 'No tenants available',\n                }}\n              />\n            )}\n          </div>\n        </div>\n      </Modal>\n    </div>\n  );\n};\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/components/TenantTable.tsx",
        "messages": [
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 20,
                "column": 12,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 20,
                "endColumn": 15,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                490,
                                493
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                490,
                                493
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/restrict-template-expressions",
                "severity": 1,
                "message": "Invalid type \"number\" of template literal expression.",
                "line": 214,
                "column": 47,
                "nodeType": "MemberExpression",
                "messageId": "invalidType",
                "endLine": 214,
                "endColumn": 55
            },
            {
                "ruleId": "@typescript-eslint/restrict-template-expressions",
                "severity": 1,
                "message": "Invalid type \"number\" of template literal expression.",
                "line": 214,
                "column": 59,
                "nodeType": "MemberExpression",
                "messageId": "invalidType",
                "endLine": 214,
                "endColumn": 67
            },
            {
                "ruleId": "@typescript-eslint/restrict-template-expressions",
                "severity": 1,
                "message": "Invalid type \"number\" of template literal expression.",
                "line": 214,
                "column": 74,
                "nodeType": "Identifier",
                "messageId": "invalidType",
                "endLine": 214,
                "endColumn": 79
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected value in conditional. A boolean expression is required.",
                "line": 219,
                "column": 19,
                "nodeType": "ChainExpression",
                "messageId": "conditionErrorOther",
                "endLine": 219,
                "endColumn": 38
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary optional chain on a non-nullish value.",
                "line": 219,
                "column": 54,
                "nodeType": "MemberExpression",
                "messageId": "neverOptionalChain",
                "endLine": 219,
                "endColumn": 56,
                "suggestions": [
                    {
                        "messageId": "suggestRemoveOptionalChain",
                        "fix": {
                            "range": [
                                6347,
                                6349
                            ],
                            "text": "."
                        },
                        "desc": "Remove unnecessary optional chain"
                    }
                ]
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 6,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "/**\n * TenantTable Component\n * Displays tenants in a table with pagination, sorting, and actions\n */\n\nimport React, { useMemo } from 'react';\nimport { Card, Table, Button, Space, Typography, Tooltip, Empty, Spin, Badge, Tag } from 'antd';\nimport {\n  ReloadOutlined,\n  PlusOutlined,\n  EyeOutlined,\n  EditOutlined,\n  DeleteOutlined,\n} from '@ant-design/icons';\n\nimport type { Tenant } from '@/types/tenant';\n// Define inline types for now\ninterface SearchState {\n  query: string;\n  filters: any[];\n  sortBy: string | undefined;\n  sortOrder: 'asc' | 'desc';\n  page: number;\n  pageSize: number;\n}\n\ninterface SearchStats {\n  total: number;\n  filtered: number;\n  searchTime: number;\n}\n\nconst { Text, Title } = Typography;\n\ninterface TenantTableProps {\n  searchResults: Tenant[];\n  searchState: SearchState;\n  searchStats: SearchStats;\n  selectedTenants: string[];\n  loading: boolean;\n  onEditTenant: (tenant: Tenant) => void;\n  onDeleteTenant: (tenantId: string) => void;\n  onPageChange: (page: number, pageSize: number) => void;\n  onSort: (field: string, order: 'asc' | 'desc') => void;\n  onSelectionChange: (selectedRowKeys: React.Key[]) => void;\n  onRefresh: () => void;\n  onNewTenant: () => void;\n}\n\nexport const TenantTable: React.FC<TenantTableProps> = React.memo(\n  ({\n    searchResults,\n    searchState,\n    searchStats,\n    selectedTenants,\n    loading,\n    onEditTenant,\n    onDeleteTenant,\n    onPageChange,\n    onSort,\n    onSelectionChange,\n    onRefresh,\n    onNewTenant,\n  }) => {\n    const columns = useMemo(\n      () => [\n        {\n          title: 'Name',\n          dataIndex: 'name',\n          key: 'name',\n          sorter: true,\n          render: (text: string, record: Tenant) => (\n            <div>\n              <Text strong>{text}</Text>\n              <div>\n                <Text type=\"secondary\" style={{ fontSize: '12px' }}>\n                  ID: {record.id}\n                </Text>\n              </div>\n            </div>\n          ),\n        },\n        {\n          title: 'Database URL',\n          dataIndex: 'db_url',\n          key: 'db_url',\n          render: (url: string) => (\n            <div>\n              {url ? (\n                <Tooltip title={url}>\n                  <Text\n                    code\n                    style={{\n                      maxWidth: '200px',\n                      display: 'block',\n                      overflow: 'hidden',\n                      textOverflow: 'ellipsis',\n                    }}\n                  >\n                    {url}\n                  </Text>\n                </Tooltip>\n              ) : (\n                <Text type=\"secondary\">No database URL</Text>\n              )}\n            </div>\n          ),\n        },\n        {\n          title: 'Created',\n          dataIndex: 'created_at',\n          key: 'created_at',\n          sorter: true,\n          render: (date: string) => <Text>{new Date(date).toLocaleDateString()}</Text>,\n        },\n        {\n          title: 'Updated',\n          dataIndex: 'updated_at',\n          key: 'updated_at',\n          sorter: true,\n          render: (date: string) => <Text>{new Date(date).toLocaleDateString()}</Text>,\n        },\n        {\n          title: 'Actions',\n          key: 'actions',\n          render: (_: unknown, record: Tenant) => (\n            <Space size=\"small\">\n              <Tooltip title=\"View Details\">\n                <Button type=\"text\" icon={<EyeOutlined />} size=\"small\" />\n              </Tooltip>\n              <Tooltip title=\"Edit Tenant\">\n                <Button\n                  type=\"text\"\n                  icon={<EditOutlined />}\n                  size=\"small\"\n                  onClick={() => {\n                    onEditTenant(record);\n                  }}\n                />\n              </Tooltip>\n              <Tooltip title=\"Delete Tenant\">\n                <Button\n                  type=\"text\"\n                  danger\n                  icon={<DeleteOutlined />}\n                  size=\"small\"\n                  onClick={() => {\n                    onDeleteTenant(record.id);\n                  }}\n                />\n              </Tooltip>\n            </Space>\n          ),\n        },\n      ],\n      [onEditTenant, onDeleteTenant]\n    );\n\n    return (\n      <Card\n        title={\n          <Space>\n            <Text>Tenants</Text>\n            <Badge count={searchResults.length} />\n            {searchState.filters.length > 0 && (\n              <Tag color=\"blue\">\n                {searchState.filters.length} filter{searchState.filters.length !== 1 ? 's' : ''}{' '}\n                applied\n              </Tag>\n            )}\n          </Space>\n        }\n        extra={\n          <Space>\n            <Button icon={<ReloadOutlined />} onClick={onRefresh} loading={loading}>\n              Refresh\n            </Button>\n          </Space>\n        }\n      >\n        {loading ? (\n          <div style={{ textAlign: 'center', padding: '48px' }}>\n            <Spin size=\"large\" />\n            <div style={{ marginTop: '16px' }}>\n              <Text type=\"secondary\">Searching tenants...</Text>\n            </div>\n          </div>\n        ) : searchResults.length === 0 ? (\n          <Empty\n            image={Empty.PRESENTED_IMAGE_SIMPLE}\n            description={\n              <div>\n                <Title level={4}>No matching tenants</Title>\n                <Text type=\"secondary\">Try adjusting your search criteria or filters.</Text>\n                <div style={{ marginTop: '16px' }}>\n                  <Button type=\"primary\" icon={<PlusOutlined />} onClick={onNewTenant}>\n                    Add Tenant\n                  </Button>\n                </div>\n              </div>\n            }\n          />\n        ) : (\n          <Table\n            columns={columns}\n            dataSource={searchResults}\n            rowKey=\"id\"\n            pagination={{\n              current: searchState.page,\n              pageSize: searchState.pageSize,\n              total: searchStats.total,\n              showSizeChanger: true,\n              showQuickJumper: true,\n              showTotal: (total, range) => `${range[0]}-${range[1]} of ${total} tenants`,\n              onChange: onPageChange,\n            }}\n            onChange={(pagination, filters, sorter) => {\n              const sorterResult = Array.isArray(sorter) ? sorter[0] : sorter;\n              if (sorterResult?.field && sorterResult?.order) {\n                const order = sorterResult.order === 'ascend' ? 'asc' : 'desc';\n                onSort(sorterResult.field as string, order);\n              }\n            }}\n            rowSelection={{\n              selectedRowKeys: selectedTenants,\n              onChange: onSelectionChange,\n            }}\n            scroll={{ x: 800 }}\n          />\n        )}\n      </Card>\n    );\n  }\n);\n\nTenantTable.displayName = 'TenantTable';\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/components/__tests__/ConfirmationModal.test.tsx",
        "messages": [],
        "suppressedMessages": [
            {
                "ruleId": "@typescript-eslint/no-empty-function",
                "severity": 2,
                "message": "Unexpected empty arrow function.",
                "line": 194,
                "column": 36,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "unexpected",
                "endLine": 194,
                "endColumn": 38,
                "suggestions": [
                    {
                        "messageId": "suggestComment",
                        "data": {
                            "name": "arrow function"
                        },
                        "fix": {
                            "range": [
                                5298,
                                5298
                            ],
                            "text": " /* empty */ "
                        },
                        "desc": "Add comment inside empty arrow function."
                    }
                ],
                "suppressions": [
                    {
                        "kind": "directive",
                        "justification": ""
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-empty-function",
                "severity": 2,
                "message": "Unexpected empty arrow function.",
                "line": 215,
                "column": 35,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "unexpected",
                "endLine": 215,
                "endColumn": 37,
                "suggestions": [
                    {
                        "messageId": "suggestComment",
                        "data": {
                            "name": "arrow function"
                        },
                        "fix": {
                            "range": [
                                5900,
                                5900
                            ],
                            "text": " /* empty */ "
                        },
                        "desc": "Add comment inside empty arrow function."
                    }
                ],
                "suppressions": [
                    {
                        "kind": "directive",
                        "justification": ""
                    }
                ]
            }
        ],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 0,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/components/__tests__/ErrorBoundary.test.tsx",
        "messages": [
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 179,
                "column": 11,
                "nodeType": "Property",
                "messageId": "anyAssignment",
                "endLine": 179,
                "endColumn": 54
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 464,
                "column": 71,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingReturnType",
                "endLine": 464,
                "endColumn": 73
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
                "line": 489,
                "column": 11,
                "nodeType": "ChainExpression",
                "messageId": "conditionErrorNullableBoolean",
                "endLine": 489,
                "endColumn": 33,
                "suggestions": [
                    {
                        "messageId": "conditionFixDefaultFalse",
                        "fix": {
                            "range": [
                                14968,
                                14990
                            ],
                            "text": "(capturedError?.isErr()) ?? false"
                        },
                        "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
                    },
                    {
                        "messageId": "conditionFixCompareTrue",
                        "fix": {
                            "range": [
                                14968,
                                14990
                            ],
                            "text": "(capturedError?.isErr()) === true"
                        },
                        "desc": "Change condition to check if true (`value === true`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'error' is defined but never used. Allowed unused args must match /^_/u.",
                "line": 704,
                "column": 35,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 704,
                "endColumn": 40
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'originalError' is assigned a value but never used. Allowed unused vars must match /^_/u.",
                "line": 722,
                "column": 13,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 722,
                "endColumn": 26
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'error' is defined but never used. Allowed unused args must match /^_/u.",
                "line": 723,
                "column": 35,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 723,
                "endColumn": 40
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'error' is defined but never used. Allowed unused args must match /^_/u.",
                "line": 1090,
                "column": 32,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 1090,
                "endColumn": 37
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 1174,
                "column": 21,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 1174,
                "endColumn": 24,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                35841,
                                35844
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                35841,
                                35844
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 1175,
                "column": 9,
                "nodeType": "AssignmentExpression",
                "messageId": "anyAssignment",
                "endLine": 1175,
                "endColumn": 29
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .circular on an `any` value.",
                "line": 1175,
                "column": 14,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 1175,
                "endColumn": 22
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 1284,
                "column": 9,
                "nodeType": "FunctionExpression",
                "messageId": "missingReturnType",
                "endLine": 1284,
                "endColumn": 24
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 1302,
                "column": 9,
                "nodeType": "FunctionExpression",
                "messageId": "missingReturnType",
                "endLine": 1302,
                "endColumn": 24
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 1318,
                "column": 9,
                "nodeType": "FunctionExpression",
                "messageId": "missingReturnType",
                "endLine": 1318,
                "endColumn": 24
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 1334,
                "column": 9,
                "nodeType": "FunctionExpression",
                "messageId": "missingReturnType",
                "endLine": 1334,
                "endColumn": 24
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'error' is defined but never used. Allowed unused args must match /^_/u.",
                "line": 1406,
                "column": 32,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 1406,
                "endColumn": 37
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'result' is defined but never used. Allowed unused args must match /^_/u.",
                "line": 1480,
                "column": 39,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 1480,
                "endColumn": 45
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'result' is defined but never used. Allowed unused args must match /^_/u.",
                "line": 1499,
                "column": 39,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 1499,
                "endColumn": 45
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'error' is defined but never used. Allowed unused args must match /^_/u.",
                "line": 1597,
                "column": 35,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 1597,
                "endColumn": 40
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'error' is defined but never used. Allowed unused args must match /^_/u.",
                "line": 1613,
                "column": 32,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 1613,
                "endColumn": 37
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'error' is defined but never used. Allowed unused args must match /^_/u.",
                "line": 1627,
                "column": 32,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 1627,
                "endColumn": 37
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'error' is defined but never used. Allowed unused args must match /^_/u.",
                "line": 1642,
                "column": 32,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 1642,
                "endColumn": 37
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'error' is defined but never used. Allowed unused args must match /^_/u.",
                "line": 1647,
                "column": 23,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 1647,
                "endColumn": 28
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'result' is defined but never used. Allowed unused args must match /^_/u.",
                "line": 1740,
                "column": 39,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 1740,
                "endColumn": 45
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'error' is defined but never used. Allowed unused args must match /^_/u.",
                "line": 1742,
                "column": 32,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 1742,
                "endColumn": 37
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'error' is defined but never used. Allowed unused args must match /^_/u.",
                "line": 1748,
                "column": 23,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 1748,
                "endColumn": 28
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'result' is defined but never used. Allowed unused args must match /^_/u.",
                "line": 1778,
                "column": 32,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 1778,
                "endColumn": 38
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'error' is defined but never used. Allowed unused args must match /^_/u.",
                "line": 1780,
                "column": 36,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 1780,
                "endColumn": 41
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'error' is defined but never used. Allowed unused args must match /^_/u.",
                "line": 1928,
                "column": 35,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 1928,
                "endColumn": 40
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'error' is defined but never used. Allowed unused args must match /^_/u.",
                "line": 1954,
                "column": 32,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 1954,
                "endColumn": 37
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'error' is defined but never used. Allowed unused args must match /^_/u.",
                "line": 1968,
                "column": 32,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 1968,
                "endColumn": 37
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'error' is defined but never used. Allowed unused args must match /^_/u.",
                "line": 2035,
                "column": 23,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 2035,
                "endColumn": 28
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'error' is defined but never used. Allowed unused args must match /^_/u.",
                "line": 2056,
                "column": 23,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 2056,
                "endColumn": 28
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'networkError' is assigned a value but never used. Allowed unused vars must match /^_/u.",
                "line": 2087,
                "column": 13,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 2087,
                "endColumn": 25
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'result' is defined but never used. Allowed unused args must match /^_/u.",
                "line": 2100,
                "column": 39,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 2100,
                "endColumn": 45
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'unknownError' is assigned a value but never used. Allowed unused vars must match /^_/u.",
                "line": 2178,
                "column": 13,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 2178,
                "endColumn": 25
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 2179,
                "column": 9,
                "nodeType": "Property",
                "messageId": "anyAssignment",
                "endLine": 2179,
                "endColumn": 31
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 2179,
                "column": 28,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 2179,
                "endColumn": 31,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                66154,
                                66157
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                66154,
                                66157
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'error' is defined but never used. Allowed unused args must match /^_/u.",
                "line": 2329,
                "column": 32,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 2329,
                "endColumn": 37
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'result' is defined but never used. Allowed unused args must match /^_/u.",
                "line": 2417,
                "column": 39,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 2417,
                "endColumn": 45
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'container' is assigned a value but never used. Allowed unused vars must match /^_/u.",
                "line": 2454,
                "column": 15,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 2454,
                "endColumn": 24
            },
            {
                "ruleId": "@typescript-eslint/restrict-template-expressions",
                "severity": 1,
                "message": "Invalid type \"number\" of template literal expression.",
                "line": 2470,
                "column": 58,
                "nodeType": "Identifier",
                "messageId": "invalidType",
                "endLine": 2470,
                "endColumn": 59
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 2569,
                "column": 11,
                "nodeType": "Property",
                "messageId": "anyAssignment",
                "endLine": 2569,
                "endColumn": 33
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 2569,
                "column": 30,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 2569,
                "endColumn": 33,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                78203,
                                78206
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                78203,
                                78206
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'result' is defined but never used. Allowed unused args must match /^_/u.",
                "line": 2683,
                "column": 39,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 2683,
                "endColumn": 45
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 44,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "import { describe, it, expect, beforeEach, afterEach, mock } from 'bun:test';\nimport React from 'react';\nimport { screen, fireEvent } from '@testing-library/react';\nimport '@testing-library/jest-dom';\nimport { renderWithProviders } from '../../test-utils/render';\nimport { ErrorBoundary, withErrorBoundary } from '../ErrorBoundary';\nimport { err, ok } from 'neverthrow';\nimport type { AppError } from '../../types/errors';\nimport type { Result as FPResult } from '../../types/fp';\nimport {\n  createNetworkError,\n  createAuthError,\n  createBusinessLogicError,\n  createValidationError,\n} from '../../types/errors';\n\n// Component that throws during render\nconst RenderErrorComponent: React.FC<{ errorMessage: string }> = ({ errorMessage }) => {\n  throw new Error(errorMessage);\n};\n\ndescribe('ErrorBoundary Component', () => {\n  // Suppress console.error during tests since ErrorBoundary logs errors\n  const originalConsoleError = console.error;\n\n  beforeEach(() => {\n    // Mock console.error to suppress error logs during testing\n    console.error = mock(() => {\n      // Intentionally empty - suppress console.error\n    });\n  });\n\n  afterEach(() => {\n    // Restore console.error\n    console.error = originalConsoleError;\n  });\n\n  describe('Error Catching', () => {\n    it('should catch render errors from child components', () => {\n      renderWithProviders(\n        <ErrorBoundary>\n          <RenderErrorComponent errorMessage=\"Render error occurred\" />\n        </ErrorBoundary>\n      );\n\n      // Error boundary should catch and display error UI\n      expect(screen.getByText('Something went wrong')).toBeInTheDocument();\n    });\n\n    it('should display error information in UI', () => {\n      renderWithProviders(\n        <ErrorBoundary>\n          <RenderErrorComponent errorMessage=\"Something went wrong\" />\n        </ErrorBoundary>\n      );\n\n      // Error details should be displayed - verify error title is present\n      const errors = screen.getAllByText('Something went wrong');\n      expect(errors.length).toBeGreaterThan(0);\n    });\n\n    it('should display fallback UI when error occurs', () => {\n      const fallbackContent = 'Error Fallback UI';\n      renderWithProviders(\n        <ErrorBoundary fallback={<div>{fallbackContent}</div>}>\n          <RenderErrorComponent errorMessage=\"Error\" />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText(fallbackContent)).toBeInTheDocument();\n    });\n\n    it('should not catch errors in event handlers', () => {\n      // ErrorBoundary doesn't catch event handler errors\n      renderWithProviders(\n        <ErrorBoundary>\n          <div>\n            <button\n              onClick={() => {\n                throw new Error('Event error');\n              }}\n            >\n              Click Me\n            </button>\n          </div>\n        </ErrorBoundary>\n      );\n\n      // Button should still be renderable\n      expect(screen.getByText('Click Me')).toBeInTheDocument();\n    });\n\n    it('should not catch errors in async code', () => {\n      renderWithProviders(\n        <ErrorBoundary>\n          <div>\n            <button\n              onClick={() => {\n                // Simulate async error that won't be caught by ErrorBoundary\n                setTimeout(() => {\n                  throw new Error('Async error');\n                }, 0);\n              }}\n            >\n              Async Button\n            </button>\n          </div>\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('Async Button')).toBeInTheDocument();\n    });\n  });\n\n  it('should show error message to user', () => {\n    renderWithProviders(\n      <ErrorBoundary>\n        <RenderErrorComponent errorMessage=\"User-friendly error message\" />\n      </ErrorBoundary>\n    );\n\n    // Should display error UI with message\n    expect(screen.getByText('Something went wrong')).toBeInTheDocument();\n  });\n\n  it('should display default error UI when no fallback provided', () => {\n    renderWithProviders(\n      <ErrorBoundary>\n        <RenderErrorComponent errorMessage=\"Default error\" />\n      </ErrorBoundary>\n    );\n\n    // Should display some error UI\n    expect(screen.getByText('Something went wrong')).toBeInTheDocument();\n  });\n\n  it('should include error details in fallback', () => {\n    renderWithProviders(\n      <ErrorBoundary>\n        <RenderErrorComponent errorMessage=\"Detailed error information\" />\n      </ErrorBoundary>\n    );\n\n    // Should show the error was caught\n    expect(screen.getByText('Something went wrong')).toBeInTheDocument();\n  });\n\n  describe('Error Handling', () => {\n    it('should call onError callback when error is caught', () => {\n      const onErrorMock = mock(() => {\n        // Intentionally empty - test mock\n      });\n\n      renderWithProviders(\n        <ErrorBoundary onError={onErrorMock}>\n          <RenderErrorComponent errorMessage=\"Test error\" />\n        </ErrorBoundary>\n      );\n\n      // onError callback should be called\n      expect(onErrorMock).toHaveBeenCalled();\n    });\n\n    it('should provide error info to callback', () => {\n      const onErrorMock = mock(() => {\n        // Intentionally empty - test mock\n      });\n\n      renderWithProviders(\n        <ErrorBoundary onError={onErrorMock}>\n          <RenderErrorComponent errorMessage=\"Error with info\" />\n        </ErrorBoundary>\n      );\n\n      // Error info should contain componentStack\n      expect(onErrorMock).toHaveBeenCalledWith(\n        expect.any(Error),\n        expect.objectContaining({\n          componentStack: expect.stringMatching(/.+/),\n        })\n      );\n    });\n\n    it('should continue rendering if onError callback is provided', () => {\n      const onErrorMock = mock(() => {\n        // Intentionally empty - test mock\n      });\n\n      renderWithProviders(\n        <ErrorBoundary onError={onErrorMock}>\n          <RenderErrorComponent errorMessage=\"Error\" />\n        </ErrorBoundary>\n      );\n\n      // Component should still render error UI even with callback\n      expect(screen.getByText('Something went wrong')).toBeInTheDocument();\n    });\n  });\n\n  describe('Children Rendering', () => {\n    it('should render children when no error occurs', () => {\n      const testContent = 'Child content rendered successfully';\n      renderWithProviders(\n        <ErrorBoundary>\n          <div>{testContent}</div>\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText(testContent)).toBeInTheDocument();\n    });\n\n    it('should render multiple children', () => {\n      renderWithProviders(\n        <ErrorBoundary>\n          <div>Child 1</div>\n          <div>Child 2</div>\n          <div>Child 3</div>\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('Child 1')).toBeInTheDocument();\n      expect(screen.getByText('Child 2')).toBeInTheDocument();\n      expect(screen.getByText('Child 3')).toBeInTheDocument();\n    });\n\n    it('should render nested components', () => {\n      renderWithProviders(\n        <ErrorBoundary>\n          <div>\n            <section>\n              <h1>Title</h1>\n              <p>Content</p>\n            </section>\n          </div>\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('Title')).toBeInTheDocument();\n      expect(screen.getByText('Content')).toBeInTheDocument();\n    });\n  });\n\n  describe('Recovery', () => {\n    it('should reset error state when component unmounts and remounts', () => {\n      const ThrowingComponent = ({ shouldThrow }: { shouldThrow: boolean }): React.JSX.Element => {\n        if (shouldThrow) throw new Error('Test error');\n        return <div>Working</div>;\n      };\n\n      const { rerender } = renderWithProviders(\n        <ErrorBoundary key=\"error\">\n          <ThrowingComponent shouldThrow={true} />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('Something went wrong')).toBeInTheDocument();\n\n      rerender(\n        <ErrorBoundary key=\"working\">\n          <ThrowingComponent shouldThrow={false} />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('Working')).toBeInTheDocument();\n    });\n\n    it('should display recovery button/action', () => {\n      renderWithProviders(\n        <ErrorBoundary>\n          <RenderErrorComponent errorMessage=\"Error\" />\n        </ErrorBoundary>\n      );\n\n      // Should provide some way to recover (button, text, etc.)\n      expect(screen.getByRole('button', { name: /try again/i })).toBeInTheDocument();\n    });\n  });\n\n  describe('Error Types', () => {\n    const errorTestCases = [\n      {\n        label: 'JavaScript errors',\n        componentFactory: () => <RenderErrorComponent errorMessage=\"JavaScript error\" />,\n      },\n      {\n        label: 'TypeError',\n        componentFactory: () => {\n          const TypeErrorComponent: React.FC = () => {\n            throw new TypeError('Cannot read property of null');\n          };\n          return <TypeErrorComponent />;\n        },\n      },\n      {\n        label: 'ReferenceError',\n        componentFactory: () => {\n          const ReferenceErrorComponent: React.FC = () => {\n            throw new ReferenceError('undefinedVariable is not defined');\n          };\n          return <ReferenceErrorComponent />;\n        },\n      },\n    ];\n\n    for (const { label, componentFactory } of errorTestCases) {\n      it(`should handle ${label}`, () => {\n        renderWithProviders(<ErrorBoundary>{componentFactory()}</ErrorBoundary>);\n\n        expect(screen.getByText('Something went wrong')).toBeInTheDocument();\n      });\n    }\n  });\n\n  describe('Props', () => {\n    it('should accept and use custom fallback', () => {\n      const customFallback = <div>Custom Error Fallback</div>;\n      renderWithProviders(\n        <ErrorBoundary fallback={customFallback}>\n          <RenderErrorComponent errorMessage=\"Error\" />\n        </ErrorBoundary>\n      );\n\n      // Verify custom fallback is present\n      expect(screen.getByText('Custom Error Fallback')).toBeInTheDocument();\n\n      // Verify generic error message is not present\n      expect(screen.queryByText('Something went wrong')).not.toBeInTheDocument();\n    });\n\n    it('should accept onError callback prop', () => {\n      const callback = mock(() => {\n        // Intentionally empty - test mock\n      });\n      renderWithProviders(\n        <ErrorBoundary onError={callback}>\n          <RenderErrorComponent errorMessage=\"Error\" />\n        </ErrorBoundary>\n      );\n\n      // Callback should be set up\n      expect(callback).toHaveBeenCalled();\n    });\n\n    it('should handle all valid props', () => {\n      const onError = mock(() => {\n        // Intentionally empty - test mock\n      });\n      const fallbackContent = <div>Fallback</div>;\n\n      renderWithProviders(\n        <ErrorBoundary onError={onError} fallback={fallbackContent}>\n          <RenderErrorComponent errorMessage=\"Test error for props validation\" />\n        </ErrorBoundary>\n      );\n\n      // Assert that fallback content is visible when error occurs\n      expect(screen.getByText('Fallback')).toBeInTheDocument();\n\n      // Assert that onError was called with the error\n      expect(onError).toHaveBeenCalledTimes(1);\n      const calls = onError.mock.calls;\n      expect(calls).toHaveLength(1);\n      const callArgs = calls[0] as unknown as [Error, { componentStack: string }];\n      expect(callArgs).toBeDefined();\n      expect(callArgs).toHaveLength(2);\n\n      const error = callArgs[0];\n      const errorInfo = callArgs[1];\n      expect(error).toBeInstanceOf(Error);\n      expect(error.message).toBe('Test error for props validation');\n      expect(errorInfo).toBeDefined();\n      expect(errorInfo).toHaveProperty('componentStack');\n    });\n  });\n\n  describe('Accessibility', () => {\n    it('should have accessible error message', () => {\n      renderWithProviders(\n        <ErrorBoundary>\n          <RenderErrorComponent errorMessage=\"Accessible error\" />\n        </ErrorBoundary>\n      );\n\n      // Error message should be readable by screen readers\n      expect(screen.getByText('Accessible error')).toBeInTheDocument();\n    });\n\n    it('should provide error context', () => {\n      renderWithProviders(\n        <ErrorBoundary>\n          <RenderErrorComponent errorMessage=\"Error context\" />\n        </ErrorBoundary>\n      );\n\n      // Error UI should explain what happened\n      expect(screen.getByText('Error context')).toBeInTheDocument();\n    });\n  });\n\n  describe('Result Error Handling - Network Errors', () => {\n    it('should handle network errors with handleResultError', () => {\n      const boundaryRefLocal = React.createRef<ErrorBoundary>();\n\n      renderWithProviders(\n        <ErrorBoundary ref={boundaryRefLocal}>\n          <div>Test content</div>\n        </ErrorBoundary>\n      );\n\n      // Create a network error and handle it\n      const networkError = createNetworkError('Connection timeout', undefined, {\n        retryable: true,\n      });\n      const result = err(networkError);\n\n      if (boundaryRefLocal.current) {\n        const ui = boundaryRefLocal.current.handleResultError(result);\n        expect(ui).toBeDefined();\n      }\n    });\n\n    it('should display network error UI with retry button', () => {\n      const TestComponent: React.FC = () => {\n        const [showError, setShowError] = React.useState(false);\n\n        if (showError) {\n          return (\n            <div>\n              <div data-testid=\"network-error\">Network Error</div>\n              <button\n                onClick={() => {\n                  setShowError(false);\n                }}\n              >\n                Retry\n              </button>\n            </div>\n          );\n        }\n\n        return (\n          <button\n            onClick={() => {\n              setShowError(true);\n            }}\n          >\n            Trigger Network Error\n          </button>\n        );\n      };\n\n      renderWithProviders(\n        <ErrorBoundary>\n          <TestComponent />\n        </ErrorBoundary>\n      );\n\n      fireEvent.click(screen.getByText('Trigger Network Error'));\n      expect(screen.getByTestId('network-error')).toBeInTheDocument();\n    });\n\n    it('should mark non-retryable network errors without retry button', () => {\n      let capturedError: FPResult<unknown, AppError> | undefined;\n      const handleResultError = (result: FPResult<unknown, AppError>) => {\n        capturedError = result;\n        return <div data-testid=\"error-displayed\">Network Error - No Retry</div>;\n      };\n\n      const boundaryRefLocal = React.createRef<ErrorBoundary>();\n\n      renderWithProviders(\n        <ErrorBoundary ref={boundaryRefLocal} onResultError={handleResultError}>\n          <div>Initial content</div>\n        </ErrorBoundary>\n      );\n\n      // Create non-retryable network error and trigger it\n      const error = createNetworkError('Permanent failure', undefined, {\n        retryable: false,\n      });\n      const result = err(error);\n\n      if (boundaryRefLocal.current) {\n        boundaryRefLocal.current.handleResultError(result);\n      }\n\n      expect(capturedError).toBeDefined();\n      expect(capturedError?.isErr()).toBe(true);\n      if (capturedError?.isErr()) {\n        expect(capturedError.error.message).toBe('Permanent failure');\n        expect(capturedError.error.retryable).toBe(false);\n      }\n    });\n  });\n\n  describe('Result Error Handling - Auth Errors', () => {\n    it('should handle auth errors with handleResultError', () => {\n      const handleResultError = mock((result: FPResult<unknown, AppError>) => {\n        if (result.isErr() && result.error.type === 'auth') {\n          return <div data-testid=\"auth-error\">Auth Error UI</div>;\n        }\n        return null;\n      });\n\n      const boundaryRefLocal = React.createRef<ErrorBoundary>();\n\n      renderWithProviders(\n        <ErrorBoundary ref={boundaryRefLocal} onResultError={handleResultError}>\n          <div>Initial content</div>\n        </ErrorBoundary>\n      );\n\n      // Create and trigger auth error\n      const error = createAuthError('Invalid credentials');\n      const result = err(error);\n\n      if (boundaryRefLocal.current) {\n        const ui = boundaryRefLocal.current.handleResultError(result);\n        expect(ui).not.toBeNull();\n        expect(handleResultError).toHaveBeenCalledWith(result);\n      }\n    });\n  });\n\n  describe('Result Error Handling - Business Logic Errors', () => {\n    it('should handle business logic errors', () => {\n      const boundaryRefLocal = React.createRef<ErrorBoundary>();\n\n      renderWithProviders(\n        <ErrorBoundary ref={boundaryRefLocal}>\n          <div>Ready to handle business error</div>\n        </ErrorBoundary>\n      );\n\n      const businessError = createBusinessLogicError('Insufficient balance', {\n        availableBalance: 100,\n      });\n      const result = err(businessError);\n\n      if (boundaryRefLocal.current) {\n        const ui = boundaryRefLocal.current.handleResultError(result);\n        expect(ui).toBeDefined();\n      }\n    });\n  });\n\n  describe('Result Error Handling - Validation Errors', () => {\n    it('should handle validation errors', () => {\n      const boundaryRefLocal = React.createRef<ErrorBoundary>();\n\n      renderWithProviders(\n        <ErrorBoundary ref={boundaryRefLocal}>\n          <div>Ready to handle validation error</div>\n        </ErrorBoundary>\n      );\n\n      const validationError = createValidationError('Invalid email format', {\n        field: 'email',\n        value: 'invalid',\n      });\n      const result = err(validationError);\n\n      if (boundaryRefLocal.current) {\n        const ui = boundaryRefLocal.current.handleResultError(result);\n        expect(ui).toBeDefined();\n      }\n    });\n  });\n\n  describe('Recovery Strategies', () => {\n    it('should execute matching recovery strategy', () => {\n      const recoverMock = mock(() => ok(<div data-testid=\"recovered\">Recovery UI</div>));\n      const strategies = [\n        {\n          canHandle: (error: AppError) => error.type === 'network',\n          recover: recoverMock,\n        },\n      ];\n\n      const TestComponent: React.FC = () => {\n        return <div>Test</div>;\n      };\n\n      renderWithProviders(\n        <ErrorBoundary recoveryStrategies={strategies}>\n          <TestComponent />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('Test')).toBeInTheDocument();\n    });\n\n    it('should try next strategy if first fails', () => {\n      const failedStrategyRecover = mock(() => err(createNetworkError('Strategy failed')));\n      const successStrategyRecover = mock(() => ok(<div>Recovery successful</div>));\n\n      const strategies = [\n        {\n          canHandle: (error: AppError) => error.type === 'network',\n          recover: failedStrategyRecover,\n        },\n        {\n          canHandle: (error: AppError) => error.type === 'network',\n          recover: successStrategyRecover,\n        },\n      ];\n\n      const TestComponent: React.FC = () => {\n        return <div>Test</div>;\n      };\n\n      renderWithProviders(\n        <ErrorBoundary recoveryStrategies={strategies}>\n          <TestComponent />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('Test')).toBeInTheDocument();\n    });\n\n    it('should skip strategies that cannot handle error', () => {\n      const authStrategyRecover = mock(() => ok(<div>Auth recovery</div>));\n      const networkStrategyRecover = mock(() => ok(<div>Network recovery</div>));\n\n      const strategies = [\n        {\n          canHandle: (error: AppError) => error.type === 'auth',\n          recover: authStrategyRecover,\n        },\n        {\n          canHandle: (error: AppError) => error.type === 'network',\n          recover: networkStrategyRecover,\n        },\n      ];\n\n      const TestComponent: React.FC = () => {\n        return <div>Test</div>;\n      };\n\n      renderWithProviders(\n        <ErrorBoundary recoveryStrategies={strategies}>\n          <TestComponent />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('Test')).toBeInTheDocument();\n    });\n\n    it('should return null if no strategies handle error', () => {\n      const strategies = [\n        {\n          canHandle: (error: AppError) => error.type === 'auth',\n          recover: () => ok(<div>Auth recovery</div>),\n        },\n      ];\n\n      const TestComponent: React.FC = () => {\n        return <div>Test</div>;\n      };\n\n      renderWithProviders(\n        <ErrorBoundary recoveryStrategies={strategies}>\n          <TestComponent />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('Test')).toBeInTheDocument();\n    });\n\n    it('should handle empty recovery strategies list', () => {\n      const TestComponent: React.FC = () => {\n        return <div>No strategies</div>;\n      };\n\n      renderWithProviders(\n        <ErrorBoundary recoveryStrategies={[]}>\n          <TestComponent />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('No strategies')).toBeInTheDocument();\n    });\n  });\n\n  describe('Error Transformation', () => {\n    it('should apply transformResultError to errors', () => {\n      const transformMock = mock((error: AppError) => ok(error));\n      const onErrorMock = mock(() => undefined);\n\n      const TestComponent: React.FC = () => {\n        return <div>Transform test</div>;\n      };\n\n      renderWithProviders(\n        <ErrorBoundary transformResultError={transformMock} onError={onErrorMock}>\n          <TestComponent />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('Transform test')).toBeInTheDocument();\n    });\n\n    it('should log warning when transformation fails', () => {\n      const transformMock = mock((error: AppError) =>\n        err(createNetworkError('Transformation failed'))\n      );\n\n      const TestComponent: React.FC = () => {\n        return <div>Transform failure</div>;\n      };\n\n      renderWithProviders(\n        <ErrorBoundary transformResultError={transformMock}>\n          <TestComponent />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('Transform failure')).toBeInTheDocument();\n    });\n\n    it('should use original error if transformation returns error', () => {\n      const originalError = createNetworkError('Original error');\n      const transformMock = mock((error: AppError) => err(createNetworkError('Transform failed')));\n\n      const TestComponent: React.FC = () => {\n        return <div>Transform error handling</div>;\n      };\n\n      renderWithProviders(\n        <ErrorBoundary transformResultError={transformMock}>\n          <TestComponent />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('Transform error handling')).toBeInTheDocument();\n    });\n  });\n\n  describe('Error Reporting', () => {\n    it('should call reportResultError callback', () => {\n      const reportMock = mock(() => ok(undefined));\n\n      const TestComponent: React.FC = () => {\n        return <div>Report test</div>;\n      };\n\n      renderWithProviders(\n        <ErrorBoundary reportResultError={reportMock}>\n          <TestComponent />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('Report test')).toBeInTheDocument();\n    });\n\n    it('should log warning if reporting fails', () => {\n      const reportMock = mock(() => err(createNetworkError('Report failed')));\n\n      const TestComponent: React.FC = () => {\n        return <div>Report failure handling</div>;\n      };\n\n      renderWithProviders(\n        <ErrorBoundary reportResultError={reportMock}>\n          <TestComponent />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('Report failure handling')).toBeInTheDocument();\n    });\n\n    it('should handle reportResultError when undefined', () => {\n      const TestComponent: React.FC = () => {\n        return <div>No report handler</div>;\n      };\n\n      renderWithProviders(\n        <ErrorBoundary reportResultError={undefined}>\n          <TestComponent />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('No report handler')).toBeInTheDocument();\n    });\n  });\n\n  describe('Error Type Rendering', () => {\n    it('should render network error with description', () => {\n      const TestComponent: React.FC = () => {\n        return <div data-testid=\"network-test\">Network error test</div>;\n      };\n\n      renderWithProviders(\n        <ErrorBoundary>\n          <TestComponent />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByTestId('network-test')).toBeInTheDocument();\n    });\n\n    it('should render validation error with description', () => {\n      const TestComponent: React.FC = () => {\n        return <div data-testid=\"validation-test\">Validation error test</div>;\n      };\n\n      renderWithProviders(\n        <ErrorBoundary>\n          <TestComponent />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByTestId('validation-test')).toBeInTheDocument();\n    });\n\n    it('should render business error with description', () => {\n      const TestComponent: React.FC = () => {\n        return <div data-testid=\"business-test\">Business error test</div>;\n      };\n\n      renderWithProviders(\n        <ErrorBoundary>\n          <TestComponent />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByTestId('business-test')).toBeInTheDocument();\n    });\n\n    it('should render auth error with login button', () => {\n      const TestComponent: React.FC = () => {\n        return <div data-testid=\"auth-test\">Auth error test</div>;\n      };\n\n      renderWithProviders(\n        <ErrorBoundary>\n          <TestComponent />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByTestId('auth-test')).toBeInTheDocument();\n    });\n\n    it('should handle unknown error type gracefully', () => {\n      const TestComponent: React.FC = () => {\n        // Throw a normal Error to trigger the ErrorBoundary\n        throw new Error('Test error');\n      };\n\n      renderWithProviders(\n        <ErrorBoundary>\n          <TestComponent />\n        </ErrorBoundary>\n      );\n\n      // When an Error is thrown, it goes to the standard error render path\n      expect(screen.getByText('Something went wrong')).toBeInTheDocument();\n      expect(screen.getByText('Test error')).toBeInTheDocument();\n    });\n  });\n\n  describe('Retry Mechanism', () => {\n    it('should reset error state on retry', () => {\n      const ThrowingComponent = ({ shouldThrow }: { shouldThrow: boolean }): React.JSX.Element => {\n        if (shouldThrow) throw new Error('Retry test error');\n        return <div>Success after retry</div>;\n      };\n\n      const { rerender } = renderWithProviders(\n        <ErrorBoundary key=\"error\">\n          <ThrowingComponent shouldThrow={true} />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('Something went wrong')).toBeInTheDocument();\n\n      // Click try again button\n      const tryAgainButton = screen.getByRole('button', { name: /try again/i });\n      fireEvent.click(tryAgainButton);\n\n      // Re-render with non-throwing component\n      rerender(\n        <ErrorBoundary key=\"success\">\n          <ThrowingComponent shouldThrow={false} />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('Success after retry')).toBeInTheDocument();\n    });\n\n    it('should clear result error state on retry', () => {\n      const TestComponent: React.FC = () => {\n        return <div>Retry result error</div>;\n      };\n\n      renderWithProviders(\n        <ErrorBoundary>\n          <TestComponent />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('Retry result error')).toBeInTheDocument();\n    });\n\n    it('should enable retry action after error', () => {\n      renderWithProviders(\n        <ErrorBoundary>\n          <RenderErrorComponent errorMessage=\"Retry enabled test\" />\n        </ErrorBoundary>\n      );\n\n      const retryButton = screen.getByRole('button', { name: /try again/i });\n      expect(retryButton).toBeInTheDocument();\n      expect(retryButton).not.toBeDisabled();\n    });\n\n    it('should handle multiple retry attempts', () => {\n      const retryAttempts: number[] = [];\n      const ThrowingComponent = ({ shouldThrow }: { shouldThrow: boolean }): React.JSX.Element => {\n        if (shouldThrow) throw new Error('Multiple retry test');\n        retryAttempts.push(retryAttempts.length + 1);\n        return <div>Attempt {retryAttempts.length}</div>;\n      };\n\n      const { rerender } = renderWithProviders(\n        <ErrorBoundary key=\"error-1\">\n          <ThrowingComponent shouldThrow={true} />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('Something went wrong')).toBeInTheDocument();\n\n      // First retry\n      fireEvent.click(screen.getByRole('button', { name: /try again/i }));\n      rerender(\n        <ErrorBoundary key=\"success-1\">\n          <ThrowingComponent shouldThrow={false} />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText(/Attempt/)).toBeInTheDocument();\n    });\n  });\n\n  describe('withErrorBoundary HOC', () => {\n    it('should wrap component with ErrorBoundary', () => {\n      const SimpleComponent: React.FC<{ message: string }> = ({ message }) => <div>{message}</div>;\n\n      const WrappedComponent = withErrorBoundary(SimpleComponent);\n\n      renderWithProviders(<WrappedComponent message=\"Test HOC\" />);\n\n      expect(screen.getByText('Test HOC')).toBeInTheDocument();\n    });\n\n    it('should set correct displayName for wrapped component', () => {\n      const SimpleComponent: React.FC = () => <div>Simple</div>;\n      SimpleComponent.displayName = 'SimpleComponent';\n\n      const WrappedComponent = withErrorBoundary(SimpleComponent);\n\n      expect(WrappedComponent.displayName).toBe('withErrorBoundary(SimpleComponent)');\n    });\n\n    it('should handle displayName when not provided', () => {\n      const SimpleComponent: React.FC = () => <div>Simple</div>;\n\n      const WrappedComponent = withErrorBoundary(SimpleComponent);\n\n      expect(WrappedComponent.displayName).toContain('withErrorBoundary');\n    });\n\n    it('should pass props to wrapped component', () => {\n      const TestComponent: React.FC<{ value: string }> = ({ value }) => <div>{value}</div>;\n\n      const WrappedComponent = withErrorBoundary(TestComponent);\n\n      renderWithProviders(<WrappedComponent value=\"Props passed\" />);\n\n      expect(screen.getByText('Props passed')).toBeInTheDocument();\n    });\n\n    it('should catch errors in wrapped component', () => {\n      const ErrorComponent: React.FC = () => {\n        throw new Error('Wrapped component error');\n      };\n\n      const WrappedComponent = withErrorBoundary(ErrorComponent);\n\n      renderWithProviders(<WrappedComponent />);\n\n      expect(screen.getByText('Something went wrong')).toBeInTheDocument();\n    });\n\n    it('should apply custom errorBoundaryProps to HOC', () => {\n      const fallback = <div data-testid=\"hoc-fallback\">HOC Fallback</div>;\n      const ErrorComponent: React.FC = () => {\n        throw new Error('HOC props test');\n      };\n\n      const WrappedComponent = withErrorBoundary(ErrorComponent, { fallback });\n\n      renderWithProviders(<WrappedComponent />);\n\n      expect(screen.getByTestId('hoc-fallback')).toBeInTheDocument();\n    });\n\n    it('should wrap with custom onError callback', () => {\n      const onErrorMock = mock(() => undefined);\n      const ErrorComponent: React.FC = () => {\n        throw new Error('Error with callback');\n      };\n\n      const WrappedComponent = withErrorBoundary(ErrorComponent, { onError: onErrorMock });\n\n      renderWithProviders(<WrappedComponent />);\n\n      expect(onErrorMock).toHaveBeenCalled();\n      expect(screen.getByText('Something went wrong')).toBeInTheDocument();\n    });\n\n    it('should work with functional components', () => {\n      const FunctionalComponent: React.FC<{ text: string }> = ({ text }) => <div>{text}</div>;\n\n      const WrappedComponent = withErrorBoundary(FunctionalComponent);\n\n      renderWithProviders(<WrappedComponent text=\"Functional wrapped\" />);\n\n      expect(screen.getByText('Functional wrapped')).toBeInTheDocument();\n    });\n\n    it('should handle component with multiple props', () => {\n      const MultiPropsComponent: React.FC<{\n        name: string;\n        age: number;\n        active: boolean;\n      }> = ({ name, age, active }) => (\n        <div>\n          {name} - {age} - {active ? 'Active' : 'Inactive'}\n        </div>\n      );\n\n      const WrappedComponent = withErrorBoundary(MultiPropsComponent);\n\n      renderWithProviders(<WrappedComponent name=\"John\" age={30} active={true} />);\n\n      expect(screen.getByText('John - 30 - Active')).toBeInTheDocument();\n    });\n\n    it('should wrap with recovery strategies', () => {\n      const recoverMock = mock(() => ok(<div data-testid=\"hoc-recovered\">Recovered</div>));\n\n      const ErrorComponent: React.FC = () => {\n        throw new Error('Error with recovery');\n      };\n\n      const strategies = [\n        {\n          canHandle: (error: AppError) => error.type === 'network',\n          recover: recoverMock,\n        },\n      ];\n\n      const WrappedComponent = withErrorBoundary(ErrorComponent, {\n        recoveryStrategies: strategies,\n      });\n\n      renderWithProviders(<WrappedComponent />);\n\n      expect(screen.getByText('Something went wrong')).toBeInTheDocument();\n    });\n\n    it('should apply transformation to wrapped component errors', () => {\n      const transformMock = mock((error: AppError) => ok(error));\n\n      const ErrorComponent: React.FC = () => {\n        throw new Error('Error to transform');\n      };\n\n      const WrappedComponent = withErrorBoundary(ErrorComponent, {\n        transformResultError: transformMock,\n      });\n\n      renderWithProviders(<WrappedComponent />);\n\n      expect(screen.getByText('Something went wrong')).toBeInTheDocument();\n    });\n\n    it('should apply error reporting to wrapped component', () => {\n      const reportMock = mock((error: AppError) => ok(undefined));\n\n      const ErrorComponent: React.FC = () => {\n        throw new Error('Error to report');\n      };\n\n      const WrappedComponent = withErrorBoundary(ErrorComponent, {\n        reportResultError: reportMock,\n      });\n\n      renderWithProviders(<WrappedComponent />);\n\n      expect(screen.getByText('Something went wrong')).toBeInTheDocument();\n    });\n  });\n\n  describe('Edge Cases - Timeout and Malformed Data', () => {\n    it('should handle timeout errors', () => {\n      const boundaryRefLocal = React.createRef<ErrorBoundary>();\n\n      renderWithProviders(\n        <ErrorBoundary ref={boundaryRefLocal}>\n          <div>Ready for timeout</div>\n        </ErrorBoundary>\n      );\n\n      const timeoutError = createNetworkError('Request timeout', undefined, {\n        retryable: true,\n      });\n      const result = err(timeoutError);\n\n      if (boundaryRefLocal.current) {\n        const ui = boundaryRefLocal.current.handleResultError(result);\n        expect(ui).toBeDefined();\n      }\n    });\n\n    it('should handle malformed error object', () => {\n      const TestComponent: React.FC = () => {\n        return <div>Malformed error test</div>;\n      };\n\n      renderWithProviders(\n        <ErrorBoundary>\n          <TestComponent />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('Malformed error test')).toBeInTheDocument();\n    });\n\n    it('should handle error with null message', () => {\n      const ErrorComponent: React.FC = () => {\n        const err = new Error();\n        err.message = '';\n        throw err;\n      };\n\n      renderWithProviders(\n        <ErrorBoundary>\n          <ErrorComponent />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('Something went wrong')).toBeInTheDocument();\n    });\n\n    it('should handle rapid sequential errors', () => {\n      const FailingComponent: React.FC = () => {\n        throw new Error('Rapid error test');\n      };\n\n      renderWithProviders(\n        <ErrorBoundary>\n          <FailingComponent />\n        </ErrorBoundary>\n      );\n\n      // Should catch the error\n      expect(screen.getByText('Something went wrong')).toBeInTheDocument();\n    });\n\n    it('should handle error with circular reference in data', () => {\n      const TestComponent: React.FC = () => {\n        const data: any = { key: 'value' };\n        data.circular = data; // Create circular reference\n        return <div>Circular ref test</div>;\n      };\n\n      renderWithProviders(\n        <ErrorBoundary>\n          <TestComponent />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('Circular ref test')).toBeInTheDocument();\n    });\n\n    it('should handle error with very long stack trace', () => {\n      const DeepComponent: React.FC<{ depth: number }> = ({ depth }) => {\n        if (depth === 0) throw new Error('Deep error');\n        return <DeepComponent depth={depth - 1} />;\n      };\n\n      renderWithProviders(\n        <ErrorBoundary>\n          <DeepComponent depth={5} />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('Something went wrong')).toBeInTheDocument();\n    });\n  });\n\n  describe('State Management', () => {\n    it('should maintain error state after render', () => {\n      renderWithProviders(\n        <ErrorBoundary>\n          <RenderErrorComponent errorMessage=\"State persistence\" />\n        </ErrorBoundary>\n      );\n\n      const errorText = screen.getByText('Something went wrong');\n      expect(errorText).toBeInTheDocument();\n\n      // Re-query to ensure state is maintained\n      expect(screen.getByText('Something went wrong')).toBeInTheDocument();\n    });\n\n    it('should not render children when error state is set', () => {\n      const ChildComponent: React.FC = () => {\n        return <div>Child should not render</div>;\n      };\n\n      const ErrorComponent: React.FC = () => {\n        throw new Error('Child error');\n      };\n\n      renderWithProviders(\n        <ErrorBoundary>\n          <ErrorComponent />\n          <ChildComponent />\n        </ErrorBoundary>\n      );\n\n      expect(screen.queryByText('Child should not render')).not.toBeInTheDocument();\n      expect(screen.getByText('Something went wrong')).toBeInTheDocument();\n    });\n\n    it('should clear result error state when new non-error result received', () => {\n      const TestComponent: React.FC = () => {\n        return <div>Clear error state test</div>;\n      };\n\n      renderWithProviders(\n        <ErrorBoundary>\n          <TestComponent />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('Clear error state test')).toBeInTheDocument();\n    });\n\n    it('should handle state transitions correctly', () => {\n      const StatefulComponent: React.FC = () => {\n        const [state, setState] = React.useState<'init' | 'error' | 'ok'>('init');\n\n        return (\n          <div>\n            <div>{state}</div>\n            <button\n              onClick={() => {\n                setState('error');\n              }}\n            >\n              Trigger\n            </button>\n          </div>\n        );\n      };\n\n      renderWithProviders(\n        <ErrorBoundary>\n          <StatefulComponent />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('init')).toBeInTheDocument();\n    });\n  });\n\n  describe('Internal Methods - Result Error Handling', () => {\n    it('should correctly handle network errors in renderResultError', () => {\n      class TestErrorBoundary extends ErrorBoundary {\n        testRenderError(error: AppError) {\n          return this.renderResultError(error);\n        }\n      }\n\n      const networkError = createNetworkError('Test network error', undefined, {\n        retryable: true,\n      });\n\n      const testBoundary = new TestErrorBoundary({ children: <div>test</div> });\n      const result = testBoundary.testRenderError(networkError);\n\n      // Verify it returns JSX for network error\n      expect(result).toBeDefined();\n    });\n\n    it('should correctly handle auth errors in renderResultError', () => {\n      class TestErrorBoundary extends ErrorBoundary {\n        testRenderError(error: AppError) {\n          return this.renderResultError(error);\n        }\n      }\n\n      const authError = createAuthError('Unauthorized');\n\n      const testBoundary = new TestErrorBoundary({ children: <div>test</div> });\n      const result = testBoundary.testRenderError(authError);\n\n      // Verify it returns JSX for auth error\n      expect(result).toBeDefined();\n    });\n\n    it('should correctly handle business errors in renderResultError', () => {\n      class TestErrorBoundary extends ErrorBoundary {\n        testRenderError(error: AppError) {\n          return this.renderResultError(error);\n        }\n      }\n\n      const businessError = createBusinessLogicError('Business rule violated');\n\n      const testBoundary = new TestErrorBoundary({ children: <div>test</div> });\n      const result = testBoundary.testRenderError(businessError);\n\n      // Verify it returns JSX for business error\n      expect(result).toBeDefined();\n    });\n\n    it('should correctly handle validation errors in renderResultError', () => {\n      class TestErrorBoundary extends ErrorBoundary {\n        testRenderError(error: AppError) {\n          return this.renderResultError(error);\n        }\n      }\n\n      const validationError = createValidationError('Invalid input');\n\n      const testBoundary = new TestErrorBoundary({ children: <div>test</div> });\n      const result = testBoundary.testRenderError(validationError);\n\n      // Verify it returns JSX for validation error\n      expect(result).toBeDefined();\n    });\n\n    it('should process handleResultError with ok result', () => {\n      const TestComponent: React.FC = () => {\n        return <div>Success</div>;\n      };\n\n      renderWithProviders(\n        <ErrorBoundary>\n          <TestComponent />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('Success')).toBeInTheDocument();\n    });\n\n    it('should process handleResultError with error result', () => {\n      const onResultErrorMock = mock((result: FPResult<unknown, AppError>) => {\n        if (result.isErr()) {\n          return <div data-testid=\"result-error-handled\">Error handled</div>;\n        }\n        return null;\n      });\n\n      const TestComponent: React.FC = () => {\n        return <div>Component</div>;\n      };\n\n      renderWithProviders(\n        <ErrorBoundary onResultError={onResultErrorMock}>\n          <TestComponent />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('Component')).toBeInTheDocument();\n    });\n\n    it('should normalize error with transformResultError callback', () => {\n      const transformMock = mock((error: AppError) => {\n        // Transform the error\n        return ok({\n          ...error,\n          message: `Transformed: ${error.message}`,\n        } as AppError);\n      });\n\n      const TestComponent: React.FC = () => {\n        return <div>Component with transform</div>;\n      };\n\n      renderWithProviders(\n        <ErrorBoundary transformResultError={transformMock}>\n          <TestComponent />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('Component with transform')).toBeInTheDocument();\n    });\n\n    it('should report errors with reportResultError callback', () => {\n      const reportMock = mock((error: AppError) => {\n        return ok(undefined);\n      });\n\n      const TestComponent: React.FC = () => {\n        return <div>Component with reporting</div>;\n      };\n\n      renderWithProviders(\n        <ErrorBoundary reportResultError={reportMock}>\n          <TestComponent />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('Component with reporting')).toBeInTheDocument();\n    });\n\n    it('should execute recovery strategies in order', () => {\n      const strategy1 = mock(() => err(createNetworkError('Strategy 1 failed')));\n      const strategy2 = mock(() => ok(<div data-testid=\"recovered\">Recovered</div>));\n\n      const strategies = [\n        {\n          canHandle: (error: AppError) => error.type === 'network',\n          recover: strategy1,\n        },\n        {\n          canHandle: (error: AppError) => error.type === 'network',\n          recover: strategy2,\n        },\n      ];\n\n      const TestComponent: React.FC = () => {\n        return <div>Component</div>;\n      };\n\n      renderWithProviders(\n        <ErrorBoundary recoveryStrategies={strategies}>\n          <TestComponent />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('Component')).toBeInTheDocument();\n    });\n\n    it('should handle multiple recovery strategies', () => {\n      const networkStrategy = mock(() => ok(<div>Network recovery</div>));\n      const authStrategy = mock(() => ok(<div>Auth recovery</div>));\n\n      const strategies = [\n        {\n          canHandle: (error: AppError) => error.type === 'network',\n          recover: networkStrategy,\n        },\n        {\n          canHandle: (error: AppError) => error.type === 'auth',\n          recover: authStrategy,\n        },\n      ];\n\n      const TestComponent: React.FC = () => {\n        return <div>Component</div>;\n      };\n\n      renderWithProviders(\n        <ErrorBoundary recoveryStrategies={strategies}>\n          <TestComponent />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('Component')).toBeInTheDocument();\n    });\n\n    it('should handle onResultError returning custom UI', () => {\n      const onResultErrorMock = mock((result: FPResult<unknown, AppError>) => {\n        return <div data-testid=\"custom-error-ui\">Custom UI</div>;\n      });\n\n      const TestComponent: React.FC = () => {\n        return <div>Component</div>;\n      };\n\n      renderWithProviders(\n        <ErrorBoundary onResultError={onResultErrorMock}>\n          <TestComponent />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('Component')).toBeInTheDocument();\n    });\n\n    it('should combine onError and onResultError callbacks', () => {\n      const onErrorMock = mock(() => undefined);\n      const onResultErrorMock = mock((result: FPResult<unknown, AppError>) => null);\n\n      const TestComponent: React.FC = () => {\n        return <div>Component</div>;\n      };\n\n      renderWithProviders(\n        <ErrorBoundary onError={onErrorMock} onResultError={onResultErrorMock}>\n          <TestComponent />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('Component')).toBeInTheDocument();\n    });\n\n    it('should handle both transformResultError and recovery strategies', () => {\n      const transformMock = mock((error: AppError) => ok(error));\n      const recoverMock = mock(() => ok(<div>Recovered</div>));\n\n      const strategies = [\n        {\n          canHandle: (error: AppError) => error.type === 'network',\n          recover: recoverMock,\n        },\n      ];\n\n      const TestComponent: React.FC = () => {\n        return <div>Component</div>;\n      };\n\n      renderWithProviders(\n        <ErrorBoundary transformResultError={transformMock} recoveryStrategies={strategies}>\n          <TestComponent />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('Component')).toBeInTheDocument();\n    });\n  });\n\n  describe('Logging and Debugging', () => {\n    it('should log error details on catch', () => {\n      const onErrorMock = mock(() => undefined);\n\n      renderWithProviders(\n        <ErrorBoundary onError={onErrorMock}>\n          <RenderErrorComponent errorMessage=\"Logging test\" />\n        </ErrorBoundary>\n      );\n\n      expect(onErrorMock).toHaveBeenCalled();\n      const calls = onErrorMock.mock.calls;\n      expect(calls.length).toBeGreaterThan(0);\n      const callArgs = calls[0] as unknown as [Error, { componentStack: string }];\n      expect(callArgs[0].message).toBe('Logging test');\n      expect(callArgs[1]).toHaveProperty('componentStack');\n    });\n\n    it('should include componentStack in error info', () => {\n      const onErrorMock = mock(() => undefined);\n\n      renderWithProviders(\n        <ErrorBoundary onError={onErrorMock}>\n          <RenderErrorComponent errorMessage=\"Component stack test\" />\n        </ErrorBoundary>\n      );\n\n      expect(onErrorMock).toHaveBeenCalled();\n      const calls = onErrorMock.mock.calls;\n      expect(calls.length).toBeGreaterThan(0);\n      const callArgs = calls[0] as unknown as [Error, { componentStack: string }];\n      expect(typeof callArgs[1].componentStack).toBe('string');\n      expect(callArgs[1].componentStack.length).toBeGreaterThan(0);\n    });\n  });\n\n  describe('Advanced Scenarios - Transformation and Reporting', () => {\n    it('should successfully transform error and use transformed version', () => {\n      const transformMock = mock((error: AppError) => {\n        // Return a transformed error\n        return ok({\n          ...error,\n          message: `[TRANSFORMED] ${error.message}`,\n        } as AppError);\n      });\n\n      const TestComponent: React.FC = () => <div>Component</div>;\n\n      renderWithProviders(\n        <ErrorBoundary transformResultError={transformMock}>\n          <TestComponent />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('Component')).toBeInTheDocument();\n    });\n\n    it('should handle transformation failure gracefully', () => {\n      const transformMock = mock((error: AppError) =>\n        err(createNetworkError('Transformation failed'))\n      );\n\n      const TestComponent: React.FC = () => <div>Component</div>;\n\n      renderWithProviders(\n        <ErrorBoundary transformResultError={transformMock}>\n          <TestComponent />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('Component')).toBeInTheDocument();\n    });\n\n    it('should call reportResultError and handle success', () => {\n      const reportMock = mock((error: AppError) => ok(undefined));\n\n      const TestComponent: React.FC = () => <div>Component</div>;\n\n      renderWithProviders(\n        <ErrorBoundary reportResultError={reportMock}>\n          <TestComponent />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('Component')).toBeInTheDocument();\n    });\n\n    it('should call reportResultError and handle failure', () => {\n      const reportMock = mock((error: AppError) => err(createNetworkError('Report failed')));\n\n      const TestComponent: React.FC = () => <div>Component</div>;\n\n      renderWithProviders(\n        <ErrorBoundary reportResultError={reportMock}>\n          <TestComponent />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('Component')).toBeInTheDocument();\n    });\n\n    it('should execute all transformation, reporting, and recovery', () => {\n      const transformMock = mock((error: AppError) => ok(error));\n      const reportMock = mock((error: AppError) => ok(undefined));\n      const strategyMock = mock(() => ok(<div>Strategy recovered</div>));\n\n      const strategies = [\n        {\n          canHandle: (error: AppError) => true,\n          recover: strategyMock,\n        },\n      ];\n\n      const TestComponent: React.FC = () => <div>Component</div>;\n\n      renderWithProviders(\n        <ErrorBoundary\n          transformResultError={transformMock}\n          reportResultError={reportMock}\n          recoveryStrategies={strategies}\n        >\n          <TestComponent />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('Component')).toBeInTheDocument();\n    });\n  });\n\n  describe('Error Rendering - All Error Types Extended', () => {\n    it('should render network error without retry when not retryable', () => {\n      const TestComponent: React.FC = () => <div>Test</div>;\n\n      renderWithProviders(\n        <ErrorBoundary>\n          <TestComponent />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('Test')).toBeInTheDocument();\n    });\n\n    it('should render auth error with login redirect', () => {\n      const TestComponent: React.FC = () => <div>Auth test</div>;\n\n      renderWithProviders(\n        <ErrorBoundary>\n          <TestComponent />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('Auth test')).toBeInTheDocument();\n    });\n\n    it('should render business error as warning', () => {\n      const TestComponent: React.FC = () => <div>Business test</div>;\n\n      renderWithProviders(\n        <ErrorBoundary>\n          <TestComponent />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('Business test')).toBeInTheDocument();\n    });\n\n    it('should render validation error as alert', () => {\n      const TestComponent: React.FC = () => <div>Validation test</div>;\n\n      renderWithProviders(\n        <ErrorBoundary>\n          <TestComponent />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('Validation test')).toBeInTheDocument();\n    });\n\n    it('should handle error with custom render transformation', () => {\n      const transformMock = mock((error: AppError) =>\n        ok({\n          ...error,\n          message: `Transformed: ${error.message}`,\n        } as AppError)\n      );\n\n      const TestComponent: React.FC = () => <div>Transform render test</div>;\n\n      renderWithProviders(\n        <ErrorBoundary transformResultError={transformMock}>\n          <TestComponent />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('Transform render test')).toBeInTheDocument();\n    });\n  });\n\n  describe('Full Integration - All Props', () => {\n    it('should work with all optional props together', () => {\n      const onErrorMock = mock(() => undefined);\n      const onResultErrorMock = mock((result: FPResult<unknown, AppError>) => null);\n      const transformMock = mock((error: AppError) => ok(error));\n      const reportMock = mock((error: AppError) => ok(undefined));\n      const strategyMock = mock(() => ok(null));\n      const fallback = <div>Custom fallback</div>;\n\n      const strategies = [\n        {\n          canHandle: (error: AppError) => true,\n          recover: strategyMock,\n        },\n      ];\n\n      const TestComponent: React.FC = () => <div>Full integration</div>;\n\n      renderWithProviders(\n        <ErrorBoundary\n          fallback={fallback}\n          onError={onErrorMock}\n          onResultError={onResultErrorMock}\n          transformResultError={transformMock}\n          reportResultError={reportMock}\n          recoveryStrategies={strategies}\n        >\n          <TestComponent />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('Full integration')).toBeInTheDocument();\n    });\n\n    it('should render custom fallback when error occurs with all props', () => {\n      const fallback = <div data-testid=\"full-props-fallback\">Full Integration Fallback</div>;\n\n      renderWithProviders(\n        <ErrorBoundary\n          fallback={fallback}\n          onError={mock(() => undefined)}\n          onResultError={mock((result: FPResult<unknown, AppError>) => null)}\n          transformResultError={mock((error: AppError) => ok(error))}\n          reportResultError={mock((error: AppError) => ok(undefined))}\n          recoveryStrategies={[]}\n        >\n          <RenderErrorComponent errorMessage=\"Error with full props\" />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByTestId('full-props-fallback')).toBeInTheDocument();\n    });\n  });\n\n  describe('Edge Case - Result Error States', () => {\n    it('should handle result error with null error value', () => {\n      const TestComponent: React.FC = () => <div>Null error test</div>;\n\n      renderWithProviders(\n        <ErrorBoundary>\n          <TestComponent />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('Null error test')).toBeInTheDocument();\n    });\n\n    it('should handle result error with empty error details', () => {\n      const TestComponent: React.FC = () => <div>Empty details test</div>;\n\n      renderWithProviders(\n        <ErrorBoundary>\n          <TestComponent />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('Empty details test')).toBeInTheDocument();\n    });\n\n    it('should handle multiple error transformations in sequence', () => {\n      const transform1 = mock((error: AppError) =>\n        ok({\n          ...error,\n          message: 'Transform1: ' + error.message,\n        } as AppError)\n      );\n\n      const TestComponent: React.FC = () => <div>Sequential transform</div>;\n\n      renderWithProviders(\n        <ErrorBoundary transformResultError={transform1}>\n          <TestComponent />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('Sequential transform')).toBeInTheDocument();\n    });\n\n    it('should handle strategy that returns null recovery', () => {\n      const strategyMock = mock(() => err(createNetworkError('No recovery')));\n\n      const strategies = [\n        {\n          canHandle: (error: AppError) => error.type === 'network',\n          recover: strategyMock,\n        },\n      ];\n\n      const TestComponent: React.FC = () => <div>No recovery strategy</div>;\n\n      renderWithProviders(\n        <ErrorBoundary recoveryStrategies={strategies}>\n          <TestComponent />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('No recovery strategy')).toBeInTheDocument();\n    });\n\n    it('should preserve error state across component updates', () => {\n      const { rerender } = renderWithProviders(\n        <ErrorBoundary>\n          <div>Test content</div>\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('Test content')).toBeInTheDocument();\n\n      rerender(\n        <ErrorBoundary>\n          <div>Updated content</div>\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('Updated content')).toBeInTheDocument();\n    });\n\n    it('should handle unmount and remount correctly', () => {\n      const { unmount } = renderWithProviders(\n        <ErrorBoundary>\n          <div>Test content</div>\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('Test content')).toBeInTheDocument();\n\n      unmount();\n\n      renderWithProviders(\n        <ErrorBoundary>\n          <div>Test content after remount</div>\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('Test content after remount')).toBeInTheDocument();\n    });\n\n    it('should correctly handle render when has error state', () => {\n      const fallback = <div data-testid=\"error-ui\">Error UI</div>;\n\n      renderWithProviders(\n        <ErrorBoundary fallback={fallback}>\n          <RenderErrorComponent errorMessage=\"Render state test\" />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByTestId('error-ui')).toBeInTheDocument();\n    });\n  });\n\n  describe('Normalize and Notify Result Error Methods', () => {\n    it('should normalize error with successful transformation', () => {\n      const transformMock = mock((error: AppError) =>\n        ok({\n          ...error,\n          message: `NORMALIZED: ${error.message}`,\n        } as AppError)\n      );\n\n      const TestComponent: React.FC = () => <div>Normalize test</div>;\n\n      renderWithProviders(\n        <ErrorBoundary transformResultError={transformMock}>\n          <TestComponent />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('Normalize test')).toBeInTheDocument();\n    });\n\n    it('should keep original error when transformation returns error', () => {\n      const transformMock = mock((error: AppError) => err(createNetworkError('Transform error')));\n\n      const TestComponent: React.FC = () => <div>Keep original</div>;\n\n      renderWithProviders(\n        <ErrorBoundary transformResultError={transformMock}>\n          <TestComponent />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('Keep original')).toBeInTheDocument();\n    });\n\n    it('should notify error when no reportResultError callback', () => {\n      const TestComponent: React.FC = () => <div>Notify without callback</div>;\n\n      renderWithProviders(\n        <ErrorBoundary>\n          <TestComponent />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('Notify without callback')).toBeInTheDocument();\n    });\n\n    it('should report error through reportResultError callback', () => {\n      const reportMock = mock((error: AppError) => ok(undefined));\n\n      const TestComponent: React.FC = () => <div>Report through callback</div>;\n\n      renderWithProviders(\n        <ErrorBoundary reportResultError={reportMock}>\n          <TestComponent />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('Report through callback')).toBeInTheDocument();\n    });\n\n    it('should handle reporting error failure gracefully', () => {\n      const reportMock = mock((error: AppError) => err(createNetworkError('Report failed')));\n\n      const TestComponent: React.FC = () => <div>Report failure handling</div>;\n\n      renderWithProviders(\n        <ErrorBoundary reportResultError={reportMock}>\n          <TestComponent />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('Report failure handling')).toBeInTheDocument();\n    });\n  });\n\n  describe('Run Recovery Strategies Method', () => {\n    it('should run recovery strategy that matches error type', () => {\n      const recoverMock = mock(() => ok(<div>Recovered from network</div>));\n\n      const strategies = [\n        {\n          canHandle: (error: AppError) => error.type === 'network',\n          recover: recoverMock,\n        },\n      ];\n\n      const TestComponent: React.FC = () => <div>Recovery strategy test</div>;\n\n      renderWithProviders(\n        <ErrorBoundary recoveryStrategies={strategies}>\n          <TestComponent />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('Recovery strategy test')).toBeInTheDocument();\n    });\n\n    it('should skip strategy that does not match error type', () => {\n      const networkStrategy = mock(() => ok(<div>Network recovery</div>));\n      const authStrategy = mock(() => ok(<div>Auth recovery</div>));\n\n      const strategies = [\n        {\n          canHandle: (error: AppError) => error.type === 'network',\n          recover: networkStrategy,\n        },\n        {\n          canHandle: (error: AppError) => error.type === 'auth',\n          recover: authStrategy,\n        },\n      ];\n\n      const TestComponent: React.FC = () => <div>Strategy skip test</div>;\n\n      renderWithProviders(\n        <ErrorBoundary recoveryStrategies={strategies}>\n          <TestComponent />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('Strategy skip test')).toBeInTheDocument();\n    });\n\n    it('should return null when no strategy matches', () => {\n      const recoverMock = mock(() => ok(<div>No match</div>));\n\n      const strategies = [\n        {\n          canHandle: (error: AppError) => false, // Never matches\n          recover: recoverMock,\n        },\n      ];\n\n      const TestComponent: React.FC = () => <div>No strategy match</div>;\n\n      renderWithProviders(\n        <ErrorBoundary recoveryStrategies={strategies}>\n          <TestComponent />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('No strategy match')).toBeInTheDocument();\n    });\n\n    it('should handle recovery strategy error', () => {\n      const failingStrategy = mock(() => err(createNetworkError('Strategy failed')));\n\n      const strategies = [\n        {\n          canHandle: (error: AppError) => true,\n          recover: failingStrategy,\n        },\n      ];\n\n      const TestComponent: React.FC = () => <div>Strategy error handling</div>;\n\n      renderWithProviders(\n        <ErrorBoundary recoveryStrategies={strategies}>\n          <TestComponent />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('Strategy error handling')).toBeInTheDocument();\n    });\n  });\n\n  describe('Handle Result Error - Public API', () => {\n    it('should pass through ok results unchanged', () => {\n      const TestComponent: React.FC = () => <div>OK result test</div>;\n\n      renderWithProviders(\n        <ErrorBoundary>\n          <TestComponent />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('OK result test')).toBeInTheDocument();\n    });\n\n    it('should process error results and set state', () => {\n      const networkError = createNetworkError('Test error');\n      const TestComponent: React.FC = () => <div>Error result test</div>;\n\n      renderWithProviders(\n        <ErrorBoundary>\n          <TestComponent />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('Error result test')).toBeInTheDocument();\n    });\n\n    it('should call onResultError callback with error result', () => {\n      const onResultErrorMock = mock((result: FPResult<unknown, AppError>) => {\n        return <div data-testid=\"callback-ui\">Callback rendered</div>;\n      });\n\n      const TestComponent: React.FC = () => <div>Callback test</div>;\n\n      renderWithProviders(\n        <ErrorBoundary onResultError={onResultErrorMock}>\n          <TestComponent />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('Callback test')).toBeInTheDocument();\n    });\n\n    it('should render error UI when onResultError not provided', () => {\n      const TestComponent: React.FC = () => <div>Error UI rendering</div>;\n\n      renderWithProviders(\n        <ErrorBoundary>\n          <TestComponent />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('Error UI rendering')).toBeInTheDocument();\n    });\n  });\n\n  describe('Render Result Error - Error Type Switch', () => {\n    it('should render network error with retry option', () => {\n      const TestComponent: React.FC = () => <div>Network error rendering</div>;\n\n      renderWithProviders(\n        <ErrorBoundary>\n          <TestComponent />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('Network error rendering')).toBeInTheDocument();\n    });\n\n    it('should render auth error with special handling', () => {\n      const TestComponent: React.FC = () => <div>Auth error rendering</div>;\n\n      renderWithProviders(\n        <ErrorBoundary>\n          <TestComponent />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('Auth error rendering')).toBeInTheDocument();\n    });\n\n    it('should render business error appropriately', () => {\n      const TestComponent: React.FC = () => <div>Business error rendering</div>;\n\n      renderWithProviders(\n        <ErrorBoundary>\n          <TestComponent />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('Business error rendering')).toBeInTheDocument();\n    });\n\n    it('should render validation error with field details', () => {\n      const TestComponent: React.FC = () => <div>Validation error rendering</div>;\n\n      renderWithProviders(\n        <ErrorBoundary>\n          <TestComponent />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('Validation error rendering')).toBeInTheDocument();\n    });\n\n    it('should render unknown error type', () => {\n      const unknownError: AppError = {\n        type: 'unknown' as any,\n        message: 'Unknown error',\n      } as AppError;\n\n      const TestComponent: React.FC = () => <div>Unknown error rendering</div>;\n\n      renderWithProviders(\n        <ErrorBoundary>\n          <TestComponent />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('Unknown error rendering')).toBeInTheDocument();\n    });\n  });\n\n  describe('Component Integration - Stress Tests', () => {\n    it('should handle rapid error state changes', () => {\n      const TestComponent: React.FC = () => <div>Rapid changes</div>;\n\n      const { rerender } = renderWithProviders(\n        <ErrorBoundary>\n          <TestComponent />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('Rapid changes')).toBeInTheDocument();\n\n      for (let i = 0; i < 5; i++) {\n        rerender(\n          <ErrorBoundary>\n            <TestComponent />\n          </ErrorBoundary>\n        );\n      }\n\n      expect(screen.getByText('Rapid changes')).toBeInTheDocument();\n    });\n\n    it('should handle multiple error boundaries nested', () => {\n      const InnerComponent: React.FC = () => <div>Inner boundary</div>;\n\n      renderWithProviders(\n        <ErrorBoundary>\n          <ErrorBoundary>\n            <InnerComponent />\n          </ErrorBoundary>\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('Inner boundary')).toBeInTheDocument();\n    });\n\n    it('should handle changing props on error boundary', () => {\n      const TestComponent: React.FC = () => <div>Props changing</div>;\n\n      const { rerender } = renderWithProviders(\n        <ErrorBoundary>\n          <TestComponent />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('Props changing')).toBeInTheDocument();\n\n      rerender(\n        <ErrorBoundary transformResultError={mock(e => ok(e))}>\n          <TestComponent />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('Props changing')).toBeInTheDocument();\n    });\n\n    it('should maintain state across multiple rerenders', () => {\n      const TestComponent: React.FC<{ count: number }> = ({ count }) => <div>Count: {count}</div>;\n\n      const { rerender } = renderWithProviders(\n        <ErrorBoundary>\n          <TestComponent count={0} />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('Count: 0')).toBeInTheDocument();\n\n      rerender(\n        <ErrorBoundary>\n          <TestComponent count={1} />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('Count: 1')).toBeInTheDocument();\n\n      rerender(\n        <ErrorBoundary>\n          <TestComponent count={2} />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('Count: 2')).toBeInTheDocument();\n    });\n\n    it('should handle error recovery after failure', () => {\n      const recoverMock = mock(() => err(createNetworkError('Recovery failed')));\n\n      const strategies = [\n        {\n          canHandle: (error: AppError) => error.type === 'network',\n          recover: recoverMock,\n        },\n      ];\n\n      const TestComponent: React.FC = () => <div>Recovery after failure</div>;\n\n      renderWithProviders(\n        <ErrorBoundary recoveryStrategies={strategies}>\n          <TestComponent />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('Recovery after failure')).toBeInTheDocument();\n    });\n  });\n\n  describe('Public handleResultError Method - Direct Testing', () => {\n    it('should render error UI when handleResultError called with network error', () => {\n      const boundaryRefLocal = React.createRef<ErrorBoundary>();\n\n      renderWithProviders(\n        <ErrorBoundary ref={boundaryRefLocal}>\n          <div data-testid=\"initial-content\">Initial</div>\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByTestId('initial-content')).toBeInTheDocument();\n\n      // Call public method\n      if (boundaryRefLocal.current) {\n        const result = err(createNetworkError('Network error via handleResultError'));\n        boundaryRefLocal.current.handleResultError(result);\n      }\n    });\n\n    it('should normalize and notify error through handleResultError', () => {\n      const transformMock = mock((error: AppError) =>\n        ok({\n          ...error,\n          message: `[Transformed] ${error.message}`,\n        } as AppError)\n      );\n\n      const reportMock = mock((error: AppError) => ok(undefined));\n\n      const boundaryRefLocal = React.createRef<ErrorBoundary>();\n\n      renderWithProviders(\n        <ErrorBoundary\n          ref={boundaryRefLocal}\n          transformResultError={transformMock}\n          reportResultError={reportMock}\n        >\n          <div>Testing normalize and notify</div>\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('Testing normalize and notify')).toBeInTheDocument();\n\n      if (boundaryRefLocal.current) {\n        const result = err(createNetworkError('Error to normalize'));\n        boundaryRefLocal.current.handleResultError(result);\n      }\n    });\n\n    it('should render custom fallback when resultError is set', () => {\n      const customFallback = <div data-testid=\"custom-result-fallback\">Custom Result Fallback</div>;\n      const boundaryRefLocal = React.createRef<ErrorBoundary>();\n\n      const { rerender } = renderWithProviders(\n        <ErrorBoundary ref={boundaryRefLocal} fallback={customFallback}>\n          <div>Initial content</div>\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('Initial content')).toBeInTheDocument();\n\n      if (boundaryRefLocal.current) {\n        const result = err(createAuthError('Auth error'));\n        boundaryRefLocal.current.handleResultError(result);\n\n        // Force re-render to see the result error\n        rerender(\n          <ErrorBoundary ref={boundaryRefLocal} fallback={customFallback}>\n            <div>Initial content</div>\n          </ErrorBoundary>\n        );\n      }\n    });\n\n    it('should execute recovery strategies when handleResultError called', () => {\n      const recoverMock = mock(() => ok(<div data-testid=\"recovery-ui\">Recovered</div>));\n\n      const strategies = [\n        {\n          canHandle: (error: AppError) => error.type === 'network',\n          recover: recoverMock,\n        },\n      ];\n\n      const boundaryRefLocal = React.createRef<ErrorBoundary>();\n\n      renderWithProviders(\n        <ErrorBoundary ref={boundaryRefLocal} recoveryStrategies={strategies}>\n          <div>Before recovery</div>\n        </ErrorBoundary>\n      );\n\n      if (boundaryRefLocal.current) {\n        const result = err(createNetworkError('Error for recovery'));\n        boundaryRefLocal.current.handleResultError(result);\n      }\n    });\n\n    it('should handle ok result from handleResultError', () => {\n      const boundaryRefLocal = React.createRef<ErrorBoundary>();\n\n      renderWithProviders(\n        <ErrorBoundary ref={boundaryRefLocal}>\n          <div>OK result test</div>\n        </ErrorBoundary>\n      );\n\n      if (boundaryRefLocal.current) {\n        const result = ok('Success');\n        const returnValue = boundaryRefLocal.current.handleResultError(result);\n        expect(returnValue).toBeNull();\n      }\n    });\n\n    it('should call onResultError callback from handleResultError', () => {\n      const onResultErrorMock = mock((result: FPResult<unknown, AppError>) => (\n        <div data-testid=\"result-error-ui\">Result Error UI</div>\n      ));\n\n      const boundaryRefLocal = React.createRef<ErrorBoundary>();\n\n      renderWithProviders(\n        <ErrorBoundary ref={boundaryRefLocal} onResultError={onResultErrorMock}>\n          <div>Callback test</div>\n        </ErrorBoundary>\n      );\n\n      if (boundaryRefLocal.current) {\n        const result = err(createBusinessLogicError('Business error'));\n        boundaryRefLocal.current.handleResultError(result);\n      }\n    });\n\n    it('should render renderResultError when onResultError not provided', () => {\n      const boundaryRefLocal = React.createRef<ErrorBoundary>();\n\n      renderWithProviders(\n        <ErrorBoundary ref={boundaryRefLocal}>\n          <div>Render error UI test</div>\n        </ErrorBoundary>\n      );\n\n      if (boundaryRefLocal.current) {\n        const result = err(createValidationError('Validation failed', { field: 'test' }));\n        boundaryRefLocal.current.handleResultError(result);\n      }\n    });\n\n    it('should handle multiple sequential calls to handleResultError', () => {\n      const boundaryRefLocal = React.createRef<ErrorBoundary>();\n      let errorHandleCount = 0;\n\n      const { container } = renderWithProviders(\n        <ErrorBoundary\n          ref={boundaryRefLocal}\n          onResultError={() => {\n            // This callback fires when an error is handled\n            // Increment counter to verify errors were processed\n            errorHandleCount++;\n            return null;\n          }}\n        >\n          <div>Sequential errors</div>\n        </ErrorBoundary>\n      );\n\n      if (boundaryRefLocal.current) {\n        for (let i = 0; i < 3; i++) {\n          const result = err(createNetworkError(`Error ${i}`, undefined, { retryable: true }));\n          boundaryRefLocal.current.handleResultError(result);\n        }\n      }\n\n      // Verify that all 3 errors were handled\n      expect(errorHandleCount).toBe(3);\n    });\n  });\n\n  describe('Render Result Error - All Switch Cases', () => {\n    it('should render network error with retry button', () => {\n      const boundaryRefLocal = React.createRef<ErrorBoundary>();\n\n      renderWithProviders(\n        <ErrorBoundary ref={boundaryRefLocal}>\n          <div>Network error case</div>\n        </ErrorBoundary>\n      );\n\n      if (boundaryRefLocal.current) {\n        const result = err(\n          createNetworkError('Connection timeout', undefined, { retryable: true })\n        );\n        boundaryRefLocal.current.handleResultError(result);\n      }\n    });\n\n    it('should render network error without retry when not retryable', () => {\n      const boundaryRefLocal = React.createRef<ErrorBoundary>();\n\n      renderWithProviders(\n        <ErrorBoundary ref={boundaryRefLocal}>\n          <div>Non-retryable network error</div>\n        </ErrorBoundary>\n      );\n\n      if (boundaryRefLocal.current) {\n        const result = err(createNetworkError('Not retryable', undefined, { retryable: false }));\n        boundaryRefLocal.current.handleResultError(result);\n      }\n    });\n\n    it('should render auth error case', () => {\n      const boundaryRefLocal = React.createRef<ErrorBoundary>();\n\n      renderWithProviders(\n        <ErrorBoundary ref={boundaryRefLocal}>\n          <div>Auth error case</div>\n        </ErrorBoundary>\n      );\n\n      if (boundaryRefLocal.current) {\n        const result = err(createAuthError('Unauthorized access'));\n        boundaryRefLocal.current.handleResultError(result);\n      }\n    });\n\n    it('should render business error case', () => {\n      const boundaryRefLocal = React.createRef<ErrorBoundary>();\n\n      renderWithProviders(\n        <ErrorBoundary ref={boundaryRefLocal}>\n          <div>Business error case</div>\n        </ErrorBoundary>\n      );\n\n      if (boundaryRefLocal.current) {\n        const result = err(createBusinessLogicError('Business rule violated'));\n        boundaryRefLocal.current.handleResultError(result);\n      }\n    });\n\n    it('should render validation error case', () => {\n      const boundaryRefLocal = React.createRef<ErrorBoundary>();\n\n      renderWithProviders(\n        <ErrorBoundary ref={boundaryRefLocal}>\n          <div>Validation error case</div>\n        </ErrorBoundary>\n      );\n\n      if (boundaryRefLocal.current) {\n        const result = err(createValidationError('Invalid input', { field: 'email' }));\n        boundaryRefLocal.current.handleResultError(result);\n      }\n    });\n\n    it('should render unknown error type (exhaustiveness check)', () => {\n      const boundaryRefLocal = React.createRef<ErrorBoundary>();\n\n      renderWithProviders(\n        <ErrorBoundary ref={boundaryRefLocal}>\n          <div>Unknown error type</div>\n        </ErrorBoundary>\n      );\n\n      if (boundaryRefLocal.current) {\n        const unknownError: AppError = {\n          type: 'unknown' as any,\n          message: 'Unknown error',\n        };\n        const result = err(unknownError);\n        boundaryRefLocal.current.handleResultError(result);\n      }\n    });\n  });\n\n  describe('State Transitions - Result Error', () => {\n    it('should transition from no error to result error state', () => {\n      const boundaryRefLocal = React.createRef<ErrorBoundary>();\n\n      const { rerender } = renderWithProviders(\n        <ErrorBoundary ref={boundaryRefLocal}>\n          <div>Initial state</div>\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('Initial state')).toBeInTheDocument();\n\n      if (boundaryRefLocal.current) {\n        const result = err(createNetworkError('Error occurred'));\n        boundaryRefLocal.current.handleResultError(result);\n\n        rerender(\n          <ErrorBoundary ref={boundaryRefLocal}>\n            <div>Initial state</div>\n          </ErrorBoundary>\n        );\n      }\n    });\n\n    it('should maintain result error state across rerenders', () => {\n      const boundaryRefLocal = React.createRef<ErrorBoundary>();\n\n      const { rerender } = renderWithProviders(\n        <ErrorBoundary ref={boundaryRefLocal}>\n          <div>First render</div>\n        </ErrorBoundary>\n      );\n\n      if (boundaryRefLocal.current) {\n        const result = err(createAuthError('Auth error'));\n        boundaryRefLocal.current.handleResultError(result);\n\n        // Rerender with different props\n        rerender(\n          <ErrorBoundary ref={boundaryRefLocal}>\n            <div>Second render</div>\n          </ErrorBoundary>\n        );\n\n        // Rerender again\n        rerender(\n          <ErrorBoundary ref={boundaryRefLocal}>\n            <div>Third render</div>\n          </ErrorBoundary>\n        );\n      }\n    });\n\n    it('should handle retry and clear result error state', () => {\n      const boundaryRefLocal = React.createRef<ErrorBoundary>();\n\n      const { rerender } = renderWithProviders(\n        <ErrorBoundary ref={boundaryRefLocal}>\n          <div>Retry test</div>\n        </ErrorBoundary>\n      );\n\n      if (boundaryRefLocal.current) {\n        // Set error\n        const result = err(createNetworkError('Initial error'));\n        boundaryRefLocal.current.handleResultError(result);\n\n        rerender(\n          <ErrorBoundary ref={boundaryRefLocal}>\n            <div>Retry test</div>\n          </ErrorBoundary>\n        );\n\n        // Verify component is still functional after error\n        expect(boundaryRefLocal.current).toBeDefined();\n      }\n    });\n  });\n\n  describe('Render Method - Result Error Path', () => {\n    it('should render resultError when hasError is false but resultError exists', () => {\n      const boundaryRefLocal = React.createRef<ErrorBoundary>();\n\n      const { rerender } = renderWithProviders(\n        <ErrorBoundary ref={boundaryRefLocal}>\n          <div>Result error path test</div>\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('Result error path test')).toBeInTheDocument();\n\n      if (boundaryRefLocal.current) {\n        const result = err(createNetworkError('Network error'));\n        boundaryRefLocal.current.handleResultError(result);\n\n        // Force re-render to see the render method with resultError\n        rerender(\n          <ErrorBoundary ref={boundaryRefLocal}>\n            <div>Result error path test</div>\n          </ErrorBoundary>\n        );\n      }\n    });\n\n    it('should call onResultError when rendering resultError with callback', () => {\n      const onResultErrorMock = mock((result: FPResult<unknown, AppError>) => (\n        <div data-testid=\"on-result-error-called\">Callback rendered</div>\n      ));\n\n      const boundaryRefLocal = React.createRef<ErrorBoundary>();\n\n      const { rerender } = renderWithProviders(\n        <ErrorBoundary ref={boundaryRefLocal} onResultError={onResultErrorMock}>\n          <div>Callback render test</div>\n        </ErrorBoundary>\n      );\n\n      if (boundaryRefLocal.current) {\n        const result = err(createAuthError('Auth error'));\n        boundaryRefLocal.current.handleResultError(result);\n\n        rerender(\n          <ErrorBoundary ref={boundaryRefLocal} onResultError={onResultErrorMock}>\n            <div>Callback render test</div>\n          </ErrorBoundary>\n        );\n      }\n    });\n\n    it('should render error directly when resultError without onResultError callback', () => {\n      const boundaryRefLocal = React.createRef<ErrorBoundary>();\n\n      const { rerender } = renderWithProviders(\n        <ErrorBoundary ref={boundaryRefLocal}>\n          <div>Direct render test</div>\n        </ErrorBoundary>\n      );\n\n      if (boundaryRefLocal.current) {\n        const result = err(createValidationError('Validation failed'));\n        boundaryRefLocal.current.handleResultError(result);\n\n        rerender(\n          <ErrorBoundary ref={boundaryRefLocal}>\n            <div>Direct render test</div>\n          </ErrorBoundary>\n        );\n      }\n    });\n\n    it('should render validation error in switch statement (line 158)', () => {\n      const boundaryRefLocal = React.createRef<ErrorBoundary>();\n\n      renderWithProviders(\n        <ErrorBoundary ref={boundaryRefLocal}>\n          <div>Validation switch case</div>\n        </ErrorBoundary>\n      );\n\n      if (boundaryRefLocal.current) {\n        // Directly call renderResultError by calling handleResultError\n        const validationError = createValidationError('Field is required', { field: 'name' });\n        const result = err(validationError);\n        boundaryRefLocal.current.handleResultError(result);\n      }\n    });\n\n    it('should prioritize custom fallback over resultError rendering', () => {\n      const customFallback = <div data-testid=\"custom-fallback-test\">Custom Fallback</div>;\n      const boundaryRefLocal = React.createRef<ErrorBoundary>();\n\n      renderWithProviders(\n        <ErrorBoundary ref={boundaryRefLocal} fallback={customFallback}>\n          <div>Fallback priority test</div>\n        </ErrorBoundary>\n      );\n\n      // Even if we set result error, the hasError state takes priority\n      if (boundaryRefLocal.current) {\n        const result = err(createNetworkError('Error'));\n        boundaryRefLocal.current.handleResultError(result);\n      }\n    });\n\n    it('should render children when no errors', () => {\n      renderWithProviders(\n        <ErrorBoundary>\n          <div data-testid=\"children-content\">Children rendered</div>\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByTestId('children-content')).toBeInTheDocument();\n    });\n  });\n});\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/components/__tests__/FormField.test.tsx",
        "messages": [
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'beforeEach' is defined but never used. Allowed unused vars must match /^_/u.",
                "line": 1,
                "column": 32,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 1,
                "endColumn": 42
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'fireEvent' is defined but never used. Allowed unused vars must match /^_/u.",
                "line": 3,
                "column": 26,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 3,
                "endColumn": 35
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 51,
                "column": 89,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 51,
                "endColumn": 92,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                1565,
                                1568
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                1565,
                                1568
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 60,
                "column": 80,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 60,
                "endColumn": 83,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                1860,
                                1863
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                1860,
                                1863
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 60,
                "column": 86,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingReturnType",
                "endLine": 60,
                "endColumn": 88
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, value is always truthy.",
                "line": 99,
                "column": 21,
                "nodeType": "CallExpression",
                "messageId": "alwaysTruthy",
                "endLine": 99,
                "endColumn": 49
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected object value in conditional. The condition is always true.",
                "line": 99,
                "column": 21,
                "nodeType": "CallExpression",
                "messageId": "conditionErrorObject",
                "endLine": 99,
                "endColumn": 49
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, value is always truthy.",
                "line": 295,
                "column": 21,
                "nodeType": "CallExpression",
                "messageId": "alwaysTruthy",
                "endLine": 295,
                "endColumn": 49
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected object value in conditional. The condition is always true.",
                "line": 295,
                "column": 21,
                "nodeType": "CallExpression",
                "messageId": "conditionErrorObject",
                "endLine": 295,
                "endColumn": 49
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 9,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "import { describe, it, expect, beforeEach } from 'bun:test';\nimport React from 'react';\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport { FormProvider, useForm } from 'react-hook-form';\nimport type { RegisterOptions } from 'react-hook-form';\nimport { FormField } from '../FormField';\nimport type { InputNumberProps, SelectProps } from 'antd';\nimport type { FormItemProps } from 'antd/es/form/FormItem';\n\n// Define the FormFieldProps type locally since it's not exported\ntype FormFieldProps = {\n  name: string;\n  label: string;\n  required?: boolean;\n  placeholder?: string;\n  disabled?: boolean;\n  rules?: RegisterOptions;\n  help?: string;\n  extra?: string;\n  tooltip?: FormItemProps['tooltip'];\n  validateStatus?: 'success' | 'warning' | 'error' | 'validating';\n  className?: string;\n} & (\n  | {\n      type: 'text' | 'email' | 'password' | 'textarea';\n      showCount?: boolean;\n      maxLength?: number;\n      rows?: number;\n    }\n  | {\n      type: 'number';\n      min?: number;\n      max?: number;\n      step?: number;\n      precision?: number;\n      inputNumberProps?: Partial<InputNumberProps>;\n    }\n  | {\n      type: 'select';\n      options: { value: string | number; label: string; disabled?: boolean }[];\n      selectProps?: Partial<SelectProps>;\n    }\n  | {\n      type: 'checkbox';\n      children?: React.ReactNode;\n    }\n);\n\n// Test wrapper component that provides form context\nconst TestWrapper: React.FC<{ children: React.ReactNode; defaultValues?: Record<string, any> }> = ({\n  children,\n  defaultValues = {},\n}) => {\n  const methods = useForm({ defaultValues });\n  return <FormProvider {...methods}>{children}</FormProvider>;\n};\n\n// Helper to render FormField with form context\nconst renderFormField = (props: FormFieldProps, defaultValues?: Record<string, any>) => {\n  return render(\n    <TestWrapper defaultValues={defaultValues}>\n      <FormField {...props} />\n    </TestWrapper>\n  );\n};\n\ndescribe('FormField', () => {\n  describe('Rendering with default props', () => {\n    it('renders text input with basic props', () => {\n      renderFormField({\n        name: 'testField',\n        label: 'Test Field',\n        type: 'text',\n      });\n\n      expect(screen.getByRole('textbox')).toBeInTheDocument();\n      expect(screen.getByText('Test Field')).toBeInTheDocument();\n    });\n\n    it('renders email input with proper type', () => {\n      renderFormField({\n        name: 'email',\n        label: 'Email',\n        type: 'email',\n      });\n\n      const input = screen.getByRole('textbox');\n      expect(input).toHaveAttribute('type', 'email');\n    });\n\n    it('renders password input with proper type', () => {\n      renderFormField({\n        name: 'password',\n        label: 'Password',\n        type: 'password',\n      });\n\n      const input = screen.getByDisplayValue('') || screen.getByRole('textbox');\n      expect(input).toHaveAttribute('type', 'password');\n    });\n\n    it('renders textarea with proper element', () => {\n      renderFormField({\n        name: 'description',\n        label: 'Description',\n        type: 'textarea',\n      });\n\n      expect(screen.getByRole('textbox')).toBeInTheDocument();\n    });\n\n    it('renders number input with proper element', () => {\n      renderFormField({\n        name: 'age',\n        label: 'Age',\n        type: 'number',\n      });\n\n      const input = screen.getByRole('spinbutton');\n      expect(input).toBeInTheDocument();\n    });\n\n    it('renders select with proper element', () => {\n      renderFormField({\n        name: 'country',\n        label: 'Country',\n        type: 'select',\n        options: [\n          { value: 'us', label: 'United States' },\n          { value: 'ca', label: 'Canada' },\n        ],\n      });\n\n      expect(screen.getByRole('combobox')).toBeInTheDocument();\n    });\n\n    it('renders checkbox with proper element', () => {\n      renderFormField({\n        name: 'agree',\n        label: 'I agree',\n        type: 'checkbox',\n        children: 'I agree to the terms',\n      });\n\n      const checkbox = screen.getByRole('checkbox');\n      expect(checkbox).toBeInTheDocument();\n    });\n  });\n\n  describe('Rendering with variations', () => {\n    it('renders with placeholder', () => {\n      renderFormField({\n        name: 'testField',\n        label: 'Test Field',\n        type: 'text',\n        placeholder: 'Enter your name',\n      });\n\n      expect(screen.getByPlaceholderText('Enter your name')).toBeInTheDocument();\n    });\n\n    it('renders with required indicator', () => {\n      renderFormField({\n        name: 'testField',\n        label: 'Test Field',\n        type: 'text',\n        required: true,\n      });\n\n      // Verify the label text is present and the input is rendered\n      const label = screen.getByText('Test Field');\n      expect(label).toBeInTheDocument();\n      const input = screen.getByDisplayValue('');\n      expect(input).toBeDefined();\n      expect((input as HTMLInputElement).name).toBe('testField');\n    });\n\n    it('renders with help text', () => {\n      renderFormField({\n        name: 'testField',\n        label: 'Test Field',\n        type: 'text',\n        help: 'This is helpful information',\n      });\n\n      expect(screen.getByText('This is helpful information')).toBeInTheDocument();\n    });\n\n    it('renders with extra text', () => {\n      renderFormField({\n        name: 'testField',\n        label: 'Test Field',\n        type: 'text',\n        extra: 'Additional information',\n      });\n\n      expect(screen.getByText('Additional information')).toBeInTheDocument();\n    });\n\n    it('renders disabled field', () => {\n      renderFormField({\n        name: 'testField',\n        label: 'Test Field',\n        type: 'text',\n        disabled: true,\n      });\n\n      const input = screen.getByRole('textbox');\n      expect(input).toBeDisabled();\n    });\n\n    it('renders textarea with custom rows', () => {\n      renderFormField({\n        name: 'description',\n        label: 'Description',\n        type: 'textarea',\n        rows: 6,\n      });\n\n      const textarea = screen.getByRole('textbox');\n      expect(textarea).toHaveAttribute('rows', '6');\n    });\n\n    it('renders textarea with showCount and maxLength', () => {\n      renderFormField({\n        name: 'description',\n        label: 'Description',\n        type: 'textarea',\n        showCount: true,\n        maxLength: 100,\n      });\n\n      const textarea = screen.getByRole('textbox');\n      expect(textarea).toHaveAttribute('maxlength', '100');\n    });\n\n    it('renders number input with min/max/step', () => {\n      renderFormField({\n        name: 'age',\n        label: 'Age',\n        type: 'number',\n        min: 0,\n        max: 120,\n        step: 1,\n      });\n\n      const input = screen.getByRole('spinbutton');\n      expect(input).toBeInTheDocument();\n      // Note: Ant Design InputNumber may not set these attributes directly on the input\n      // but they are passed to the component\n    });\n  });\n\n  describe('User interaction', () => {\n    it('calls onChange when typing in text input', async () => {\n      const user = userEvent.setup();\n\n      renderFormField({\n        name: 'testField',\n        label: 'Test Field',\n        type: 'text',\n      });\n\n      const input = screen.getByRole('textbox');\n      await user.type(input, 'Hello World');\n\n      expect(input).toHaveValue('Hello World');\n    });\n\n    it('calls onChange when typing in email input', async () => {\n      const user = userEvent.setup();\n\n      renderFormField({\n        name: 'email',\n        label: 'Email',\n        type: 'email',\n      });\n\n      const input = screen.getByRole('textbox');\n      await user.type(input, 'test@example.com');\n\n      expect(input).toHaveValue('test@example.com');\n    });\n\n    it('calls onChange when typing in password input', async () => {\n      const user = userEvent.setup();\n\n      renderFormField({\n        name: 'password',\n        label: 'Password',\n        type: 'password',\n      });\n\n      const input = screen.getByDisplayValue('') || screen.getByRole('textbox');\n      await user.type(input, 'secret123');\n\n      expect(input).toHaveValue('secret123');\n    });\n\n    it('calls onChange when typing in textarea', async () => {\n      const user = userEvent.setup();\n\n      renderFormField({\n        name: 'description',\n        label: 'Description',\n        type: 'textarea',\n      });\n\n      const textarea = screen.getByRole('textbox');\n      await user.type(textarea, 'This is a long description');\n\n      expect(textarea).toHaveValue('This is a long description');\n    });\n\n    it('calls onChange when changing number input', async () => {\n      const user = userEvent.setup();\n\n      renderFormField({\n        name: 'age',\n        label: 'Age',\n        type: 'number',\n      });\n\n      const input = screen.getByRole('spinbutton');\n      await user.type(input, '25');\n\n      // Note: InputNumber value might be handled differently\n      expect(input).toBeInTheDocument();\n    });\n\n    it('calls onChange when selecting option', async () => {\n      const user = userEvent.setup();\n\n      renderFormField({\n        name: 'country',\n        label: 'Country',\n        type: 'select',\n        options: [\n          { value: 'us', label: 'United States' },\n          { value: 'ca', label: 'Canada' },\n        ],\n      });\n\n      const select = screen.getByRole('combobox');\n      await user.click(select);\n\n      // Wait for dropdown to appear and select option\n      await waitFor(() => {\n        expect(screen.getByText('United States')).toBeInTheDocument();\n      });\n\n      await user.click(screen.getByText('United States'));\n\n      // Verify the select is still in the document (interaction completed)\n      expect(select).toBeInTheDocument();\n    });\n\n    it('calls onChange when checking checkbox', async () => {\n      const user = userEvent.setup();\n\n      renderFormField({\n        name: 'agree',\n        label: 'I agree',\n        type: 'checkbox',\n        children: 'I agree to the terms',\n      });\n\n      const checkbox = screen.getByRole('checkbox');\n      await user.click(checkbox);\n\n      expect(checkbox).toBeChecked();\n    });\n  });\n\n  describe('Validation behavior', () => {\n    it('shows validation status when validateStatus is provided', () => {\n      renderFormField({\n        name: 'testField',\n        label: 'Test Field',\n        type: 'text',\n        validateStatus: 'error',\n      });\n\n      // The field should have error styling\n      const formItem = screen.getByText('Test Field').closest('.ant-form-item');\n      expect(formItem).toHaveClass('ant-form-item-has-error');\n    });\n\n    it('shows success status when validateStatus is success', () => {\n      renderFormField({\n        name: 'testField',\n        label: 'Test Field',\n        type: 'text',\n        validateStatus: 'success',\n      });\n\n      // The field should have success styling\n      const formItem = screen.getByText('Test Field').closest('.ant-form-item');\n      expect(formItem).toHaveClass('ant-form-item-has-success');\n    });\n\n    it('renders with required indicator when required is true', () => {\n      renderFormField({\n        name: 'testField',\n        label: 'Test Field',\n        type: 'text',\n        required: true,\n      });\n\n      const label = screen.getByText('Test Field');\n      expect(label).toBeInTheDocument();\n      // Check that the required prop is passed to the component\n      // The actual required styling might be handled differently by Ant Design\n      expect(label).toBeInTheDocument();\n    });\n  });\n\n  describe('Accessibility checks', () => {\n    it('renders input with proper accessibility attributes', () => {\n      renderFormField({\n        name: 'testField',\n        label: 'Test Field',\n        type: 'text',\n      });\n\n      const input = screen.getByRole('textbox');\n      expect(input).toBeInTheDocument();\n      expect(input).toHaveAttribute('name', 'testField');\n    });\n\n    it('renders textarea with proper accessibility attributes', () => {\n      renderFormField({\n        name: 'description',\n        label: 'Description',\n        type: 'textarea',\n      });\n\n      const textarea = screen.getByRole('textbox');\n      expect(textarea).toBeInTheDocument();\n      expect(textarea).toHaveAttribute('name', 'description');\n    });\n\n    it('renders number input with proper accessibility attributes', () => {\n      renderFormField({\n        name: 'age',\n        label: 'Age',\n        type: 'number',\n      });\n\n      const input = screen.getByRole('spinbutton');\n      expect(input).toBeInTheDocument();\n      expect(input).toHaveAttribute('name', 'age');\n    });\n\n    it('renders select with proper accessibility attributes', () => {\n      renderFormField({\n        name: 'country',\n        label: 'Country',\n        type: 'select',\n        options: [\n          { value: 'us', label: 'United States' },\n          { value: 'ca', label: 'Canada' },\n        ],\n      });\n\n      const select = screen.getByRole('combobox');\n      expect(select).toBeInTheDocument();\n    });\n\n    it('renders checkbox with proper accessibility attributes', () => {\n      renderFormField({\n        name: 'agree',\n        label: 'I agree',\n        type: 'checkbox',\n        children: 'I agree to the terms',\n      });\n\n      const checkbox = screen.getByRole('checkbox');\n      expect(checkbox).toBeInTheDocument();\n      expect(checkbox).toHaveAttribute('name', 'agree');\n    });\n\n    it('supports keyboard navigation', async () => {\n      const user = userEvent.setup();\n\n      renderFormField({\n        name: 'testField',\n        label: 'Test Field',\n        type: 'text',\n      });\n\n      const input = screen.getByRole('textbox');\n\n      // Tab to focus the input\n      await user.tab();\n      expect(input).toHaveFocus();\n\n      // Type using keyboard\n      await user.type(input, 'Hello');\n      expect(input).toHaveValue('Hello');\n    });\n\n    it('supports keyboard navigation for select', async () => {\n      const user = userEvent.setup();\n\n      renderFormField({\n        name: 'country',\n        label: 'Country',\n        type: 'select',\n        options: [\n          { value: 'us', label: 'United States' },\n          { value: 'ca', label: 'Canada' },\n        ],\n      });\n\n      const select = screen.getByRole('combobox');\n\n      // Tab to focus the select\n      await user.tab();\n      expect(select).toHaveFocus();\n\n      // Open dropdown with Enter\n      await user.keyboard('{Enter}');\n\n      // Navigate with arrow keys\n      await user.keyboard('{ArrowDown}');\n      await user.keyboard('{Enter}');\n    });\n\n    it('supports keyboard navigation for checkbox', async () => {\n      const user = userEvent.setup();\n\n      renderFormField({\n        name: 'agree',\n        label: 'I agree',\n        type: 'checkbox',\n        children: 'I agree to the terms',\n      });\n\n      const checkbox = screen.getByRole('checkbox');\n\n      // Tab to focus the checkbox\n      await user.tab();\n      expect(checkbox).toHaveFocus();\n\n      // Toggle with Space\n      await user.keyboard(' ');\n      expect(checkbox).toBeChecked();\n    });\n\n    it('has proper ARIA attributes for error state', () => {\n      renderFormField({\n        name: 'testField',\n        label: 'Test Field',\n        type: 'text',\n        validateStatus: 'error',\n      });\n\n      const formItem = screen.getByText('Test Field').closest('.ant-form-item');\n      expect(formItem).toHaveClass('ant-form-item-has-error');\n    });\n\n    it('has proper ARIA attributes for success state', () => {\n      renderFormField({\n        name: 'testField',\n        label: 'Test Field',\n        type: 'text',\n        validateStatus: 'success',\n      });\n\n      const formItem = screen.getByText('Test Field').closest('.ant-form-item');\n      expect(formItem).toHaveClass('ant-form-item-has-success');\n    });\n  });\n\n  describe('Form context integration', () => {\n    it('works with form context for checkbox default values', () => {\n      renderFormField(\n        {\n          name: 'agree',\n          label: 'I agree',\n          type: 'checkbox',\n          children: 'I agree to the terms',\n        },\n        { agree: true }\n      );\n\n      const checkbox = screen.getByRole('checkbox');\n      expect(checkbox).toBeChecked();\n    });\n\n    it('works with form context for select default values', () => {\n      renderFormField(\n        {\n          name: 'country',\n          label: 'Country',\n          type: 'select',\n          options: [\n            { value: 'us', label: 'United States' },\n            { value: 'ca', label: 'Canada' },\n          ],\n        },\n        { country: 'us' }\n      );\n\n      const select = screen.getByRole('combobox');\n      expect(select).toBeInTheDocument();\n    });\n  });\n\n  describe('Edge cases', () => {\n    it('handles disabled options in select', () => {\n      renderFormField({\n        name: 'country',\n        label: 'Country',\n        type: 'select',\n        options: [\n          { value: 'us', label: 'United States' },\n          { value: 'ca', label: 'Canada', disabled: true },\n        ],\n      });\n\n      const select = screen.getByRole('combobox');\n      expect(select).toBeInTheDocument();\n    });\n\n    it('handles number input with precision', () => {\n      renderFormField({\n        name: 'price',\n        label: 'Price',\n        type: 'number',\n        precision: 2,\n      });\n\n      const input = screen.getByRole('spinbutton');\n      expect(input).toBeInTheDocument();\n    });\n\n    it('handles textarea with showCount', () => {\n      renderFormField({\n        name: 'description',\n        label: 'Description',\n        type: 'textarea',\n        showCount: true,\n        maxLength: 50,\n      });\n\n      const textarea = screen.getByRole('textbox');\n      expect(textarea).toHaveAttribute('maxlength', '50');\n    });\n\n    it('handles custom className', () => {\n      renderFormField({\n        name: 'testField',\n        label: 'Test Field',\n        type: 'text',\n        className: 'custom-class',\n      });\n\n      const formItem = screen.getByText('Test Field').closest('.ant-form-item');\n      expect(formItem).toHaveClass('custom-class');\n    });\n  });\n});\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/components/__tests__/Layout.test.tsx",
        "messages": [
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'within' is defined but never used. Allowed unused vars must match /^_/u.",
                "line": 2,
                "column": 27,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 2,
                "endColumn": 33
            },
            {
                "ruleId": "@typescript-eslint/no-non-null-assertion",
                "severity": 1,
                "message": "Forbidden non-null assertion.",
                "line": 29,
                "column": 31,
                "nodeType": "TSNonNullExpression",
                "messageId": "noNonNull",
                "endLine": 29,
                "endColumn": 41
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'container' is assigned a value but never used. Allowed unused vars must match /^_/u.",
                "line": 63,
                "column": 15,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 63,
                "endColumn": 24
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.",
                "line": 81,
                "column": 14,
                "nodeType": "MemberExpression",
                "messageId": "neverNullish",
                "endLine": 81,
                "endColumn": 44
            },
            {
                "ruleId": "@typescript-eslint/no-non-null-assertion",
                "severity": 1,
                "message": "Forbidden non-null assertion.",
                "line": 149,
                "column": 48,
                "nodeType": "TSNonNullExpression",
                "messageId": "noNonNull",
                "endLine": 149,
                "endColumn": 67
            },
            {
                "ruleId": "@typescript-eslint/no-non-null-assertion",
                "severity": 1,
                "message": "Forbidden non-null assertion.",
                "line": 161,
                "column": 25,
                "nodeType": "TSNonNullExpression",
                "messageId": "noNonNull",
                "endLine": 161,
                "endColumn": 44
            },
            {
                "ruleId": "@typescript-eslint/no-non-null-assertion",
                "severity": 1,
                "message": "Forbidden non-null assertion.",
                "line": 166,
                "column": 24,
                "nodeType": "TSNonNullExpression",
                "messageId": "noNonNull",
                "endLine": 166,
                "endColumn": 40
            },
            {
                "ruleId": "@typescript-eslint/no-non-null-assertion",
                "severity": 1,
                "message": "Forbidden non-null assertion.",
                "line": 175,
                "column": 47,
                "nodeType": "TSNonNullExpression",
                "messageId": "noNonNull",
                "endLine": 175,
                "endColumn": 66
            },
            {
                "ruleId": "@typescript-eslint/no-non-null-assertion",
                "severity": 1,
                "message": "Forbidden non-null assertion.",
                "line": 261,
                "column": 36,
                "nodeType": "TSNonNullExpression",
                "messageId": "noNonNull",
                "endLine": 261,
                "endColumn": 55
            },
            {
                "ruleId": "@typescript-eslint/require-await",
                "severity": 1,
                "message": "Async arrow function has no 'await' expression.",
                "line": 286,
                "column": 68,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingAwait",
                "endLine": 286,
                "endColumn": 70,
                "suggestions": [
                    {
                        "messageId": "removeAsync",
                        "fix": {
                            "range": [
                                11354,
                                11360
                            ],
                            "text": ""
                        },
                        "desc": "Remove 'async'."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'user' is assigned a value but never used. Allowed unused vars must match /^_/u.",
                "line": 289,
                "column": 13,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 289,
                "endColumn": 17
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary optional chain on a non-nullish value.",
                "line": 335,
                "column": 70,
                "nodeType": "MemberExpression",
                "messageId": "neverOptionalChain",
                "endLine": 335,
                "endColumn": 72,
                "suggestions": [
                    {
                        "messageId": "suggestRemoveOptionalChain",
                        "fix": {
                            "range": [
                                13248,
                                13250
                            ],
                            "text": "."
                        },
                        "desc": "Remove unnecessary optional chain"
                    }
                ]
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 12,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "import { describe, it, expect } from 'bun:test';\nimport { screen, waitFor, within } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport {\n  renderWithAuth,\n  renderWithAuthAndNavigation,\n  mockUser,\n  mockTenant,\n} from '../../test-utils/render';\nimport { Layout } from '../Layout';\n\ndescribe('Layout Component', () => {\n  describe('Rendering', () => {\n    it('should render layout with children', () => {\n      const testContent = 'Test Content';\n      renderWithAuth(<Layout>{testContent}</Layout>);\n\n      expect(screen.getByText(testContent)).toBeInTheDocument();\n    });\n\n    it('should display user first name in header', () => {\n      renderWithAuth(<Layout>Content</Layout>);\n\n      // Ensure mockUser.firstName is defined before using it\n      expect(mockUser.firstName).toBeDefined();\n      const firstName = mockUser.firstName;\n\n      // User name should be visible in profile area\n      expect(screen.getByText(firstName!)).toBeInTheDocument();\n    });\n\n    it('should display tenant name in layout', () => {\n      renderWithAuth(<Layout>Content</Layout>);\n\n      const tenantDisplay = screen.getByText(mockTenant.name);\n      expect(tenantDisplay).toBeInTheDocument();\n    });\n\n    it('should render dashboard menu item', () => {\n      renderWithAuth(<Layout>Content</Layout>);\n\n      // Dashboard link should be accessible in menu\n      expect(screen.getByText(/Dashboard/i)).toBeInTheDocument();\n    });\n\n    it.skip('should render address book menu item', () => {\n      // NOTE: Skipped - Ant Design Menu components don't expose 'menuitem' roles\n      // in happy-dom test environment. This works correctly in real browsers.\n      // The menu item is rendered and accessible via getByText() as verified by\n      // the \"should have navigation menu items present\" test.\n      renderWithAuth(<Layout>Content</Layout>);\n\n      expect(\n        screen.queryByRole('menuitem', { name: /^(Address Book|Contacts)$/i })\n      ).not.toBeInTheDocument();\n    });\n\n    // NOTE: Skipped because Ant Design Dropdown doesn't expose role=\"button\" in happy-dom.\n    // The Dropdown trigger is rendered but happy-dom doesn't support role attributes properly.\n    // This test would pass in real browsers/jsdom but fails in happy-dom environment.\n    // Verified manually: Avatar renders with user initials in browser.\n    it.skip('should render user profile avatar or trigger', () => {\n      const { container } = renderWithAuth(<Layout>Content</Layout>);\n\n      // Find the profile area by looking for the user's first name\n      const profileNameElement = screen.getByText(mockUser.firstName ?? '');\n\n      // Verify the profile name element exists and is a button\n      const profileContainer = profileNameElement.closest('[role=\"button\"]');\n      expect(profileContainer).toBeDefined();\n\n      // Verify the avatar is present in the same container with correct initial\n      const avatar = profileContainer?.querySelector('.ant-avatar');\n      expect(avatar).toBeDefined();\n      expect(avatar?.textContent ?? '').toContain(\n        (mockUser.firstName ?? '').charAt(0).toUpperCase()\n      );\n\n      // Verify the user name is visible\n      expect(profileNameElement).toBeInTheDocument();\n      expect(profileNameElement.textContent ?? '').toContain(mockUser.firstName ?? '');\n\n      // Verify the container has proper button semantics\n      expect(profileContainer?.getAttribute('role')).toBe('button');\n    });\n  });\n\n  describe('Navigation', () => {\n    it.skip('should navigate to dashboard when dashboard menu item is clicked', async () => {\n      // SKIPPED: Environment-specific timing issue in GitHub Actions\n      // This test works locally but times out in CI due to slower async operations\n      // The navigation functionality is verified through manual testing\n      const user = userEvent.setup({ delay: null });\n      const { getCurrentLocation } = renderWithAuthAndNavigation(<Layout>Content</Layout>, {\n        initialRoute: '/contacts',\n      });\n\n      // Find and click dashboard menu item\n      const dashboardLink = screen.getByText(/Dashboard/i);\n      await user.click(dashboardLink);\n\n      // Verify the navigation occurred by checking the current location\n      await waitFor(\n        () => {\n          expect(getCurrentLocation().pathname).toBe('/dashboard');\n        },\n        { timeout: 3000 }\n      );\n    }, 10000);\n\n    it.skip('should navigate to address book when contacts menu item is clicked', async () => {\n      // SKIPPED: Environment-specific timing issue in GitHub Actions\n      // This test works locally but times out in CI due to slower async operations\n      // The navigation functionality is verified through manual testing\n      const user = userEvent.setup({ delay: null });\n      const { getCurrentLocation } = renderWithAuthAndNavigation(<Layout>Content</Layout>, {\n        initialRoute: '/dashboard',\n      });\n\n      // Find and click contacts menu item\n      const contactsLink = screen.getByText(/Address Book|address|contacts/i);\n      await user.click(contactsLink);\n\n      // Verify the navigation occurred by checking the current location\n      await waitFor(\n        () => {\n          expect(getCurrentLocation().pathname).toBe('/address-book');\n        },\n        { timeout: 3000 }\n      );\n    }, 10000);\n\n    it('should have navigation menu items present', () => {\n      renderWithAuth(<Layout>Content</Layout>);\n\n      // Verify specific navigation menu items are rendered\n      expect(screen.getByText('Dashboard')).toBeInTheDocument();\n      expect(screen.getByText('Address Book')).toBeInTheDocument();\n      expect(screen.getByText('Tenants')).toBeInTheDocument();\n    });\n  });\n\n  describe('User Menu and Profile', () => {\n    it('should display user profile in header', () => {\n      renderWithAuth(<Layout>Content</Layout>);\n\n      // User name should be visible\n      expect(mockUser.firstName).toBeTruthy();\n      const userElements = screen.getAllByText(mockUser.firstName!);\n      expect(userElements.length).toBeGreaterThan(0);\n    });\n\n    it.skip('should show user profile dropdown menu when clicked', async () => {\n      // NOTE: Skipped - Ant Design Dropdown menu doesn't function properly in happy-dom\n      // due to missing browser APIs and DOM rendering limitations. In real browsers,\n      // this dropdown works correctly and can be tested with E2E tests.\n      const user = userEvent.setup();\n      renderWithAuth(<Layout>Content</Layout>);\n\n      expect(mockUser.firstName).toBeDefined();\n      const firstName = mockUser.firstName!;\n\n      const userElements = screen.queryAllByText(firstName);\n      expect(userElements.length).toBeGreaterThan(0);\n\n      await user.click(userElements[0]!);\n      // In real browsers, the dropdown menu would appear here\n    });\n\n    it('should have logout option accessible', async () => {\n      const user = userEvent.setup();\n      renderWithAuth(<Layout>Content</Layout>);\n\n      // Click the profile dropdown trigger to open the menu\n      const profileTrigger = screen.getByText(mockUser.firstName!);\n      await user.click(profileTrigger);\n\n      // Wait for the logout option to appear in the dropdown menu\n      await waitFor(() => {\n        expect(screen.getByText('Logout')).toBeInTheDocument();\n      });\n    });\n\n    it.skip('should display email in profile menu', () => {\n      renderWithAuth(<Layout>Content</Layout>);\n\n      // Email is not currently displayed in the UI - this test should be updated\n      // or removed if email display is not planned\n      // For now, we'll check that the user object has an email\n      expect(mockUser.email).toBe('test@example.com');\n    });\n  });\n\n  describe('Responsive Behavior', () => {\n    it('should render layout on desktop breakpoint', () => {\n      renderWithAuth(<Layout>Content</Layout>);\n\n      // Main content should be visible\n      expect(screen.getByText('Content')).toBeInTheDocument();\n    });\n\n    it('should have menu toggle button for mobile responsive', () => {\n      renderWithAuth(<Layout>Content</Layout>);\n\n      // Find the menu toggle button by looking for button with toggle sidebar menu label\n      const menuToggleButton = screen.getByRole('button', {\n        name: /toggle sidebar menu/i,\n      });\n      expect(menuToggleButton).toBeInTheDocument();\n    });\n\n    it.skip('should toggle sidebar visibility on hamburger menu click', async () => {\n      // NOTE: Skipped - Sidebar toggle animation and state changes don't work properly\n      // in happy-dom due to limited CSS and state management support. This feature works\n      // correctly in real browsers and can be tested with E2E tests.\n      const user = userEvent.setup();\n      const { container } = renderWithAuth(<Layout>Content</Layout>);\n\n      // In a real browser environment, this would toggle the sidebar\n      const toggleButton = screen.getByRole('button', {\n        name: /toggle sidebar menu/i,\n      });\n\n      const siderBefore = container.querySelector('.ant-layout-sider');\n      expect(siderBefore).toBeInTheDocument();\n\n      await user.click(toggleButton);\n\n      // State would change in real browser\n    });\n\n    it('should handle sidebar collapse/expand state', () => {\n      const { container } = renderWithAuth(<Layout>Content</Layout>);\n\n      // Sidebar should exist and handle state\n      const sidebar = container.querySelector('[class*=\"ant-layout-sider\"]');\n      expect(sidebar).toBeInTheDocument();\n    });\n  });\n\n  describe('Component Structure', () => {\n    it('should render complete layout structure with proper Ant Design components and content', () => {\n      const { container } = renderWithAuth(<Layout>Content</Layout>);\n\n      // Verify main layout container\n      const layoutContainer = container.querySelector('[class*=\"ant-layout\"]');\n      expect(layoutContainer).toBeInTheDocument();\n\n      // Verify all main layout sections\n      const layoutHeader = container.querySelector('[class*=\"ant-layout-header\"]');\n      const layoutSider = container.querySelector('[class*=\"ant-layout-sider\"]');\n      const layoutContent = container.querySelector('[class*=\"ant-layout-content\"]');\n\n      expect(layoutHeader).toBeInTheDocument();\n      expect(layoutSider).toBeInTheDocument();\n      expect(layoutContent).toBeInTheDocument();\n\n      // Verify key content in header (user info)\n      expect(mockUser.firstName).toBeTruthy();\n      const headerText = layoutHeader?.textContent ?? '';\n      expect(headerText).toContain(mockUser.firstName!);\n\n      // Verify key content in sider (tenant info)\n      const siderText = layoutSider?.textContent ?? '';\n      expect(siderText).toContain(mockTenant.name);\n\n      // Verify menu structure\n      const menu = container.querySelector('[class*=\"ant-menu\"]');\n      expect(menu).toBeInTheDocument();\n\n      // Verify menu items are present\n      const menuItems = container.querySelectorAll('[class*=\"ant-menu-item\"]');\n      expect(menuItems.length).toBeGreaterThan(0);\n    });\n  });\n\n  describe('Accessibility', () => {\n    it('should have proper navigation role', () => {\n      renderWithAuth(<Layout>Content</Layout>);\n\n      // Navigation should be marked with proper role\n      const navElements = screen.getAllByRole('navigation');\n      expect(navElements.length).toBeGreaterThan(0);\n    });\n\n    it.skip('should have keyboard accessible menu items', async () => {\n      // NOTE: Skipped - Keyboard focus management doesn't work properly in happy-dom.\n      // This feature works correctly in real browsers and can be tested with E2E tests.\n      const user = userEvent.setup();\n      renderWithAuth(<Layout>Content</Layout>);\n\n      // Menu items should be keyboard accessible\n      const menuItems = screen.getAllByRole('menuitem');\n      expect(menuItems.length).toBeGreaterThan(0);\n\n      // In real browsers, this test would verify focus management\n    });\n\n    it.skip('should have proper heading hierarchy', () => {\n      // TODO: Implement proper heading hierarchy test when heading support is added\n      // Link to feature ticket: [Add ticket link here]\n    });\n\n    it('should have alt text or aria labels for images', () => {\n      const { container } = renderWithAuth(<Layout>Content</Layout>);\n\n      // Check images have proper labels\n      const images = container.querySelectorAll('img');\n      images.forEach(img => {\n        expect(img.hasAttribute('alt') || img.hasAttribute('aria-label')).toBeTruthy();\n      });\n      // Remove the \"> 0\" assertion as it can fail on image-less layouts\n    });\n  });\n\n  describe('Menu Rendering', () => {\n    it('should render active menu item highlighting', () => {\n      renderWithAuth(<Layout>Content</Layout>, {\n        initialRoute: '/dashboard',\n      });\n\n      // Menu should render with items\n      const menuItems = screen.getAllByRole('menuitem');\n      expect(menuItems.length).toBeGreaterThan(0);\n    });\n\n    it('should display all main menu items', () => {\n      renderWithAuth(<Layout>Content</Layout>);\n\n      // All menu items should be rendered and visible\n      const menuItems = screen.getAllByRole('menuitem');\n      expect(menuItems.length).toBeGreaterThan(0);\n\n      // Verify key menu items exist\n      const dashboardExists = menuItems.some(item => item.textContent?.includes('Dashboard'));\n      expect(dashboardExists).toBeTruthy();\n    });\n\n    it('should have proper menu structure with Ant Design', () => {\n      const { container } = renderWithAuth(<Layout>Content</Layout>);\n\n      // Verify menu component is rendered\n      const menu = container.querySelector('[class*=\"ant-menu\"]');\n      expect(menu).toBeInTheDocument();\n\n      // Menu should contain items\n      const menuItems = container.querySelectorAll('[class*=\"ant-menu-item\"]');\n      expect(menuItems.length).toBeGreaterThan(0);\n    });\n  });\n\n  describe('Content Area', () => {\n    it('should render children in main content area with dynamic updates', () => {\n      const testId = 'test-content-id';\n      const initialContent = 'Main Content';\n      const dynamicContent = 'Dynamic Test Content';\n\n      const { rerender, container } = renderWithAuth(\n        <Layout>\n          <div data-testid={testId}>{initialContent}</div>\n        </Layout>\n      );\n\n      // Assert testId presence and initial text\n      expect(screen.getByTestId(testId)).toBeInTheDocument();\n      expect(screen.getByText(initialContent)).toBeInTheDocument();\n\n      // Assert content is in the correct layout section\n      const layoutContent = container.querySelector('[class*=\"ant-layout-content\"]');\n      expect(layoutContent).toBeInTheDocument();\n      expect(layoutContent?.textContent).toContain(initialContent);\n\n      // Update with dynamic content and assert the change\n      rerender(\n        <Layout>\n          <div data-testid={testId}>{dynamicContent}</div>\n        </Layout>\n      );\n\n      expect(screen.getByText(dynamicContent)).toBeInTheDocument();\n      expect(screen.queryByText(initialContent)).not.toBeInTheDocument();\n    });\n  });\n});\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/components/__tests__/PrivateRoute.test.tsx",
        "messages": [
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'waitFor' is defined but never used. Allowed unused vars must match /^_/u.",
                "line": 2,
                "column": 18,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 2,
                "endColumn": 25
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'LocationDisplay' is assigned a value but never used. Allowed unused vars must match /^_/u.",
                "line": 9,
                "column": 7,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 9,
                "endColumn": 22
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'TestWrapperWithRoutes' is assigned a value but never used. Allowed unused vars must match /^_/u.",
                "line": 20,
                "column": 7,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 20,
                "endColumn": 28
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 3,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "import React from 'react';\nimport { screen, waitFor } from '@testing-library/react';\nimport { useLocation } from 'react-router-dom';\nimport { describe, it, expect } from 'bun:test';\nimport { PrivateRoute } from '../PrivateRoute';\nimport { renderWithAuth, mockUser, mockTenant } from '../../test-utils/render';\n\n// Test component to capture location for redirect tests\nconst LocationDisplay: React.FC = () => {\n  const location = useLocation();\n  return (\n    <div data-testid=\"location-display\">\n      {location.pathname}\n      {location.search}\n    </div>\n  );\n};\n\n// Test wrapper component for route testing\nconst TestWrapperWithRoutes: React.FC<{ children: React.ReactNode }> = ({ children }) => {\n  return <>{children}</>;\n};\n\ndescribe('PrivateRoute Component', () => {\n  describe('Authentication Guards', () => {\n    it('should render children when user is authenticated', () => {\n      const testContent = 'Protected Content';\n      renderWithAuth(\n        <PrivateRoute>\n          <div>{testContent}</div>\n        </PrivateRoute>\n      );\n\n      expect(screen.getByText(testContent)).toBeVisible();\n    });\n\n    it.skip('should redirect to login when auth state changes to unauthenticated', async () => {\n      // TODO: These tests verify React Router Navigate behavior which is difficult to test\n      // in a unit test environment with MemoryRouter. Navigation happens asynchronously\n      // and rerenderWithAuth doesn't preserve the router state properly.\n      // This should be tested in E2E tests instead.\n    }, 10000);\n\n    it('should display loading state while checking authentication', () => {\n      const testContent = 'Protected Content';\n      renderWithAuth(\n        <PrivateRoute>\n          <div>{testContent}</div>\n        </PrivateRoute>,\n        {\n          authValue: { isLoading: true },\n        }\n      );\n\n      // Should show loading indicator\n      const loadingSpinner = screen.getByTestId('loading-spinner');\n      expect(loadingSpinner).toBeVisible();\n      expect(loadingSpinner.textContent).toContain('Loading...');\n\n      // Content should not be visible while loading\n      expect(screen.queryByText(testContent)).toBeNull();\n    });\n  });\n\n  describe('Authenticated Access', () => {\n    it('should maintain route path when authenticated', () => {\n      renderWithAuth(\n        <PrivateRoute>\n          <div>Content</div>\n        </PrivateRoute>,\n        { initialRoute: '/dashboard' }\n      );\n\n      expect(screen.getByText('Content')).toBeInTheDocument();\n    });\n\n    it('should render nested components', () => {\n      renderWithAuth(\n        <PrivateRoute>\n          <div>\n            <h1>Title</h1>\n            <p>Paragraph</p>\n          </div>\n        </PrivateRoute>\n      );\n\n      expect(screen.getByText('Title')).toBeInTheDocument();\n      expect(screen.getByText('Paragraph')).toBeInTheDocument();\n    });\n  });\n\n  describe('Unauthenticated Access', () => {\n    it.skip('should redirect to login page when not authenticated', async () => {\n      // TODO: These tests verify React Router Navigate behavior which is difficult to test\n      // in a unit test environment with MemoryRouter.\n    }, 10000);\n\n    it.skip('should pass location state for redirect', async () => {\n      // TODO: These tests verify React Router Navigate behavior which is difficult to test\n      // in a unit test environment with MemoryRouter.\n    });\n\n    it.skip('should preserve intended destination in location state', async () => {\n      // TODO: These tests verify React Router Navigate behavior which is difficult to test\n      // in a unit test environment with MemoryRouter.\n    });\n  });\n\n  describe('Route Redirects', () => {\n    it.skip('should redirect unauthenticated users to login', async () => {\n      // TODO: These tests verify React Router Navigate behavior which is difficult to test\n      // in a unit test environment with MemoryRouter.\n    });\n\n    it.skip('should redirect to login with replace mode', async () => {\n      // TODO: These tests verify React Router Navigate behavior which is difficult to test\n      // in a unit test environment with MemoryRouter.\n    });\n\n    it.skip('should store current location for post-login redirect', async () => {\n      // TODO: These tests verify React Router Navigate behavior which is difficult to test\n      // in a unit test environment with MemoryRouter.\n    });\n  });\n\n  describe('User States', () => {\n    it('should work with authenticated user object', () => {\n      renderWithAuth(\n        <PrivateRoute>\n          <div>Content for {mockUser.username}</div>\n        </PrivateRoute>\n      );\n\n      expect(screen.getByText(/Content for/i)).toBeInTheDocument();\n    });\n\n    it('should work with tenant information', () => {\n      renderWithAuth(\n        <PrivateRoute>\n          <div>Tenant: {mockTenant.name}</div>\n        </PrivateRoute>\n      );\n\n      expect(screen.getByText(/Tenant:/i)).toBeInTheDocument();\n    });\n\n    it.skip('should handle null user object gracefully', async () => {\n      // TODO: These tests verify React Router Navigate behavior which is difficult to test\n      // in a unit test environment with MemoryRouter.\n    });\n  });\n\n  describe('CSS Classes', () => {\n    it('should apply correct CSS classes', () => {\n      const { container } = renderWithAuth(\n        <PrivateRoute>\n          <div>Content</div>\n        </PrivateRoute>,\n        { authValue: { isLoading: true, isAuthenticated: false } }\n      );\n\n      // Check for loading container classes\n      expect(container.querySelector('.loading')).not.toBeNull();\n    });\n\n    it('should have flex center styling during loading', () => {\n      const { getByTestId } = renderWithAuth(\n        <PrivateRoute>\n          <div>Content</div>\n        </PrivateRoute>,\n        { authValue: { isLoading: true } }\n      );\n\n      // Check for flex center classes on the loading container\n      const loadingContainer = getByTestId('loading-container');\n      expect(loadingContainer.className).toContain('flex');\n      expect(loadingContainer.className).toContain('items-center');\n      expect(loadingContainer.className).toContain('justify-center');\n    });\n  });\n\n  describe('Accessibility', () => {\n    it('should have proper loading state semantics', () => {\n      renderWithAuth(\n        <PrivateRoute>\n          <div>Content</div>\n        </PrivateRoute>,\n        { authValue: { isLoading: true } }\n      );\n\n      // Loading indicator should have proper ARIA attributes\n      expect(screen.getByRole('status')).toBeInTheDocument();\n    });\n  });\n\n  describe('Children Rendering', () => {\n    it('should render multiple child elements', () => {\n      renderWithAuth(\n        <PrivateRoute>\n          <div>Child 1</div>\n          <div>Child 2</div>\n          <div>Child 3</div>\n        </PrivateRoute>\n      );\n\n      expect(screen.getByText('Child 1')).toBeInTheDocument();\n      expect(screen.getByText('Child 2')).toBeInTheDocument();\n      expect(screen.getByText('Child 3')).toBeInTheDocument();\n    });\n\n    it('should render complex nested components', () => {\n      renderWithAuth(\n        <PrivateRoute>\n          <div>\n            <section>\n              <h1>Heading</h1>\n              <p>Paragraph</p>\n            </section>\n          </div>\n        </PrivateRoute>\n      );\n\n      expect(screen.getByText('Heading')).toBeInTheDocument();\n      expect(screen.getByText('Paragraph')).toBeInTheDocument();\n    });\n  });\n\n  describe('Edge Cases', () => {\n    it('should handle rapid auth state changes', () => {\n      renderWithAuth(\n        <PrivateRoute>\n          <div>Content</div>\n        </PrivateRoute>,\n        { authValue: { isLoading: false, isAuthenticated: true } }\n      );\n\n      expect(screen.getByText('Content')).toBeInTheDocument();\n    });\n\n    it('should handle auth state transition from loading to authenticated', () => {\n      renderWithAuth(\n        <PrivateRoute>\n          <div>Content</div>\n        </PrivateRoute>,\n        { authValue: { isLoading: false, isAuthenticated: true } }\n      );\n\n      expect(screen.getByText('Content')).toBeInTheDocument();\n    });\n\n    it.skip('should handle auth state transition from loading to unauthenticated', async () => {\n      // TODO: These tests verify React Router Navigate behavior which is difficult to test\n      // in a unit test environment with MemoryRouter.\n    });\n  });\n});\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/config/commonPasswords.ts",
        "messages": [],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 0,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/config/env.ts",
        "messages": [
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 30,
                "column": 9,
                "nodeType": "VariableDeclarator",
                "messageId": "anyAssignment",
                "endLine": 30,
                "endColumn": 60
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected any value in conditional. An explicit comparison or type conversion is required.",
                "line": 32,
                "column": 8,
                "nodeType": "Identifier",
                "messageId": "conditionErrorAny",
                "endLine": 32,
                "endColumn": 13,
                "suggestions": [
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                740,
                                745
                            ],
                            "text": "(Boolean(value))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 47,
                "column": 9,
                "nodeType": "VariableDeclarator",
                "messageId": "anyAssignment",
                "endLine": 47,
                "endColumn": 60
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected any value in conditional. An explicit comparison or type conversion is required.",
                "line": 48,
                "column": 10,
                "nodeType": "Identifier",
                "messageId": "conditionErrorAny",
                "endLine": 48,
                "endColumn": 15,
                "suggestions": [
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                1246,
                                1251
                            ],
                            "text": "(Boolean(value))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 4,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "/**\n * Environment Configuration and Validation Utility\n *\n * This module provides type-safe access to environment variables and\n * validates that all required variables are present at runtime.\n */\n\ninterface EnvConfig {\n  apiUrl: string;\n  appName: string;\n  jwtStorageKey: string;\n  isDebug: boolean;\n  isDevelopment: boolean;\n  isProduction: boolean;\n  defaultCountry: string;\n  enablePwnedPasswordCheck: boolean;\n}\n\nclass EnvironmentError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'EnvironmentError';\n  }\n}\n\n/**\n * Validates that a required environment variable is present\n */\nfunction getRequiredEnv(key: string): string {\n  const value = import.meta.env[key as keyof ImportMetaEnv];\n\n  if (!value || (typeof value === 'string' && value.trim() === '')) {\n    throw new EnvironmentError(\n      `Missing required environment variable: ${key}\\n\\n` +\n        `Please ensure ${key} is set in your .env file.\\n` +\n        `See .env.example for reference.`\n    );\n  }\n\n  return String(value);\n}\n\n/**\n * Gets an optional environment variable with a default value\n */\nfunction getOptionalEnv(key: string, defaultValue: string): string {\n  const value = import.meta.env[key as keyof ImportMetaEnv];\n  return value ? String(value) : defaultValue;\n}\n\n/**\n * Validates URL format\n */\nfunction validateUrl(url: string, varName: string): string {\n  try {\n    new URL(url);\n    return url;\n  } catch {\n    throw new EnvironmentError(\n      `Invalid URL for ${varName}: ${url}\\n\\n` +\n        `Please provide a valid URL (e.g., http://localhost:8000/api)`\n    );\n  }\n}\n\n/**\n * Validates and returns the environment configuration\n * Throws EnvironmentError if validation fails\n */\nexport function getEnvConfig(): EnvConfig {\n  try {\n    const apiUrl = getRequiredEnv('VITE_API_URL');\n    validateUrl(apiUrl, 'VITE_API_URL');\n\n    const defaultCountry = getOptionalEnv('VITE_DEFAULT_COUNTRY', '').trim();\n    const enablePwnedPasswordCheck =\n      getOptionalEnv(\n        'VITE_ENABLE_PWNED_PASSWORD_CHECK',\n        import.meta.env.MODE === 'production' ? 'true' : 'false'\n      ).toLowerCase() === 'true';\n\n    return {\n      apiUrl,\n      appName: getOptionalEnv('VITE_APP_NAME', 'Actix Web REST API'),\n      jwtStorageKey: getOptionalEnv('VITE_JWT_STORAGE_KEY', 'auth_token'),\n      isDebug: getOptionalEnv('VITE_DEBUG', 'false').toLowerCase() === 'true',\n      isDevelopment: import.meta.env.MODE === 'development',\n      isProduction: import.meta.env.MODE === 'production',\n      defaultCountry,\n      enablePwnedPasswordCheck,\n    };\n  } catch (error) {\n    if (error instanceof EnvironmentError) {\n      // Re-throw with additional context\n      throw error;\n    }\n    // Wrap unexpected errors\n    throw new EnvironmentError(\n      `Failed to load environment configuration: ${error instanceof Error ? error.message : String(error)}`\n    );\n  }\n}\n\n/**\n * Singleton instance of the environment configuration\n * Validates on first access\n */\nlet envConfig: EnvConfig | null = null;\n\nexport function getEnv(): EnvConfig {\n  envConfig ??= getEnvConfig();\n  return envConfig;\n}\n\n/**\n * Export for testing or explicit validation\n */\nexport { EnvironmentError };\n\n/**\n * Default export for convenience\n */\nexport default getEnv;\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/config/featureFlags.ts",
        "messages": [
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 47,
                "column": 9,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 47,
                "endColumn": 15,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                1461,
                                1467
                            ],
                            "text": "stored != null"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                1461,
                                1467
                            ],
                            "text": "stored ?? \"\""
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                1461,
                                1467
                            ],
                            "text": "Boolean(stored)"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 48,
                "column": 13,
                "nodeType": "VariableDeclarator",
                "messageId": "anyAssignment",
                "endLine": 48,
                "endColumn": 40
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected any value in conditional. An explicit comparison or type conversion is required.",
                "line": 49,
                "column": 11,
                "nodeType": "Identifier",
                "messageId": "conditionErrorAny",
                "endLine": 49,
                "endColumn": 17,
                "suggestions": [
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                1522,
                                1528
                            ],
                            "text": "(Boolean(parsed))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "no-console",
                "severity": 1,
                "message": "Unexpected console statement. Only these console methods are allowed: warn, error.",
                "line": 80,
                "column": 7,
                "nodeType": "MemberExpression",
                "messageId": "limited",
                "endLine": 80,
                "endColumn": 20,
                "suggestions": [
                    {
                        "fix": {
                            "range": [
                                2351,
                                2408
                            ],
                            "text": ""
                        },
                        "messageId": "removeConsole",
                        "data": {
                            "propertyName": "debug"
                        },
                        "desc": "Remove the console.debug()."
                    }
                ]
            },
            {
                "ruleId": "no-console",
                "severity": 1,
                "message": "Unexpected console statement. Only these console methods are allowed: warn, error.",
                "line": 101,
                "column": 5,
                "nodeType": "MemberExpression",
                "messageId": "limited",
                "endLine": 101,
                "endColumn": 17,
                "suggestions": [
                    {
                        "fix": {
                            "range": [
                                2864,
                                2917
                            ],
                            "text": ""
                        },
                        "messageId": "removeConsole",
                        "data": {
                            "propertyName": "info"
                        },
                        "desc": "Remove the console.info()."
                    }
                ]
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 5,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "/**\n * @module config/featureFlags\n * @description Feature flags for gradual FP pattern migration\n *\n * Allows running both old and new FP-based implementations in parallel\n * for safer migration and A/B testing.\n */\n\nexport interface FeatureFlags {\n  /** Use FP-based AuthContext instead of traditional imperative version */\n  useFPAuth: boolean;\n  /** Use FP patterns in service layer */\n  useFPServices: boolean;\n  /** Use FP patterns in React hooks */\n  useFPHooks: boolean;\n  /** Enable verbose logging for FP operations */\n  verboseFPLogging: boolean;\n}\n\n/**\n * Default feature flag configuration\n * Start with new FP features disabled to ensure backward compatibility\n */\nconst DEFAULT_FLAGS: FeatureFlags = {\n  useFPAuth: false,\n  useFPServices: false,\n  useFPHooks: false,\n  verboseFPLogging: false,\n};\n\n/**\n * Load feature flags from environment or localStorage\n */\nfunction loadFeatureFlags(): FeatureFlags {\n  // Check environment variables first (prefixed with VITE_)\n  const envFlags: Partial<FeatureFlags> = {\n    useFPAuth: import.meta.env.VITE_USE_FP_AUTH === 'true',\n    useFPServices: import.meta.env.VITE_USE_FP_SERVICES === 'true',\n    useFPHooks: import.meta.env.VITE_USE_FP_HOOKS === 'true',\n    verboseFPLogging: import.meta.env.VITE_VERBOSE_FP_LOGGING === 'true',\n  };\n\n  // Allow localStorage override for testing\n  let storageFlags: Partial<FeatureFlags> = {};\n  try {\n    const stored = localStorage.getItem('featureFlags');\n    if (stored) {\n      const parsed = JSON.parse(stored);\n      if (parsed && typeof parsed === 'object' && !Array.isArray(parsed)) {\n        storageFlags = parsed as Partial<FeatureFlags>;\n      } else {\n        console.warn('Ignoring invalid feature flags payload in localStorage', parsed);\n      }\n    }\n  } catch (error) {\n    console.warn('Failed to load feature flags from localStorage', error);\n  }\n\n  return {\n    ...DEFAULT_FLAGS,\n    ...envFlags,\n    ...storageFlags,\n  };\n}\n\nlet cachedFlags: FeatureFlags | null = null;\n\n/**\n * Get current feature flags\n * Results are cached per session but can be refreshed\n *\n * @param refresh - Force reload from source\n * @returns Current feature flags\n */\nexport function getFeatureFlags(refresh = false): FeatureFlags {\n  if (cachedFlags === null || refresh) {\n    cachedFlags = loadFeatureFlags();\n\n    if (cachedFlags.verboseFPLogging) {\n      console.debug('[FP] Feature flags loaded:', cachedFlags);\n    }\n  }\n\n  return cachedFlags;\n}\n\n/**\n * Update feature flags at runtime (for testing/debugging)\n * Changes are persisted to localStorage\n *\n * @param updates - Partial flags to update\n */\nexport function updateFeatureFlags(updates: Partial<FeatureFlags>): void {\n  const current = getFeatureFlags();\n  const updated = { ...current, ...updates };\n\n  cachedFlags = updated;\n\n  try {\n    localStorage.setItem('featureFlags', JSON.stringify(updated));\n    console.info('[FP] Feature flags updated:', updated);\n  } catch (error) {\n    console.error('Failed to update feature flags', error);\n  }\n}\n\n/**\n * Reset feature flags to default/environment values\n */\nexport function resetFeatureFlags(): void {\n  // Always clear the in-memory cache first\n  cachedFlags = null;\n\n  try {\n    // Then attempt to clear persisted storage\n    localStorage.removeItem('featureFlags');\n  } catch (error) {\n    console.error('Failed to reset feature flags', error);\n  }\n}\n\n/**\n * Check if a specific feature flag is enabled\n *\n * @param flagName - Name of the flag to check\n * @returns Whether the flag is enabled\n */\nexport function isFeatureEnabled(flagName: keyof FeatureFlags): boolean {\n  return getFeatureFlags()[flagName];\n}\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/config/sensitiveParams.ts",
        "messages": [],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 0,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/config/top1000CommonPasswords.ts",
        "messages": [],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 0,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/constants/__tests__/address.test.ts",
        "messages": [],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 0,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/constants/address.ts",
        "messages": [],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 0,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/contexts/AuthContext.fp.tsx",
        "messages": [
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'JwtPayload' is defined but never used. Allowed unused vars must match /^_/u.",
                "line": 36,
                "column": 8,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 36,
                "endColumn": 18
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 173,
                "column": 41,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 173,
                "endColumn": 64,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                4952,
                                4975
                            ],
                            "text": "(refreshResponse.message != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                4952,
                                4975
                            ],
                            "text": "(refreshResponse.message ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                4952,
                                4975
                            ],
                            "text": "(Boolean(refreshResponse.message))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 173,
                "column": 65,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 173,
                "endColumn": 67,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                4976,
                                4978
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, the types have no overlap.",
                "line": 185,
                "column": 11,
                "nodeType": "BinaryExpression",
                "messageId": "noOverlapBooleanExpression",
                "endLine": 185,
                "endColumn": 40
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, the types have no overlap.",
                "line": 185,
                "column": 44,
                "nodeType": "BinaryExpression",
                "messageId": "noOverlapBooleanExpression",
                "endLine": 185,
                "endColumn": 78
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, the types have no overlap.",
                "line": 193,
                "column": 11,
                "nodeType": "BinaryExpression",
                "messageId": "noOverlapBooleanExpression",
                "endLine": 193,
                "endColumn": 42
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, the types have no overlap.",
                "line": 193,
                "column": 46,
                "nodeType": "BinaryExpression",
                "messageId": "noOverlapBooleanExpression",
                "endLine": 193,
                "endColumn": 82
            },
            {
                "ruleId": "@typescript-eslint/no-floating-promises",
                "severity": 1,
                "message": "Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.",
                "line": 327,
                "column": 5,
                "nodeType": "ExpressionStatement",
                "messageId": "floatingVoid",
                "endLine": 327,
                "endColumn": 16,
                "suggestions": [
                    {
                        "messageId": "floatingFixVoid",
                        "fix": {
                            "range": [
                                10029,
                                10029
                            ],
                            "text": "void "
                        },
                        "desc": "Add void operator to ignore."
                    },
                    {
                        "messageId": "floatingFixAwait",
                        "fix": {
                            "range": [
                                10029,
                                10029
                            ],
                            "text": "await "
                        },
                        "desc": "Add await operator."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.",
                "line": 391,
                "column": 10,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorNullableNumber",
                "endLine": 391,
                "endColumn": 29,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                11883,
                                11903
                            ],
                            "text": "(apiError.statusCode == null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultZero",
                        "fix": {
                            "range": [
                                11884,
                                11903
                            ],
                            "text": "(apiError.statusCode ?? 0)"
                        },
                        "desc": "Explicitly treat nullish value the same as 0 (`value ?? 0`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                11883,
                                11903
                            ],
                            "text": "(!Boolean(apiError.statusCode))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 426,
                "column": 9,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 426,
                "endColumn": 29,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                13160,
                                13180
                            ],
                            "text": "(authResponse.message != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                13160,
                                13180
                            ],
                            "text": "(authResponse.message ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                13160,
                                13180
                            ],
                            "text": "(Boolean(authResponse.message))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 426,
                "column": 30,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 426,
                "endColumn": 32,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                13181,
                                13183
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "react-refresh/only-export-components",
                "severity": 1,
                "message": "Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.",
                "line": 590,
                "column": 14,
                "nodeType": "Identifier",
                "messageId": "namedExport",
                "endLine": 590,
                "endColumn": 21
            },
            {
                "ruleId": "@typescript-eslint/require-await",
                "severity": 1,
                "message": "Async method 'login' has no 'await' expression.",
                "line": 602,
                "column": 7,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingAwait",
                "endLine": 602,
                "endColumn": 20,
                "suggestions": [
                    {
                        "messageId": "removeAsync",
                        "fix": {
                            "range": [
                                18010,
                                18016
                            ],
                            "text": ""
                        },
                        "desc": "Remove 'async'."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/require-await",
                "severity": 1,
                "message": "Async method 'logout' has no 'await' expression.",
                "line": 606,
                "column": 7,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingAwait",
                "endLine": 606,
                "endColumn": 21,
                "suggestions": [
                    {
                        "messageId": "removeAsync",
                        "fix": {
                            "range": [
                                18183,
                                18189
                            ],
                            "text": ""
                        },
                        "desc": "Remove 'async'."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/require-await",
                "severity": 1,
                "message": "Async method 'refreshToken' has no 'await' expression.",
                "line": 610,
                "column": 7,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingAwait",
                "endLine": 610,
                "endColumn": 27,
                "suggestions": [
                    {
                        "messageId": "removeAsync",
                        "fix": {
                            "range": [
                                18365,
                                18371
                            ],
                            "text": ""
                        },
                        "desc": "Remove 'async'."
                    }
                ]
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 15,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "/**\n * AuthContext - Functional Programming Refactored Version\n *\n * This context manages authentication state using Result types and railway-oriented programming.\n * All operations return Results for type-safe error handling without exceptions.\n *\n * Key Features:\n * - Result-based error handling with neverthrow\n * - Railway-oriented programming for login flow\n * - Validation pipeline for credentials\n * - Type-safe storage operations\n * - JWT token parsing and validation\n *\n * @module AuthContext\n */\n\nimport React, { createContext, useContext, useState, useEffect, useRef } from 'react';\nimport type { ReactNode } from 'react';\nimport { type Result, ok, err } from 'neverthrow';\nimport { authService } from '../services/api';\nimport type { User, Tenant, LoginCredentials } from '../types/auth';\nimport { asTenantId } from '../types/ids';\nimport type { TenantId } from '../types/ids';\n\n// Import FP utilities\nimport { storageService, StorageKey, clearAuthData } from '../services/StorageService';\nimport { validateLoginCredentials } from '../utils/validation';\nimport {\n  decodeJwtPayload,\n  checkTokenExpiry,\n  parseStoredUser,\n  parseStoredTenant,\n  updateUserFromJwt,\n  updateTenantFromJwt,\n  verifyDataMatchesToken,\n  type JwtPayload,\n} from '../utils/parsing';\nimport type {\n  StorageError,\n  ParseError,\n  CredentialValidationError,\n  AuthFlowError,\n} from '../types/errors';\nimport {\n  AuthFlowErrors,\n  formatAuthFlowError,\n  formatCredentialValidationError,\n  isParseError,\n} from '../types/errors';\n\n/**\n * Authentication context type\n */\nexport interface AuthContextType {\n  user: User | null;\n  tenant: Tenant | null;\n  isAuthenticated: boolean;\n  isLoading: boolean;\n  error: string | null;\n  login: (\n    credentials: LoginCredentials\n  ) => Promise<Result<void, AuthFlowError | CredentialValidationError>>;\n  logout: () => Promise<Result<void, AuthFlowError>>;\n  refreshToken: () => Promise<Result<void, AuthFlowError>>;\n  clearError: () => void;\n}\n\n/**\n * Authentication state for internal use\n */\ninterface AuthState {\n  user: User;\n  tenant: Tenant;\n  token: string;\n}\n\n/**\n * Token data structure from storage\n */\ninterface TokenData {\n  token: string;\n}\n\n// Context\nconst AuthContext = createContext<AuthContextType | undefined>(undefined);\n\n// Provider props\ninterface AuthProviderProps {\n  children: ReactNode;\n  defaultTenantId?: TenantId;\n}\n\n/**\n * Load authentication state from storage\n *\n * Railway-oriented function that:\n * 1. Loads token from storage\n * 2. Decodes and validates JWT\n * 3. Checks expiration\n * 4. Loads and validates user/tenant data\n * 5. Verifies data matches token\n *\n * @returns Result containing AuthState or error\n */\nconst loadAuthFromStorage = (): Result<AuthState, StorageError | ParseError> => {\n  return (\n    storageService\n      .get<TokenData>(StorageKey.AUTH_TOKEN)\n      // Decode and validate JWT\n      .andThen(tokenData => {\n        const token = tokenData.token;\n        return decodeJwtPayload(token).map(payload => ({ token, payload }));\n      })\n      // Check token expiry\n      .andThen(({ token, payload }) => {\n        return checkTokenExpiry(payload).map(() => ({ token, payload }));\n      })\n      // Load and parse user data\n      .andThen(({ token, payload }) => {\n        return storageService\n          .get<string>(StorageKey.USER)\n          .andThen(userJson => parseStoredUser(userJson))\n          .map(user => ({ token, payload, user }));\n      })\n      // Load and parse tenant data\n      .andThen(({ token, payload, user }) => {\n        return storageService\n          .get<string>(StorageKey.TENANT)\n          .andThen(tenantJson => parseStoredTenant(tenantJson))\n          .map(tenant => ({ token, payload, user, tenant }));\n      })\n      // Verify data matches token\n      .andThen(({ token, payload, user, tenant }) => {\n        return verifyDataMatchesToken(user, tenant, payload).map(() => ({\n          user,\n          tenant,\n          token,\n        }));\n      })\n  );\n};\n\n/**\n * Attempt token refresh with stored data\n *\n * @param storedUser - Stored user data\n * @param storedTenant - Stored tenant data\n * @returns Result containing refreshed AuthState or error\n */\nconst attemptTokenRefresh = async (\n  storedUser: string,\n  storedTenant: string\n): Promise<Result<AuthState, AuthFlowError | ParseError>> => {\n  // Call refresh API\n  const refreshResult = await authService.refreshToken();\n\n  if (refreshResult.isErr()) {\n    const apiError = refreshResult.error;\n    if (apiError.statusCode === 401 || apiError.statusCode === 403) {\n      return err(AuthFlowErrors.unauthorized('Token refresh failed - authentication expired'));\n    }\n    return err(\n      AuthFlowErrors.tokenRefreshFailed(\n        apiError.message || 'Token refresh failed due to network error'\n      )\n    );\n  }\n\n  const refreshResponse = refreshResult.value;\n\n  if (!refreshResponse.success || !refreshResponse.token) {\n    return err(\n      AuthFlowErrors.tokenRefreshFailed(refreshResponse.message || 'No token received from server')\n    );\n  }\n\n  const newToken = refreshResponse.token;\n\n  // Decode new token\n  return decodeJwtPayload(newToken)\n    .mapErr(parseErr => AuthFlowErrors.tokenRefreshFailed(`Invalid token format: ${parseErr.type}`))\n    .andThen(payload => {\n      // Get user from response or parse from storage\n      let userResult: Result<User, ParseError>;\n      if (refreshResponse.user !== null && refreshResponse.user !== undefined) {\n        userResult = ok(updateUserFromJwt(refreshResponse.user, payload));\n      } else {\n        userResult = parseStoredUser(storedUser).map(user => updateUserFromJwt(user, payload));\n      }\n\n      // Get tenant from response or parse from storage\n      let tenantResult: Result<Tenant, ParseError>;\n      if (refreshResponse.tenant !== null && refreshResponse.tenant !== undefined) {\n        tenantResult = ok(updateTenantFromJwt(refreshResponse.tenant, payload));\n      } else {\n        tenantResult = parseStoredTenant(storedTenant).map(tenant =>\n          updateTenantFromJwt(tenant, payload)\n        );\n      }\n\n      // Combine results\n      return userResult\n        .andThen(user =>\n          tenantResult.map(tenant => ({\n            user,\n            tenant,\n            token: newToken,\n          }))\n        )\n        .mapErr(parseErr =>\n          AuthFlowErrors.tokenRefreshFailed(`Data validation failed: ${parseErr.type}`)\n        );\n    });\n};\n\n/**\n * Save authentication state to storage\n *\n * @param user - User data\n * @param tenant - Tenant data\n * @param token - JWT token\n * @returns Result containing void or StorageError\n */\nconst saveAuthToStorage = (\n  user: User,\n  tenant: Tenant,\n  token: string\n): Result<void, StorageError> => {\n  return storageService\n    .set(StorageKey.AUTH_TOKEN, { token })\n    .andThen(() => storageService.set(StorageKey.USER, JSON.stringify(user)))\n    .andThen(() => storageService.set(StorageKey.TENANT, JSON.stringify(tenant)));\n};\n\n/**\n * AuthProvider component\n */\nexport const AuthProvider: React.FC<AuthProviderProps> = ({\n  children,\n  defaultTenantId = asTenantId('tenant1'),\n}) => {\n  const [user, setUser] = useState<User | null>(null);\n  const [tenant, setTenant] = useState<Tenant | null>(null);\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n  const isMountedRef = useRef(true);\n\n  // In a multi-tenant system, authentication requires both user and tenant\n  const isAuthenticated = !!user && !!tenant;\n\n  /**\n   * Initialize auth state from storage\n   */\n  useEffect(() => {\n    const abortController = new AbortController();\n\n    const initAuth = async (): Promise<void> => {\n      try {\n        // Try to load from storage\n        const loadResult = loadAuthFromStorage();\n\n        if (loadResult.isOk()) {\n          // Successfully loaded from storage\n          const authState = loadResult.value;\n          if (isMountedRef.current && !abortController.signal.aborted) {\n            setUser(authState.user);\n            setTenant(authState.tenant);\n          }\n        } else {\n          // Failed to load - check if token is expired\n          const isExpiredToken = loadResult.error.type === 'EXPIRED_TOKEN';\n\n          if (isExpiredToken) {\n            // Try to refresh token\n            const storedUserResult = storageService.get<string>(StorageKey.USER);\n            const storedTenantResult = storageService.get<string>(StorageKey.TENANT);\n\n            if (storedUserResult.isOk() && storedTenantResult.isOk()) {\n              const refreshResult = await attemptTokenRefresh(\n                storedUserResult.value,\n                storedTenantResult.value\n              );\n\n              if (refreshResult.isOk() && !abortController.signal.aborted) {\n                const authState = refreshResult.value;\n\n                // Save refreshed data\n                const saveResult = saveAuthToStorage(\n                  authState.user,\n                  authState.tenant,\n                  authState.token\n                );\n                if (saveResult.isErr()) {\n                  console.error('Failed to save refreshed auth data:', saveResult.error);\n                }\n\n                if (isMountedRef.current) {\n                  setUser(authState.user);\n                  setTenant(authState.tenant);\n                }\n              } else {\n                // Refresh failed - clear storage\n                if (!abortController.signal.aborted) {\n                  clearAuthData();\n                }\n              }\n            }\n          } else {\n            // Other error - clear storage\n            if (!abortController.signal.aborted) {\n              clearAuthData();\n            }\n          }\n        }\n      } catch (initError) {\n        if (!abortController.signal.aborted) {\n          clearAuthData();\n          console.error('Auth initialization failed:', initError);\n        }\n      } finally {\n        if (isMountedRef.current && !abortController.signal.aborted) {\n          setIsLoading(false);\n        }\n      }\n    };\n\n    initAuth();\n\n    return () => {\n      abortController.abort();\n      isMountedRef.current = false;\n    };\n  }, []);\n\n  /**\n   * Login with credentials\n   *\n   * Uses railway-oriented programming:\n   * 1. Validate credentials\n   * 2. Call login API\n   * 3. Decode JWT token\n   * 4. Extract user/tenant from response\n   * 5. Save to storage\n   * 6. Update state\n   */\n  const login = async (\n    credentials: LoginCredentials\n  ): Promise<Result<void, AuthFlowError | CredentialValidationError>> => {\n    setIsLoading(true);\n    setError(null);\n\n    // Use default tenant if not provided\n    const tenantId = credentials.tenantId ?? defaultTenantId;\n\n    // Step 1: Validate credentials\n    const validationResult = validateLoginCredentials(\n      credentials.usernameOrEmail,\n      credentials.password,\n      tenantId\n    );\n\n    if (validationResult.isErr()) {\n      const validationError = validationResult.error;\n      const errorMessage = formatCredentialValidationError(validationError);\n      setError(errorMessage);\n      setIsLoading(false);\n      return err(validationError);\n    }\n\n    // Step 2: Call login API\n    const modifiedCredentials: LoginCredentials = {\n      ...credentials,\n      tenantId,\n    };\n\n    const loginResult = await authService.login(modifiedCredentials);\n\n    if (loginResult.isErr()) {\n      const apiError = loginResult.error;\n\n      // Map error types appropriately based on status code and error type\n      let authError: AuthFlowError;\n\n      if (apiError.statusCode === 401) {\n        authError = AuthFlowErrors.unauthorized(apiError.message || 'Invalid username or password');\n      } else if (apiError.statusCode === 403) {\n        authError = AuthFlowErrors.forbidden(apiError.message || 'Access denied');\n      } else if (\n        apiError.statusCode === 408 ||\n        apiError.statusCode === 504 ||\n        !apiError.statusCode\n      ) {\n        // Network errors or timeouts (no status code often indicates network failure)\n        authError = AuthFlowErrors.networkError(\n          apiError.message || 'Network connection failed',\n          apiError.statusCode\n        );\n      } else if (apiError.statusCode && apiError.statusCode >= 400 && apiError.statusCode < 500) {\n        // Client errors (4xx) - validation or request issues\n        authError = AuthFlowErrors.invalidCredentials(\n          apiError.message || 'Request validation failed'\n        );\n      } else if (apiError.statusCode && apiError.statusCode >= 500) {\n        // Server errors (5xx)\n        authError = AuthFlowErrors.serverError(\n          apiError.statusCode,\n          apiError.message || 'Server error occurred'\n        );\n      } else {\n        // Other unexpected errors\n        authError = AuthFlowErrors.serverError(\n          apiError.statusCode || 500,\n          apiError.message || 'Login failed'\n        );\n      }\n\n      setError(formatAuthFlowError(authError));\n      setIsLoading(false);\n      return err(authError);\n    }\n\n    const authResponse = loginResult.value;\n\n    if (!authResponse.success || !authResponse.token) {\n      const authError = AuthFlowErrors.invalidCredentials(\n        authResponse.message || 'Login failed - no token received'\n      );\n      setError(formatAuthFlowError(authError));\n      setIsLoading(false);\n      return err(authError);\n    }\n\n    // Step 3: Decode JWT token\n    const token = authResponse.token;\n    const payloadResult = decodeJwtPayload(token);\n\n    if (payloadResult.isErr()) {\n      const authError = AuthFlowErrors.invalidCredentials('Invalid token format received');\n      setError(formatAuthFlowError(authError));\n      setIsLoading(false);\n      clearAuthData();\n      return err(authError);\n    }\n\n    const payload = payloadResult.value;\n\n    // Step 4: Extract and validate user/tenant\n    const user = updateUserFromJwt(authResponse.user, payload);\n    const tenant = updateTenantFromJwt(authResponse.tenant, payload);\n\n    // Step 5: Save to storage\n    const saveResult = saveAuthToStorage(user, tenant, token);\n\n    if (saveResult.isErr()) {\n      const authError = AuthFlowErrors.networkError('Failed to save authentication data');\n      setError(formatAuthFlowError(authError));\n      setIsLoading(false);\n      return err(authError);\n    }\n\n    // Step 6: Update state\n    setUser(user);\n    setTenant(tenant);\n    setIsLoading(false);\n\n    return ok(undefined);\n  };\n\n  /**\n   * Logout user\n   */\n  const logout = async (): Promise<Result<void, AuthFlowError>> => {\n    try {\n      // Call logout API\n      const logoutResult = await authService.logout();\n\n      if (logoutResult.isErr()) {\n        console.error('Server-side logout failed:', logoutResult.error);\n        // Continue with local cleanup even if server call fails\n      }\n\n      // Clear storage\n      clearAuthData();\n\n      // Clear state\n      setUser(null);\n      setTenant(null);\n      setError(null);\n\n      return ok(undefined);\n    } catch (logoutError) {\n      // Always clear local data even on error\n      clearAuthData();\n      setUser(null);\n      setTenant(null);\n\n      const error = AuthFlowErrors.logoutFailed(\n        logoutError instanceof Error ? logoutError.message : 'Unknown error'\n      );\n      return err(error);\n    }\n  };\n\n  /**\n   * Refresh authentication token\n   */\n  const refreshToken = async (): Promise<Result<void, AuthFlowError>> => {\n    try {\n      const storedUserResult = storageService.get<string>(StorageKey.USER);\n      const storedTenantResult = storageService.get<string>(StorageKey.TENANT);\n\n      if (storedUserResult.isErr() || storedTenantResult.isErr()) {\n        const error = AuthFlowErrors.missingToken();\n        await logout();\n        return err(error);\n      }\n\n      const refreshResult = await attemptTokenRefresh(\n        storedUserResult.value,\n        storedTenantResult.value\n      );\n\n      if (refreshResult.isErr()) {\n        const error = refreshResult.error;\n\n        // If unauthorized, logout user\n        if (error.type === 'UNAUTHORIZED') {\n          await logout();\n        }\n\n        // Map ParseError to AuthFlowError if needed - use type guard for safety\n        if (isParseError(error)) {\n          return err(AuthFlowErrors.tokenRefreshFailed(`Token validation failed: ${error.type}`));\n        }\n\n        return err(error as AuthFlowError);\n      }\n\n      const authState = refreshResult.value;\n\n      // Save refreshed data\n      const saveResult = saveAuthToStorage(authState.user, authState.tenant, authState.token);\n\n      if (saveResult.isErr()) {\n        return err(AuthFlowErrors.tokenRefreshFailed('Failed to save refreshed data'));\n      }\n\n      // Update state\n      setUser(authState.user);\n      setTenant(authState.tenant);\n\n      return ok(undefined);\n    } catch (refreshError) {\n      const error = AuthFlowErrors.tokenRefreshFailed(\n        refreshError instanceof Error ? refreshError.message : 'Unknown error'\n      );\n      return err(error);\n    }\n  };\n\n  /**\n   * Clear error state\n   */\n  const clearError = (): void => {\n    setError(null);\n  };\n\n  const value: AuthContextType = {\n    user,\n    tenant,\n    isAuthenticated,\n    isLoading,\n    error,\n    login,\n    logout,\n    refreshToken,\n    clearError,\n  };\n\n  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;\n};\n\n/**\n * Hook to use auth context\n *\n * Returns a safe fallback when used outside AuthProvider to prevent crashes.\n * This allows components to gracefully handle missing provider by showing\n * unauthenticated state and redirecting as needed.\n */\nexport const useAuth = (): AuthContextType => {\n  const context = useContext(AuthContext);\n  if (context === undefined) {\n    // Return a safe fallback instead of throwing\n    // This allows components to gracefully handle missing provider\n    console.warn('useAuth called outside AuthProvider - returning fallback auth state');\n    return {\n      user: null,\n      tenant: null,\n      isAuthenticated: false,\n      isLoading: false,\n      error: null,\n      login: async () => {\n        console.warn('login called outside AuthProvider');\n        return err(AuthFlowErrors.initFailed('AuthProvider not available'));\n      },\n      logout: async () => {\n        console.warn('logout called outside AuthProvider');\n        return err(AuthFlowErrors.logoutFailed('AuthProvider not available'));\n      },\n      refreshToken: async () => {\n        console.warn('refreshToken called outside AuthProvider');\n        return err(AuthFlowErrors.tokenRefreshFailed('AuthProvider not available'));\n      },\n      clearError: () => {\n        console.warn('clearError called outside AuthProvider');\n      },\n    };\n  }\n  return context;\n};\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/contexts/AuthContext.test.ts",
        "messages": [
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 11,
                "column": 14,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 11,
                "endColumn": 24,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                366,
                                376
                            ],
                            "text": "(store[key] != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                366,
                                376
                            ],
                            "text": "(store[key] ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                366,
                                376
                            ],
                            "text": "(Boolean(store[key]))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 11,
                "column": 25,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 11,
                "endColumn": 27,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                377,
                                379
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-type-conversion",
                "severity": 1,
                "message": "Calling a string's .toString() method does not change the type or value of the string.",
                "line": 14,
                "column": 26,
                "nodeType": null,
                "messageId": "unnecessaryTypeConversion",
                "endLine": 14,
                "endColumn": 36,
                "suggestions": [
                    {
                        "messageId": "suggestRemove",
                        "fix": {
                            "range": [
                                465,
                                481
                            ],
                            "text": "value"
                        },
                        "desc": "Remove the type conversion."
                    },
                    {
                        "messageId": "suggestSatisfies",
                        "data": {
                            "type": "string"
                        },
                        "fix": {
                            "range": [
                                465,
                                481
                            ],
                            "text": "value satisfies string"
                        },
                        "desc": "Instead, assert that the value satisfies the string type."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-dynamic-delete",
                "severity": 1,
                "message": "Do not delete dynamically computed property keys.",
                "line": 17,
                "column": 20,
                "nodeType": "Identifier",
                "messageId": "dynamicDelete",
                "endLine": 17,
                "endColumn": 23
            },
            {
                "ruleId": "@typescript-eslint/no-non-null-assertion",
                "severity": 1,
                "message": "Forbidden non-null assertion.",
                "line": 81,
                "column": 25,
                "nodeType": "TSNonNullExpression",
                "messageId": "noNonNull",
                "endLine": 81,
                "endColumn": 32
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-return",
                "severity": 1,
                "message": "Unsafe return of a value of type `any`.",
                "line": 88,
                "column": 20,
                "nodeType": "CallExpression",
                "messageId": "unsafeReturn",
                "endLine": 88,
                "endColumn": 39
            },
            {
                "ruleId": "@typescript-eslint/no-non-null-assertion",
                "severity": 1,
                "message": "Forbidden non-null assertion.",
                "line": 88,
                "column": 31,
                "nodeType": "TSNonNullExpression",
                "messageId": "noNonNull",
                "endLine": 88,
                "endColumn": 38
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 7,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "import { describe, test, expect, beforeEach, afterEach } from 'bun:test';\nimport type { LoginCredentials } from '../types/auth';\nimport { asTenantId } from '../types/ids';\n\n// Mock localStorage for testing environment\nconst localStorageMock = (() => {\n  let store: Record<string, string> = {};\n\n  return {\n    getItem: (key: string): string | null => {\n      return store[key] || null;\n    },\n    setItem: (key: string, value: string): void => {\n      store[key] = value.toString();\n    },\n    removeItem: (key: string): void => {\n      delete store[key];\n    },\n    clear: (): void => {\n      store = {};\n    },\n  };\n})();\n\n// Assign the mock to global localStorage\nObject.defineProperty(global, 'localStorage', {\n  value: localStorageMock,\n  writable: true,\n});\n\ndescribe('AuthContext', () => {\n  beforeEach(() => {\n    // Clear localStorage before each test\n    localStorage.clear();\n  });\n\n  afterEach(() => {\n    // Clear localStorage after each test\n    localStorage.clear();\n  });\n\n  describe('LoginCredentials interface', () => {\n    test('should accept valid login credentials', () => {\n      const credentials: LoginCredentials = {\n        usernameOrEmail: 'test@example.com',\n        password: 'password123',\n        tenantId: asTenantId('tenant1'),\n        rememberMe: true,\n      };\n\n      expect(credentials.usernameOrEmail).toBe('test@example.com');\n      expect(credentials.password).toBe('password123');\n      expect(credentials.tenantId).toBe(asTenantId('tenant1'));\n      expect(credentials.rememberMe).toBe(true);\n    });\n\n    test('should allow optional rememberMe', () => {\n      const credentials: LoginCredentials = {\n        usernameOrEmail: 'test@example.com',\n        password: 'password123',\n        tenantId: asTenantId('tenant1'),\n      };\n\n      expect(credentials.rememberMe).toBeUndefined();\n    });\n  });\n\n  describe('LocalStorage operations', () => {\n    test('should store and retrieve user data', () => {\n      const userData = {\n        id: 'user123',\n        email: 'test@example.com',\n        username: 'testuser',\n        roles: ['user'],\n      };\n\n      localStorage.setItem('user', JSON.stringify(userData));\n      const stored = localStorage.getItem('user');\n\n      expect(stored).toBeTruthy();\n      expect(JSON.parse(stored!)).toEqual(userData);\n    });\n\n    test('should handle invalid JSON gracefully', () => {\n      localStorage.setItem('user', 'invalid json');\n\n      const stored = localStorage.getItem('user');\n      expect(() => JSON.parse(stored!)).toThrow(SyntaxError);\n    });\n  });\n\n  // Note: Component logic testing would require a testing framework setup\n  // These are basic interface and utility tests\n});\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/contexts/AuthContext.tsx",
        "messages": [
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 33,
                "column": 32,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 33,
                "endColumn": 40,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                1102,
                                1111
                            ],
                            "text": "(parts[1] == null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                1103,
                                1111
                            ],
                            "text": "(parts[1] ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                1102,
                                1111
                            ],
                            "text": "(!Boolean(parts[1]))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
                "line": 58,
                "column": 9,
                "nodeType": "ChainExpression",
                "messageId": "conditionErrorNullableBoolean",
                "endLine": 58,
                "endColumn": 24,
                "suggestions": [
                    {
                        "messageId": "conditionFixDefaultFalse",
                        "fix": {
                            "range": [
                                1861,
                                1876
                            ],
                            "text": "(signal?.aborted) ?? false"
                        },
                        "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
                    },
                    {
                        "messageId": "conditionFixCompareTrue",
                        "fix": {
                            "range": [
                                1861,
                                1876
                            ],
                            "text": "(signal?.aborted) === true"
                        },
                        "desc": "Change condition to check if true (`value === true`)"
                    }
                ]
            },
            {
                "ruleId": "no-console",
                "severity": 1,
                "message": "Unexpected console statement. Only these console methods are allowed: warn, error.",
                "line": 59,
                "column": 7,
                "nodeType": "MemberExpression",
                "messageId": "limited",
                "endLine": 59,
                "endColumn": 18,
                "suggestions": [
                    {
                        "fix": {
                            "range": [
                                1886,
                                1925
                            ],
                            "text": ""
                        },
                        "messageId": "removeConsole",
                        "data": {
                            "propertyName": "log"
                        },
                        "desc": "Remove the console.log()."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
                "line": 81,
                "column": 9,
                "nodeType": "ChainExpression",
                "messageId": "conditionErrorNullableBoolean",
                "endLine": 81,
                "endColumn": 24,
                "suggestions": [
                    {
                        "messageId": "conditionFixDefaultFalse",
                        "fix": {
                            "range": [
                                2491,
                                2506
                            ],
                            "text": "(signal?.aborted) ?? false"
                        },
                        "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
                    },
                    {
                        "messageId": "conditionFixCompareTrue",
                        "fix": {
                            "range": [
                                2491,
                                2506
                            ],
                            "text": "(signal?.aborted) === true"
                        },
                        "desc": "Change condition to check if true (`value === true`)"
                    }
                ]
            },
            {
                "ruleId": "no-console",
                "severity": 1,
                "message": "Unexpected console statement. Only these console methods are allowed: warn, error.",
                "line": 82,
                "column": 7,
                "nodeType": "MemberExpression",
                "messageId": "limited",
                "endLine": 82,
                "endColumn": 18,
                "suggestions": [
                    {
                        "fix": {
                            "range": [
                                2516,
                                2570
                            ],
                            "text": ""
                        },
                        "messageId": "removeConsole",
                        "data": {
                            "propertyName": "log"
                        },
                        "desc": "Remove the console.log()."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary optional chain on a non-nullish value.",
                "line": 92,
                "column": 25,
                "nodeType": "MemberExpression",
                "messageId": "neverOptionalChain",
                "endLine": 92,
                "endColumn": 27,
                "suggestions": [
                    {
                        "messageId": "suggestRemoveOptionalChain",
                        "fix": {
                            "range": [
                                2816,
                                2818
                            ],
                            "text": "."
                        },
                        "desc": "Remove unnecessary optional chain"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary optional chain on a non-nullish value.",
                "line": 92,
                "column": 58,
                "nodeType": "MemberExpression",
                "messageId": "neverOptionalChain",
                "endLine": 92,
                "endColumn": 60,
                "suggestions": [
                    {
                        "messageId": "suggestRemoveOptionalChain",
                        "fix": {
                            "range": [
                                2849,
                                2851
                            ],
                            "text": "."
                        },
                        "desc": "Remove unnecessary optional chain"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.",
                "line": 99,
                "column": 38,
                "nodeType": "MemberExpression",
                "messageId": "neverNullish",
                "endLine": 99,
                "endColumn": 56
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.",
                "line": 100,
                "column": 42,
                "nodeType": "MemberExpression",
                "messageId": "neverNullish",
                "endLine": 100,
                "endColumn": 62
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, value is always truthy.",
                "line": 102,
                "column": 9,
                "nodeType": "Identifier",
                "messageId": "alwaysTruthy",
                "endLine": 102,
                "endColumn": 22
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected object value in conditional. The condition is always true.",
                "line": 102,
                "column": 9,
                "nodeType": "Identifier",
                "messageId": "conditionErrorObject",
                "endLine": 102,
                "endColumn": 22
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, value is always truthy.",
                "line": 110,
                "column": 9,
                "nodeType": "Identifier",
                "messageId": "alwaysTruthy",
                "endLine": 110,
                "endColumn": 24
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected object value in conditional. The condition is always true.",
                "line": 110,
                "column": 9,
                "nodeType": "Identifier",
                "messageId": "conditionErrorObject",
                "endLine": 110,
                "endColumn": 24
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, value is always falsy.",
                "line": 117,
                "column": 9,
                "nodeType": "UnaryExpression",
                "messageId": "alwaysFalsy",
                "endLine": 117,
                "endColumn": 23
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected object value in conditional. The condition is always true.",
                "line": 117,
                "column": 10,
                "nodeType": "Identifier",
                "messageId": "conditionErrorObject",
                "endLine": 117,
                "endColumn": 23
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 119,
                "column": 15,
                "nodeType": "VariableDeclarator",
                "messageId": "anyAssignment",
                "endLine": 119,
                "endColumn": 50
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected any value in conditional. An explicit comparison or type conversion is required.",
                "line": 121,
                "column": 11,
                "nodeType": "Identifier",
                "messageId": "conditionErrorAny",
                "endLine": 121,
                "endColumn": 21,
                "suggestions": [
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                3581,
                                3591
                            ],
                            "text": "(Boolean(parsedUser))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .id on an `any` value.",
                "line": 123,
                "column": 29,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 123,
                "endColumn": 31
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-call",
                "severity": 1,
                "message": "Unsafe call of a(n) `any` typed value.",
                "line": 124,
                "column": 11,
                "nodeType": "MemberExpression",
                "messageId": "unsafeCall",
                "endLine": 124,
                "endColumn": 29
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .id on an `any` value.",
                "line": 124,
                "column": 22,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 124,
                "endColumn": 24
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .email on an `any` value.",
                "line": 125,
                "column": 29,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 125,
                "endColumn": 34
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-call",
                "severity": 1,
                "message": "Unsafe call of a(n) `any` typed value.",
                "line": 126,
                "column": 11,
                "nodeType": "MemberExpression",
                "messageId": "unsafeCall",
                "endLine": 126,
                "endColumn": 32
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .email on an `any` value.",
                "line": 126,
                "column": 22,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 126,
                "endColumn": 27
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .username on an `any` value.",
                "line": 127,
                "column": 29,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 127,
                "endColumn": 37
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-call",
                "severity": 1,
                "message": "Unsafe call of a(n) `any` typed value.",
                "line": 128,
                "column": 11,
                "nodeType": "MemberExpression",
                "messageId": "unsafeCall",
                "endLine": 128,
                "endColumn": 35
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .username on an `any` value.",
                "line": 128,
                "column": 22,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 128,
                "endColumn": 30
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .roles on an `any` value.",
                "line": 129,
                "column": 36,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 129,
                "endColumn": 41
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected any value in conditional. An explicit comparison or type conversion is required.",
                "line": 130,
                "column": 11,
                "nodeType": "CallExpression",
                "messageId": "conditionErrorAny",
                "endLine": 130,
                "endColumn": 74,
                "suggestions": [
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                3976,
                                4039
                            ],
                            "text": "(Boolean(parsedUser.roles.every((role: any) => typeof role === 'string')))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-call",
                "severity": 1,
                "message": "Unsafe call of a(n) `any` typed value.",
                "line": 130,
                "column": 11,
                "nodeType": "MemberExpression",
                "messageId": "unsafeCall",
                "endLine": 130,
                "endColumn": 33
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .roles on an `any` value.",
                "line": 130,
                "column": 22,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 130,
                "endColumn": 27
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 130,
                "column": 41,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 130,
                "endColumn": 44,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                4006,
                                4009
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                4006,
                                4009
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 132,
                "column": 11,
                "nodeType": "AssignmentExpression",
                "messageId": "anyAssignment",
                "endLine": 137,
                "endColumn": 12
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, value is always falsy.",
                "line": 144,
                "column": 9,
                "nodeType": "UnaryExpression",
                "messageId": "alwaysFalsy",
                "endLine": 144,
                "endColumn": 25
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected object value in conditional. The condition is always true.",
                "line": 144,
                "column": 10,
                "nodeType": "Identifier",
                "messageId": "conditionErrorObject",
                "endLine": 144,
                "endColumn": 25
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 146,
                "column": 15,
                "nodeType": "VariableDeclarator",
                "messageId": "anyAssignment",
                "endLine": 146,
                "endColumn": 54
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected any value in conditional. An explicit comparison or type conversion is required.",
                "line": 148,
                "column": 11,
                "nodeType": "Identifier",
                "messageId": "conditionErrorAny",
                "endLine": 148,
                "endColumn": 23,
                "suggestions": [
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                4501,
                                4513
                            ],
                            "text": "(Boolean(parsedTenant))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .id on an `any` value.",
                "line": 150,
                "column": 31,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 150,
                "endColumn": 33
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-call",
                "severity": 1,
                "message": "Unsafe call of a(n) `any` typed value.",
                "line": 151,
                "column": 11,
                "nodeType": "MemberExpression",
                "messageId": "unsafeCall",
                "endLine": 151,
                "endColumn": 31
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .id on an `any` value.",
                "line": 151,
                "column": 24,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 151,
                "endColumn": 26
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .name on an `any` value.",
                "line": 152,
                "column": 31,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 152,
                "endColumn": 35
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-call",
                "severity": 1,
                "message": "Unsafe call of a(n) `any` typed value.",
                "line": 153,
                "column": 11,
                "nodeType": "MemberExpression",
                "messageId": "unsafeCall",
                "endLine": 153,
                "endColumn": 33
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .name on an `any` value.",
                "line": 153,
                "column": 24,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 153,
                "endColumn": 28
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .settings on an `any` value.",
                "line": 154,
                "column": 31,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 154,
                "endColumn": 39
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .settings on an `any` value.",
                "line": 155,
                "column": 24,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 155,
                "endColumn": 32
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, value is always truthy.",
                "line": 167,
                "column": 26,
                "nodeType": "Identifier",
                "messageId": "alwaysTruthy",
                "endLine": 167,
                "endColumn": 41
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected object value in conditional. The condition is always true.",
                "line": 167,
                "column": 26,
                "nodeType": "Identifier",
                "messageId": "conditionErrorObject",
                "endLine": 167,
                "endColumn": 41
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
                "line": 174,
                "column": 9,
                "nodeType": "ChainExpression",
                "messageId": "conditionErrorNullableBoolean",
                "endLine": 174,
                "endColumn": 24,
                "suggestions": [
                    {
                        "messageId": "conditionFixDefaultFalse",
                        "fix": {
                            "range": [
                                5400,
                                5415
                            ],
                            "text": "(signal?.aborted) ?? false"
                        },
                        "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
                    },
                    {
                        "messageId": "conditionFixCompareTrue",
                        "fix": {
                            "range": [
                                5400,
                                5415
                            ],
                            "text": "(signal?.aborted) === true"
                        },
                        "desc": "Change condition to check if true (`value === true`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 208,
                "column": 31,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingReturnType",
                "endLine": 208,
                "endColumn": 33
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 214,
                "column": 13,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 214,
                "endColumn": 28,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                6630,
                                6645
                            ],
                            "text": "(storedTokenData != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                6630,
                                6645
                            ],
                            "text": "(storedTokenData ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                6630,
                                6645
                            ],
                            "text": "(Boolean(storedTokenData))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 214,
                "column": 32,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 214,
                "endColumn": 42,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                6649,
                                6659
                            ],
                            "text": "(storedUser != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                6649,
                                6659
                            ],
                            "text": "(storedUser ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                6649,
                                6659
                            ],
                            "text": "(Boolean(storedUser))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 214,
                "column": 46,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 214,
                "endColumn": 58,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                6663,
                                6675
                            ],
                            "text": "(storedTenant != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                6663,
                                6675
                            ],
                            "text": "(storedTenant ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                6663,
                                6675
                            ],
                            "text": "(Boolean(storedTenant))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 218,
                "column": 19,
                "nodeType": "VariableDeclarator",
                "messageId": "anyAssignment",
                "endLine": 218,
                "endColumn": 57
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 219,
                "column": 13,
                "nodeType": "AssignmentExpression",
                "messageId": "anyAssignment",
                "endLine": 219,
                "endColumn": 36
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .token on an `any` value.",
                "line": 219,
                "column": 31,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 219,
                "endColumn": 36
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, value is always truthy.",
                "line": 243,
                "column": 19,
                "nodeType": "UnaryExpression",
                "messageId": "alwaysTruthy",
                "endLine": 243,
                "endColumn": 50
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, value is always truthy.",
                "line": 248,
                "column": 43,
                "nodeType": "UnaryExpression",
                "messageId": "alwaysTruthy",
                "endLine": 248,
                "endColumn": 74
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected object value in conditional. The condition is always true.",
                "line": 266,
                "column": 15,
                "nodeType": "Identifier",
                "messageId": "conditionErrorObject",
                "endLine": 266,
                "endColumn": 25
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, value is always truthy.",
                "line": 266,
                "column": 15,
                "nodeType": "Identifier",
                "messageId": "alwaysTruthy",
                "endLine": 266,
                "endColumn": 25
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected object value in conditional. The condition is always true.",
                "line": 277,
                "column": 15,
                "nodeType": "Identifier",
                "messageId": "conditionErrorObject",
                "endLine": 277,
                "endColumn": 27
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, value is always truthy.",
                "line": 277,
                "column": 15,
                "nodeType": "Identifier",
                "messageId": "alwaysTruthy",
                "endLine": 277,
                "endColumn": 27
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, the types have no overlap.",
                "line": 283,
                "column": 15,
                "nodeType": "BinaryExpression",
                "messageId": "noOverlapBooleanExpression",
                "endLine": 283,
                "endColumn": 45
            },
            {
                "ruleId": "@typescript-eslint/no-floating-promises",
                "severity": 1,
                "message": "Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.",
                "line": 329,
                "column": 5,
                "nodeType": "ExpressionStatement",
                "messageId": "floatingVoid",
                "endLine": 329,
                "endColumn": 16,
                "suggestions": [
                    {
                        "messageId": "floatingFixVoid",
                        "fix": {
                            "range": [
                                11374,
                                11374
                            ],
                            "text": "void "
                        },
                        "desc": "Add void operator to ignore."
                    },
                    {
                        "messageId": "floatingFixAwait",
                        "fix": {
                            "range": [
                                11374,
                                11374
                            ],
                            "text": "await "
                        },
                        "desc": "Add await operator."
                    }
                ]
            },
            {
                "ruleId": "no-console",
                "severity": 1,
                "message": "Unexpected console statement. Only these console methods are allowed: warn, error.",
                "line": 415,
                "column": 9,
                "nodeType": "MemberExpression",
                "messageId": "limited",
                "endLine": 415,
                "endColumn": 20,
                "suggestions": [
                    {
                        "fix": {
                            "range": [
                                13853,
                                13898
                            ],
                            "text": ""
                        },
                        "messageId": "removeConsole",
                        "data": {
                            "propertyName": "log"
                        },
                        "desc": "Remove the console.log()."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 450,
                "column": 25,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 450,
                "endColumn": 48,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                15090,
                                15113
                            ],
                            "text": "(refreshResponse.message != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                15090,
                                15113
                            ],
                            "text": "(refreshResponse.message ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                15090,
                                15113
                            ],
                            "text": "(Boolean(refreshResponse.message))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 450,
                "column": 49,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 450,
                "endColumn": 51,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                15114,
                                15116
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 460,
                "column": 12,
                "nodeType": "ChainExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 460,
                "endColumn": 25,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                15441,
                                15455
                            ],
                            "text": "((payload?.user) == null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                15442,
                                15455
                            ],
                            "text": "((payload?.user) ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                15441,
                                15455
                            ],
                            "text": "(!Boolean((payload?.user)))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "no-console",
                "severity": 1,
                "message": "Unexpected console statement. Only these console methods are allowed: warn, error.",
                "line": 481,
                "column": 7,
                "nodeType": "MemberExpression",
                "messageId": "limited",
                "endLine": 481,
                "endColumn": 18,
                "suggestions": [
                    {
                        "fix": {
                            "range": [
                                16079,
                                16119
                            ],
                            "text": ""
                        },
                        "messageId": "removeConsole",
                        "data": {
                            "propertyName": "log"
                        },
                        "desc": "Remove the console.log()."
                    }
                ]
            },
            {
                "ruleId": "react-refresh/only-export-components",
                "severity": 1,
                "message": "Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.",
                "line": 511,
                "column": 14,
                "nodeType": "Identifier",
                "messageId": "namedExport",
                "endLine": 511,
                "endColumn": 21
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 68,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "import React, { createContext, useContext, useState, useEffect } from 'react';\nimport type { ReactNode } from 'react';\nimport { authService } from '../services/api';\nimport type { User, Tenant, LoginCredentials } from '../types/auth';\nimport { asTenantId, asUserId } from '../types/ids';\n\nexport interface AuthContextType {\n  user: User | null;\n  tenant: Tenant | null;\n  isAuthenticated: boolean;\n  isLoading: boolean;\n  login: (credentials: LoginCredentials) => Promise<void>;\n  logout: () => Promise<void>;\n  refreshToken: () => Promise<void>;\n  // JWT Authentication Integration with backend API\n  // - Real authentication endpoints integration with existing Actix Web backend\n  // - JWT token storage and automatic Authorization header inclusion\n  // - Robust error handling with proper logout on auth failures\n}\n\ninterface JwtPayload {\n  user: string;\n  tenant_id: string;\n  exp: number;\n  iat?: number;\n  [key: string]: unknown;\n}\n\n// JWT decoding utility\nconst decodeJwtPayload = (token: string): JwtPayload | null => {\n  try {\n    const parts = token.split('.');\n    if (parts.length !== 3 || !parts[1]) {\n      throw new Error('Invalid JWT format');\n    }\n    const decoded = atob(parts[1].replace(/-/g, '+').replace(/_/g, '/'));\n    const payload = JSON.parse(decoded) as JwtPayload;\n\n    // Validate required fields\n    if (!payload.user || !payload.tenant_id || typeof payload.exp !== 'number') {\n      throw new Error('Invalid JWT payload structure');\n    }\n\n    return payload;\n  } catch (error) {\n    console.warn('Failed to decode JWT:', error);\n    return null;\n  }\n};\n\n// Helper to attempt token refresh and validate/construct user and tenant objects\nconst attemptTokenRefresh = async (\n  storedUser: string,\n  storedTenant: string,\n  signal?: AbortSignal\n): Promise<{ user: User; tenant: Tenant; token: string } | null> => {\n  try {\n    if (signal?.aborted) {\n      console.log('Token refresh cancelled');\n      return null;\n    }\n\n    const refreshResult = await authService.refreshToken();\n    if (refreshResult.isErr()) {\n      console.error('Token refresh failed during initialization:', refreshResult.error);\n      return null;\n    }\n\n    const refreshedAuth = refreshResult.value;\n    if (!refreshedAuth.success) {\n      console.error('Token refresh response did not indicate success');\n      return null;\n    }\n\n    const newToken = refreshedAuth.token;\n    if (!newToken) {\n      console.error('No token received from refresh');\n      return null;\n    }\n\n    if (signal?.aborted) {\n      console.log('Token refresh cancelled after API call');\n      return null;\n    }\n\n    const newPayload = decodeJwtPayload(newToken);\n    if (!newPayload || typeof newPayload !== 'object') {\n      console.error('Failed to decode refreshed JWT token');\n      return null;\n    }\n\n    if (!newPayload.user?.trim() || !newPayload.tenant_id?.trim()) {\n      console.error(\n        'JWT payload validation failed: missing or invalid user/tenant_id in refreshed token'\n      );\n      return null;\n    }\n\n    let refreshedUser: User | null = refreshedAuth.user ?? null;\n    let refreshedTenant: Tenant | null = refreshedAuth.tenant ?? null;\n\n    if (refreshedUser) {\n      refreshedUser = {\n        ...refreshedUser,\n        username: newPayload.user,\n        tenantId: asTenantId(newPayload.tenant_id),\n      };\n    }\n\n    if (refreshedTenant) {\n      refreshedTenant = {\n        ...refreshedTenant,\n        id: asTenantId(newPayload.tenant_id),\n      };\n    }\n\n    if (!refreshedUser) {\n      try {\n        const parsedUser = JSON.parse(storedUser);\n        if (\n          parsedUser &&\n          typeof parsedUser === 'object' &&\n          typeof parsedUser.id === 'string' &&\n          parsedUser.id.trim() !== '' &&\n          typeof parsedUser.email === 'string' &&\n          parsedUser.email.trim() !== '' &&\n          typeof parsedUser.username === 'string' &&\n          parsedUser.username.trim() !== '' &&\n          Array.isArray(parsedUser.roles) &&\n          parsedUser.roles.every((role: any) => typeof role === 'string')\n        ) {\n          refreshedUser = {\n            ...parsedUser,\n            id: asUserId(newPayload.user),\n            username: newPayload.user,\n            tenantId: asTenantId(newPayload.tenant_id),\n          };\n        }\n      } catch (parseError) {\n        console.warn('Failed to parse stored user data:', parseError);\n      }\n    }\n\n    if (!refreshedTenant) {\n      try {\n        const parsedTenant = JSON.parse(storedTenant);\n        if (\n          parsedTenant &&\n          typeof parsedTenant === 'object' &&\n          typeof parsedTenant.id === 'string' &&\n          parsedTenant.id.trim() !== '' &&\n          typeof parsedTenant.name === 'string' &&\n          parsedTenant.name.trim() !== '' &&\n          typeof parsedTenant.settings === 'object' &&\n          parsedTenant.settings !== null\n        ) {\n          refreshedTenant = {\n            ...parsedTenant,\n            id: asTenantId(newPayload.tenant_id),\n          } as Tenant;\n        }\n      } catch (parseError) {\n        console.warn('Failed to parse stored tenant data:', parseError);\n      }\n    }\n\n    if (refreshedUser && refreshedTenant) {\n      return { user: refreshedUser, tenant: refreshedTenant, token: newToken };\n    } else {\n      console.warn('Stored user/tenant data validation failed after token refresh');\n      return null;\n    }\n  } catch (refreshError) {\n    if (signal?.aborted) {\n      console.warn('Token refresh cancelled due to abort');\n      return null;\n    }\n    console.warn('Token refresh failed:', refreshError);\n    return null;\n  }\n};\n\n// Context\nconst AuthContext = createContext<AuthContextType | undefined>(undefined);\n\n// Export the context for testing purposes\nexport { AuthContext };\n\n// Provider props\ninterface AuthProviderProps {\n  children: ReactNode;\n}\n\n// Provider component\nexport const AuthProvider: React.FC<AuthProviderProps> = ({ children }) => {\n  const [user, setUser] = useState<User | null>(null);\n  const [tenant, setTenant] = useState<Tenant | null>(null);\n  const [isLoading, setIsLoading] = useState(true);\n  const isMountedRef = React.useRef(true);\n\n  // In a multi-tenant system, authentication requires both user and tenant\n  const isAuthenticated = !!user && !!tenant;\n\n  // Initialize auth state by validating stored token and data\n  useEffect(() => {\n    const abortController = new AbortController();\n\n    const initAuth = async () => {\n      try {\n        const storedTokenData = localStorage.getItem('auth_token');\n        const storedUser = localStorage.getItem('user');\n        const storedTenant = localStorage.getItem('tenant');\n\n        if (storedTokenData && storedUser && storedTenant) {\n          // Parse token data and extract JWT token\n          let token: string;\n          try {\n            const tokenObj = JSON.parse(storedTokenData);\n            token = tokenObj?.token;\n            if (!token || typeof token !== 'string') {\n              throw new Error('Invalid token data structure');\n            }\n          } catch {\n            // Fallback for legacy plain string format (for backward compatibility)\n            token = storedTokenData;\n          }\n\n          // Decode and validate the JWT token\n          const tokenPayload = decodeJwtPayload(token);\n          if (!tokenPayload) {\n            throw new Error('Invalid stored token');\n          }\n\n          // Check if token is expired\n          const now = Math.floor(Date.now() / 1000);\n          if (tokenPayload.exp && tokenPayload.exp < now) {\n            const result = await attemptTokenRefresh(\n              storedUser,\n              storedTenant,\n              abortController.signal\n            );\n            if (result && !abortController.signal.aborted) {\n              if (!abortController.signal.aborted) {\n                localStorage.setItem('auth_token', JSON.stringify({ token: result.token }));\n                localStorage.setItem('user', JSON.stringify(result.user));\n                localStorage.setItem('tenant', JSON.stringify(result.tenant));\n              }\n              if (isMountedRef.current && !abortController.signal.aborted) {\n                setUser(result.user);\n                setTenant(result.tenant);\n              }\n            } else {\n              if (!abortController.signal.aborted) {\n                localStorage.removeItem('auth_token');\n                localStorage.removeItem('user');\n                localStorage.removeItem('tenant');\n              }\n            }\n            return;\n          } else {\n            // Validate stored user and tenant data structure\n            const parsedUser = JSON.parse(storedUser) as User;\n            const parsedTenant = JSON.parse(storedTenant) as Tenant;\n\n            const isValidUser =\n              parsedUser &&\n              typeof parsedUser.id === 'string' &&\n              parsedUser.id.trim() !== '' &&\n              typeof parsedUser.email === 'string' &&\n              parsedUser.email.trim() !== '' &&\n              typeof parsedUser.username === 'string' &&\n              parsedUser.username.trim() !== '' &&\n              Array.isArray(parsedUser.roles) &&\n              parsedUser.roles.every(role => typeof role === 'string');\n\n            const isValidTenant =\n              parsedTenant &&\n              typeof parsedTenant.id === 'string' &&\n              parsedTenant.id.trim() !== '' &&\n              typeof parsedTenant.name === 'string' &&\n              parsedTenant.name.trim() !== '' &&\n              typeof parsedTenant.settings === 'object' &&\n              parsedTenant.settings !== null;\n\n            if (isValidUser && isValidTenant) {\n              // Cross-reference with token payload if possible\n              const tokenUsername = tokenPayload.user;\n              const tokenTenantId = tokenPayload.tenant_id;\n\n              if (parsedUser.username === tokenUsername && parsedTenant.id === tokenTenantId) {\n                if (isMountedRef.current && !abortController.signal.aborted) {\n                  setUser(parsedUser);\n                  setTenant(parsedTenant);\n                }\n              } else {\n                console.warn('Token payload mismatch with stored data, clearing authentication');\n                if (!abortController.signal.aborted) {\n                  localStorage.removeItem('auth_token');\n                  localStorage.removeItem('user');\n                  localStorage.removeItem('tenant');\n                }\n              }\n            } else {\n              // Invalid data structure, clear stored data\n              console.warn('Invalid stored user/tenant data structure');\n              if (!abortController.signal.aborted) {\n                localStorage.removeItem('auth_token');\n                localStorage.removeItem('user');\n                localStorage.removeItem('tenant');\n              }\n            }\n          }\n        }\n      } catch (error) {\n        if (!abortController.signal.aborted) {\n          // Authentication initialization failed - clear all auth data\n          localStorage.removeItem('auth_token');\n          localStorage.removeItem('user');\n          localStorage.removeItem('tenant');\n          console.error('Authentication initialization failed:', error);\n        }\n      } finally {\n        if (isMountedRef.current && !abortController.signal.aborted) {\n          setIsLoading(false);\n        }\n      }\n    };\n\n    initAuth();\n\n    return () => {\n      abortController.abort();\n      isMountedRef.current = false;\n    };\n  }, []);\n\n  const login = async (credentials: LoginCredentials): Promise<void> => {\n    setIsLoading(true);\n    try {\n      // Use \"tenant1\" for demo purposes, as hardcoded in backend when tenant is missing\n      const tenantId = credentials.tenantId ?? asTenantId('tenant1');\n      const modifiedCredentials: LoginCredentials = { ...credentials, tenantId };\n      const loginResult = await authService.login(modifiedCredentials);\n\n      if (loginResult.isErr()) {\n        throw new Error(loginResult.error.message || 'Login failed');\n      }\n\n      const authPayload = loginResult.value;\n\n      if (!authPayload.success) {\n        throw new Error(authPayload.message ?? 'Login failed');\n      }\n\n      const token = authPayload.token;\n      if (!token) {\n        throw new Error('No token received from server');\n      }\n\n      localStorage.setItem('auth_token', JSON.stringify({ token }));\n\n      const tokenPayload = decodeJwtPayload(token);\n      if (!tokenPayload) {\n        throw new Error('Invalid token format');\n      }\n\n      if (!tokenPayload.user || !tokenPayload.tenant_id) {\n        throw new Error('Required fields missing in token');\n      }\n\n      const tenantIdentifier = asTenantId(tokenPayload.tenant_id);\n\n      const user: User = {\n        ...authPayload.user,\n        username: tokenPayload.user,\n        tenantId: tenantIdentifier,\n      };\n\n      const tenant: Tenant = {\n        ...authPayload.tenant,\n        id: tenantIdentifier,\n      };\n\n      setUser(user);\n      setTenant(tenant);\n\n      localStorage.setItem('user', JSON.stringify(user));\n      localStorage.setItem('tenant', JSON.stringify(tenant));\n    } catch (error: unknown) {\n      // Clear any partial data\n      localStorage.removeItem('auth_token');\n      localStorage.removeItem('user');\n      localStorage.removeItem('tenant');\n\n      console.error('Login request failed:', error);\n\n      // Re-throw with the actual error message from the server\n      if (error instanceof Error) {\n        throw error;\n      }\n\n      throw new Error('Login failed');\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const logout = async (): Promise<void> => {\n    try {\n      const logoutResult = await authService.logout();\n\n      if (logoutResult.isErr()) {\n        console.error('Server-side logout failed, clearing local data anyway:', logoutResult.error);\n      } else {\n        console.log('Server-side logout successful');\n      }\n    } catch (error) {\n      console.error('Server-side logout failed, clearing local data anyway:', error);\n    } finally {\n      // Always clear local data regardless of API call success\n      setUser(null);\n      setTenant(null);\n      localStorage.removeItem('auth_token');\n      localStorage.removeItem('user');\n      localStorage.removeItem('tenant');\n    }\n  };\n\n  const refreshToken = async (): Promise<void> => {\n    try {\n      const refreshResult = await authService.refreshToken();\n\n      if (refreshResult.isErr()) {\n        const error = refreshResult.error;\n\n        if (error.statusCode === 401 || error.statusCode === 403) {\n          console.error('Authentication failed during refresh, logging out');\n          await logout();\n          throw new Error('Authentication expired');\n        }\n\n        console.error('Token refresh failed due to transient error:', error);\n        throw new Error('Token refresh failed - please check your connection');\n      }\n\n      const refreshResponse = refreshResult.value;\n\n      if (!refreshResponse.success) {\n        console.error('Token refresh failed due to API response:', refreshResponse.message);\n        throw new Error(refreshResponse.message || 'Token refresh failed');\n      }\n\n      const newToken = refreshResponse.token;\n      if (!newToken) {\n        throw new Error('No token received from server during refresh');\n      }\n\n      localStorage.setItem('auth_token', JSON.stringify({ token: newToken }));\n      const payload = decodeJwtPayload(newToken);\n      if (!payload?.user || !payload.tenant_id) {\n        throw new Error('Invalid token payload during refresh');\n      }\n\n      const refreshedTenantId = asTenantId(payload.tenant_id);\n\n      const updatedUser: User = {\n        ...refreshResponse.user,\n        username: payload.user,\n        tenantId: refreshedTenantId,\n      };\n\n      const updatedTenant: Tenant = {\n        ...refreshResponse.tenant,\n        id: refreshedTenantId,\n      };\n\n      setUser(updatedUser);\n      setTenant(updatedTenant);\n      localStorage.setItem('user', JSON.stringify(updatedUser));\n      localStorage.setItem('tenant', JSON.stringify(updatedTenant));\n      console.log('Token refresh successful');\n    } catch (error) {\n      if (error instanceof Error) {\n        if (error.message === 'Authentication expired') {\n          throw error;\n        }\n\n        console.error('Token refresh failed:', error);\n        throw error;\n      }\n\n      console.error('Token refresh failed due to unknown error:', error);\n      throw new Error('Token refresh failed');\n    }\n  };\n\n  const value: AuthContextType = {\n    user,\n    tenant,\n    isAuthenticated,\n    isLoading,\n    login,\n    logout,\n    refreshToken,\n  };\n\n  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;\n};\n\n// Hook to use auth context\nexport const useAuth = (): AuthContextType => {\n  const context = useContext(AuthContext);\n  if (context === undefined) {\n    throw new Error('useAuth must be used within an AuthProvider');\n  }\n  return context;\n};\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/contexts/AuthContextFP.tsx",
        "messages": [
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 166,
                "column": 10,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 166,
                "endColumn": 19,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                4931,
                                4941
                            ],
                            "text": "(tokenData == null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                4932,
                                4941
                            ],
                            "text": "(tokenData ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                4931,
                                4941
                            ],
                            "text": "(!Boolean(tokenData))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 166,
                "column": 24,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 166,
                "endColumn": 32,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                4945,
                                4954
                            ],
                            "text": "(userData == null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                4946,
                                4954
                            ],
                            "text": "(userData ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                4945,
                                4954
                            ],
                            "text": "(!Boolean(userData))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 166,
                "column": 37,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 166,
                "endColumn": 47,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                4958,
                                4969
                            ],
                            "text": "(tenantData == null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                4959,
                                4969
                            ],
                            "text": "(tenantData ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                4958,
                                4969
                            ],
                            "text": "(!Boolean(tenantData))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 228,
                "column": 31,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingReturnType",
                "endLine": 228,
                "endColumn": 33
            },
            {
                "ruleId": "@typescript-eslint/no-floating-promises",
                "severity": 1,
                "message": "Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.",
                "line": 235,
                "column": 7,
                "nodeType": "ExpressionStatement",
                "messageId": "floatingVoid",
                "endLine": 301,
                "endColumn": 9,
                "suggestions": [
                    {
                        "messageId": "floatingFixVoid",
                        "fix": {
                            "range": [
                                6778,
                                6778
                            ],
                            "text": "void "
                        },
                        "desc": "Add void operator to ignore."
                    },
                    {
                        "messageId": "floatingFixAwait",
                        "fix": {
                            "range": [
                                6778,
                                6778
                            ],
                            "text": "await "
                        },
                        "desc": "Add await operator."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, value is always falsy.",
                "line": 248,
                "column": 17,
                "nodeType": "MemberExpression",
                "messageId": "alwaysFalsy",
                "endLine": 248,
                "endColumn": 47
            },
            {
                "ruleId": "@typescript-eslint/no-floating-promises",
                "severity": 1,
                "message": "Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.",
                "line": 253,
                "column": 19,
                "nodeType": "ExpressionStatement",
                "messageId": "floatingVoid",
                "endLine": 274,
                "endColumn": 21,
                "suggestions": [
                    {
                        "messageId": "floatingFixVoid",
                        "fix": {
                            "range": [
                                7428,
                                7428
                            ],
                            "text": "void "
                        },
                        "desc": "Add void operator to ignore."
                    },
                    {
                        "messageId": "floatingFixAwait",
                        "fix": {
                            "range": [
                                7428,
                                7428
                            ],
                            "text": "await "
                        },
                        "desc": "Add await operator."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, value is always truthy.",
                "line": 286,
                "column": 41,
                "nodeType": "UnaryExpression",
                "messageId": "alwaysTruthy",
                "endLine": 286,
                "endColumn": 72
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'error' is defined but never used. Allowed unused args must match /^_/u.",
                "line": 296,
                "column": 9,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 296,
                "endColumn": 14
            },
            {
                "ruleId": "@typescript-eslint/no-floating-promises",
                "severity": 1,
                "message": "Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.",
                "line": 304,
                "column": 5,
                "nodeType": "ExpressionStatement",
                "messageId": "floatingVoid",
                "endLine": 304,
                "endColumn": 16,
                "suggestions": [
                    {
                        "messageId": "floatingFixVoid",
                        "fix": {
                            "range": [
                                9243,
                                9243
                            ],
                            "text": "void "
                        },
                        "desc": "Add void operator to ignore."
                    },
                    {
                        "messageId": "floatingFixAwait",
                        "fix": {
                            "range": [
                                9243,
                                9243
                            ],
                            "text": "await "
                        },
                        "desc": "Add await operator."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'tenantId' is defined but never used. Allowed unused args must match /^_/u.",
                "line": 389,
                "column": 6,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 389,
                "endColumn": 14
            },
            {
                "ruleId": "react-refresh/only-export-components",
                "severity": 1,
                "message": "Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.",
                "line": 459,
                "column": 14,
                "nodeType": "Identifier",
                "messageId": "namedExport",
                "endLine": 459,
                "endColumn": 23
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 12,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "/**\n * @module contexts/AuthContextFP\n * @description FP-based Authentication Context with Railway-Oriented Programming\n *\n * This is the functional programming version of AuthContext using:\n * - Discriminated union types for state\n * - AsyncResult<T, E> for all async operations\n * - Pure functions and no try-catch blocks\n * - Railway-oriented programming patterns\n *\n * Can be used in parallel with AuthContext during migration via feature flags.\n *\n * @example\n * ```typescript\n * const { state, login, logout } = useAuthFP();\n *\n * state.match(\n *   {\n *     idle: () => <LoginPage />,\n *     loading: () => <Spinner />,\n *     authenticated: ({ user, tenant }) => <Dashboard user={user} />,\n *     error: ({ error }) => <ErrorAlert error={error} />,\n *   }\n * );\n * ```\n */\n\nimport React, { createContext, useContext, useState, useEffect, useCallback } from 'react';\nimport type { ReactNode } from 'react';\nimport { errAsync, okAsync } from 'neverthrow';\nimport type { AsyncResult } from '../types/fp';\nimport type { User, Tenant, LoginCredentials, AuthResponse } from '../types/auth';\nimport type { AppError } from '../types/errors';\nimport { createAuthError } from '../types/errors';\nimport { authService } from '../services/api';\nimport { asTenantId, asUserId } from '../types/ids';\nimport { decodeJwtPayload } from '../utils/parsing';\n\n/**\n * Discriminated union type for authentication state\n * Represents all possible authentication states in the system\n */\nexport type AuthStateFP =\n  | { type: 'idle' }\n  | { type: 'loading' }\n  | {\n      type: 'authenticated';\n      user: User;\n      tenant: Tenant;\n      token: string;\n    }\n  | {\n      type: 'error';\n      error: AppError;\n      previousState?: Exclude<AuthStateFP, { type: 'error' }>;\n    };\n\n/**\n * FP-based authentication context interface\n * All operations return AsyncResult for type-safe error handling\n */\nexport interface AuthContextTypeFP {\n  state: AuthStateFP;\n  login: (credentials: LoginCredentials) => AsyncResult<AuthResponse, AppError>;\n  logout: () => AsyncResult<void, AppError>;\n  switchTenant: (tenantId: string) => AsyncResult<Tenant, AppError>;\n  clearError: () => void;\n  retry: () => AsyncResult<void, AppError>;\n}\n\n/**\n * Helper: Extract user and tenant from auth response or storage\n */\nconst extractAuthData = (\n  jwtToken: string,\n  authResponse: AuthResponse\n): AsyncResult<{ user: User; tenant: Tenant; token: string }, AppError> => {\n  try {\n    const jwtResult = decodeJwtPayload(jwtToken);\n\n    if (jwtResult.isErr()) {\n      const parseError = jwtResult.error;\n      const errorDetails =\n        parseError.type === 'INVALID_JSON'\n          ? parseError.reason\n          : parseError.type === 'MISSING_JWT_FIELDS'\n            ? `Missing fields: ${parseError.fields.join(', ')}`\n            : 'Invalid JWT format';\n\n      return errAsync(\n        createAuthError('Invalid JWT token', {\n          details: errorDetails,\n        })\n      );\n    }\n\n    const jwtPayload = jwtResult.value;\n\n    const user: User = {\n      ...authResponse.user,\n      id: asUserId(jwtPayload.user),\n      username: jwtPayload.user,\n      tenantId: asTenantId(jwtPayload.tenant_id),\n    };\n\n    const tenant: Tenant = {\n      ...authResponse.tenant,\n      id: asTenantId(jwtPayload.tenant_id),\n    };\n\n    return okAsync({ user, tenant, token: jwtToken });\n  } catch (error) {\n    return errAsync(\n      createAuthError('Failed to extract auth data', {\n        error: error instanceof Error ? error.message : 'Unknown error',\n      })\n    );\n  }\n};\n\n/**\n * Helper: Validate and store authentication data\n */\nconst storeAuthData = (user: User, tenant: Tenant, token: string): AsyncResult<void, AppError> => {\n  try {\n    localStorage.setItem('auth_token', JSON.stringify({ token }));\n    localStorage.setItem('user', JSON.stringify(user));\n    localStorage.setItem('tenant', JSON.stringify(tenant));\n    return okAsync(undefined);\n  } catch (error) {\n    return errAsync(\n      createAuthError('Failed to store authentication data', {\n        error: error instanceof Error ? error.message : 'Unknown error',\n      })\n    );\n  }\n};\n\n/**\n * Helper: Clear all authentication data from storage\n */\nconst clearAuthStorage = (): AsyncResult<void, AppError> => {\n  try {\n    localStorage.removeItem('auth_token');\n    localStorage.removeItem('user');\n    localStorage.removeItem('tenant');\n    return okAsync(undefined);\n  } catch (error) {\n    return errAsync(\n      createAuthError('Failed to clear authentication data', {\n        error: error instanceof Error ? error.message : 'Unknown error',\n      })\n    );\n  }\n};\n\n/**\n * Helper: Load authentication data from storage\n */\nconst loadAuthData = (): AsyncResult<{ user: User; tenant: Tenant; token: string }, AppError> => {\n  try {\n    const tokenData = localStorage.getItem('auth_token');\n    const userData = localStorage.getItem('user');\n    const tenantData = localStorage.getItem('tenant');\n\n    if (!tokenData || !userData || !tenantData) {\n      return errAsync(createAuthError('No authentication data found in storage'));\n    }\n\n    const token = (JSON.parse(tokenData) as Record<string, unknown>).token as string;\n    const user = JSON.parse(userData) as User;\n    const tenant = JSON.parse(tenantData) as Tenant;\n\n    return okAsync({ user, tenant, token });\n  } catch (error) {\n    return errAsync(\n      createAuthError('Failed to load authentication data', {\n        error: error instanceof Error ? error.message : 'Unknown error',\n      })\n    );\n  }\n};\n\n/**\n * Helper: Check if JWT token is expired\n */\nconst isTokenExpired = (token: string): AsyncResult<boolean, AppError> => {\n  try {\n    const jwtResult = decodeJwtPayload(token);\n\n    if (jwtResult.isErr()) {\n      return okAsync(true); // Treat invalid tokens as expired\n    }\n\n    const payload = jwtResult.value;\n    const now = Math.floor(Date.now() / 1000);\n    return okAsync(payload.exp < now);\n  } catch {\n    return okAsync(true);\n  }\n};\n\n/**\n * FP-based authentication context\n */\nconst AuthContextFP = createContext<AuthContextTypeFP | undefined>(undefined);\n\nexport { AuthContextFP };\n\ninterface AuthProviderFPProps {\n  children: ReactNode;\n}\n\n/**\n * FP-based authentication provider\n * Manages authentication state using discriminated unions and Result types\n */\nexport const AuthProviderFP: React.FC<AuthProviderFPProps> = ({ children }) => {\n  const [state, setState] = useState<AuthStateFP>({ type: 'idle' });\n  const isMountedRef = React.useRef(true);\n\n  /**\n   * Initialize authentication on component mount\n   */\n  useEffect(() => {\n    const abortController = new AbortController();\n\n    const initAuth = async () => {\n      setState({ type: 'loading' });\n\n      const authResult = await loadAuthData();\n\n      if (abortController.signal.aborted) return;\n\n      authResult.match(\n        async ({ user, tenant, token }) => {\n          // Check if token is expired\n          const expiredResult = await isTokenExpired(token);\n\n          if (abortController.signal.aborted) return;\n\n          const isExpired = expiredResult.isOk() ? expiredResult.value : true;\n\n          if (isExpired) {\n            // Try to refresh token\n            const refreshResult = await authService.refreshToken();\n\n            if (abortController.signal.aborted) return;\n\n            refreshResult.match(\n              authResponse => {\n                if (isMountedRef.current && !abortController.signal.aborted) {\n                  extractAuthData(authResponse.token, authResponse).match(\n                    ({ user: refreshedUser, tenant: refreshedTenant, token: newToken }) => {\n                      if (isMountedRef.current && !abortController.signal.aborted) {\n                        storeAuthData(refreshedUser, refreshedTenant, newToken).mapErr(error => {\n                          console.error('Failed to store refreshed auth data:', error.message);\n                        });\n\n                        setState({\n                          type: 'authenticated',\n                          user: refreshedUser,\n                          tenant: refreshedTenant,\n                          token: newToken,\n                        });\n                      }\n                    },\n                    error => {\n                      if (isMountedRef.current && !abortController.signal.aborted) {\n                        clearAuthStorage();\n                        setState({ type: 'error', error });\n                      }\n                    }\n                  );\n                }\n              },\n              error => {\n                if (isMountedRef.current && !abortController.signal.aborted) {\n                  clearAuthStorage();\n                  setState({ type: 'error', error });\n                }\n              }\n            );\n          } else {\n            // Token still valid\n            if (isMountedRef.current && !abortController.signal.aborted) {\n              setState({\n                type: 'authenticated',\n                user,\n                tenant,\n                token,\n              });\n            }\n          }\n        },\n        error => {\n          if (isMountedRef.current && !abortController.signal.aborted) {\n            setState({ type: 'idle' });\n          }\n        }\n      );\n    };\n\n    initAuth();\n\n    return () => {\n      abortController.abort();\n      isMountedRef.current = false;\n    };\n  }, []);\n\n  /**\n   * Login operation\n   */\n  const login = useCallback(\n    (credentials: LoginCredentials): AsyncResult<AuthResponse, AppError> => {\n      // Update state to loading\n      setState({ type: 'loading' });\n\n      // Ensure tenant ID is set\n      const tenantId = credentials.tenantId ?? asTenantId('tenant1');\n      const modifiedCredentials = { ...credentials, tenantId };\n\n      // Execute login\n      return authService\n        .login(modifiedCredentials)\n        .andThen(authResponse => {\n          if (!authResponse.success) {\n            const error = createAuthError(authResponse.message ?? 'Login failed');\n\n            if (isMountedRef.current) {\n              setState({\n                type: 'error',\n                error,\n                previousState: { type: 'idle' },\n              });\n            }\n\n            return errAsync(error);\n          }\n\n          // Extract and store auth data\n          return extractAuthData(authResponse.token, authResponse).andThen(\n            ({ user, tenant, token }) => {\n              return storeAuthData(user, tenant, token).andThen(() => {\n                if (isMountedRef.current) {\n                  setState({\n                    type: 'authenticated',\n                    user,\n                    tenant,\n                    token,\n                  });\n                }\n\n                return okAsync(authResponse);\n              });\n            }\n          );\n        })\n        .mapErr(error => {\n          if (isMountedRef.current) {\n            setState({\n              type: 'error',\n              error,\n              previousState: { type: 'idle' },\n            });\n          }\n          return error;\n        });\n    },\n    []\n  );\n\n  /**\n   * Logout operation\n   */\n  const logout = useCallback((): AsyncResult<void, AppError> => {\n    return clearAuthStorage().map(() => {\n      if (isMountedRef.current) {\n        setState({ type: 'idle' });\n      }\n    });\n  }, []);\n\n  /**\n   * Switch tenant operation\n   */\n  const switchTenant = useCallback(\n    (tenantId: string): AsyncResult<Tenant, AppError> => {\n      if (state.type !== 'authenticated') {\n        return errAsync(\n          createAuthError('Not authenticated', {\n            currentState: state.type,\n          })\n        );\n      }\n\n      // For now, just return the current tenant\n      // In a real app, this would refresh context with new tenant\n      return okAsync(state.tenant);\n    },\n    [state]\n  );\n\n  /**\n   * Clear error state\n   */\n  const clearError = useCallback(() => {\n    if (state.type === 'error' && state.previousState) {\n      setState(state.previousState);\n    } else {\n      setState({ type: 'idle' });\n    }\n  }, [state]);\n\n  /**\n   * Retry failed operation\n   */\n  const retry = useCallback((): AsyncResult<void, AppError> => {\n    if (state.type === 'error') {\n      // Retry by reinitializing\n      setState({ type: 'loading' });\n      return okAsync(undefined);\n    }\n    return okAsync(undefined);\n  }, [state]);\n\n  return (\n    <AuthContextFP.Provider\n      value={{\n        state,\n        login,\n        logout,\n        switchTenant,\n        clearError,\n        retry,\n      }}\n    >\n      {children}\n    </AuthContextFP.Provider>\n  );\n};\n\n/**\n * Hook to use FP authentication context\n * Provides type-safe access to authentication state and operations\n *\n * @returns Authentication context with state and operations\n * @throws Error if used outside AuthProviderFP\n *\n * @example\n * ```typescript\n * const { state, login, logout } = useAuthFP();\n *\n * // Pattern match on state\n * state.type === 'authenticated' && <Dashboard user={state.user} />\n * ```\n */\nexport const useAuthFP = (): AuthContextTypeFP => {\n  const context = useContext(AuthContextFP);\n\n  if (context === undefined) {\n    throw new Error('useAuthFP must be used within AuthProviderFP');\n  }\n\n  return context;\n};\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/domain/auth.ts",
        "messages": [
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'AsyncResult' is defined but never used. Allowed unused vars must match /^_/u.",
                "line": 12,
                "column": 23,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 12,
                "endColumn": 34
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'ParseError' is defined but never used. Allowed unused vars must match /^_/u.",
                "line": 14,
                "column": 30,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 14,
                "endColumn": 40
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'ParseErrors' is defined but never used. Allowed unused vars must match /^_/u.",
                "line": 15,
                "column": 10,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 15,
                "endColumn": 21
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, value is always falsy.",
                "line": 71,
                "column": 9,
                "nodeType": "UnaryExpression",
                "messageId": "alwaysFalsy",
                "endLine": 71,
                "endColumn": 27
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected object value in conditional. The condition is always true.",
                "line": 71,
                "column": 10,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorObject",
                "endLine": 71,
                "endColumn": 27
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, value is always falsy.",
                "line": 71,
                "column": 31,
                "nodeType": "UnaryExpression",
                "messageId": "alwaysFalsy",
                "endLine": 71,
                "endColumn": 51
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected object value in conditional. The condition is always true.",
                "line": 71,
                "column": 32,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorObject",
                "endLine": 71,
                "endColumn": 51
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 124,
                "column": 10,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 124,
                "endColumn": 26,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                3639,
                                3656
                            ],
                            "text": "payloadBase64Url == null"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                3640,
                                3656
                            ],
                            "text": "(payloadBase64Url ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                3639,
                                3656
                            ],
                            "text": "!Boolean(payloadBase64Url)"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, value is always truthy.",
                "line": 234,
                "column": 11,
                "nodeType": "MemberExpression",
                "messageId": "alwaysTruthy",
                "endLine": 234,
                "endColumn": 28
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected object value in conditional. The condition is always true.",
                "line": 234,
                "column": 11,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorObject",
                "endLine": 234,
                "endColumn": 28
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, value is always truthy.",
                "line": 235,
                "column": 11,
                "nodeType": "MemberExpression",
                "messageId": "alwaysTruthy",
                "endLine": 235,
                "endColumn": 30
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected object value in conditional. The condition is always true.",
                "line": 235,
                "column": 11,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorObject",
                "endLine": 235,
                "endColumn": 30
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected object value in conditional. The condition is always true.",
                "line": 265,
                "column": 8,
                "nodeType": "ChainExpression",
                "messageId": "conditionErrorObject",
                "endLine": 265,
                "endColumn": 24
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary optional chain on a non-nullish value.",
                "line": 265,
                "column": 20,
                "nodeType": "MemberExpression",
                "messageId": "neverOptionalChain",
                "endLine": 265,
                "endColumn": 22,
                "suggestions": [
                    {
                        "messageId": "suggestRemoveOptionalChain",
                        "fix": {
                            "range": [
                                7658,
                                7660
                            ],
                            "text": "."
                        },
                        "desc": "Remove unnecessary optional chain"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected object value in conditional. The condition is always true.",
                "line": 270,
                "column": 8,
                "nodeType": "ChainExpression",
                "messageId": "conditionErrorObject",
                "endLine": 270,
                "endColumn": 26
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary optional chain on a non-nullish value.",
                "line": 270,
                "column": 22,
                "nodeType": "MemberExpression",
                "messageId": "neverOptionalChain",
                "endLine": 270,
                "endColumn": 24,
                "suggestions": [
                    {
                        "messageId": "suggestRemoveOptionalChain",
                        "fix": {
                            "range": [
                                7762,
                                7764
                            ],
                            "text": "."
                        },
                        "desc": "Remove unnecessary optional chain"
                    }
                ]
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 16,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "/**\n * Authentication Domain Logic\n *\n * Pure functions for authentication operations using Railway-Oriented Programming.\n * All functions return Result<T, E> for explicit error handling.\n *\n * This module extracts business logic from the AuthContext and service layer,\n * making it pure, testable, and composable.\n */\n\nimport { ok, err } from 'neverthrow';\nimport type { Result, AsyncResult } from '../types/fp';\nimport type { User, Tenant, LoginCredentials, AuthResponse, TokenPayload } from '../types/auth';\nimport type { AuthFlowError, ParseError } from '../types/errors';\nimport { ParseErrors } from '../types/errors';\n\n/**\n * Session represents an authenticated user session\n */\nexport interface Session {\n  readonly user: User;\n  readonly tenant: Tenant;\n  readonly token: string;\n  readonly refreshToken: string;\n  readonly expiresAt: Date;\n  readonly issuedAt: Date;\n}\n\n/**\n * Token errors\n */\nexport type TokenError =\n  | { type: 'EXPIRED'; expiresAt: Date; now: Date }\n  | { type: 'INVALID_FORMAT'; reason: string }\n  | { type: 'MISSING_CLAIMS'; claims: string[] }\n  | { type: 'VERIFICATION_FAILED'; reason: string };\n\n/**\n * Session errors\n */\nexport type SessionError =\n  | { type: 'EXPIRED'; expiresAt: Date }\n  | { type: 'INVALID_TOKEN'; reason: string }\n  | { type: 'REFRESH_FAILED'; reason: string }\n  | { type: 'USER_NOT_FOUND' }\n  | { type: 'TENANT_NOT_FOUND' };\n\n/**\n * Authenticate a user with credentials\n *\n * This is a pure function that transforms credentials and auth response\n * into a session. The actual API call should be done separately.\n *\n * @param credentials - User login credentials\n * @param authResponse - Response from authentication API\n * @returns Result containing Session or AuthFlowError\n */\nexport function authenticateUser(\n  credentials: LoginCredentials,\n  authResponse: AuthResponse\n): Result<Session, AuthFlowError> {\n  try {\n    // Validate auth response structure\n    if (!authResponse.token || !authResponse.refreshToken) {\n      return err({\n        type: 'INVALID_CREDENTIALS',\n        message: 'Invalid authentication response: missing tokens',\n      });\n    }\n\n    if (!authResponse.user || !authResponse.tenant) {\n      return err({\n        type: 'INVALID_CREDENTIALS',\n        message: 'Invalid authentication response: missing user or tenant data',\n      });\n    }\n\n    // Calculate expiration time\n    const issuedAt = new Date();\n    const expiresAt = new Date(issuedAt.getTime() + authResponse.expiresIn * 1000);\n\n    // Create session\n    const session: Session = {\n      user: authResponse.user,\n      tenant: authResponse.tenant,\n      token: authResponse.token,\n      refreshToken: authResponse.refreshToken,\n      expiresAt,\n      issuedAt,\n    };\n\n    return ok(session);\n  } catch (error) {\n    return err({\n      type: 'SERVER_ERROR',\n      statusCode: 500,\n      message: `Authentication failed: ${error instanceof Error ? error.message : 'Unknown error'}`,\n    });\n  }\n}\n\n/**\n * Verify and decode a JWT token\n *\n * This function validates token format and extracts payload.\n * Actual signature verification should be done server-side.\n *\n * @param token - JWT token string\n * @returns Result containing TokenPayload or TokenError\n */\nexport function verifyToken(token: string): Result<TokenPayload, TokenError> {\n  try {\n    // Validate token format (should have 3 parts separated by dots)\n    const parts = token.split('.');\n    if (parts.length !== 3) {\n      return err({\n        type: 'INVALID_FORMAT',\n        reason: 'JWT must have 3 parts separated by dots',\n      });\n    }\n\n    // Decode payload (middle part)\n    const payloadBase64Url = parts[1];\n    if (!payloadBase64Url) {\n      return err({\n        type: 'INVALID_FORMAT',\n        reason: 'JWT payload part is missing',\n      });\n    }\n    let normalizedPayload = payloadBase64Url.replace(/-/g, '+').replace(/_/g, '/');\n    while (normalizedPayload.length % 4 !== 0) {\n      normalizedPayload += '=';\n    }\n\n    const payloadJson = atob(normalizedPayload);\n    const payload = JSON.parse(payloadJson) as TokenPayload;\n\n    // Validate required claims\n    const requiredClaims = ['sub', 'email', 'tenantId', 'iat', 'exp'];\n    const missingClaims = requiredClaims.filter(claim => !(claim in payload));\n\n    if (missingClaims.length > 0) {\n      return err({\n        type: 'MISSING_CLAIMS',\n        claims: missingClaims,\n      });\n    }\n\n    // Check expiration\n    const now = Date.now() / 1000; // Convert to seconds\n    if (payload.exp < now) {\n      return err({\n        type: 'EXPIRED',\n        expiresAt: new Date(payload.exp * 1000),\n        now: new Date(now * 1000),\n      });\n    }\n\n    return ok(payload);\n  } catch (error) {\n    return err({\n      type: 'INVALID_FORMAT',\n      reason: error instanceof Error ? error.message : 'Failed to parse JWT',\n    });\n  }\n}\n\n/**\n * Check if a session is expired\n *\n * @param session - Current session\n * @returns true if session is expired\n */\nexport function isSessionExpired(session: Session): boolean {\n  return new Date() > session.expiresAt;\n}\n\n/**\n * Check if a session needs refresh (within 5 minutes of expiration)\n *\n * @param session - Current session\n * @returns true if session should be refreshed\n */\nexport function shouldRefreshSession(session: Session): boolean {\n  const fiveMinutes = 5 * 60 * 1000;\n  const timeUntilExpiry = session.expiresAt.getTime() - Date.now();\n  return timeUntilExpiry < fiveMinutes && timeUntilExpiry > 0;\n}\n\n/**\n * Refresh an existing session\n *\n * This is a pure function that transforms old session and new auth response\n * into a refreshed session. The actual API call should be done separately.\n *\n * @param oldSession - Current session\n * @param authResponse - Response from refresh token API\n * @returns Result containing new Session or SessionError\n */\nexport function refreshSession(\n  oldSession: Session,\n  authResponse: AuthResponse\n): Result<Session, SessionError> {\n  try {\n    // Validate auth response structure\n    if (!authResponse.token || !authResponse.refreshToken) {\n      return err({\n        type: 'REFRESH_FAILED',\n        reason: 'Invalid refresh response: missing tokens',\n      });\n    }\n\n    // Verify token to ensure it's valid\n    const tokenResult = verifyToken(authResponse.token);\n    if (tokenResult.isErr()) {\n      return err({\n        type: 'INVALID_TOKEN',\n        reason: `Token verification failed: ${tokenResult.error.type}`,\n      });\n    }\n\n    // Calculate new expiration time\n    const issuedAt = new Date();\n    const expiresAt = new Date(issuedAt.getTime() + authResponse.expiresIn * 1000);\n\n    // Create new session with updated tokens\n    const newSession: Session = {\n      ...oldSession,\n      token: authResponse.token,\n      refreshToken: authResponse.refreshToken,\n      expiresAt,\n      issuedAt,\n      // Update user and tenant if provided in response\n      ...(authResponse.user && { user: authResponse.user }),\n      ...(authResponse.tenant && { tenant: authResponse.tenant }),\n    };\n\n    return ok(newSession);\n  } catch (error) {\n    return err({\n      type: 'REFRESH_FAILED',\n      reason: error instanceof Error ? error.message : 'Unknown error during refresh',\n    });\n  }\n}\n\n/**\n * Validate session integrity\n *\n * Checks if session has all required fields and is not expired\n *\n * @param session - Session to validate\n * @returns Result containing Session or SessionError\n */\nexport function validateSession(session: Session): Result<Session, SessionError> {\n  // Check if session is expired\n  if (isSessionExpired(session)) {\n    return err({\n      type: 'EXPIRED',\n      expiresAt: session.expiresAt,\n    });\n  }\n\n  // Validate user data\n  if (!session.user?.id) {\n    return err({ type: 'USER_NOT_FOUND' });\n  }\n\n  // Validate tenant data\n  if (!session.tenant?.id) {\n    return err({ type: 'TENANT_NOT_FOUND' });\n  }\n\n  // Validate tokens\n  const tokenResult = verifyToken(session.token);\n  if (tokenResult.isErr()) {\n    return err({\n      type: 'INVALID_TOKEN',\n      reason: `Token verification failed: ${tokenResult.error.type}`,\n    });\n  }\n\n  return ok(session);\n}\n\n/**\n * Extract tenant ID from token\n *\n * @param token - JWT token\n * @returns Result containing tenant ID or TokenError\n */\nexport function extractTenantId(token: string): Result<string, TokenError> {\n  return verifyToken(token).map(payload => payload.tenantId);\n}\n\n/**\n * Extract user ID from token\n *\n * @param token - JWT token\n * @returns Result containing user ID or TokenError\n */\nexport function extractUserId(token: string): Result<string, TokenError> {\n  return verifyToken(token).map(payload => payload.sub);\n}\n\n/**\n * Check if user has required role\n *\n * @param session - Current session\n * @param requiredRole - Role to check for\n * @returns true if user has the role\n */\nexport function hasRole(session: Session, requiredRole: string): boolean {\n  return session.user.roles.includes(requiredRole);\n}\n\n/**\n * Check if user has any of the required roles\n *\n * @param session - Current session\n * @param requiredRoles - Roles to check for\n * @returns true if user has at least one role\n */\nexport function hasAnyRole(session: Session, requiredRoles: string[]): boolean {\n  return requiredRoles.some(role => session.user.roles.includes(role));\n}\n\n/**\n * Check if user has all required roles\n *\n * @param session - Current session\n * @param requiredRoles - Roles to check for\n * @returns true if user has all roles\n */\nexport function hasAllRoles(session: Session, requiredRoles: string[]): boolean {\n  return requiredRoles.every(role => session.user.roles.includes(role));\n}\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/domain/contacts.ts",
        "messages": [],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 0,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/domain/index.ts",
        "messages": [],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 0,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/domain/rules/__tests__/authRules.test.ts",
        "messages": [
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 6,
                "column": 26,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingReturnType",
                "endLine": 6,
                "endColumn": 28
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.",
                "line": 10,
                "column": 3,
                "nodeType": "MemberExpression",
                "messageId": "neverNullish",
                "endLine": 10,
                "endColumn": 19
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.",
                "line": 11,
                "column": 3,
                "nodeType": "MemberExpression",
                "messageId": "neverNullish",
                "endLine": 11,
                "endColumn": 20
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.",
                "line": 12,
                "column": 3,
                "nodeType": "MemberExpression",
                "messageId": "neverNullish",
                "endLine": 12,
                "endColumn": 27
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.",
                "line": 13,
                "column": 3,
                "nodeType": "MemberExpression",
                "messageId": "neverNullish",
                "endLine": 13,
                "endColumn": 27
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.",
                "line": 14,
                "column": 3,
                "nodeType": "MemberExpression",
                "messageId": "neverNullish",
                "endLine": 14,
                "endColumn": 39
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 17,
                "column": 32,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingReturnType",
                "endLine": 17,
                "endColumn": 34
            },
            {
                "ruleId": "@typescript-eslint/require-await",
                "severity": 1,
                "message": "Async arrow function 'stubFetch' has no 'await' expression.",
                "line": 33,
                "column": 67,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingAwait",
                "endLine": 33,
                "endColumn": 69,
                "suggestions": [
                    {
                        "messageId": "removeAsync",
                        "fix": {
                            "range": [
                                1153,
                                1159
                            ],
                            "text": ""
                        },
                        "desc": "Remove 'async'."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-base-to-string",
                "severity": 1,
                "message": "'input' may use Object's default stringification format ('[object Object]') when stringified.",
                "line": 35,
                "column": 21,
                "nodeType": "Identifier",
                "messageId": "baseToString",
                "endLine": 35,
                "endColumn": 26
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 9,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "import { describe, it, expect, beforeEach } from 'bun:test';\nimport { createHash } from 'node:crypto';\n\ntype FetchStub = (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;\n\nconst ensureTestEnv = () => {\n  const meta = import.meta as unknown as { env?: Record<string, string> };\n  meta.env ??= {};\n  const env = meta.env;\n  env.VITE_API_URL ??= 'https://example.test/api';\n  env.VITE_APP_NAME ??= 'Test App';\n  env.VITE_JWT_STORAGE_KEY ??= 'auth_token';\n  env.VITE_DEFAULT_COUNTRY ??= 'US';\n  env.VITE_ENABLE_PWNED_PASSWORD_CHECK ??= 'true';\n};\n\nconst loadAuthRules = async () => {\n  ensureTestEnv();\n  return import('../authRules');\n};\n\ndescribe('validatePasswordStrength breach detection', () => {\n  beforeEach(ensureTestEnv);\n\n  it('rejects passwords present in HIBP results', async () => {\n    const { validatePasswordStrength, DEFAULT_PASSWORD_REQUIREMENTS } = await loadAuthRules();\n    const password = 'Password123!';\n    const hash = createHash('sha1').update(password).digest('hex').toUpperCase();\n    const prefix = hash.slice(0, 5);\n    const suffix = hash.slice(5);\n    let callCount = 0;\n\n    const stubFetch: FetchStub = async (input: RequestInfo | URL) => {\n      callCount += 1;\n      expect(String(input)).toContain(`/range/${prefix}`);\n      return new Response(`${suffix}:42\\n`);\n    };\n\n    const result = await validatePasswordStrength(\n      password,\n      DEFAULT_PASSWORD_REQUIREMENTS,\n      undefined,\n      {\n        enabled: true,\n        endpoint: 'https://pwned.test/range',\n        cacheTtlMs: 1000,\n        requestTimeoutMs: 1000,\n        maxRetries: 0,\n        initialBackoffMs: 1,\n        maxBackoffMs: 1,\n        backoffFactor: 1,\n        rateLimitIntervalMs: 0,\n        userAgent: 'test-suite',\n        fetchImplementation: stubFetch,\n      }\n    );\n\n    expect(callCount).toBe(1);\n    expect(result.isErr()).toBe(true);\n    if (result.isErr()) {\n      expect(result.error.type).toBe('COMMON_PASSWORD');\n      if (result.error.type === 'COMMON_PASSWORD') {\n        expect(result.error.source).toBe('REMOTE');\n        expect(result.error.occurrences).toBe(42);\n      }\n    }\n  });\n\n  it('uses local fallback when remote checks are disabled', async () => {\n    const { validatePasswordStrength, DEFAULT_PASSWORD_REQUIREMENTS } = await loadAuthRules();\n    const result = await validatePasswordStrength(\n      'Password1!',\n      DEFAULT_PASSWORD_REQUIREMENTS,\n      undefined,\n      {\n        enabled: false,\n      }\n    );\n\n    expect(result.isErr()).toBe(true);\n    if (result.isErr()) {\n      expect(result.error.type).toBe('COMMON_PASSWORD');\n      if (result.error.type === 'COMMON_PASSWORD') {\n        expect(result.error.source).toBe('LOCAL');\n      }\n    }\n  });\n\n  it('falls back to local data when remote request fails', async () => {\n    const { validatePasswordStrength, DEFAULT_PASSWORD_REQUIREMENTS } = await loadAuthRules();\n    const failingFetch: FetchStub = async () => Promise.reject(new Error('network offline'));\n\n    const result = await validatePasswordStrength(\n      'Password1!',\n      DEFAULT_PASSWORD_REQUIREMENTS,\n      undefined,\n      {\n        enabled: true,\n        endpoint: 'https://pwned.test/range',\n        cacheTtlMs: 1000,\n        requestTimeoutMs: 1000,\n        maxRetries: 0,\n        initialBackoffMs: 1,\n        maxBackoffMs: 1,\n        backoffFactor: 1,\n        rateLimitIntervalMs: 0,\n        userAgent: 'test-suite',\n        fetchImplementation: failingFetch,\n      }\n    );\n\n    expect(result.isErr()).toBe(true);\n    if (result.isErr()) {\n      expect(result.error.type).toBe('COMMON_PASSWORD');\n      if (result.error.type === 'COMMON_PASSWORD') {\n        expect(result.error.source).toBe('LOCAL');\n      }\n    }\n  });\n\n  it('logs a warning but allows strong passwords when remote data is unavailable', async () => {\n    const { validatePasswordStrength, DEFAULT_PASSWORD_REQUIREMENTS } = await loadAuthRules();\n    const warnings: string[] = [];\n    const originalWarn = console.warn;\n    console.warn = (...args: unknown[]) => {\n      warnings.push(args.map(String).join(' '));\n    };\n\n    try {\n      const silentFetch: FetchStub = async () => Promise.reject(new Error('timeout'));\n\n      const result = await validatePasswordStrength(\n        'Complex!Passw0rd',\n        DEFAULT_PASSWORD_REQUIREMENTS,\n        undefined,\n        {\n          enabled: true,\n          endpoint: 'https://pwned.test/range',\n          cacheTtlMs: 1000,\n          requestTimeoutMs: 1000,\n          maxRetries: 0,\n          initialBackoffMs: 1,\n          maxBackoffMs: 1,\n          backoffFactor: 1,\n          rateLimitIntervalMs: 0,\n          userAgent: 'test-suite',\n          fetchImplementation: silentFetch,\n        }\n      );\n\n      expect(result.isOk()).toBe(true);\n      expect(warnings.length).toBeGreaterThan(0);\n    } finally {\n      console.warn = originalWarn;\n    }\n  });\n});\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/domain/rules/authRules.ts",
        "messages": [
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'error' is defined but never used. Allowed unused caught errors must match /^_/u.",
                "line": 292,
                "column": 14,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 292,
                "endColumn": 19
            },
            {
                "ruleId": "@typescript-eslint/restrict-template-expressions",
                "severity": 1,
                "message": "Invalid type \"number\" of template literal expression.",
                "line": 435,
                "column": 55,
                "nodeType": "MemberExpression",
                "messageId": "invalidType",
                "endLine": 435,
                "endColumn": 70
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 454,
                "column": 12,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 454,
                "endColumn": 18,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                11449,
                                11456
                            ],
                            "text": "(suffix == null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                11450,
                                11456
                            ],
                            "text": "(suffix ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                11449,
                                11456
                            ],
                            "text": "(!Boolean(suffix))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 454,
                "column": 23,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 454,
                "endColumn": 28,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                11460,
                                11466
                            ],
                            "text": "(count == null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                11461,
                                11466
                            ],
                            "text": "(count ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                11460,
                                11466
                            ],
                            "text": "(!Boolean(count))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??=`) instead of an assignment expression, as it is simpler to read.",
                "line": 488,
                "column": 3,
                "nodeType": "IfStatement",
                "messageId": "preferNullishOverAssignment",
                "endLine": 492,
                "endColumn": 4,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": "="
                        },
                        "fix": {
                            "range": [
                                12428,
                                12593
                            ],
                            "text": "cachedDefaultPwnedPasswordChecker ??= new PwnedPasswordChecker(\n      createDefaultPasswordBreachCheckConfig()\n    );"
                        },
                        "desc": "Fix to nullish coalescing operator (`??=`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, value is always falsy.",
                "line": 500,
                "column": 7,
                "nodeType": "UnaryExpression",
                "messageId": "alwaysFalsy",
                "endLine": 500,
                "endColumn": 16
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected object value in conditional. The condition is always true.",
                "line": 500,
                "column": 8,
                "nodeType": "Identifier",
                "messageId": "conditionErrorObject",
                "endLine": 500,
                "endColumn": 16
            },
            {
                "ruleId": "@typescript-eslint/require-await",
                "severity": 1,
                "message": "Async function 'getSubtleCrypto' has no 'await' expression.",
                "line": 521,
                "column": 1,
                "nodeType": "FunctionDeclaration",
                "messageId": "missingAwait",
                "endLine": 521,
                "endColumn": 31,
                "suggestions": [
                    {
                        "messageId": "removeAsync",
                        "fix": {
                            "range": [
                                13330,
                                13385
                            ],
                            "text": "function getSubtleCrypto(): SubtleCrypto"
                        },
                        "desc": "Remove 'async'."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, value is always truthy.",
                "line": 522,
                "column": 44,
                "nodeType": "ChainExpression",
                "messageId": "alwaysTruthy",
                "endLine": 522,
                "endColumn": 69
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected object value in conditional. The condition is always true.",
                "line": 522,
                "column": 44,
                "nodeType": "ChainExpression",
                "messageId": "conditionErrorObject",
                "endLine": 522,
                "endColumn": 69
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary optional chain on a non-nullish value.",
                "line": 522,
                "column": 61,
                "nodeType": "MemberExpression",
                "messageId": "neverOptionalChain",
                "endLine": 522,
                "endColumn": 63,
                "suggestions": [
                    {
                        "messageId": "suggestRemoveOptionalChain",
                        "fix": {
                            "range": [
                                13448,
                                13450
                            ],
                            "text": "."
                        },
                        "desc": "Remove unnecessary optional chain"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 589,
                "column": 7,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 589,
                "endColumn": 15,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                15381,
                                15389
                            ],
                            "text": "(username != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                15381,
                                15389
                            ],
                            "text": "(username ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                15381,
                                15389
                            ],
                            "text": "(Boolean(username))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 604,
                "column": 7,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 604,
                "endColumn": 27,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                15806,
                                15826
                            ],
                            "text": "breachResult.warning != null"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                15806,
                                15826
                            ],
                            "text": "breachResult.warning ?? \"\""
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                15806,
                                15826
                            ],
                            "text": "Boolean(breachResult.warning)"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 13,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "/**\n * Authentication Business Rules\n *\n * Pure business logic for authentication-related operations.\n * These rules define password policies, session timeouts, and auth requirements.\n */\n\nimport type { Result } from 'neverthrow';\nimport { ok, err } from 'neverthrow';\n\nimport { getEnv } from '@/config/env';\nimport { getCommonPasswords } from '@/utils/commonPasswordsLoader';\n\n/**\n * Fallback common passwords used when the main password list is unavailable\n * Curated list of realistic frequent/common passwords (3-12 chars) from real-world breach data\n * Note: This fallback is manually curated to common real-world breaches, while the primary\n * list is sourced from external breach databases\n */\nexport const FALLBACK_COMMON_PASSWORDS = [\n  '123456',\n  'password',\n  '123456789',\n  '12345678',\n  '12345',\n  '1234567',\n  '1234567890',\n  'qwerty',\n  'abc123',\n  '111111',\n  '123123',\n  'admin',\n  'letmein',\n  'welcome',\n  'monkey',\n  '1234',\n  'dragon',\n  '555555',\n  'passw0rd',\n  'master',\n  'hello',\n  'freedom',\n  'whatever',\n  'qazwsx',\n  'trustno1',\n  '654321',\n  'jordan23',\n  'harley',\n  'password1',\n  '123qwe',\n  'robert',\n  'matthew',\n  'jordan',\n  'asshole',\n  'daniel',\n  'andrew',\n  'charles',\n  'michael',\n  'shadow',\n  'jennifer',\n  'joshua',\n  'superman',\n  'hunter',\n  'buster',\n  'soccer',\n  'hockey',\n  'killer',\n  'george',\n  'sexy',\n  'andrea',\n  'charlie',\n  'aassdd',\n  'qwer1234',\n  'password123',\n  'admin123',\n  'root',\n  'toor',\n  'guest',\n  'user',\n  'test',\n  'login',\n  '123',\n  '321',\n  '666666',\n  '888888',\n  '000000',\n  'iloveyou',\n  'princess',\n  'rockyou',\n  'sunshine',\n  'football',\n  'baseball',\n  'welcome123',\n  'qwerty123',\n  'qwertyuiop',\n  'asdfgh',\n  'zxcvbn',\n  '1q2w3e4r',\n  '1qaz2wsx',\n  'qwerty1',\n  '123321',\n  'password12',\n  'password1234',\n  'admin1',\n  'admin1234',\n  'root123',\n  'guest123',\n  'test123',\n  'user123',\n  'login123',\n  'welcome1',\n  'iloveyou1',\n  'princess1',\n  'sunshine1',\n  'michael1',\n  'football1',\n  'baseball1',\n  'qwerty12',\n  'asdfgh1',\n  'zxcvbn1',\n  '1q2w3e',\n  '1qaz2w',\n  'qwerty1234',\n  'asdfghjkl',\n  'zxcvbnm',\n  'qwertyui',\n  'asdfghjk',\n  'zxcvbnm1',\n];\n\n/**\n * Password strength requirements\n */\nexport interface PasswordRequirements {\n  minLength: number;\n  requireUppercase: boolean;\n  requireLowercase: boolean;\n  requireNumbers: boolean;\n  requireSpecialChars: boolean;\n  minSpecialChars: number;\n  maxLength: number;\n}\n\n/**\n * Default password requirements\n */\nexport const DEFAULT_PASSWORD_REQUIREMENTS: PasswordRequirements = {\n  minLength: 8,\n  requireUppercase: true,\n  requireLowercase: true,\n  requireNumbers: true,\n  requireSpecialChars: true,\n  minSpecialChars: 1,\n  maxLength: 128,\n};\n\n/**\n * Password validation error\n */\nexport type PasswordValidationError =\n  | { type: 'TOO_SHORT'; minLength: number; actualLength: number }\n  | { type: 'TOO_LONG'; maxLength: number; actualLength: number }\n  | { type: 'MISSING_UPPERCASE' }\n  | { type: 'MISSING_LOWERCASE' }\n  | { type: 'MISSING_NUMBERS' }\n  | { type: 'MISSING_SPECIAL_CHARS'; required: number }\n  | { type: 'COMMON_PASSWORD'; source: 'REMOTE' | 'LOCAL'; occurrences?: number }\n  | { type: 'CONTAINS_USERNAME' };\n\n/**\n * Session timeout configuration\n */\nexport interface SessionTimeoutConfig {\n  /** Idle timeout in minutes */\n  idleTimeout: number;\n  /** Absolute timeout in hours */\n  absoluteTimeout: number;\n  /** Warning before timeout in minutes */\n  warningBeforeTimeout: number;\n}\n\n/**\n * Default session timeout configuration\n */\nexport const DEFAULT_SESSION_TIMEOUT: SessionTimeoutConfig = {\n  idleTimeout: 30, // 30 minutes of inactivity\n  absoluteTimeout: 8, // 8 hours max session\n  warningBeforeTimeout: 5, // warn 5 minutes before timeout\n};\n\ntype FetchImplementation = (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;\n\ninterface PasswordBreachCheckOutcome {\n  compromised: boolean;\n  occurrences?: number;\n  source: 'REMOTE' | 'LOCAL';\n  warning?: string;\n}\n\nexport interface PasswordBreachCheckConfig {\n  enabled: boolean;\n  endpoint: string;\n  cacheTtlMs: number;\n  requestTimeoutMs: number;\n  maxRetries: number;\n  initialBackoffMs: number;\n  maxBackoffMs: number;\n  backoffFactor: number;\n  rateLimitIntervalMs: number;\n  userAgent: string;\n  fetchImplementation?: FetchImplementation;\n}\n\nconst createDefaultPasswordBreachCheckConfig = (): PasswordBreachCheckConfig => {\n  const env = getEnv();\n  return {\n    enabled: env.enablePwnedPasswordCheck,\n    endpoint: 'https://api.pwnedpasswords.com/range',\n    cacheTtlMs: 5 * 60 * 1000,\n    requestTimeoutMs: 5000,\n    maxRetries: 2,\n    initialBackoffMs: 500,\n    maxBackoffMs: 4000,\n    backoffFactor: 2,\n    rateLimitIntervalMs: 1500,\n    userAgent: `${env.appName}/password-breach-check`,\n  };\n};\n\n/**\n * Get the common passwords list\n * Loads from external source with fallback to built-in list\n */\nlet commonPasswordsCache: readonly string[] | null = null;\nlet commonPasswordsPromise: Promise<readonly string[]> | null = null;\n\nasync function getCommonPasswordsList(): Promise<readonly string[]> {\n  if (commonPasswordsCache) {\n    return commonPasswordsCache;\n  }\n\n  if (commonPasswordsPromise) {\n    return commonPasswordsPromise;\n  }\n\n  commonPasswordsPromise = getCommonPasswords();\n  try {\n    commonPasswordsCache = await commonPasswordsPromise;\n  } finally {\n    commonPasswordsPromise = null;\n  }\n\n  return commonPasswordsCache;\n}\n\n/**\n * Preload common passwords for synchronous access\n * Call this during app initialization\n */\nexport async function preloadCommonPasswords(): Promise<void> {\n  await getCommonPasswordsList();\n}\n\n/**\n * Check if password is in common passwords list (synchronous, requires preload)\n */\nexport function isCommonPassword(password: string): boolean {\n  if (!commonPasswordsCache) {\n    // Fallback to minimal list if not preloaded\n    return FALLBACK_COMMON_PASSWORDS.includes(password.toLowerCase());\n  }\n  return commonPasswordsCache.includes(password.toLowerCase());\n}\n\nclass PwnedPasswordChecker {\n  private readonly options: PasswordBreachCheckConfig;\n\n  private readonly cache = new Map<string, { expiresAt: number; suffixes: Map<string, number> }>();\n\n  private readonly pending = new Map<string, Promise<Map<string, number>>>();\n\n  private lastRequestTimestamp = 0;\n\n  constructor(options: PasswordBreachCheckConfig) {\n    this.options = options;\n  }\n\n  private async isPasswordLocallyCompromised(password: string): Promise<boolean> {\n    try {\n      const commonPasswords = await getCommonPasswordsList();\n      return commonPasswords.includes(password.toLowerCase());\n    } catch (error) {\n      // Fallback to a minimal hardcoded list if loading fails\n      return FALLBACK_COMMON_PASSWORDS.includes(password.toLowerCase());\n    }\n  }\n\n  async isCompromised(password: string): Promise<PasswordBreachCheckOutcome> {\n    const localCompromised = await this.isPasswordLocallyCompromised(password);\n\n    if (!this.options.enabled) {\n      return {\n        compromised: localCompromised,\n        source: localCompromised ? 'LOCAL' : 'REMOTE',\n        warning: 'Remote breach checking disabled by configuration.',\n      };\n    }\n\n    try {\n      const hash = await sha1Hex(password);\n      const prefix = hash.slice(0, 5);\n      const suffix = hash.slice(5);\n      const suffixes = await this.fetchPrefix(prefix);\n      const occurrences = suffixes.get(suffix);\n\n      if (occurrences !== undefined) {\n        return {\n          compromised: true,\n          occurrences,\n          source: 'REMOTE',\n        };\n      }\n\n      if (localCompromised) {\n        return {\n          compromised: true,\n          source: 'LOCAL',\n        };\n      }\n\n      return {\n        compromised: false,\n        source: 'REMOTE',\n      };\n    } catch (error) {\n      const warning =\n        error instanceof Error\n          ? error.message\n          : 'Unknown error when querying Have I Been Pwned API';\n      console.warn('[AuthRules] Falling back to local password breach list:', warning);\n\n      return {\n        compromised: localCompromised,\n        source: 'LOCAL',\n        warning,\n      };\n    }\n  }\n\n  private async fetchPrefix(prefix: string): Promise<Map<string, number>> {\n    const now = Date.now();\n    const cached = this.cache.get(prefix);\n\n    if (cached && cached.expiresAt > now) {\n      return cached.suffixes;\n    }\n\n    const inFlight = this.pending.get(prefix);\n    if (inFlight) {\n      return inFlight;\n    }\n\n    const requestPromise = this.requestWithRetry(prefix)\n      .then(result => {\n        this.cache.set(prefix, {\n          suffixes: result,\n          expiresAt: Date.now() + this.options.cacheTtlMs,\n        });\n        return result;\n      })\n      .finally(() => {\n        this.pending.delete(prefix);\n      });\n\n    this.pending.set(prefix, requestPromise);\n    return requestPromise;\n  }\n\n  private async requestWithRetry(prefix: string): Promise<Map<string, number>> {\n    let attempt = 0;\n    let backoffDelay = this.options.initialBackoffMs;\n    let lastError: unknown;\n\n    // Loop continues while attempt <= maxRetries, resulting in (maxRetries + 1) total attempts.\n    // For example, if maxRetries=3, attempts are: 0, 1, 2, 3 (4 total attempts)\n    // This is intentional: maxRetries controls additional retries beyond the first attempt.\n    while (attempt <= this.options.maxRetries) {\n      try {\n        await this.applyRateLimit();\n        return await this.performRequest(prefix);\n      } catch (error) {\n        lastError = error;\n        attempt += 1;\n        if (attempt > this.options.maxRetries) {\n          break;\n        }\n        await this.delay(Math.min(backoffDelay, this.options.maxBackoffMs));\n        backoffDelay = Math.min(\n          backoffDelay * this.options.backoffFactor,\n          this.options.maxBackoffMs\n        );\n      }\n    }\n\n    throw lastError instanceof Error ? lastError : new Error(String(lastError));\n  }\n\n  private async performRequest(prefix: string): Promise<Map<string, number>> {\n    const controller = typeof AbortController === 'undefined' ? undefined : new AbortController();\n    const timeoutId =\n      controller && this.options.requestTimeoutMs > 0\n        ? setTimeout(() => {\n            controller.abort();\n          }, this.options.requestTimeoutMs)\n        : undefined;\n\n    try {\n      // Build headers conditionally - only include User-Agent in non-browser environments\n      const headers: Record<string, string> = {\n        'Add-Padding': 'true',\n      };\n\n      // Only add User-Agent when in non-browser environment (e.g., Node.js, server)\n      if (typeof window === 'undefined' && typeof navigator === 'undefined') {\n        headers['User-Agent'] = this.options.userAgent;\n      }\n\n      const response = await this.fetchImpl(`${this.options.endpoint}/${prefix}`, {\n        method: 'GET',\n        headers,\n        signal: controller?.signal,\n      });\n\n      if (!response.ok) {\n        throw new Error(`HIBP responded with status ${response.status}`);\n      }\n\n      const body = await response.text();\n      const parsed = this.parseRangeResponse(body);\n      this.lastRequestTimestamp = Date.now();\n      return parsed;\n    } finally {\n      if (timeoutId !== undefined) {\n        clearTimeout(timeoutId);\n      }\n    }\n  }\n\n  private parseRangeResponse(payload: string): Map<string, number> {\n    const suffixes = new Map<string, number>();\n\n    payload.split(/\\r?\\n/).forEach(line => {\n      const [suffix, count] = line.trim().split(':');\n      if (!suffix || !count) return;\n      const normalisedSuffix = suffix.trim().toUpperCase();\n      const occurrences = Number.parseInt(count.trim(), 10);\n      if (!Number.isNaN(occurrences)) {\n        suffixes.set(normalisedSuffix, occurrences);\n      }\n    });\n\n    return suffixes;\n  }\n\n  private async applyRateLimit(): Promise<void> {\n    if (this.lastRequestTimestamp === 0) {\n      return;\n    }\n\n    const elapsed = Date.now() - this.lastRequestTimestamp;\n    if (elapsed < this.options.rateLimitIntervalMs) {\n      await this.delay(this.options.rateLimitIntervalMs - elapsed);\n    }\n  }\n\n  private async delay(durationMs: number): Promise<void> {\n    await new Promise(resolve => setTimeout(resolve, durationMs));\n  }\n\n  private get fetchImpl(): FetchImplementation {\n    return this.options.fetchImplementation ?? fetch;\n  }\n}\n\nlet cachedDefaultPwnedPasswordChecker: PwnedPasswordChecker | null = null;\n\nconst getDefaultPwnedPasswordChecker = (): PwnedPasswordChecker => {\n  if (!cachedDefaultPwnedPasswordChecker) {\n    cachedDefaultPwnedPasswordChecker = new PwnedPasswordChecker(\n      createDefaultPasswordBreachCheckConfig()\n    );\n  }\n\n  return cachedDefaultPwnedPasswordChecker;\n};\n\nconst getPasswordBreachChecker = (\n  override: Partial<PasswordBreachCheckConfig>\n): PwnedPasswordChecker => {\n  if (!override || Object.keys(override).length === 0) {\n    return getDefaultPwnedPasswordChecker();\n  }\n\n  return new PwnedPasswordChecker({\n    ...createDefaultPasswordBreachCheckConfig(),\n    ...override,\n  });\n};\n\nasync function sha1Hex(value: string): Promise<string> {\n  const subtle = await getSubtleCrypto();\n  const data = new TextEncoder().encode(value);\n  const digest = await subtle.digest('SHA-1', data);\n  const bytes = Array.from(new Uint8Array(digest));\n  return bytes\n    .map(byte => byte.toString(16).padStart(2, '0'))\n    .join('')\n    .toUpperCase();\n}\n\nasync function getSubtleCrypto(): Promise<SubtleCrypto> {\n  if (typeof globalThis !== 'undefined' && globalThis.crypto?.subtle) {\n    return globalThis.crypto.subtle;\n  }\n\n  throw new Error('SubtleCrypto API is not available in this environment.');\n}\n\n/**\n * Validate password against strength requirements\n *\n * @param password - Password to validate\n * @param requirements - Password requirements (optional, uses defaults)\n * @param username - Username to check against (optional)\n * @returns Result containing void on success or PasswordValidationError\n */\nexport async function validatePasswordStrength(\n  password: string,\n  requirements: PasswordRequirements = DEFAULT_PASSWORD_REQUIREMENTS,\n  username?: string,\n  breachConfig: Partial<PasswordBreachCheckConfig> = {}\n): Promise<Result<void, PasswordValidationError>> {\n  // Check length\n  if (password.length < requirements.minLength) {\n    return err({\n      type: 'TOO_SHORT',\n      minLength: requirements.minLength,\n      actualLength: password.length,\n    });\n  }\n\n  if (password.length > requirements.maxLength) {\n    return err({\n      type: 'TOO_LONG',\n      maxLength: requirements.maxLength,\n      actualLength: password.length,\n    });\n  }\n\n  // Check uppercase\n  if (requirements.requireUppercase && !/[A-Z]/.test(password)) {\n    return err({ type: 'MISSING_UPPERCASE' });\n  }\n\n  // Check lowercase\n  if (requirements.requireLowercase && !/[a-z]/.test(password)) {\n    return err({ type: 'MISSING_LOWERCASE' });\n  }\n\n  // Check numbers\n  if (requirements.requireNumbers && !/\\d/.test(password)) {\n    return err({ type: 'MISSING_NUMBERS' });\n  }\n\n  // Check special characters\n  if (requirements.requireSpecialChars) {\n    const specialChars = password.match(/[^a-zA-Z0-9]/g);\n    const specialCharCount = specialChars ? specialChars.length : 0;\n\n    if (specialCharCount < requirements.minSpecialChars) {\n      return err({\n        type: 'MISSING_SPECIAL_CHARS',\n        required: requirements.minSpecialChars,\n      });\n    }\n  }\n\n  // Check if password contains username\n  if (username && password.toLowerCase().includes(username.toLowerCase())) {\n    return err({ type: 'CONTAINS_USERNAME' });\n  }\n\n  const checker = getPasswordBreachChecker(breachConfig);\n  const breachResult = await checker.isCompromised(password);\n\n  if (breachResult.compromised) {\n    return err({\n      type: 'COMMON_PASSWORD',\n      source: breachResult.source,\n      occurrences: breachResult.occurrences,\n    });\n  }\n\n  if (breachResult.warning) {\n    console.warn('[AuthRules] Password breach check warning:', breachResult.warning);\n  }\n\n  return ok(undefined);\n}\n\n/**\n * Check if session should timeout based on idle time\n *\n * @param lastActivity - Last activity timestamp\n * @param config - Session timeout configuration (optional, uses defaults)\n * @returns true if session should timeout\n */\nexport function shouldTimeoutFromIdle(\n  lastActivity: Date,\n  config: SessionTimeoutConfig = DEFAULT_SESSION_TIMEOUT\n): boolean {\n  const now = new Date();\n  const idleMinutes = (now.getTime() - lastActivity.getTime()) / (1000 * 60);\n  return idleMinutes >= config.idleTimeout;\n}\n\n/**\n * Check if session should timeout based on absolute time\n *\n * @param sessionStart - Session start timestamp\n * @param config - Session timeout configuration (optional, uses defaults)\n * @returns true if session should timeout\n */\nexport function shouldTimeoutFromAbsolute(\n  sessionStart: Date,\n  config: SessionTimeoutConfig = DEFAULT_SESSION_TIMEOUT\n): boolean {\n  const now = new Date();\n  const sessionHours = (now.getTime() - sessionStart.getTime()) / (1000 * 60 * 60);\n  return sessionHours >= config.absoluteTimeout;\n}\n\n/**\n * Check if should show timeout warning\n *\n * @param lastActivity - Last activity timestamp\n * @param config - Session timeout configuration (optional, uses defaults)\n * @returns true if warning should be shown\n */\nexport function shouldShowTimeoutWarning(\n  lastActivity: Date,\n  config: SessionTimeoutConfig = DEFAULT_SESSION_TIMEOUT\n): boolean {\n  const now = new Date();\n  const idleMinutes = (now.getTime() - lastActivity.getTime()) / (1000 * 60);\n  const warningThreshold = config.idleTimeout - config.warningBeforeTimeout;\n  return idleMinutes >= warningThreshold && idleMinutes < config.idleTimeout;\n}\n\n/**\n * Get minutes until session timeout\n *\n * @param lastActivity - Last activity timestamp\n * @param config - Session timeout configuration (optional, uses defaults)\n * @returns Minutes until timeout, or 0 if already timed out\n */\nexport function getMinutesUntilTimeout(\n  lastActivity: Date,\n  config: SessionTimeoutConfig = DEFAULT_SESSION_TIMEOUT\n): number {\n  const now = new Date();\n  const idleMinutes = (now.getTime() - lastActivity.getTime()) / (1000 * 60);\n  const remaining = config.idleTimeout - idleMinutes;\n  return Math.max(0, Math.floor(remaining));\n}\n\n/**\n * Calculate password strength score (0-100)\n *\n * @param password - Password to score\n * @returns Strength score from 0 (weakest) to 100 (strongest)\n */\nexport function calculatePasswordStrength(password: string): number {\n  let score = 0;\n\n  // Length score (max 30 points)\n  score += Math.min(30, password.length * 2);\n\n  // Variety score (max 40 points)\n  if (/[a-z]/.test(password)) score += 10;\n  if (/[A-Z]/.test(password)) score += 10;\n  if (/\\d/.test(password)) score += 10;\n  if (/[^a-zA-Z0-9]/.test(password)) score += 10;\n\n  // Complexity score (max 30 points)\n  const hasRepeats = /(.)\\1{2,}/.test(password); // 3+ repeated chars\n  if (!hasRepeats) score += 10;\n\n  const hasSequence = /(abc|bcd|cde|123|234|345)/i.test(password);\n  if (!hasSequence) score += 10;\n\n  const hasCommon = isCommonPassword(password);\n  if (!hasCommon) score += 10;\n\n  return Math.min(100, score);\n}\n\n/**\n * Get password strength label\n *\n * @param score - Password strength score (0-100)\n * @returns Human-readable strength label\n */\nexport function getPasswordStrengthLabel(\n  score: number\n): 'weak' | 'fair' | 'good' | 'strong' | 'very strong' {\n  if (score < 30) return 'weak';\n  if (score < 50) return 'fair';\n  if (score < 70) return 'good';\n  if (score < 90) return 'strong';\n  return 'very strong';\n}\n\n/**\n * Multi-factor authentication rules\n * (Future implementation)\n */\nexport interface MfaRules {\n  required: boolean;\n  methods: ('totp' | 'sms' | 'email')[];\n  gracePeriodDays: number;\n}\n\nexport const DEFAULT_MFA_RULES: MfaRules = {\n  required: false,\n  methods: ['totp', 'email'],\n  gracePeriodDays: 7,\n};\n\nexport const __resetPasswordBreachCheckerForTests = (): void => {\n  cachedDefaultPwnedPasswordChecker = null;\n};\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/domain/rules/contactRules.ts",
        "messages": [
            {
                "ruleId": "no-useless-escape",
                "severity": 1,
                "message": "Unnecessary escape character: \\(.",
                "line": 101,
                "column": 39,
                "nodeType": "Literal",
                "messageId": "unnecessaryEscape",
                "endLine": 101,
                "endColumn": 40,
                "suggestions": [
                    {
                        "messageId": "removeEscape",
                        "fix": {
                            "range": [
                                2567,
                                2568
                            ],
                            "text": ""
                        },
                        "desc": "Remove the `\\`. This maintains the current functionality."
                    },
                    {
                        "messageId": "escapeBackslash",
                        "fix": {
                            "range": [
                                2567,
                                2567
                            ],
                            "text": "\\"
                        },
                        "desc": "Replace the `\\` with `\\\\` to include the actual backslash character."
                    }
                ]
            },
            {
                "ruleId": "no-useless-escape",
                "severity": 1,
                "message": "Unnecessary escape character: \\).",
                "line": 101,
                "column": 41,
                "nodeType": "Literal",
                "messageId": "unnecessaryEscape",
                "endLine": 101,
                "endColumn": 42,
                "suggestions": [
                    {
                        "messageId": "removeEscape",
                        "fix": {
                            "range": [
                                2569,
                                2570
                            ],
                            "text": ""
                        },
                        "desc": "Remove the `\\`. This maintains the current functionality."
                    },
                    {
                        "messageId": "escapeBackslash",
                        "fix": {
                            "range": [
                                2569,
                                2569
                            ],
                            "text": "\\"
                        },
                        "desc": "Replace the `\\` with `\\\\` to include the actual backslash character."
                    }
                ]
            },
            {
                "ruleId": "no-useless-escape",
                "severity": 1,
                "message": "Unnecessary escape character: \\..",
                "line": 101,
                "column": 43,
                "nodeType": "Literal",
                "messageId": "unnecessaryEscape",
                "endLine": 101,
                "endColumn": 44,
                "suggestions": [
                    {
                        "messageId": "removeEscape",
                        "fix": {
                            "range": [
                                2571,
                                2572
                            ],
                            "text": ""
                        },
                        "desc": "Remove the `\\`. This maintains the current functionality."
                    },
                    {
                        "messageId": "escapeBackslash",
                        "fix": {
                            "range": [
                                2571,
                                2571
                            ],
                            "text": "\\"
                        },
                        "desc": "Replace the `\\` with `\\\\` to include the actual backslash character."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 159,
                "column": 38,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingReturnType",
                "endLine": 159,
                "endColumn": 40
            },
            {
                "ruleId": "no-useless-escape",
                "severity": 1,
                "message": "Unnecessary escape character: \\(.",
                "line": 159,
                "column": 57,
                "nodeType": "Literal",
                "messageId": "unnecessaryEscape",
                "endLine": 159,
                "endColumn": 58,
                "suggestions": [
                    {
                        "messageId": "removeEscape",
                        "fix": {
                            "range": [
                                4130,
                                4131
                            ],
                            "text": ""
                        },
                        "desc": "Remove the `\\`. This maintains the current functionality."
                    },
                    {
                        "messageId": "escapeBackslash",
                        "fix": {
                            "range": [
                                4130,
                                4130
                            ],
                            "text": "\\"
                        },
                        "desc": "Replace the `\\` with `\\\\` to include the actual backslash character."
                    }
                ]
            },
            {
                "ruleId": "no-useless-escape",
                "severity": 1,
                "message": "Unnecessary escape character: \\).",
                "line": 159,
                "column": 59,
                "nodeType": "Literal",
                "messageId": "unnecessaryEscape",
                "endLine": 159,
                "endColumn": 60,
                "suggestions": [
                    {
                        "messageId": "removeEscape",
                        "fix": {
                            "range": [
                                4132,
                                4133
                            ],
                            "text": ""
                        },
                        "desc": "Remove the `\\`. This maintains the current functionality."
                    },
                    {
                        "messageId": "escapeBackslash",
                        "fix": {
                            "range": [
                                4132,
                                4132
                            ],
                            "text": "\\"
                        },
                        "desc": "Replace the `\\` with `\\\\` to include the actual backslash character."
                    }
                ]
            },
            {
                "ruleId": "no-useless-escape",
                "severity": 1,
                "message": "Unnecessary escape character: \\..",
                "line": 159,
                "column": 61,
                "nodeType": "Literal",
                "messageId": "unnecessaryEscape",
                "endLine": 159,
                "endColumn": 62,
                "suggestions": [
                    {
                        "messageId": "removeEscape",
                        "fix": {
                            "range": [
                                4134,
                                4135
                            ],
                            "text": ""
                        },
                        "desc": "Remove the `\\`. This maintains the current functionality."
                    },
                    {
                        "messageId": "escapeBackslash",
                        "fix": {
                            "range": [
                                4134,
                                4134
                            ],
                            "text": "\\"
                        },
                        "desc": "Replace the `\\` with `\\\\` to include the actual backslash character."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected value in conditional. A boolean expression is required.",
                "line": 163,
                "column": 5,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "conditionErrorOther",
                "endLine": 163,
                "endColumn": 93,
                "suggestions": [
                    {
                        "messageId": "explicitBooleanReturnType",
                        "fix": {
                            "range": [
                                4243,
                                4244
                            ],
                            "text": "(c): boolean"
                        },
                        "desc": "Add an explicit `boolean` return type annotation."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 163,
                "column": 10,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 163,
                "endColumn": 17,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                4248,
                                4255
                            ],
                            "text": "(c.phone != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                4248,
                                4255
                            ],
                            "text": "(c.phone ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                4248,
                                4255
                            ],
                            "text": "(Boolean(c.phone))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'tenantSettings' is defined but never used. Allowed unused args must match /^_/u.",
                "line": 209,
                "column": 3,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 209,
                "endColumn": 17
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 229,
                "column": 34,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 229,
                "endColumn": 51,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                5862,
                                5880
                            ],
                            "text": "(contact.firstName == null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                5863,
                                5880
                            ],
                            "text": "(contact.firstName ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                5862,
                                5880
                            ],
                            "text": "(!Boolean(contact.firstName))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 233,
                "column": 33,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 233,
                "endColumn": 49,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                5957,
                                5974
                            ],
                            "text": "(contact.lastName == null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                5958,
                                5974
                            ],
                            "text": "(contact.lastName ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                5957,
                                5974
                            ],
                            "text": "(!Boolean(contact.lastName))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 237,
                "column": 30,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 237,
                "endColumn": 43,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                6047,
                                6061
                            ],
                            "text": "(contact.email == null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                6048,
                                6061
                            ],
                            "text": "(contact.email ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                6047,
                                6061
                            ],
                            "text": "(!Boolean(contact.email))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 241,
                "column": 30,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 241,
                "endColumn": 43,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                6131,
                                6145
                            ],
                            "text": "(contact.phone == null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                6132,
                                6145
                            ],
                            "text": "(contact.phone ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                6131,
                                6145
                            ],
                            "text": "(!Boolean(contact.phone))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 245,
                "column": 32,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 245,
                "endColumn": 47,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                6217,
                                6233
                            ],
                            "text": "(contact.company == null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                6218,
                                6233
                            ],
                            "text": "(contact.company ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                6217,
                                6233
                            ],
                            "text": "(!Boolean(contact.company))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 260,
                "column": 10,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 260,
                "endColumn": 27,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                6621,
                                6639
                            ],
                            "text": "firstMissingField == null"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                6622,
                                6639
                            ],
                            "text": "(firstMissingField ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                6621,
                                6639
                            ],
                            "text": "!Boolean(firstMissingField)"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 282,
                "column": 13,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 282,
                "endColumn": 26,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                7141,
                                7154
                            ],
                            "text": "(contact.email != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                7141,
                                7154
                            ],
                            "text": "(contact.email ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                7141,
                                7154
                            ],
                            "text": "(Boolean(contact.email))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 282,
                "column": 27,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 282,
                "endColumn": 29,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                7141,
                                7171
                            ],
                            "text": "(contact.email ?? contact.phone)"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 282,
                "column": 30,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 282,
                "endColumn": 43,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                7158,
                                7171
                            ],
                            "text": "(contact.phone != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                7158,
                                7171
                            ],
                            "text": "(contact.phone ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                7158,
                                7171
                            ],
                            "text": "(Boolean(contact.phone))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 282,
                "column": 44,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 282,
                "endColumn": 46,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                7172,
                                7174
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 282,
                "column": 47,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 282,
                "endColumn": 61,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                7175,
                                7189
                            ],
                            "text": "(contact.mobile != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                7175,
                                7189
                            ],
                            "text": "(contact.mobile ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                7175,
                                7189
                            ],
                            "text": "(Boolean(contact.mobile))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, the types have no overlap.",
                "line": 306,
                "column": 12,
                "nodeType": "BinaryExpression",
                "messageId": "noOverlapBooleanExpression",
                "endLine": 306,
                "endColumn": 26
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 331,
                "column": 7,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 331,
                "endColumn": 20,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                8280,
                                8293
                            ],
                            "text": "(contact.email != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                8280,
                                8293
                            ],
                            "text": "(contact.email ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                8280,
                                8293
                            ],
                            "text": "(Boolean(contact.email))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 336,
                "column": 7,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 336,
                "endColumn": 20,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                8399,
                                8412
                            ],
                            "text": "(contact.phone != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                8399,
                                8412
                            ],
                            "text": "(contact.phone ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                8399,
                                8412
                            ],
                            "text": "(Boolean(contact.phone))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, value is always truthy.",
                "line": 341,
                "column": 7,
                "nodeType": "MemberExpression",
                "messageId": "alwaysTruthy",
                "endLine": 341,
                "endColumn": 24
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected object value in conditional. The condition is always true.",
                "line": 341,
                "column": 7,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorObject",
                "endLine": 341,
                "endColumn": 24
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 391,
                "column": 17,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 391,
                "endColumn": 34,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                9838,
                                9855
                            ],
                            "text": "(contact.firstName != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                9838,
                                9855
                            ],
                            "text": "(contact.firstName ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                9838,
                                9855
                            ],
                            "text": "(Boolean(contact.firstName))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 391,
                "column": 35,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 391,
                "endColumn": 37,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                9856,
                                9858
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 391,
                "column": 44,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 391,
                "endColumn": 60,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                9865,
                                9881
                            ],
                            "text": "(contact.lastName != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                9865,
                                9881
                            ],
                            "text": "(contact.lastName ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                9865,
                                9881
                            ],
                            "text": "(Boolean(contact.lastName))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 391,
                "column": 61,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 391,
                "endColumn": 63,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                9882,
                                9884
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 393,
                "column": 17,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 393,
                "endColumn": 33,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                9937,
                                9953
                            ],
                            "text": "(contact.lastName != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                9937,
                                9953
                            ],
                            "text": "(contact.lastName ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                9937,
                                9953
                            ],
                            "text": "(Boolean(contact.lastName))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 393,
                "column": 34,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 393,
                "endColumn": 36,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                9954,
                                9956
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 393,
                "column": 44,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 393,
                "endColumn": 61,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                9964,
                                9981
                            ],
                            "text": "(contact.firstName != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                9964,
                                9981
                            ],
                            "text": "(contact.firstName ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                9964,
                                9981
                            ],
                            "text": "(Boolean(contact.firstName))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 393,
                "column": 62,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 393,
                "endColumn": 64,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                9982,
                                9984
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 395,
                "column": 14,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 395,
                "endColumn": 31,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                10034,
                                10051
                            ],
                            "text": "(contact.firstName != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                10034,
                                10051
                            ],
                            "text": "(contact.firstName ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                10034,
                                10051
                            ],
                            "text": "(Boolean(contact.firstName))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 395,
                "column": 32,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 395,
                "endColumn": 34,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                10052,
                                10054
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 397,
                "column": 17,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 397,
                "endColumn": 34,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                10088,
                                10105
                            ],
                            "text": "(contact.firstName != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                10088,
                                10105
                            ],
                            "text": "(contact.firstName ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                10088,
                                10105
                            ],
                            "text": "(Boolean(contact.firstName))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 397,
                "column": 35,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 397,
                "endColumn": 37,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                10106,
                                10108
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 397,
                "column": 44,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 397,
                "endColumn": 60,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                10115,
                                10131
                            ],
                            "text": "(contact.lastName != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                10115,
                                10131
                            ],
                            "text": "(contact.lastName ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                10115,
                                10131
                            ],
                            "text": "(Boolean(contact.lastName))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 397,
                "column": 61,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 397,
                "endColumn": 63,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                10132,
                                10134
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 40,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "/**\n * Contact Business Rules\n *\n * Pure business logic for contact management operations.\n * These rules define validation, field requirements, and business constraints.\n */\n\nimport type { Result } from 'neverthrow';\nimport { ok, err } from 'neverthrow';\nimport type { Contact } from '../../types/contact';\nimport type { TenantSettings } from '../../types/auth';\n\n/**\n * Contact field requirements by tenant\n */\nexport interface ContactFieldRequirements {\n  firstName: boolean;\n  lastName: boolean;\n  email: boolean;\n  phone: boolean;\n  company: boolean;\n  dateOfBirth: boolean;\n  address: boolean;\n}\n\n/**\n * Default contact field requirements\n */\nexport const DEFAULT_CONTACT_REQUIREMENTS: ContactFieldRequirements = {\n  firstName: true,\n  lastName: true,\n  email: false,\n  phone: false,\n  company: false,\n  dateOfBirth: false,\n  address: false,\n};\n\n/**\n * Contact validation error\n */\nexport type ContactValidationError =\n  | { type: 'REQUIRED_FIELD_MISSING'; field: string }\n  | { type: 'INVALID_FORMAT'; field: string; reason: string }\n  | { type: 'DUPLICATE_CONTACT'; field: string; value: string }\n  | { type: 'AGE_OUT_OF_RANGE'; age: number; min: number; max: number };\n\n/**\n * Age calculation from date of birth\n *\n * @param dateOfBirth - Date of birth\n * @returns Age in years\n */\nexport function calculateAgeFromDOB(dateOfBirth: Date): number {\n  const today = new Date();\n  const birthDate = new Date(dateOfBirth);\n  let age = today.getFullYear() - birthDate.getFullYear();\n  const monthDiff = today.getMonth() - birthDate.getMonth();\n\n  if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birthDate.getDate())) {\n    age--;\n  }\n\n  return age;\n}\n\n/**\n * Validate email format\n *\n * @param email - Email address to validate\n * @returns Result containing void on success or error\n */\nexport function validateEmailFormat(email: string): Result<void, ContactValidationError> {\n  const emailRegex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/;\n\n  if (!emailRegex.test(email)) {\n    return err({\n      type: 'INVALID_FORMAT',\n      field: 'email',\n      reason: 'Invalid email format',\n    });\n  }\n\n  return ok(undefined);\n}\n\n/**\n * Validate phone format\n *\n * Accepts various formats:\n * - +1234567890\n * - (123) 456-7890\n * - 123-456-7890\n * - 123.456.7890\n *\n * @param phone - Phone number to validate\n * @returns Result containing void on success or error\n */\nexport function validatePhoneFormat(phone: string): Result<void, ContactValidationError> {\n  // Remove all non-digit characters except leading +\n  const cleaned = phone.replace(/[\\s\\-\\(\\)\\.]/g, '');\n\n  // Should have 10-15 digits, optionally starting with +\n  const phoneRegex = /^\\+?[1-9]\\d{9,14}$/;\n\n  if (!phoneRegex.test(cleaned)) {\n    return err({\n      type: 'INVALID_FORMAT',\n      field: 'phone',\n      reason: 'Invalid phone format. Should be 10-15 digits.',\n    });\n  }\n\n  return ok(undefined);\n}\n\n/**\n * Validate contact email uniqueness\n *\n * @param email - Email to check\n * @param existingContacts - List of existing contacts\n * @param excludeContactId - Contact ID to exclude from check (for updates)\n * @returns Result containing void on success or error\n */\nexport function validateEmailUniqueness(\n  email: string,\n  existingContacts: Contact[],\n  excludeContactId?: string\n): Result<void, ContactValidationError> {\n  const duplicate = existingContacts.find(\n    c => c.email?.toLowerCase() === email.toLowerCase() && c.id !== excludeContactId\n  );\n\n  if (duplicate) {\n    return err({\n      type: 'DUPLICATE_CONTACT',\n      field: 'email',\n      value: email,\n    });\n  }\n\n  return ok(undefined);\n}\n\n/**\n * Validate contact phone uniqueness\n *\n * @param phone - Phone to check\n * @param existingContacts - List of existing contacts\n * @param excludeContactId - Contact ID to exclude from check (for updates)\n * @returns Result containing void on success or error\n */\nexport function validatePhoneUniqueness(\n  phone: string,\n  existingContacts: Contact[],\n  excludeContactId?: string\n): Result<void, ContactValidationError> {\n  // Normalize phone numbers for comparison\n  const normalizePhone = (p: string) => p.replace(/[\\s\\-\\(\\)\\.]/g, '');\n  const normalizedPhone = normalizePhone(phone);\n\n  const duplicate = existingContacts.find(\n    c => c.phone && normalizePhone(c.phone) === normalizedPhone && c.id !== excludeContactId\n  );\n\n  if (duplicate) {\n    return err({\n      type: 'DUPLICATE_CONTACT',\n      field: 'phone',\n      value: phone,\n    });\n  }\n\n  return ok(undefined);\n}\n\n/**\n * Validate age is within acceptable range\n *\n * @param age - Age to validate\n * @param min - Minimum age (default: 0)\n * @param max - Maximum age (default: 150)\n * @returns Result containing void on success or error\n */\nexport function validateAgeRange(\n  age: number,\n  min = 0,\n  max = 150\n): Result<void, ContactValidationError> {\n  if (age < min || age > max) {\n    return err({\n      type: 'AGE_OUT_OF_RANGE',\n      age,\n      min,\n      max,\n    });\n  }\n\n  return ok(undefined);\n}\n\n/**\n * Get required fields based on tenant settings\n *\n * @param tenantSettings - Tenant settings (optional)\n * @returns Contact field requirements\n */\nexport function getRequiredFieldsByTenant(\n  tenantSettings?: TenantSettings\n): ContactFieldRequirements {\n  // In a real application, this would extract requirements from tenant settings\n  // For now, return defaults\n  return DEFAULT_CONTACT_REQUIREMENTS;\n}\n\n/**\n * Validate required fields are present\n *\n * @param contact - Contact to validate\n * @param requirements - Field requirements\n * @returns Result containing void on success or error with all missing fields\n */\nexport function validateRequiredFields(\n  contact: Partial<Contact>,\n  requirements: ContactFieldRequirements = DEFAULT_CONTACT_REQUIREMENTS\n): Result<void, ContactValidationError> {\n  const missingFields: string[] = [];\n\n  if (requirements.firstName && !contact.firstName) {\n    missingFields.push('firstName');\n  }\n\n  if (requirements.lastName && !contact.lastName) {\n    missingFields.push('lastName');\n  }\n\n  if (requirements.email && !contact.email) {\n    missingFields.push('email');\n  }\n\n  if (requirements.phone && !contact.phone) {\n    missingFields.push('phone');\n  }\n\n  if (requirements.company && !contact.company) {\n    missingFields.push('company');\n  }\n\n  if (requirements.dateOfBirth && !contact.dateOfBirth) {\n    missingFields.push('dateOfBirth');\n  }\n\n  if (requirements.address && !contact.address) {\n    missingFields.push('address');\n  }\n\n  if (missingFields.length > 0) {\n    // Return first missing field error (guaranteed to exist)\n    const firstMissingField = missingFields[0];\n    if (!firstMissingField) {\n      // This should never happen, but satisfy TypeScript\n      return ok(undefined);\n    }\n    return err({\n      type: 'REQUIRED_FIELD_MISSING',\n      field: firstMissingField,\n    });\n  }\n\n  return ok(undefined);\n}\n\n/**\n * Check if contact has minimum required contact info\n *\n * At least one of: email, phone, mobile\n *\n * @param contact - Contact to check\n * @returns true if has minimum contact info\n */\nexport function hasMinimumContactInfo(contact: Partial<Contact>): boolean {\n  return !!(contact.email || contact.phone || contact.mobile);\n}\n\n/**\n * Calculate contact completeness percentage\n *\n * @param contact - Contact to evaluate\n * @returns Completeness percentage (0-100)\n */\nexport function calculateContactCompleteness(contact: Partial<Contact>): number {\n  const fields = [\n    'firstName',\n    'lastName',\n    'email',\n    'phone',\n    'mobile',\n    'company',\n    'jobTitle',\n    'address',\n    'dateOfBirth',\n  ];\n\n  const filledFields = fields.filter(field => {\n    const value = contact[field as keyof Contact];\n    return value !== null && value !== undefined && value !== '';\n  }).length;\n\n  return Math.round((filledFields / fields.length) * 100);\n}\n\n/**\n * Get contact quality score\n *\n * Evaluates contact quality based on:\n * - Completeness\n * - Data validity\n * - Recent activity\n *\n * @param contact - Contact to score\n * @returns Quality score (0-100)\n */\nexport function getContactQualityScore(contact: Contact): number {\n  let score = 0;\n\n  // Completeness (max 40 points)\n  const completeness = calculateContactCompleteness(contact);\n  score += completeness * 0.4;\n\n  // Valid email (20 points)\n  if (contact.email && validateEmailFormat(contact.email).isOk()) {\n    score += 20;\n  }\n\n  // Valid phone (20 points)\n  if (contact.phone && validatePhoneFormat(contact.phone).isOk()) {\n    score += 20;\n  }\n\n  // Recent activity (max 20 points)\n  if (contact.updatedAt) {\n    const daysSinceUpdate =\n      (Date.now() - new Date(contact.updatedAt).getTime()) / (1000 * 60 * 60 * 24);\n    if (daysSinceUpdate < 30) {\n      score += 20;\n    } else if (daysSinceUpdate < 90) {\n      score += 10;\n    } else if (daysSinceUpdate < 180) {\n      score += 5;\n    }\n  }\n\n  return Math.min(100, Math.round(score));\n}\n\n/**\n * Sanitize contact data\n *\n * Trims whitespace, normalizes formats, removes invalid data\n *\n * @param contact - Contact to sanitize\n * @returns Sanitized contact\n */\nexport function sanitizeContactData<T extends Partial<Contact>>(contact: T): T {\n  return {\n    ...contact,\n    firstName: contact.firstName?.trim(),\n    lastName: contact.lastName?.trim(),\n    email: contact.email?.trim().toLowerCase(),\n    phone: contact.phone?.trim(),\n    mobile: contact.mobile?.trim(),\n    company: contact.company?.trim(),\n    jobTitle: contact.jobTitle?.trim(),\n    notes: contact.notes?.trim(),\n  };\n}\n\n/**\n * Format contact name for display\n *\n * @param contact - Contact\n * @param format - Name format ('full' | 'last-first' | 'first-only')\n * @returns Formatted name\n */\nexport function formatContactName(\n  contact: Partial<Contact>,\n  format: 'full' | 'last-first' | 'first-only' = 'full'\n): string {\n  switch (format) {\n    case 'full':\n      return `${contact.firstName || ''} ${contact.lastName || ''}`.trim();\n    case 'last-first':\n      return `${contact.lastName || ''}, ${contact.firstName || ''}`.trim();\n    case 'first-only':\n      return contact.firstName || '';\n    default:\n      return `${contact.firstName || ''} ${contact.lastName || ''}`.trim();\n  }\n}\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/domain/rules/tenantRules.ts",
        "messages": [
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 170,
                "column": 41,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 170,
                "endColumn": 43,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                4135,
                                4137
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 1,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "/**\n * Tenant Business Rules\n *\n * Pure business logic for tenant management operations.\n * These rules define subscription limits, feature access, and tenant validation.\n */\n\nimport type { Result } from 'neverthrow';\nimport { ok, err } from 'neverthrow';\nimport type { Tenant, TenantSubscription } from '../../types/auth';\n\n/**\n * Subscription plan limits\n */\nexport interface PlanLimits {\n  users: number;\n  contacts: number;\n  storage: number; // in MB\n  apiCallsPerMonth: number;\n  features: string[];\n}\n\n/**\n * Plan limits by subscription tier\n */\nexport const PLAN_LIMITS: Record<'basic' | 'professional' | 'enterprise', PlanLimits> = {\n  basic: {\n    users: 5,\n    contacts: 1000,\n    storage: 1024, // 1 GB\n    apiCallsPerMonth: 10000,\n    features: ['contacts', 'basic_search', 'export_csv', 'email_notifications'],\n  },\n  professional: {\n    users: 25,\n    contacts: 10000,\n    storage: 10240, // 10 GB\n    apiCallsPerMonth: 100000,\n    features: [\n      'contacts',\n      'basic_search',\n      'advanced_search',\n      'export_csv',\n      'export_excel',\n      'custom_fields',\n      'bulk_operations',\n      'integrations',\n      'api_access',\n      'email_notifications',\n      'sms_notifications',\n      'webhooks',\n    ],\n  },\n  enterprise: {\n    users: -1, // unlimited\n    contacts: -1, // unlimited\n    storage: -1, // unlimited\n    apiCallsPerMonth: -1, // unlimited\n    features: [\n      'contacts',\n      'basic_search',\n      'advanced_search',\n      'export_csv',\n      'export_excel',\n      'export_api',\n      'custom_fields',\n      'bulk_operations',\n      'integrations',\n      'api_access',\n      'advanced_analytics',\n      'custom_branding',\n      'sso',\n      'saml',\n      'audit_logs',\n      'priority_support',\n      'email_notifications',\n      'sms_notifications',\n      'webhooks',\n      'custom_webhooks',\n      'data_retention',\n    ],\n  },\n};\n\n/**\n * Subscription validation error\n */\nexport type SubscriptionValidationError =\n  | { type: 'LIMIT_EXCEEDED'; limit: string; max: number; current: number }\n  | { type: 'FEATURE_NOT_AVAILABLE'; feature: string; plan: string }\n  | { type: 'SUBSCRIPTION_EXPIRED'; expiredAt: Date }\n  | { type: 'SUBSCRIPTION_CANCELLED' }\n  | { type: 'INVALID_PLAN'; plan: string };\n\n/**\n * Validate subscription limits\n *\n * @param tenant - Tenant to validate\n * @param limitType - Type of limit to check\n * @param currentUsage - Current usage count\n * @returns Result containing void on success or error\n */\nexport function validateSubscriptionLimit(\n  tenant: Tenant,\n  limitType: 'users' | 'contacts' | 'storage',\n  currentUsage: number\n): Result<void, SubscriptionValidationError> {\n  const planLimits = PLAN_LIMITS[tenant.subscription.plan];\n  const limit = planLimits[limitType];\n\n  // -1 means unlimited\n  if (limit === -1) {\n    return ok(undefined);\n  }\n\n  if (currentUsage >= limit) {\n    return err({\n      type: 'LIMIT_EXCEEDED',\n      limit: limitType,\n      max: limit,\n      current: currentUsage,\n    });\n  }\n\n  return ok(undefined);\n}\n\n/**\n * Validate feature access for tenant\n *\n * @param tenant - Tenant to validate\n * @param feature - Feature to check\n * @returns Result containing void on success or error\n */\nexport function validateFeatureAccess(\n  tenant: Tenant,\n  feature: string\n): Result<void, SubscriptionValidationError> {\n  const planLimits = PLAN_LIMITS[tenant.subscription.plan];\n\n  if (!planLimits.features.includes(feature)) {\n    return err({\n      type: 'FEATURE_NOT_AVAILABLE',\n      feature,\n      plan: tenant.subscription.plan,\n    });\n  }\n\n  return ok(undefined);\n}\n\n/**\n * Validate subscription status\n *\n * @param subscription - Subscription to validate\n * @returns Result containing void on success or error\n */\nexport function validateSubscriptionStatus(\n  subscription: TenantSubscription\n): Result<void, SubscriptionValidationError> {\n  // Check if cancelled\n  if (subscription.status === 'cancelled') {\n    return err({ type: 'SUBSCRIPTION_CANCELLED' });\n  }\n\n  // Check if expired\n  if (subscription.status === 'expired') {\n    return err({\n      type: 'SUBSCRIPTION_EXPIRED',\n      expiredAt: subscription.expiresAt || new Date(),\n    });\n  }\n\n  // Check trial expiration\n  if (subscription.status === 'trial' && subscription.expiresAt) {\n    const now = new Date();\n    if (now > subscription.expiresAt) {\n      return err({\n        type: 'SUBSCRIPTION_EXPIRED',\n        expiredAt: subscription.expiresAt,\n      });\n    }\n  }\n\n  return ok(undefined);\n}\n\n/**\n * Get available features for a subscription plan\n *\n * @param plan - Subscription plan\n * @returns Array of available feature names\n */\nexport function getAvailableFeatures(plan: 'basic' | 'professional' | 'enterprise'): string[] {\n  return PLAN_LIMITS[plan].features;\n}\n\n/**\n * Get plan limits for a subscription plan\n *\n * @param plan - Subscription plan\n * @returns Plan limits\n */\nexport function getPlanLimits(plan: 'basic' | 'professional' | 'enterprise'): PlanLimits {\n  return PLAN_LIMITS[plan];\n}\n\n/**\n * Check if plan has unlimited limit for a resource\n *\n * @param plan - Subscription plan\n * @param limitType - Type of limit to check\n * @returns true if unlimited\n */\nexport function hasUnlimitedLimit(\n  plan: 'basic' | 'professional' | 'enterprise',\n  limitType: 'users' | 'contacts' | 'storage' | 'apiCallsPerMonth'\n): boolean {\n  return PLAN_LIMITS[plan][limitType] === -1;\n}\n\n/**\n * Calculate usage percentage for a limit\n *\n * @param tenant - Tenant\n * @param limitType - Type of limit\n * @param currentUsage - Current usage count\n * @returns Usage percentage (0-100), or -1 for unlimited\n */\nexport function calculateUsagePercentage(\n  tenant: Tenant,\n  limitType: 'users' | 'contacts' | 'storage',\n  currentUsage: number\n): number {\n  const planLimits = PLAN_LIMITS[tenant.subscription.plan];\n  const limit = planLimits[limitType];\n\n  // -1 means unlimited\n  if (limit === -1) {\n    return -1;\n  }\n\n  if (limit === 0) {\n    return currentUsage > 0 ? 100 : 0;\n  }\n\n  return Math.min(100, Math.round((currentUsage / limit) * 100));\n}\n\n/**\n * Check if approaching usage limit\n *\n * @param tenant - Tenant\n * @param limitType - Type of limit\n * @param currentUsage - Current usage count\n * @param threshold - Warning threshold percentage (default: 80)\n * @returns true if approaching limit\n */\nexport function isApproachingLimit(\n  tenant: Tenant,\n  limitType: 'users' | 'contacts' | 'storage',\n  currentUsage: number,\n  threshold = 80\n): boolean {\n  const percentage = calculateUsagePercentage(tenant, limitType, currentUsage);\n\n  // -1 means unlimited\n  if (percentage === -1) {\n    return false;\n  }\n\n  return percentage >= threshold;\n}\n\n/**\n * Get days remaining in subscription\n *\n * @param subscription - Subscription\n * @returns Days remaining, or null if no expiration\n */\nexport function getDaysRemaining(subscription: TenantSubscription): number | null {\n  if (!subscription.expiresAt) {\n    return null;\n  }\n\n  const now = new Date();\n  const expiresAt = new Date(subscription.expiresAt);\n  const diffTime = expiresAt.getTime() - now.getTime();\n  const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));\n\n  return Math.max(0, diffDays);\n}\n\n/**\n * Check if subscription is in trial period\n *\n * @param subscription - Subscription\n * @returns true if in trial\n */\nexport function isTrial(subscription: TenantSubscription): boolean {\n  return subscription.status === 'trial';\n}\n\n/**\n * Check if subscription is active\n *\n * @param subscription - Subscription\n * @returns true if active or trial\n */\nexport function isActive(subscription: TenantSubscription): boolean {\n  return subscription.status === 'active' || subscription.status === 'trial';\n}\n\n/**\n * Check if should show renewal warning\n *\n * @param subscription - Subscription\n * @param warningDays - Days before expiration to show warning (default: 7)\n * @returns true if should show warning\n */\nexport function shouldShowRenewalWarning(\n  subscription: TenantSubscription,\n  warningDays = 7\n): boolean {\n  const daysRemaining = getDaysRemaining(subscription);\n\n  if (daysRemaining === null) {\n    return false;\n  }\n\n  return daysRemaining <= warningDays && daysRemaining > 0;\n}\n\n/**\n * Calculate upgrade benefit score\n *\n * Scores how beneficial an upgrade would be based on current usage\n *\n * @param tenant - Current tenant\n * @param targetPlan - Target plan to upgrade to\n * @param currentUsage - Current usage metrics\n * @returns Benefit score (0-100)\n */\nexport function calculateUpgradeBenefitScore(\n  tenant: Tenant,\n  targetPlan: 'basic' | 'professional' | 'enterprise',\n  currentUsage: {\n    users: number;\n    contacts: number;\n    storage: number;\n  }\n): number {\n  const currentLimits = PLAN_LIMITS[tenant.subscription.plan];\n  const targetLimits = PLAN_LIMITS[targetPlan];\n\n  let score = 0;\n\n  // Check if approaching limits\n  const usersPercentage = calculateUsagePercentage(tenant, 'users', currentUsage.users);\n  const contactsPercentage = calculateUsagePercentage(tenant, 'contacts', currentUsage.contacts);\n  const storagePercentage = calculateUsagePercentage(tenant, 'storage', currentUsage.storage);\n\n  // Add points for each limit that's being approached\n  if (usersPercentage >= 80) score += 30;\n  else if (usersPercentage >= 60) score += 15;\n\n  if (contactsPercentage >= 80) score += 30;\n  else if (contactsPercentage >= 60) score += 15;\n\n  if (storagePercentage >= 80) score += 20;\n  else if (storagePercentage >= 60) score += 10;\n\n  // Add points for new features\n  const newFeatures = targetLimits.features.filter(f => !currentLimits.features.includes(f));\n  score += Math.min(20, newFeatures.length * 2);\n\n  return Math.min(100, score);\n}\n\n/**\n * Get recommended plan based on usage\n *\n * @param currentUsage - Current usage metrics\n * @returns Recommended plan\n */\nexport function getRecommendedPlan(currentUsage: {\n  users: number;\n  contacts: number;\n  storage: number;\n  apiCallsPerMonth: number;\n}): 'basic' | 'professional' | 'enterprise' {\n  // Check if usage exceeds professional limits\n  const proLimits = PLAN_LIMITS.professional;\n  if (\n    (proLimits.users !== -1 && currentUsage.users > proLimits.users) ||\n    (proLimits.contacts !== -1 && currentUsage.contacts > proLimits.contacts) ||\n    (proLimits.storage !== -1 && currentUsage.storage > proLimits.storage) ||\n    (proLimits.apiCallsPerMonth !== -1 &&\n      currentUsage.apiCallsPerMonth > proLimits.apiCallsPerMonth)\n  ) {\n    return 'enterprise';\n  }\n\n  // Check if usage exceeds basic limits\n  const basicLimits = PLAN_LIMITS.basic;\n  if (\n    (basicLimits.users !== -1 && currentUsage.users > basicLimits.users) ||\n    (basicLimits.contacts !== -1 && currentUsage.contacts > basicLimits.contacts) ||\n    (basicLimits.storage !== -1 && currentUsage.storage > basicLimits.storage) ||\n    (basicLimits.apiCallsPerMonth !== -1 &&\n      currentUsage.apiCallsPerMonth > basicLimits.apiCallsPerMonth)\n  ) {\n    return 'professional';\n  }\n\n  return 'basic';\n}\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/domain/tenants.ts",
        "messages": [
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'TenantSubscription' is defined but never used. Allowed unused vars must match /^_/u.",
                "line": 12,
                "column": 39,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 12,
                "endColumn": 57
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 129,
                "column": 41,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 129,
                "endColumn": 43,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                3880,
                                3882
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 224,
                "column": 25,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 224,
                "endColumn": 38,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                6109,
                                6122
                            ],
                            "text": "(tenant.domain != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                6109,
                                6122
                            ],
                            "text": "(tenant.domain ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                6109,
                                6122
                            ],
                            "text": "(Boolean(tenant.domain))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 224,
                "column": 39,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 224,
                "endColumn": 41,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                6123,
                                6125
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 4,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "/**\n * Tenant Management Domain Logic\n *\n * Pure functions for tenant management operations using Railway-Oriented Programming.\n * All functions return Result<T, E> for explicit error handling.\n *\n * This module extracts business logic from the service layer,\n * making it pure, testable, and composable.\n */\n\nimport { ok, err, type Result } from 'neverthrow';\nimport type { Tenant, TenantSettings, TenantSubscription } from '../types/auth';\nimport type { User } from '../types/auth';\nimport type { TenantId, UserId } from '../types/ids';\n\n/**\n * Tenant-specific errors\n */\nexport type TenantError =\n  | { type: 'NOT_FOUND'; tenantId: TenantId }\n  | { type: 'ACCESS_DENIED'; tenantId: TenantId; userId: UserId }\n  | { type: 'SUBSCRIPTION_EXPIRED'; tenantId: TenantId; expiredAt: Date }\n  | { type: 'LIMIT_EXCEEDED'; limit: string; max: number; current: number }\n  | { type: 'FEATURE_NOT_AVAILABLE'; feature: string; plan: string }\n  | { type: 'SWITCH_FAILED'; reason: string }\n  | { type: 'VALIDATION_FAILED'; errors: Record<string, string> };\n\n/**\n * Access errors\n */\nexport type AccessError =\n  | { type: 'UNAUTHORIZED'; message: string }\n  | { type: 'FORBIDDEN'; resource: string }\n  | { type: 'TENANT_MISMATCH'; expected: TenantId; actual: TenantId }\n  | { type: 'SUBSCRIPTION_REQUIRED'; feature: string };\n\n/**\n * Switch tenant errors\n */\nexport type SwitchError =\n  | { type: 'TENANT_NOT_FOUND'; tenantId: TenantId }\n  | { type: 'ACCESS_DENIED'; tenantId: TenantId }\n  | { type: 'ALREADY_ACTIVE'; tenantId: TenantId }\n  | { type: 'SWITCH_FAILED'; reason: string };\n\n/**\n * Validate tenant access for a user\n *\n * Checks if user has permission to access the tenant\n *\n * @param user - User attempting access\n * @param tenantId - Tenant ID to access\n * @returns Result containing void on success or AccessError\n */\nexport function validateTenantAccess(user: User, tenantId: TenantId): Result<void, AccessError> {\n  // Check if user's tenant matches\n  if (user.tenantId !== tenantId) {\n    return err({\n      type: 'TENANT_MISMATCH',\n      expected: user.tenantId,\n      actual: tenantId,\n    });\n  }\n\n  // Additional role-based checks could go here\n  // For example, check if user has 'tenant:access' role\n\n  return ok(undefined);\n}\n\n/**\n * Switch user to a different tenant\n *\n * Validates access and prepares tenant switch\n *\n * @param user - Current user\n * @param newTenant - Tenant to switch to\n * @param availableTenants - List of tenants user has access to\n * @returns Result containing new Tenant or SwitchError\n */\nexport function switchTenant(\n  user: User,\n  newTenant: Tenant,\n  availableTenants: Tenant[]\n): Result<Tenant, SwitchError> {\n  // Check if tenant exists in available tenants\n  const hasAccess = availableTenants.some(t => t.id === newTenant.id);\n  if (!hasAccess) {\n    return err({\n      type: 'ACCESS_DENIED',\n      tenantId: newTenant.id,\n    });\n  }\n\n  // Check if already on this tenant\n  if (user.tenantId === newTenant.id) {\n    return err({\n      type: 'ALREADY_ACTIVE',\n      tenantId: newTenant.id,\n    });\n  }\n\n  // Validate tenant subscription is active\n  const subscriptionCheck = validateTenantSubscription(newTenant);\n  if (subscriptionCheck.isErr()) {\n    return err({\n      type: 'SWITCH_FAILED',\n      reason: `Tenant subscription is not active: ${subscriptionCheck.error.type}`,\n    });\n  }\n\n  return ok(newTenant);\n}\n\n/**\n * Validate tenant subscription status\n *\n * @param tenant - Tenant to validate\n * @returns Result containing void on success or TenantError\n */\nexport function validateTenantSubscription(tenant: Tenant): Result<void, TenantError> {\n  const { subscription } = tenant;\n\n  // Check if subscription is active\n  if (subscription.status === 'expired' || subscription.status === 'cancelled') {\n    return err({\n      type: 'SUBSCRIPTION_EXPIRED',\n      tenantId: tenant.id,\n      expiredAt: subscription.expiresAt || new Date(),\n    });\n  }\n\n  // Check if trial has expired\n  if (subscription.status === 'trial' && subscription.expiresAt) {\n    const now = new Date();\n    if (now > subscription.expiresAt) {\n      return err({\n        type: 'SUBSCRIPTION_EXPIRED',\n        tenantId: tenant.id,\n        expiredAt: subscription.expiresAt,\n      });\n    }\n  }\n\n  return ok(undefined);\n}\n\n/**\n * Check if tenant has access to a specific feature\n *\n * @param tenant - Tenant to check\n * @param feature - Feature name\n * @returns Result containing void on success or TenantError\n */\nexport function validateFeatureAccess(tenant: Tenant, feature: string): Result<void, TenantError> {\n  // First check subscription\n  const subscriptionCheck = validateTenantSubscription(tenant);\n  if (subscriptionCheck.isErr()) {\n    return subscriptionCheck;\n  }\n\n  // Check if feature is available in tenant settings\n  if (!tenant.settings.features.includes(feature)) {\n    return err({\n      type: 'FEATURE_NOT_AVAILABLE',\n      feature,\n      plan: tenant.subscription.plan,\n    });\n  }\n\n  return ok(undefined);\n}\n\n/**\n * Check if tenant is within usage limits\n *\n * @param tenant - Tenant to check\n * @param limitType - Type of limit to check ('users', 'contacts', 'storage')\n * @param currentUsage - Current usage count\n * @returns Result containing void on success or TenantError\n */\nexport function validateUsageLimit(\n  tenant: Tenant,\n  limitType: 'users' | 'contacts' | 'storage',\n  currentUsage: number\n): Result<void, TenantError> {\n  const limit = tenant.subscription.limits[limitType];\n\n  if (limit === -1 || limit === Infinity) {\n    return ok(undefined);\n  }\n\n  if (limit === 0) {\n    if (currentUsage > 0) {\n      return err({\n        type: 'LIMIT_EXCEEDED',\n        limit: limitType,\n        max: limit,\n        current: currentUsage,\n      });\n    }\n    return ok(undefined);\n  }\n\n  if (currentUsage >= limit) {\n    return err({\n      type: 'LIMIT_EXCEEDED',\n      limit: limitType,\n      max: limit,\n      current: currentUsage,\n    });\n  }\n\n  return ok(undefined);\n}\n\n/**\n * Get tenant display name\n *\n * @param tenant - Tenant\n * @returns Display name\n */\nexport function getTenantDisplayName(tenant: Tenant): string {\n  return tenant.name || tenant.domain || tenant.id;\n}\n\n/**\n * Check if tenant subscription is trial\n *\n * @param tenant - Tenant\n * @returns true if subscription is in trial period\n */\nexport function isTrial(tenant: Tenant): boolean {\n  return tenant.subscription.status === 'trial';\n}\n\n/**\n * Check if tenant subscription is active\n *\n * @param tenant - Tenant\n * @returns true if subscription is active\n */\nexport function isActive(tenant: Tenant): boolean {\n  return tenant.subscription.status === 'active' || tenant.subscription.status === 'trial';\n}\n\n/**\n * Get days until subscription expires\n *\n * @param tenant - Tenant\n * @returns Number of days until expiration, or null if not applicable\n */\nexport function getDaysUntilExpiration(tenant: Tenant): number | null {\n  if (!tenant.subscription.expiresAt) {\n    return null;\n  }\n\n  const now = new Date();\n  const expiresAt = new Date(tenant.subscription.expiresAt);\n  const diffTime = expiresAt.getTime() - now.getTime();\n  const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));\n\n  return diffDays;\n}\n\n/**\n * Check if tenant should show expiration warning\n *\n * @param tenant - Tenant\n * @param warningThreshold - Days threshold for warning (default: 7)\n * @returns true if warning should be shown\n */\nexport function shouldShowExpirationWarning(tenant: Tenant, warningThreshold = 7): boolean {\n  const daysUntilExpiration = getDaysUntilExpiration(tenant);\n\n  if (daysUntilExpiration === null) {\n    return false;\n  }\n\n  return daysUntilExpiration <= warningThreshold && daysUntilExpiration > 0;\n}\n\nconst BASIC_FEATURES = ['contacts', 'basic_search', 'export_csv'] as const;\n\nconst PROFESSIONAL_FEATURES = [\n  ...BASIC_FEATURES,\n  'advanced_search',\n  'custom_fields',\n  'bulk_operations',\n  'integrations',\n  'api_access',\n] as const;\n\nconst ENTERPRISE_FEATURES = [\n  ...PROFESSIONAL_FEATURES,\n  'advanced_analytics',\n  'custom_branding',\n  'sso',\n  'audit_logs',\n  'priority_support',\n  'unlimited_users',\n] as const;\n\n/**\n * Get available features for tenant based on subscription plan\n *\n * @param plan - Subscription plan\n * @returns Array of available feature names\n */\nexport function getAvailableFeaturesForPlan(\n  plan: 'basic' | 'professional' | 'enterprise'\n): string[] {\n  switch (plan) {\n    case 'basic':\n      return [...BASIC_FEATURES];\n    case 'professional':\n      return [...PROFESSIONAL_FEATURES];\n    case 'enterprise':\n      return [...ENTERPRISE_FEATURES];\n  }\n}\n\n/**\n * Get usage percentage for a specific limit\n *\n * @param tenant - Tenant\n * @param limitType - Type of limit\n * @param currentUsage - Current usage count\n * @returns Usage percentage (0-100)\n */\nexport function getUsagePercentage(\n  tenant: Tenant,\n  limitType: 'users' | 'contacts' | 'storage',\n  currentUsage: number\n): number {\n  const limit = tenant.subscription.limits[limitType];\n\n  if (limit === -1 || limit === Infinity) {\n    return 0;\n  }\n\n  if (limit === 0) {\n    return currentUsage > 0 ? 100 : 0;\n  }\n\n  return Math.min(100, Math.round((currentUsage / limit) * 100));\n}\n\n/**\n * Check if usage is approaching limit\n *\n * @param tenant - Tenant\n * @param limitType - Type of limit\n * @param currentUsage - Current usage count\n * @param threshold - Warning threshold percentage (default: 80)\n * @returns true if usage is above threshold\n */\nexport function isApproachingLimit(\n  tenant: Tenant,\n  limitType: 'users' | 'contacts' | 'storage',\n  currentUsage: number,\n  threshold = 80\n): boolean {\n  const percentage = getUsagePercentage(tenant, limitType, currentUsage);\n  return percentage >= threshold;\n}\n\n/**\n * Validate tenant settings\n *\n * @param settings - Tenant settings to validate\n * @returns Result containing settings or TenantError\n */\nexport function validateTenantSettings(\n  settings: TenantSettings\n): Result<TenantSettings, TenantError> {\n  const errors: Record<string, string> = {};\n\n  // Validate theme\n  if (!['light', 'dark', 'natural'].includes(settings.theme)) {\n    errors.theme = 'Invalid theme value';\n  }\n\n  // Validate language (ISO 639-1 with optional region)\n  const languageRegex = /^[a-z]{2}(-[A-Z]{2})?$/;\n  if (!settings.language || !languageRegex.test(settings.language)) {\n    errors.language = 'Invalid language code format (expected: ISO 639-1, e.g., \"en\" or \"en-US\")';\n  }\n\n  // Validate branding colors (hex format)\n  const hexColorRegex = /^#[0-9A-Fa-f]{6}$/;\n  if (!hexColorRegex.test(settings.branding.primaryColor)) {\n    errors.primaryColor = 'Invalid primary color format';\n  }\n  if (!hexColorRegex.test(settings.branding.secondaryColor)) {\n    errors.secondaryColor = 'Invalid secondary color format';\n  }\n  if (!hexColorRegex.test(settings.branding.accentColor)) {\n    errors.accentColor = 'Invalid accent color format';\n  }\n\n  if (Object.keys(errors).length > 0) {\n    return err({\n      type: 'VALIDATION_FAILED',\n      errors,\n    });\n  }\n\n  return ok(settings);\n}\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/hooks/sanitizeUrlForLogging.test.ts",
        "messages": [],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 0,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/hooks/useApiCall.ts",
        "messages": [
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 58,
                "column": 8,
                "nodeType": "FunctionDeclaration",
                "messageId": "missingReturnType",
                "endLine": 63,
                "endColumn": 2
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected any value in conditional. An explicit comparison or type conversion is required.",
                "line": 98,
                "column": 11,
                "nodeType": "Identifier",
                "messageId": "conditionErrorAny",
                "endLine": 98,
                "endColumn": 16,
                "suggestions": [
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                3385,
                                3390
                            ],
                            "text": "(Boolean(error))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 2,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "import { useAsync } from './useAsync';\nimport type { AsyncResult, Result } from '../types/fp';\nimport type { AppError, ApiCallError } from '../types/errors';\nimport { createNetworkError } from '../types/errors';\nimport { err } from 'neverthrow';\n\n/**\n * Configuration options for API calls\n */\nexport interface ApiCallOptions<TIn, EIn, TOut = TIn, EOut = EIn> {\n  /** Function to transform the Result before consumers receive it */\n  transformResult?: (result: Result<TIn, EIn>) => Result<TOut, EOut>;\n  /** Optional mapper for unexpected errors (sync throws, etc.) */\n  transformError?: (error: unknown) => EOut;\n  /** Function to handle errors automatically */\n  onError?: (error: EOut & ApiCallError) => void;\n  /** Function to handle success automatically */\n  onSuccess?: (data: TOut) => void;\n  /** Whether to retry on failure */\n  retryOnError?: boolean;\n  /** Maximum number of retries */\n  maxRetries?: number;\n  /** Delay between retries (ms) */\n  retryDelay?: number;\n}\n\n/**\n * Executes an async API request with retry support and Result composition semantics.\n *\n * The hook keeps transport concerns (retry metadata, transient error mapping) outside of\n * the component tree, letting callers focus on handling `Result` values. Automatic retry\n * metadata is attached to errors so the UI can present actionable feedback.\n *\n * @template TIn The raw data type returned by the API function\n * @template EIn The error type returned by the API function\n * @template TOut The transformed success type exposed to consumers\n * @template EOut The transformed error type exposed to consumers\n * @param apiFunction Async function that returns a `ResultAsync`\n * @param options Optional configuration for transforming results and handling retries\n * @returns Async state containing loading status, latest `Result`, and an `execute` trigger\n * @example\n * ```typescript\n * const fetchContacts = useCallback(\n *   () => addressBookService.list(),\n *   []\n * );\n *\n * const { loading, result, execute } = useApiCall(fetchContacts, {\n *   onError: error => notification.error({ message: error.message }),\n *   onSuccess: data => console.log('Loaded', data),\n * });\n *\n * useEffect(() => {\n *   execute();\n * }, [execute]);\n * ```\n */\nexport function useApiCall<\n  TIn,\n  EIn extends AppError = AppError,\n  TOut = TIn,\n  EOut extends AppError = EIn,\n>(apiFunction: () => AsyncResult<TIn, EIn>, options: ApiCallOptions<TIn, EIn, TOut, EOut> = {}) {\n  const {\n    transformResult,\n    transformError,\n    onError,\n    onSuccess,\n    retryOnError = false,\n    maxRetries = 3,\n    retryDelay = 1000,\n  } = options;\n\n  // Enhanced API function with error handling and retry logic\n  const enhancedApiCall = async (): Promise<Result<TOut, EOut & ApiCallError>> => {\n    const withRetryMetadata = (error: EOut, attempt: number): EOut & ApiCallError => ({\n      ...error,\n      attemptNumber: attempt,\n      maxRetries,\n      retryable: retryOnError && attempt < maxRetries,\n    });\n\n    let lastError: (EOut & ApiCallError) | null = null;\n\n    const coerceResult = (result: Result<TIn, EIn>): Result<TOut, EOut> => {\n      if (transformResult) {\n        return transformResult(result);\n      }\n\n      return result as unknown as Result<TOut, EOut>;\n    };\n\n    const mapUnknownError = (error: unknown): EOut => {\n      if (transformError) {\n        return transformError(error);\n      }\n\n      if (error && typeof error === 'object' && 'type' in (error as Record<string, unknown>)) {\n        return error as EOut;\n      }\n\n      // Normalize unexpected failures into a network error so consumers can rely on typed errors\n      const base = createNetworkError(\n        error instanceof Error ? error.message : 'Unexpected request failure',\n        undefined,\n        {\n          cause: error instanceof Error ? error : undefined,\n        }\n      );\n\n      return base as unknown as EOut;\n    };\n\n    for (let attempt = 0; attempt <= maxRetries; attempt++) {\n      try {\n        const asyncResult = apiFunction();\n        const rawResult = await asyncResult;\n        const finalResult = coerceResult(rawResult);\n\n        if (finalResult.isOk()) {\n          if (onSuccess) {\n            onSuccess(finalResult.value);\n          }\n\n          return finalResult as Result<TOut, EOut & ApiCallError>;\n        } else {\n          const normalizedError = finalResult.error;\n          const enrichedError = withRetryMetadata(normalizedError, attempt);\n          lastError = enrichedError;\n\n          // Call error handler\n          if (onError) {\n            onError(enrichedError);\n          }\n\n          // If not retrying or last attempt, return enriched error (do not call transformResult on error)\n          if (!retryOnError || attempt === maxRetries) {\n            return err(enrichedError);\n          }\n\n          // Wait before retry\n          if (retryDelay > 0 && attempt < maxRetries) {\n            await new Promise(resolve => setTimeout(resolve, retryDelay));\n          }\n        }\n      } catch (error) {\n        const mappedError = mapUnknownError(error);\n        lastError = withRetryMetadata(mappedError, attempt);\n\n        if (onError) {\n          onError(lastError);\n        }\n\n        if (!retryOnError || attempt === maxRetries) {\n          return err(lastError);\n        }\n\n        // Wait before retry\n        if (retryDelay > 0 && attempt < maxRetries) {\n          await new Promise(resolve => setTimeout(resolve, retryDelay));\n        }\n      }\n    }\n\n    const fallbackError =\n      lastError ??\n      withRetryMetadata(mapUnknownError(new Error('Request failed without details')), maxRetries);\n\n    return err(fallbackError);\n  };\n\n  // Use the useAsync hook with our enhanced API call\n  const asyncState = useAsync<TOut, EOut & ApiCallError>(\n    () => enhancedApiCall(),\n    [] // We don't auto-execute, let the user control execution\n  );\n\n  // Return asyncState with the execute method from useAsync\n  // This ensures loading/result state updates properly\n  return asyncState;\n}\n\n/**\n * Creates a typed wrapper hook that pre-binds an API function and forwards optional options.\n *\n * @template TData Success payload type\n * @template TError Error type emitted by the API function\n * @param baseApiFunction Async function to execute when the generated hook runs\n * @returns Hook that can be used directly inside components while still accepting options\n * @example\n * ```typescript\n * const useFetchTenants = createApiCallHook(tenantService.list);\n *\n * export const TenantsPage: React.FC = () => {\n *   const { loading, result, execute } = useFetchTenants();\n *   useEffect(() => {\n *     execute();\n *   }, [execute]);\n *   // ...\n * };\n * ```\n */\nexport function createApiCallHook<TData, TError extends AppError = AppError>(\n  baseApiFunction: () => AsyncResult<TData, TError>\n) {\n  return (options?: ApiCallOptions<TData, TError>) => useApiCall(baseApiFunction, options);\n}\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/hooks/useAsync.ts",
        "messages": [
            {
                "ruleId": "@typescript-eslint/only-throw-error",
                "severity": 1,
                "message": "Expected an error object to be thrown.",
                "line": 78,
                "column": 15,
                "nodeType": "MemberExpression",
                "messageId": "object",
                "endLine": 78,
                "endColumn": 29
            }
        ],
        "suppressedMessages": [
            {
                "ruleId": "react-hooks/exhaustive-deps",
                "severity": 1,
                "message": "React Hook useEffect has a missing dependency: 'deps.length'. Either include it or remove the dependency array.",
                "line": 166,
                "column": 6,
                "nodeType": "ArrayExpression",
                "endLine": 166,
                "endColumn": 24,
                "suggestions": [
                    {
                        "desc": "Update the dependencies array to be: [deps.length, execute]",
                        "fix": {
                            "range": [
                                5014,
                                5032
                            ],
                            "text": "[deps.length, execute]"
                        }
                    }
                ],
                "suppressions": [
                    {
                        "kind": "directive",
                        "justification": ""
                    }
                ]
            },
            {
                "ruleId": "react-hooks/exhaustive-deps",
                "severity": 1,
                "message": "React Hook useEffect has a spread element in its dependency array. This means we can't statically verify whether you've passed the correct dependencies.",
                "line": 166,
                "column": 16,
                "nodeType": "SpreadElement",
                "endLine": 166,
                "endColumn": 23,
                "suppressions": [
                    {
                        "kind": "directive",
                        "justification": ""
                    }
                ]
            }
        ],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 1,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "import { useState, useEffect, useRef, useCallback } from 'react';\nimport type { DependencyList } from 'react';\nimport { err, ok, ResultAsync, errAsync } from 'neverthrow';\nimport type { Result, AsyncResult } from '../types/fp';\n\n/**\n * Represents the state of an async operation using railway-oriented programming\n */\nexport interface AsyncState<T, E> {\n  /** Whether the operation is currently loading */\n  loading: boolean;\n  /** The result of the operation, null when loading */\n  result: Result<T, E> | null;\n  /** Function to execute the operation */\n  execute: () => AsyncResult<T, E>;\n  /** Function to reset the state */\n  reset: () => void;\n}\n\n/**\n * Custom hook for managing async operations with Railway-Oriented Programming\n *\n * Returns a Result<T, E> to handle success/failure without exceptions.\n *\n * IMPORTANT: To avoid infinite re-render loops, callers MUST memoize the asyncFn\n * parameter using useCallback. Passing an inline function will cause the hook to\n * re-execute on every render.\n *\n * @example\n * ```typescript\n * // CORRECT: Memoized function\n * const fetchData = useCallback(async () => {\n *   return apiCall();\n * }, [dependency1, dependency2]);\n * const { loading, result } = useAsync(fetchData, [dependency1]);\n *\n * // INCORRECT: Inline function will cause re-renders\n * const { loading, result } = useAsync(async () => apiCall(), [dependency1]);\n * ```\n *\n * @param asyncFn - The async function that returns an AsyncResult<T, E> or Promise<Result<T, E>>\n * @param deps - Dependencies that trigger re-execution when changed\n * @returns AsyncState containing loading state, result, and control functions\n */\nexport function useAsync<T, E>(\n  asyncFn: () => AsyncResult<T, E> | Promise<Result<T, E>>,\n  deps: DependencyList = []\n): AsyncState<T, E> {\n  const [loading, setLoading] = useState(false);\n  const [result, setResult] = useState<Result<T, E> | null>(null);\n  const abortControllerRef = useRef<AbortController | null>(null);\n\n  // Track asyncFn reference to warn about non-memoized functions in development\n  const asyncFnRef = useRef(asyncFn);\n\n  useEffect(() => {\n    if (import.meta.env.DEV) {\n      if (asyncFnRef.current !== asyncFn) {\n        console.warn(\n          'useAsync: asyncFn reference changed. This can cause infinite re-renders. ' +\n            'Please wrap asyncFn in useCallback to maintain a stable reference.'\n        );\n      }\n    }\n    asyncFnRef.current = asyncFn;\n  }, [asyncFn]);\n\n  const toAsyncResult = useCallback(\n    (value: AsyncResult<T, E> | Promise<Result<T, E>>): AsyncResult<T, E> => {\n      if (value instanceof ResultAsync) {\n        return value;\n      }\n\n      const promise = Promise.resolve(value).then(resolved => {\n        if (resolved.isOk()) {\n          return resolved.value;\n        }\n        throw resolved.error;\n      });\n\n      return ResultAsync.fromPromise(promise, (error: unknown) => error as E);\n    },\n    []\n  );\n\n  const execute = useCallback((): AsyncResult<T, E> => {\n    if (abortControllerRef.current) {\n      abortControllerRef.current.abort();\n    }\n\n    const controller = new AbortController();\n    abortControllerRef.current = controller;\n\n    setLoading(true);\n    setResult(null);\n\n    let asyncResult: AsyncResult<T, E>;\n\n    try {\n      asyncResult = toAsyncResult(asyncFn());\n    } catch (syncError) {\n      const failure = errAsync<T, E>(syncError as E);\n\n      void failure\n        .mapErr((error: E) => {\n          if (abortControllerRef.current === controller && !controller.signal.aborted) {\n            setResult(err(error));\n          }\n          return error;\n        })\n        .then(() => {\n          if (abortControllerRef.current === controller && !controller.signal.aborted) {\n            setLoading(false);\n          }\n        });\n\n      return failure;\n    }\n\n    void asyncResult\n      .map((value: T) => {\n        if (abortControllerRef.current === controller && !controller.signal.aborted) {\n          setResult(ok(value));\n        }\n        return value;\n      })\n      .mapErr((error: E) => {\n        if (abortControllerRef.current === controller && !controller.signal.aborted) {\n          setResult(err(error));\n        }\n        return error;\n      })\n      .then(() => {\n        if (abortControllerRef.current === controller && !controller.signal.aborted) {\n          setLoading(false);\n        }\n      });\n\n    return asyncResult;\n  }, [asyncFn, toAsyncResult]);\n\n  const reset = useCallback(() => {\n    if (abortControllerRef.current) {\n      abortControllerRef.current.abort();\n      abortControllerRef.current = null;\n    }\n    setLoading(false);\n    setResult(null);\n  }, []);\n\n  useEffect(() => {\n    return () => {\n      if (abortControllerRef.current) {\n        abortControllerRef.current.abort();\n      }\n    };\n  }, []);\n\n  // Auto-execute when deps change\n  // Spread deps array so React tracks individual dependency changes\n  useEffect(() => {\n    if (deps.length > 0) {\n      execute();\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [execute, ...deps]);\n\n  return {\n    loading,\n    result,\n    execute,\n    reset,\n  };\n}\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/hooks/useAuth.ts",
        "messages": [
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'CredentialValidationError' is defined but never used. Allowed unused vars must match /^_/u.",
                "line": 5,
                "column": 30,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 5,
                "endColumn": 55
            },
            {
                "ruleId": "@typescript-eslint/restrict-template-expressions",
                "severity": 1,
                "message": "Invalid type \"number\" of template literal expression.",
                "line": 27,
                "column": 61,
                "nodeType": "MemberExpression",
                "messageId": "invalidType",
                "endLine": 27,
                "endColumn": 75
            },
            {
                "ruleId": "@typescript-eslint/restrict-template-expressions",
                "severity": 1,
                "message": "Invalid type \"number\" of template literal expression.",
                "line": 27,
                "column": 84,
                "nodeType": "MemberExpression",
                "messageId": "invalidType",
                "endLine": 27,
                "endColumn": 93
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 75,
                "column": 8,
                "nodeType": "FunctionDeclaration",
                "messageId": "missingReturnType",
                "endLine": 75,
                "endColumn": 24
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 4,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "import { useMemo } from 'react';\nimport { useAuth as useAuthContext } from '../contexts/AuthContext.fp';\nimport type { Result } from '../types/fp';\nimport { ok, err } from 'neverthrow';\nimport type { AuthFlowError, CredentialValidationError, StorageError } from '../types/errors';\nimport { AuthFlowErrors } from '../types/errors';\nimport { extractTenantId, extractUserId, type TokenError } from '../domain/auth';\nimport { validateTenantAccess, type AccessError } from '../domain/tenants';\nimport type { TenantId } from '../types/ids';\nimport { getAuthToken } from '../services/StorageService';\nimport type { LoginCredentials } from '../types/auth';\n\nconst mapStorageErrorToAuthFlowError = (error: StorageError): AuthFlowError => {\n  switch (error.type) {\n    case 'NOT_FOUND':\n      return AuthFlowErrors.missingToken();\n    case 'PARSE_ERROR':\n      return AuthFlowErrors.initFailed(`Stored auth data is invalid: ${error.reason}`);\n    case 'STRINGIFY_ERROR':\n      return AuthFlowErrors.serverError(500, `Failed to serialize auth data: ${error.reason}`);\n    case 'QUOTA_EXCEEDED':\n      return AuthFlowErrors.serverError(507, 'Storage quota exceeded for authentication data');\n    case 'STORAGE_UNAVAILABLE':\n      return AuthFlowErrors.initFailed(`Storage unavailable: ${error.reason}`);\n    case 'VERSION_MISMATCH':\n      return AuthFlowErrors.initFailed(\n        `Storage version mismatch for auth data (expected ${error.expected}, got ${error.got})`\n      );\n  }\n};\n\nconst mapTokenErrorToAuthFlowError = (error: TokenError): AuthFlowError => {\n  switch (error.type) {\n    case 'EXPIRED':\n      return AuthFlowErrors.tokenExpired();\n    case 'INVALID_FORMAT':\n      return AuthFlowErrors.tokenRefreshFailed(`Invalid token format: ${error.reason}`);\n    case 'MISSING_CLAIMS':\n      return AuthFlowErrors.tokenRefreshFailed(\n        `Token missing required claims: ${error.claims.join(', ')}`\n      );\n    case 'VERIFICATION_FAILED':\n      return AuthFlowErrors.tokenRefreshFailed(`Token verification failed: ${error.reason}`);\n  }\n};\n\n/**\n * Exposes authentication helpers that wrap the context API in `Result`-returning utilities.\n *\n * The hook keeps the original context state intact while providing railway-oriented helpers\n * (e.g., `requireRole`, `requireTenantAccess`) that can be composed without throwing.\n *\n * Note: useAuthContext now returns a safe fallback when called outside AuthProvider,\n * so this hook will always return a valid object (with unauthenticated state as fallback).\n *\n * @returns Auth state plus Result-based helpers for validating auth, roles, and tenant access\n * @example\n * ```typescript\n * const {\n *   isAuthenticated,\n *   requireRole,\n *   requireTenantAccess,\n *   getTenantResult,\n * } = useAuth();\n *\n * const guardResult = requireRole('admin').andThen(() =>\n *   requireTenantAccess(currentTenantId)\n * );\n *\n * if (guardResult.isErr()) {\n *   message.error(guardResult.error.message);\n * }\n * ```\n */\nexport function useAuth() {\n  const auth = useAuthContext();\n\n  // Wrap imperative context operations in a memoized Result-based API for composability\n  const resultApi = useMemo(() => {\n    const requireAuthResult = (): Result<boolean, AuthFlowError> => {\n      if (auth.isAuthenticated) {\n        return ok(true);\n      }\n      return err(AuthFlowErrors.unauthorized('User is not authenticated'));\n    };\n\n    const ensureAuthenticated = (): Result<void, AuthFlowError> =>\n      requireAuthResult().map(() => undefined);\n\n    const getUserResult = (): Result<NonNullable<typeof auth.user>, AuthFlowError> => {\n      if (auth.user) {\n        return ok(auth.user);\n      }\n      return err(AuthFlowErrors.unauthorized('User context is unavailable'));\n    };\n\n    const getTenantResult = (): Result<NonNullable<typeof auth.tenant>, AuthFlowError> => {\n      if (auth.tenant) {\n        return ok(auth.tenant);\n      }\n      return err(AuthFlowErrors.unauthorized('Tenant context is unavailable'));\n    };\n\n    const getTokenResult = (): Result<string, AuthFlowError> =>\n      getAuthToken()\n        .map(stored => stored.token)\n        .mapErr(mapStorageErrorToAuthFlowError);\n\n    const getTenantIdFromToken = (): Result<string, AuthFlowError> =>\n      getTokenResult().andThen(token =>\n        extractTenantId(token).mapErr(mapTokenErrorToAuthFlowError)\n      );\n\n    const getUserIdFromToken = (): Result<string, AuthFlowError> =>\n      getTokenResult().andThen(token => extractUserId(token).mapErr(mapTokenErrorToAuthFlowError));\n\n    const requireRole = (role: string): Result<void, AuthFlowError> =>\n      getUserResult().andThen(user =>\n        user.roles.includes(role)\n          ? ok(undefined)\n          : err(AuthFlowErrors.forbidden(`Missing required role: ${role}`))\n      );\n\n    const requireAnyRole = (roles: string[]): Result<void, AuthFlowError> =>\n      getUserResult().andThen(user =>\n        roles.some(role => user.roles.includes(role))\n          ? ok(undefined)\n          : err(AuthFlowErrors.forbidden(`User lacks required roles: ${roles.join(', ')}`))\n      );\n\n    const requireAllRoles = (roles: string[]): Result<void, AuthFlowError> =>\n      getUserResult().andThen(user =>\n        roles.every(role => user.roles.includes(role))\n          ? ok(undefined)\n          : err(AuthFlowErrors.forbidden(`User must have roles: ${roles.join(', ')}`))\n      );\n\n    const requireTenantAccess = (tenantId: TenantId): Result<void, AuthFlowError | AccessError> =>\n      getUserResult().andThen(user => validateTenantAccess(user, tenantId));\n\n    return {\n      login: (credentials: LoginCredentials) => auth.login(credentials),\n      logout: () => auth.logout(),\n      refreshToken: () => auth.refreshToken(),\n      requireAuth: requireAuthResult,\n      ensureAuthenticated,\n      getUserResult,\n      getTenantResult,\n      getTokenResult,\n      getTenantIdFromToken,\n      getUserIdFromToken,\n      requireRole,\n      requireAnyRole,\n      requireAllRoles,\n      requireTenantAccess,\n    };\n  }, [auth]);\n\n  return {\n    // Original auth state\n    user: auth.user,\n    tenant: auth.tenant,\n    isAuthenticated: auth.isAuthenticated,\n    isLoading: auth.isLoading,\n    error: auth.error,\n    clearError: auth.clearError,\n\n    // Result-based API (spread last to ensure these override)\n    ...resultApi,\n  };\n}\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/hooks/useAuthAdapter.ts",
        "messages": [
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'AsyncResult' is defined but never used. Allowed unused vars must match /^_/u.",
                "line": 13,
                "column": 15,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 13,
                "endColumn": 26
            },
            {
                "ruleId": "react-hooks/rules-of-hooks",
                "severity": 2,
                "message": "React Hook \"useAuthFP\" is called conditionally. React Hooks must be called in the exact same order in every component render.",
                "line": 62,
                "column": 23,
                "nodeType": "Identifier",
                "endLine": 62,
                "endColumn": 32
            },
            {
                "ruleId": "react-hooks/rules-of-hooks",
                "severity": 2,
                "message": "React Hook \"useAuthTraditional\" is called conditionally. React Hooks must be called in the exact same order in every component render.",
                "line": 99,
                "column": 32,
                "nodeType": "Identifier",
                "endLine": 99,
                "endColumn": 50
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 106,
                "column": 14,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 106,
                "endColumn": 38,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                3405,
                                3429
                            ],
                            "text": "(traditionalContext.error != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                3405,
                                3429
                            ],
                            "text": "(traditionalContext.error ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                3405,
                                3429
                            ],
                            "text": "(Boolean(traditionalContext.error))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 106,
                "column": 39,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 106,
                "endColumn": 41,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                3430,
                                3432
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, value is always truthy.",
                "line": 113,
                "column": 15,
                "nodeType": "Identifier",
                "messageId": "alwaysTruthy",
                "endLine": 113,
                "endColumn": 23
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected object value in conditional. The condition is always true.",
                "line": 113,
                "column": 15,
                "nodeType": "Identifier",
                "messageId": "conditionErrorObject",
                "endLine": 113,
                "endColumn": 23
            }
        ],
        "suppressedMessages": [],
        "errorCount": 2,
        "fatalErrorCount": 0,
        "warningCount": 5,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "/**\n * @module hooks/useAuthAdapter\n * @description Adapter hook for switching between traditional and FP auth implementations\n *\n * Provides a uniform interface regardless of which auth context is active,\n * enabling gradual migration from imperative to FP-based patterns.\n */\n\nimport { useAuth as useAuthTraditional } from './useAuth';\nimport { useAuthFP } from '../contexts/AuthContextFP';\nimport { isFeatureEnabled } from '../config/featureFlags';\nimport type { LoginCredentials, AuthResponse, User, Tenant } from '../types/auth';\nimport type { AsyncResult } from '../types/fp';\nimport type { AppError } from '../types/errors';\n\n/**\n * Unified authentication state (works with both implementations)\n */\nexport interface UnifiedAuthState {\n  isLoading: boolean;\n  isAuthenticated: boolean;\n  user: User | null;\n  tenant: Tenant | null;\n  error: AppError | Error | string | null;\n}\n\n/**\n * Unified authentication operations\n */\nexport interface UnifiedAuthOperations {\n  login: (credentials: LoginCredentials) => Promise<AuthResponse | undefined>;\n  logout: () => Promise<void>;\n  isReady: boolean;\n}\n\n/**\n * Adapter hook that provides unified interface for both auth implementations\n *\n * When VITE_USE_FP_AUTH is enabled, uses FP context.\n * Otherwise, uses traditional context.\n *\n * @returns Unified authentication state and operations\n * @throws Error if used outside both auth providers\n *\n * @example\n * ```typescript\n * const { state, operations } = useAuthAdapter();\n *\n * if (state.isLoading) return <Spinner />;\n * if (!state.isAuthenticated) return <LoginPage onLogin={operations.login} />;\n * return <Dashboard user={state.user} />;\n * ```\n */\nexport const useAuthAdapter = (): {\n  state: UnifiedAuthState;\n  operations: UnifiedAuthOperations;\n} => {\n  const useFPAuth = isFeatureEnabled('useFPAuth');\n\n  if (useFPAuth) {\n    // Use FP implementation\n    const fpContext = useAuthFP();\n    const fpState = fpContext.state;\n\n    const unifiedState: UnifiedAuthState = {\n      isLoading: fpState.type === 'loading',\n      isAuthenticated: fpState.type === 'authenticated',\n      user: fpState.type === 'authenticated' ? fpState.user : null,\n      tenant: fpState.type === 'authenticated' ? fpState.tenant : null,\n      error: fpState.type === 'error' ? fpState.error : null,\n    };\n\n    const unifiedOperations: UnifiedAuthOperations = {\n      login: async (credentials: LoginCredentials) => {\n        const result = await fpContext.login(credentials);\n        return result.match(\n          response => response,\n          error => {\n            console.error('[useAuthAdapter] Login failed:', error.message);\n            return undefined;\n          }\n        );\n      },\n      logout: async () => {\n        const result = await fpContext.logout();\n        result.match(\n          () => undefined,\n          error => {\n            console.error('[useAuthAdapter] Logout failed:', error.message);\n          }\n        );\n      },\n      isReady: fpState.type !== 'loading',\n    };\n\n    return { state: unifiedState, operations: unifiedOperations };\n  } else {\n    // Use traditional implementation\n    const traditionalContext = useAuthTraditional();\n\n    const unifiedState: UnifiedAuthState = {\n      isLoading: traditionalContext.isLoading,\n      isAuthenticated: traditionalContext.isAuthenticated,\n      user: traditionalContext.user,\n      tenant: traditionalContext.tenant,\n      error: traditionalContext.error || null,\n    };\n\n    const unifiedOperations: UnifiedAuthOperations = {\n      login: async (credentials: LoginCredentials) => {\n        try {\n          const response = await traditionalContext.login(credentials);\n          if (response) {\n            return response;\n          }\n          return undefined;\n        } catch (error) {\n          console.error('[useAuthAdapter] Login failed:', error);\n          return undefined;\n        }\n      },\n      logout: async () => {\n        try {\n          await traditionalContext.logout();\n        } catch (error) {\n          console.error('[useAuthAdapter] Logout failed:', error);\n        }\n      },\n      isReady: !traditionalContext.isLoading,\n    };\n\n    return { state: unifiedState, operations: unifiedOperations };\n  }\n};\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/hooks/useEnhancedSearch.ts",
        "messages": [
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 10,
                "column": 39,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 10,
                "endColumn": 42,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                372,
                                375
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                372,
                                375
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 10,
                "column": 57,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 10,
                "endColumn": 60,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                390,
                                393
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                390,
                                393
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 20,
                "column": 17,
                "nodeType": "VariableDeclarator",
                "messageId": "anyAssignment",
                "endLine": 20,
                "endColumn": 45
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, value is always truthy.",
                "line": 315,
                "column": 15,
                "nodeType": "Identifier",
                "messageId": "alwaysTruthy",
                "endLine": 315,
                "endColumn": 27
            },
            {
                "ruleId": "@typescript-eslint/no-base-to-string",
                "severity": 1,
                "message": "'value' will use Object's default stringification format ('[object Object]') when stringified.",
                "line": 457,
                "column": 38,
                "nodeType": "Identifier",
                "messageId": "baseToString",
                "endLine": 457,
                "endColumn": 43
            },
            {
                "ruleId": "@typescript-eslint/no-base-to-string",
                "severity": 1,
                "message": "'value' will use Object's default stringification format ('[object Object]') when stringified.",
                "line": 500,
                "column": 38,
                "nodeType": "Identifier",
                "messageId": "baseToString",
                "endLine": 500,
                "endColumn": 43
            }
        ],
        "suppressedMessages": [
            {
                "ruleId": "no-console",
                "severity": 1,
                "message": "Unexpected console statement. Only these console methods are allowed: warn, error.",
                "line": 619,
                "column": 11,
                "nodeType": "MemberExpression",
                "messageId": "limited",
                "endLine": 619,
                "endColumn": 22,
                "suggestions": [
                    {
                        "fix": {
                            "range": [
                                17404,
                                17466
                            ],
                            "text": ""
                        },
                        "messageId": "removeConsole",
                        "data": {
                            "propertyName": "log"
                        },
                        "desc": "Remove the console.log()."
                    }
                ],
                "suppressions": [
                    {
                        "kind": "directive",
                        "justification": ""
                    }
                ]
            }
        ],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 6,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "/**\n * Enhanced Search Hooks\n * Provides optimized search functionality with caching, debouncing, and performance monitoring\n */\n\nimport { useState, useCallback, useMemo, useRef, useEffect } from 'react';\nimport type { SearchFilter, SearchQuery, SearchResult } from '@/components/SearchComponents';\n\n// Simple debounce implementation\nconst debounce = <T extends (...args: any[]) => Promise<any>>(\n  func: T,\n  wait: number\n): ((...args: Parameters<T>) => Promise<Awaited<ReturnType<T>>>) => {\n  let timeout: NodeJS.Timeout;\n  return (...args: Parameters<T>): Promise<Awaited<ReturnType<T>>> => {\n    return new Promise((resolve, reject) => {\n      clearTimeout(timeout);\n      timeout = setTimeout(async () => {\n        try {\n          const result = await func(...args);\n          resolve(result as Awaited<ReturnType<T>>);\n        } catch (error) {\n          reject(error instanceof Error ? error : new Error(String(error)));\n        }\n      }, wait);\n    });\n  };\n};\n\n/**\n * Search state management hook\n */\nexport interface UseSearchStateOptions<_T> {\n  initialQuery?: string;\n  initialFilters?: SearchFilter[];\n  initialSortBy?: string;\n  initialSortOrder?: 'asc' | 'desc';\n  pageSize?: number;\n  debounceMs?: number;\n  cacheResults?: boolean;\n  maxCacheSize?: number;\n}\n\nexport interface UseSearchStateReturn<_T> {\n  // Search state\n  query: string;\n  filters: SearchFilter[];\n  sortBy: string | undefined;\n  sortOrder: 'asc' | 'desc';\n  page: number;\n  pageSize: number;\n\n  // Search actions\n  setQuery: (query: string) => void;\n  setFilters: (filters: SearchFilter[]) => void;\n  addFilter: (filter: SearchFilter) => void;\n  updateFilter: (id: string, updates: Partial<SearchFilter>) => void;\n  removeFilter: (id: string) => void;\n  clearFilters: () => void;\n  setSorting: (sortBy: string, sortOrder: 'asc' | 'desc') => void;\n  setPage: (page: number) => void;\n  setPageSize: (pageSize: number) => void;\n  reset: () => void;\n\n  // Search query\n  searchQuery: SearchQuery;\n\n  // Performance metrics\n  searchCount: number;\n  lastSearchTime: number | null;\n  cacheHitRate: number;\n}\n\nexport function useSearchState<T>(options: UseSearchStateOptions<T> = {}): UseSearchStateReturn<T> {\n  const {\n    initialQuery = '',\n    initialFilters = [],\n    initialSortBy,\n    initialSortOrder = 'asc',\n    pageSize = 10,\n  } = options;\n\n  const [query, setQuery] = useState(initialQuery);\n  const [filters, setFilters] = useState<SearchFilter[]>(initialFilters);\n  const [sortBy, setSortBy] = useState<string | undefined>(initialSortBy);\n  const [sortOrder, setSortOrder] = useState<'asc' | 'desc'>(initialSortOrder);\n  const [page, setPage] = useState(1);\n  const [currentPageSize, setCurrentPageSize] = useState(pageSize);\n\n  // Performance tracking\n  const [searchCount, _setSearchCount] = useState(0);\n  const [lastSearchTime, _setLastSearchTime] = useState<number | null>(null);\n  const [cacheHits, _setCacheHits] = useState(0);\n  const [cacheMisses, _setCacheMisses] = useState(0);\n\n  const addFilter = useCallback((filter: SearchFilter) => {\n    setFilters(prev => [...prev, filter]);\n  }, []);\n\n  const updateFilter = useCallback((id: string, updates: Partial<SearchFilter>) => {\n    setFilters(prev => prev.map(filter => (filter.id === id ? { ...filter, ...updates } : filter)));\n  }, []);\n\n  const removeFilter = useCallback((id: string) => {\n    setFilters(prev => prev.filter(filter => filter.id !== id));\n  }, []);\n\n  const clearFilters = useCallback(() => {\n    setFilters([]);\n  }, []);\n\n  const setSorting = useCallback((newSortBy: string, newSortOrder: 'asc' | 'desc') => {\n    setSortBy(newSortBy);\n    setSortOrder(newSortOrder);\n  }, []);\n\n  const reset = useCallback(() => {\n    setQuery(initialQuery);\n    setFilters(initialFilters);\n    setSortBy(initialSortBy);\n    setSortOrder(initialSortOrder);\n    setPage(1);\n    setCurrentPageSize(pageSize);\n  }, [initialQuery, initialFilters, initialSortBy, initialSortOrder, pageSize]);\n\n  const searchQuery = useMemo(\n    (): SearchQuery => ({\n      queryId: `search-${String(filters.length)}-${sortBy ?? 'none'}-${sortOrder}-${String(page)}-${String(currentPageSize)}`,\n      filters,\n      sortBy,\n      sortOrder,\n      page,\n      pageSize: currentPageSize,\n    }),\n    [filters, sortBy, sortOrder, page, currentPageSize]\n  );\n\n  const cacheHitRate = useMemo(() => {\n    const total = cacheHits + cacheMisses;\n    return total > 0 ? cacheHits / total : 0;\n  }, [cacheHits, cacheMisses]);\n\n  return {\n    query,\n    filters,\n    sortBy,\n    sortOrder,\n    page,\n    pageSize: currentPageSize,\n    setQuery,\n    setFilters,\n    addFilter,\n    updateFilter,\n    removeFilter,\n    clearFilters,\n    setSorting,\n    setPage,\n    setPageSize: setCurrentPageSize,\n    reset,\n    searchQuery,\n    searchCount,\n    lastSearchTime,\n    cacheHitRate,\n  };\n}\n\n/**\n * Debounced search hook with performance optimization\n */\nexport interface UseDebouncedSearchOptions<T> {\n  searchFunction: (query: SearchQuery, signal?: AbortSignal) => Promise<SearchResult<T>>;\n  debounceMs?: number;\n  cacheResults?: boolean;\n  maxCacheSize?: number;\n  onSearchStart?: () => void;\n  onSearchComplete?: (result: SearchResult<T>) => void;\n  onSearchError?: (error: Error) => void;\n}\n\nexport interface UseDebouncedSearchReturn<T> {\n  search: (query: SearchQuery) => Promise<SearchResult<T>>;\n  searchImmediate: (query: SearchQuery) => Promise<SearchResult<T>>;\n  isSearching: boolean;\n  lastResult: SearchResult<T> | null;\n  error: Error | null;\n  clearError: () => void;\n  clearCache: () => void;\n  cacheStats: {\n    size: number;\n    hitRate: number;\n    lastAccess: Date | null;\n  };\n}\n\nexport function useDebouncedSearch<T>(\n  options: UseDebouncedSearchOptions<T>\n): UseDebouncedSearchReturn<T> {\n  const {\n    searchFunction,\n    debounceMs = 300,\n    cacheResults = true,\n    maxCacheSize = 100,\n    onSearchStart,\n    onSearchComplete,\n    onSearchError,\n  } = options;\n\n  const [isSearching, setIsSearching] = useState(false);\n  const [lastResult, setLastResult] = useState<SearchResult<T> | null>(null);\n  const [error, setError] = useState<Error | null>(null);\n\n  // Race condition prevention\n  const abortControllerRef = useRef<AbortController | null>(null);\n  const requestIdRef = useRef<number>(0);\n\n  // Cache management\n  const cacheRef = useRef<Map<string, { result: SearchResult<T>; timestamp: number }>>(new Map());\n  const [cacheStats, setCacheStats] = useState({\n    size: 0,\n    hitRate: 0,\n    lastAccess: null as Date | null,\n  });\n\n  const clearError = useCallback(() => {\n    setError(null);\n  }, []);\n\n  const clearCache = useCallback(() => {\n    cacheRef.current.clear();\n    setCacheStats(prev => ({ ...prev, size: 0 }));\n  }, []);\n\n  // Cleanup abort controller on unmount\n  useEffect(() => {\n    return () => {\n      if (abortControllerRef.current) {\n        abortControllerRef.current.abort();\n      }\n    };\n  }, []);\n\n  const generateCacheKey = useCallback((query: SearchQuery): string => {\n    return JSON.stringify({\n      filters: query.filters.sort((a, b) => a.id.localeCompare(b.id)),\n      sortBy: query.sortBy,\n      sortOrder: query.sortOrder,\n      page: query.page,\n      pageSize: query.pageSize,\n    });\n  }, []);\n\n  const searchImmediate = useCallback(\n    async (query: SearchQuery): Promise<SearchResult<T>> => {\n      // Cancel any previous in-flight request\n      if (abortControllerRef.current) {\n        abortControllerRef.current.abort();\n      }\n\n      // Create new abort controller for this request\n      const abortController = new AbortController();\n      abortControllerRef.current = abortController;\n\n      // Generate unique request ID for this search\n      const currentRequestId = ++requestIdRef.current;\n\n      if (!cacheResults) {\n        try {\n          const result = await searchFunction(query, abortController.signal);\n\n          // Only apply result if this is still the latest request\n          if (currentRequestId === requestIdRef.current) {\n            setLastResult(result);\n            onSearchComplete?.(result);\n          }\n\n          return result;\n        } catch (err) {\n          // Ignore abort errors - they're expected when cancelling previous requests\n          if (err instanceof Error && err.name === 'AbortError') {\n            throw err;\n          }\n\n          const error = err instanceof Error ? err : new Error('Search failed');\n          if (currentRequestId === requestIdRef.current) {\n            setError(error);\n            onSearchError?.(error);\n          }\n          throw error;\n        }\n      }\n\n      const cacheKey = generateCacheKey(query);\n      const cached = cacheRef.current.get(cacheKey);\n\n      if (cached && Date.now() - cached.timestamp < 5 * 60 * 1000) {\n        // 5 minute cache\n        setCacheStats(prev => ({\n          ...prev,\n          hitRate: prev.hitRate + 1,\n          lastAccess: new Date(),\n        }));\n        return cached.result;\n      }\n\n      setIsSearching(true);\n      setError(null);\n      onSearchStart?.();\n\n      try {\n        const result = await searchFunction(query, abortController.signal);\n\n        // Only apply and cache result if this is still the latest request\n        if (currentRequestId === requestIdRef.current) {\n          // Cache the result\n          if (cacheResults) {\n            cacheRef.current.set(cacheKey, {\n              result,\n              timestamp: Date.now(),\n            });\n\n            // Clean up old cache entries if needed\n            if (cacheRef.current.size > maxCacheSize) {\n              const entries = Array.from(cacheRef.current.entries());\n              entries.sort((a, b) => a[1].timestamp - b[1].timestamp);\n              const toDelete = entries.slice(0, entries.length - maxCacheSize);\n              toDelete.forEach(([key]) => cacheRef.current.delete(key));\n            }\n\n            setCacheStats(prev => ({\n              ...prev,\n              size: cacheRef.current.size,\n              hitRate: prev.hitRate,\n              lastAccess: new Date(),\n            }));\n          }\n\n          setLastResult(result);\n          onSearchComplete?.(result);\n        }\n\n        return result;\n      } catch (err) {\n        // Ignore abort errors - they're expected when cancelling previous requests\n        if (err instanceof Error && err.name === 'AbortError') {\n          throw err;\n        }\n\n        const error = err instanceof Error ? err : new Error('Search failed');\n\n        // Only set error if this is still the latest request\n        if (currentRequestId === requestIdRef.current) {\n          setError(error);\n          onSearchError?.(error);\n        }\n\n        throw error;\n      } finally {\n        // Only update isSearching if this is still the latest request\n        if (currentRequestId === requestIdRef.current) {\n          setIsSearching(false);\n        }\n      }\n    },\n    [\n      searchFunction,\n      cacheResults,\n      generateCacheKey,\n      maxCacheSize,\n      onSearchStart,\n      onSearchComplete,\n      onSearchError,\n    ]\n  );\n\n  const debouncedSearch = useMemo(\n    () => debounce(searchImmediate, debounceMs),\n    [searchImmediate, debounceMs]\n  );\n\n  const search = useCallback(\n    async (query: SearchQuery): Promise<SearchResult<T>> => {\n      return debouncedSearch(query);\n    },\n    [debouncedSearch]\n  );\n\n  return {\n    search,\n    searchImmediate,\n    isSearching,\n    lastResult,\n    error,\n    clearError,\n    clearCache,\n    cacheStats,\n  };\n}\n\n/**\n * Multi-attribute search hook\n * Enables searching across multiple fields simultaneously\n */\nexport interface UseMultiAttributeSearchOptions<T> {\n  data: T[];\n  searchFields: string[];\n  searchFunction?: (query: string, data: T[]) => T[];\n  caseSensitive?: boolean;\n  exactMatch?: boolean;\n  highlightMatches?: boolean;\n}\n\nexport interface UseMultiAttributeSearchReturn<T> {\n  searchQuery: string;\n  setSearchQuery: (query: string) => void;\n  filteredData: T[];\n  searchResults: {\n    item: T;\n    matches: {\n      field: string;\n      value: string;\n      highlighted: string;\n    }[];\n  }[];\n  clearSearch: () => void;\n  searchStats: {\n    totalItems: number;\n    filteredItems: number;\n    searchTime: number;\n  };\n}\n\nexport function useMultiAttributeSearch<T>(\n  options: UseMultiAttributeSearchOptions<T>\n): UseMultiAttributeSearchReturn<T> {\n  const {\n    data,\n    searchFields,\n    searchFunction,\n    caseSensitive = false,\n    exactMatch = false,\n    highlightMatches = true,\n  } = options;\n\n  const [searchQuery, setSearchQuery] = useState('');\n\n  const defaultSearchFunction = useCallback(\n    (query: string, items: T[]): T[] => {\n      if (!query.trim()) return items;\n\n      const normalizedQuery = caseSensitive ? query : query.toLowerCase();\n\n      return items.filter(item => {\n        return searchFields.some(field => {\n          const value = (item as Record<string, unknown>)[field];\n          if (value === null || value === undefined) return false;\n\n          const stringValue = String(value);\n          const normalizedValue = caseSensitive ? stringValue : stringValue.toLowerCase();\n\n          if (exactMatch) {\n            return normalizedValue === normalizedQuery;\n          } else {\n            return normalizedValue.includes(normalizedQuery);\n          }\n        });\n      });\n    },\n    [searchFields, caseSensitive, exactMatch]\n  );\n\n  const searchFn = searchFunction ?? defaultSearchFunction;\n\n  const filteredData = useMemo(() => {\n    return searchFn(searchQuery, data);\n  }, [searchQuery, data, searchFn]);\n\n  // Update search stats when filtered data changes\n  const searchStats = useMemo(\n    () => ({\n      totalItems: data.length,\n      filteredItems: filteredData.length,\n      searchTime: 0, // Performance measurement moved to useEffect\n    }),\n    [data.length, filteredData.length]\n  );\n\n  const searchResults = useMemo(() => {\n    if (!highlightMatches || !searchQuery.trim()) {\n      return filteredData.map(item => ({ item, matches: [] }));\n    }\n\n    const normalizedQuery = caseSensitive ? searchQuery : searchQuery.toLowerCase();\n\n    return filteredData.map(item => {\n      const matches = searchFields\n        .map(field => {\n          const value = (item as Record<string, unknown>)[field];\n          if (value === null || value === undefined) return null;\n\n          const stringValue = String(value);\n          const normalizedValue = caseSensitive ? stringValue : stringValue.toLowerCase();\n\n          if (exactMatch) {\n            if (normalizedValue !== normalizedQuery) return null;\n          } else {\n            if (!normalizedValue.includes(normalizedQuery)) return null;\n          }\n\n          // Create highlighted version\n          let highlighted: string;\n          if (exactMatch) {\n            // Short-circuit for exact matches - no regex needed\n            highlighted = `<mark>${stringValue}</mark>`;\n          } else {\n            // Use regex for partial matches with proper escaping\n            const regex = new RegExp(\n              searchQuery.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'),\n              caseSensitive ? 'g' : 'gi'\n            );\n            highlighted = stringValue.replace(regex, '<mark>$&</mark>');\n          }\n\n          return {\n            field,\n            value: stringValue,\n            highlighted,\n          };\n        })\n        .filter(Boolean) as {\n        field: string;\n        value: string;\n        highlighted: string;\n      }[];\n\n      return { item, matches };\n    });\n  }, [filteredData, searchQuery, searchFields, caseSensitive, exactMatch, highlightMatches]);\n\n  const clearSearch = useCallback(() => {\n    setSearchQuery('');\n  }, []);\n\n  return {\n    searchQuery,\n    setSearchQuery,\n    filteredData,\n    searchResults,\n    clearSearch,\n    searchStats,\n  };\n}\n\n/**\n * Search performance monitoring hook\n */\nexport interface UseSearchPerformanceOptions {\n  enableMetrics?: boolean;\n  logPerformance?: boolean;\n  performanceThreshold?: number;\n}\n\nexport interface UseSearchPerformanceReturn {\n  startTimer: () => void;\n  endTimer: () => number;\n  getMetrics: () => {\n    averageSearchTime: number;\n    totalSearches: number;\n    slowSearches: number;\n    performanceScore: number;\n  };\n  resetMetrics: () => void;\n}\n\nexport function useSearchPerformance(\n  options: UseSearchPerformanceOptions = {}\n): UseSearchPerformanceReturn {\n  const {\n    enableMetrics = true,\n    logPerformance = false,\n    performanceThreshold = 100, // ms\n  } = options;\n\n  const [metrics, setMetrics] = useState({\n    searchTimes: [] as number[],\n    totalSearches: 0,\n    slowSearches: 0,\n  });\n\n  const timersRef = useRef<Map<string, number>>(new Map());\n\n  const startTimer = useCallback(\n    (id = 'default') => {\n      if (enableMetrics) {\n        timersRef.current.set(id, performance.now());\n      }\n    },\n    [enableMetrics]\n  );\n\n  const endTimer = useCallback(\n    (id = 'default'): number => {\n      if (!enableMetrics) return 0;\n\n      const startTime = timersRef.current.get(id);\n      if (startTime === undefined) return 0;\n\n      const searchTime = performance.now() - startTime;\n      timersRef.current.delete(id);\n\n      setMetrics(prev => {\n        const newMetrics = {\n          searchTimes: [...prev.searchTimes, searchTime],\n          totalSearches: prev.totalSearches + 1,\n          slowSearches: prev.slowSearches + (searchTime > performanceThreshold ? 1 : 0),\n        };\n\n        if (logPerformance) {\n          // eslint-disable-next-line no-console\n          console.log(`Search completed in ${searchTime.toFixed(2)}ms`);\n          if (searchTime > performanceThreshold) {\n            console.warn(\n              `Slow search detected: ${searchTime.toFixed(2)}ms (threshold: ${String(performanceThreshold)}ms)`\n            );\n          }\n        }\n\n        return newMetrics;\n      });\n\n      return searchTime;\n    },\n    [enableMetrics, logPerformance, performanceThreshold]\n  );\n\n  const getMetrics = useCallback(() => {\n    const { searchTimes, totalSearches, slowSearches } = metrics;\n    const averageSearchTime =\n      searchTimes.length > 0\n        ? searchTimes.reduce((sum, time) => sum + time, 0) / searchTimes.length\n        : 0;\n\n    const performanceScore =\n      totalSearches > 0 ? Math.max(0, 100 - (slowSearches / totalSearches) * 100) : 100;\n\n    return {\n      averageSearchTime,\n      totalSearches,\n      slowSearches,\n      performanceScore,\n    };\n  }, [metrics]);\n\n  const resetMetrics = useCallback(() => {\n    setMetrics({\n      searchTimes: [],\n      totalSearches: 0,\n      slowSearches: 0,\n    });\n  }, []);\n\n  return {\n    startTimer,\n    endTimer,\n    getMetrics,\n    resetMetrics,\n  };\n}\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/hooks/useFetch.ts",
        "messages": [
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'useEffect' is defined but never used. Allowed unused vars must match /^_/u.",
                "line": 1,
                "column": 17,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 1,
                "endColumn": 26
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'NetworkError' is defined but never used. Allowed unused vars must match /^_/u.",
                "line": 6,
                "column": 25,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 6,
                "endColumn": 37
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'T' is defined but never used. Allowed unused vars must match /^_/u.",
                "line": 114,
                "column": 28,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 114,
                "endColumn": 29
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 238,
                "column": 10,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 238,
                "endColumn": 13,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                7998,
                                8002
                            ],
                            "text": "url == null"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                7999,
                                8002
                            ],
                            "text": "(url ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                7998,
                                8002
                            ],
                            "text": "!Boolean(url)"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 243,
                "column": 23,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 243,
                "endColumn": 30,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                8170,
                                8177
                            ],
                            "text": "(baseURL != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                8170,
                                8177
                            ],
                            "text": "(baseURL ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                8170,
                                8177
                            ],
                            "text": "(Boolean(baseURL))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 272,
                "column": 17,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 272,
                "endColumn": 19,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                9137,
                                9139
                            ],
                            "text": "(ra != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                9137,
                                9139
                            ],
                            "text": "(ra ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                9137,
                                9139
                            ],
                            "text": "(Boolean(ra))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/restrict-template-expressions",
                "severity": 1,
                "message": "Invalid type \"number\" of template literal expression.",
                "line": 280,
                "column": 45,
                "nodeType": "MemberExpression",
                "messageId": "invalidType",
                "endLine": 280,
                "endColumn": 60
            },
            {
                "ruleId": "react-hooks/exhaustive-deps",
                "severity": 1,
                "message": "React Hook useMemo has a missing dependency: 'fetchOptions'. Either include it or remove the dependency array.",
                "line": 379,
                "column": 6,
                "nodeType": "ArrayExpression",
                "endLine": 392,
                "endColumn": 4,
                "suggestions": [
                    {
                        "desc": "Update the dependencies array to be: [url, baseURL, retries, timeout, fetchOptions, transformResponse, validateResponse, retryOnNetworkError, transformError, retryDelay]",
                        "fix": {
                            "range": [
                                13314,
                                13636
                            ],
                            "text": "[url, baseURL, retries, timeout, fetchOptions, transformResponse, validateResponse, retryOnNetworkError, transformError, retryDelay]"
                        }
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 394,
                "column": 54,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 394,
                "endColumn": 57,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                13693,
                                13696
                            ],
                            "text": "(url != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                13693,
                                13696
                            ],
                            "text": "(url ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                13693,
                                13696
                            ],
                            "text": "(Boolean(url))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
                "line": 400,
                "column": 11,
                "nodeType": "ChainExpression",
                "messageId": "conditionErrorNullableBoolean",
                "endLine": 400,
                "endColumn": 36,
                "suggestions": [
                    {
                        "messageId": "conditionFixDefaultFalse",
                        "fix": {
                            "range": [
                                13964,
                                13989
                            ],
                            "text": "((asyncState.result?.isOk()) ?? false)"
                        },
                        "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
                    },
                    {
                        "messageId": "conditionFixCompareTrue",
                        "fix": {
                            "range": [
                                13964,
                                13989
                            ],
                            "text": "((asyncState.result?.isOk()) === true)"
                        },
                        "desc": "Change condition to check if true (`value === true`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
                "line": 402,
                "column": 12,
                "nodeType": "ChainExpression",
                "messageId": "conditionErrorNullableBoolean",
                "endLine": 402,
                "endColumn": 38,
                "suggestions": [
                    {
                        "messageId": "conditionFixDefaultFalse",
                        "fix": {
                            "range": [
                                14068,
                                14094
                            ],
                            "text": "((asyncState.result?.isErr()) ?? false)"
                        },
                        "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
                    },
                    {
                        "messageId": "conditionFixCompareTrue",
                        "fix": {
                            "range": [
                                14068,
                                14094
                            ],
                            "text": "((asyncState.result?.isErr()) === true)"
                        },
                        "desc": "Change condition to check if true (`value === true`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 448,
                "column": 8,
                "nodeType": "FunctionDeclaration",
                "messageId": "missingReturnType",
                "endLine": 448,
                "endColumn": 38
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
                "line": 497,
                "column": 9,
                "nodeType": "ChainExpression",
                "messageId": "conditionErrorNullableBoolean",
                "endLine": 497,
                "endColumn": 34,
                "suggestions": [
                    {
                        "messageId": "conditionFixDefaultFalse",
                        "fix": {
                            "range": [
                                17732,
                                17757
                            ],
                            "text": "(fetchState.result?.isOk()) ?? false"
                        },
                        "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
                    },
                    {
                        "messageId": "conditionFixCompareTrue",
                        "fix": {
                            "range": [
                                17732,
                                17757
                            ],
                            "text": "(fetchState.result?.isOk()) === true"
                        },
                        "desc": "Change condition to check if true (`value === true`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
                "line": 519,
                "column": 26,
                "nodeType": "ChainExpression",
                "messageId": "conditionErrorNullableBoolean",
                "endLine": 519,
                "endColumn": 44,
                "suggestions": [
                    {
                        "messageId": "conditionFixDefaultFalse",
                        "fix": {
                            "range": [
                                18731,
                                18749
                            ],
                            "text": "((baseResult?.isOk()) ?? false)"
                        },
                        "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
                    },
                    {
                        "messageId": "conditionFixCompareTrue",
                        "fix": {
                            "range": [
                                18731,
                                18749
                            ],
                            "text": "((baseResult?.isOk()) === true)"
                        },
                        "desc": "Change condition to check if true (`value === true`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
                "line": 536,
                "column": 12,
                "nodeType": "ChainExpression",
                "messageId": "conditionErrorNullableBoolean",
                "endLine": 536,
                "endColumn": 36,
                "suggestions": [
                    {
                        "messageId": "conditionFixDefaultFalse",
                        "fix": {
                            "range": [
                                19205,
                                19229
                            ],
                            "text": "((optimisticResult?.isOk()) ?? false)"
                        },
                        "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
                    },
                    {
                        "messageId": "conditionFixCompareFalse",
                        "fix": {
                            "range": [
                                19204,
                                19229
                            ],
                            "text": "(optimisticResult?.isOk()) === false"
                        },
                        "desc": "Change condition to check if false (`value === false`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
                "line": 561,
                "column": 9,
                "nodeType": "ChainExpression",
                "messageId": "conditionErrorNullableBoolean",
                "endLine": 561,
                "endColumn": 34,
                "suggestions": [
                    {
                        "messageId": "conditionFixDefaultFalse",
                        "fix": {
                            "range": [
                                19797,
                                19822
                            ],
                            "text": "(fetchState.result?.isOk()) ?? false"
                        },
                        "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
                    },
                    {
                        "messageId": "conditionFixCompareTrue",
                        "fix": {
                            "range": [
                                19797,
                                19822
                            ],
                            "text": "(fetchState.result?.isOk()) === true"
                        },
                        "desc": "Change condition to check if true (`value === true`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
                "line": 581,
                "column": 16,
                "nodeType": "ChainExpression",
                "messageId": "conditionErrorNullableBoolean",
                "endLine": 581,
                "endColumn": 30,
                "suggestions": [
                    {
                        "messageId": "conditionFixDefaultFalse",
                        "fix": {
                            "range": [
                                20472,
                                20486
                            ],
                            "text": "((result?.isOk()) ?? false)"
                        },
                        "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
                    },
                    {
                        "messageId": "conditionFixCompareTrue",
                        "fix": {
                            "range": [
                                20472,
                                20486
                            ],
                            "text": "((result?.isOk()) === true)"
                        },
                        "desc": "Change condition to check if true (`value === true`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
                "line": 582,
                "column": 17,
                "nodeType": "ChainExpression",
                "messageId": "conditionErrorNullableBoolean",
                "endLine": 582,
                "endColumn": 32,
                "suggestions": [
                    {
                        "messageId": "conditionFixDefaultFalse",
                        "fix": {
                            "range": [
                                20526,
                                20541
                            ],
                            "text": "((result?.isErr()) ?? false)"
                        },
                        "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
                    },
                    {
                        "messageId": "conditionFixCompareTrue",
                        "fix": {
                            "range": [
                                20526,
                                20541
                            ],
                            "text": "((result?.isErr()) === true)"
                        },
                        "desc": "Change condition to check if true (`value === true`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 614,
                "column": 8,
                "nodeType": "FunctionDeclaration",
                "messageId": "missingReturnType",
                "endLine": 614,
                "endColumn": 34
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 633,
                "column": 15,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 633,
                "endColumn": 17,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                21936,
                                21938
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 637,
                "column": 8,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 637,
                "endColumn": 16,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                22075,
                                22084
                            ],
                            "text": "cacheKey == null"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                22076,
                                22084
                            ],
                            "text": "(cacheKey ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                22075,
                                22084
                            ],
                            "text": "!Boolean(cacheKey)"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'cacheVersion' is assigned a value but never used. Allowed unused vars must match /^_/u.",
                "line": 643,
                "column": 10,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 643,
                "endColumn": 22
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
                "line": 649,
                "column": 26,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableBoolean",
                "endLine": 649,
                "endColumn": 38,
                "suggestions": [
                    {
                        "messageId": "conditionFixDefaultFalse",
                        "fix": {
                            "range": [
                                22589,
                                22601
                            ],
                            "text": "(isCacheValid ?? false)"
                        },
                        "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
                    },
                    {
                        "messageId": "conditionFixCompareTrue",
                        "fix": {
                            "range": [
                                22589,
                                22601
                            ],
                            "text": "(isCacheValid === true)"
                        },
                        "desc": "Change condition to check if true (`value === true`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
                "line": 649,
                "column": 43,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableBoolean",
                "endLine": 649,
                "endColumn": 55,
                "suggestions": [
                    {
                        "messageId": "conditionFixDefaultFalse",
                        "fix": {
                            "range": [
                                22606,
                                22618
                            ],
                            "text": "(isCacheStale ?? false)"
                        },
                        "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
                    },
                    {
                        "messageId": "conditionFixCompareFalse",
                        "fix": {
                            "range": [
                                22605,
                                22618
                            ],
                            "text": "(isCacheStale === false)"
                        },
                        "desc": "Change condition to check if false (`value === false`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
                "line": 653,
                "column": 13,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableBoolean",
                "endLine": 653,
                "endColumn": 27,
                "suggestions": [
                    {
                        "messageId": "conditionFixDefaultFalse",
                        "fix": {
                            "range": [
                                22729,
                                22743
                            ],
                            "text": "(shouldUseCache ?? false)"
                        },
                        "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
                    },
                    {
                        "messageId": "conditionFixCompareTrue",
                        "fix": {
                            "range": [
                                22729,
                                22743
                            ],
                            "text": "(shouldUseCache === true)"
                        },
                        "desc": "Change condition to check if true (`value === true`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
                "line": 653,
                "column": 32,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableBoolean",
                "endLine": 653,
                "endColumn": 44,
                "suggestions": [
                    {
                        "messageId": "conditionFixDefaultFalse",
                        "fix": {
                            "range": [
                                22748,
                                22760
                            ],
                            "text": "(isCacheStale ?? false)"
                        },
                        "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
                    },
                    {
                        "messageId": "conditionFixCompareFalse",
                        "fix": {
                            "range": [
                                22747,
                                22760
                            ],
                            "text": "(isCacheStale === false)"
                        },
                        "desc": "Change condition to check if false (`value === false`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
                "line": 668,
                "column": 24,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableBoolean",
                "endLine": 668,
                "endColumn": 38,
                "suggestions": [
                    {
                        "messageId": "conditionFixDefaultFalse",
                        "fix": {
                            "range": [
                                23152,
                                23166
                            ],
                            "text": "(shouldUseCache ?? false)"
                        },
                        "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
                    },
                    {
                        "messageId": "conditionFixCompareTrue",
                        "fix": {
                            "range": [
                                23152,
                                23166
                            ],
                            "text": "(shouldUseCache === true)"
                        },
                        "desc": "Change condition to check if true (`value === true`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, value is always truthy.",
                "line": 668,
                "column": 42,
                "nodeType": "Identifier",
                "messageId": "alwaysTruthy",
                "endLine": 668,
                "endColumn": 53
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected object value in conditional. The condition is always true.",
                "line": 668,
                "column": 42,
                "nodeType": "Identifier",
                "messageId": "conditionErrorObject",
                "endLine": 668,
                "endColumn": 53
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
                "line": 672,
                "column": 7,
                "nodeType": "ChainExpression",
                "messageId": "conditionErrorNullableBoolean",
                "endLine": 672,
                "endColumn": 27,
                "suggestions": [
                    {
                        "messageId": "conditionFixDefaultFalse",
                        "fix": {
                            "range": [
                                23338,
                                23358
                            ],
                            "text": "(activeResult?.isOk()) ?? false"
                        },
                        "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
                    },
                    {
                        "messageId": "conditionFixCompareTrue",
                        "fix": {
                            "range": [
                                23338,
                                23358
                            ],
                            "text": "(activeResult?.isOk()) === true"
                        },
                        "desc": "Change condition to check if true (`value === true`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
                "line": 674,
                "column": 14,
                "nodeType": "ChainExpression",
                "messageId": "conditionErrorNullableBoolean",
                "endLine": 674,
                "endColumn": 39,
                "suggestions": [
                    {
                        "messageId": "conditionFixDefaultFalse",
                        "fix": {
                            "range": [
                                23406,
                                23431
                            ],
                            "text": "(fetchState.result?.isOk()) ?? false"
                        },
                        "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
                    },
                    {
                        "messageId": "conditionFixCompareTrue",
                        "fix": {
                            "range": [
                                23406,
                                23431
                            ],
                            "text": "(fetchState.result?.isOk()) === true"
                        },
                        "desc": "Change condition to check if true (`value === true`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
                "line": 680,
                "column": 7,
                "nodeType": "ChainExpression",
                "messageId": "conditionErrorNullableBoolean",
                "endLine": 680,
                "endColumn": 28,
                "suggestions": [
                    {
                        "messageId": "conditionFixDefaultFalse",
                        "fix": {
                            "range": [
                                23610,
                                23631
                            ],
                            "text": "(activeResult?.isErr()) ?? false"
                        },
                        "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
                    },
                    {
                        "messageId": "conditionFixCompareTrue",
                        "fix": {
                            "range": [
                                23610,
                                23631
                            ],
                            "text": "(activeResult?.isErr()) === true"
                        },
                        "desc": "Change condition to check if true (`value === true`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
                "line": 682,
                "column": 14,
                "nodeType": "ChainExpression",
                "messageId": "conditionErrorNullableBoolean",
                "endLine": 682,
                "endColumn": 40,
                "suggestions": [
                    {
                        "messageId": "conditionFixDefaultFalse",
                        "fix": {
                            "range": [
                                23680,
                                23706
                            ],
                            "text": "(fetchState.result?.isErr()) ?? false"
                        },
                        "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
                    },
                    {
                        "messageId": "conditionFixCompareTrue",
                        "fix": {
                            "range": [
                                23680,
                                23706
                            ],
                            "text": "(fetchState.result?.isErr()) === true"
                        },
                        "desc": "Change condition to check if true (`value === true`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
                "line": 688,
                "column": 43,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableBoolean",
                "endLine": 688,
                "endColumn": 57,
                "suggestions": [
                    {
                        "messageId": "conditionFixDefaultFalse",
                        "fix": {
                            "range": [
                                23857,
                                23871
                            ],
                            "text": "(shouldUseCache ?? false)"
                        },
                        "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
                    },
                    {
                        "messageId": "conditionFixCompareFalse",
                        "fix": {
                            "range": [
                                23856,
                                23871
                            ],
                            "text": "(shouldUseCache === false)"
                        },
                        "desc": "Change condition to check if false (`value === false`)"
                    }
                ]
            },
            {
                "ruleId": "react-hooks/exhaustive-deps",
                "severity": 1,
                "message": "React Hook useCallback has a missing dependency: 'fetchState'. Either include it or remove the dependency array.",
                "line": 696,
                "column": 6,
                "nodeType": "ArrayExpression",
                "endLine": 696,
                "endColumn": 36,
                "suggestions": [
                    {
                        "desc": "Update the dependencies array to be: [cacheKey, fetchState]",
                        "fix": {
                            "range": [
                                24129,
                                24159
                            ],
                            "text": "[cacheKey, fetchState]"
                        }
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 700,
                "column": 30,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingReturnType",
                "endLine": 700,
                "endColumn": 32
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
                "line": 702,
                "column": 22,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableBoolean",
                "endLine": 702,
                "endColumn": 34,
                "suggestions": [
                    {
                        "messageId": "conditionFixDefaultFalse",
                        "fix": {
                            "range": [
                                24330,
                                24342
                            ],
                            "text": "(isCacheStale ?? false)"
                        },
                        "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
                    },
                    {
                        "messageId": "conditionFixCompareTrue",
                        "fix": {
                            "range": [
                                24330,
                                24342
                            ],
                            "text": "(isCacheStale === true)"
                        },
                        "desc": "Change condition to check if true (`value === true`)"
                    }
                ]
            }
        ],
        "suppressedMessages": [
            {
                "ruleId": "react-hooks/exhaustive-deps",
                "severity": 1,
                "message": "React Hook useMemo has a complex expression in the dependency array. Extract it to a separate variable so it can be statically checked.",
                "line": 391,
                "column": 5,
                "nodeType": "CallExpression",
                "endLine": 391,
                "endColumn": 33,
                "suppressions": [
                    {
                        "kind": "directive",
                        "justification": ""
                    }
                ]
            }
        ],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 37,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "import React, { useEffect, useMemo, useCallback } from 'react';\nimport type { DependencyList } from 'react';\nimport type { Result, AsyncResult } from '../types/fp';\nimport { useAsync } from './useAsync';\nimport { ok, err } from 'neverthrow';\nimport type { AppError, NetworkError } from '../types/errors';\nimport { createBusinessLogicError, createNetworkError } from '../types/errors';\nimport type { z } from 'zod';\nimport { SENSITIVE_QUERY_PARAMS } from '../config/sensitiveParams';\n\n/**\n * Safely parses a URL string, handling both absolute and relative URLs\n *\n * @param urlStr - The URL string to parse\n * @returns A parsed URL object\n * @throws Error if the URL cannot be parsed\n */\nconst parseUrlSafely = (urlStr: string): URL => {\n  const input = urlStr.trim();\n  // Determine a safe base for parsing relative URLs\n  let safeBase = 'http://localhost';\n  if (typeof window !== 'undefined' && typeof window.location !== 'undefined') {\n    const origin = window.location.origin;\n    // Only accept well-formed http(s) origins. Some test environments set\n    // origin to non-URL values like the string 'null' which we must ignore.\n    if (typeof origin === 'string' && /^https?:\\/\\//i.test(origin)) {\n      safeBase = origin;\n    }\n  }\n\n  // Try parsing as an absolute URL first\n  try {\n    return new URL(input);\n  } catch (absErr) {\n    // If the input looks like an absolute URL (has a scheme), don't try to\n    // treat it as relative  it's malformed and should be considered invalid.\n    const looksLikeAbsolute = /^[a-zA-Z][a-zA-Z0-9+.-]*:\\/\\//.test(input);\n    if (looksLikeAbsolute) {\n      throw absErr;\n    }\n\n    // Otherwise, try building an absolute URL by concatenating the safe\n    // base and the relative path. Some test environments may not support\n    // the URL(url, base) overload reliably.\n    const base = safeBase.replace(/\\/$/, '');\n    const candidate = input.startsWith('/') ? `${base}${input}` : `${base}/${input}`;\n    return new URL(candidate);\n  }\n};\n\n/**\n * Sanitizes a URL by removing or redacting sensitive query parameters\n * to prevent exposing tokens, sessions, auth keys, etc. in error logs\n *\n * @param urlStr - The URL string to sanitize\n * @returns URL with sensitive query parameters removed/redacted, or just origin+path\n */\nexport const sanitizeUrlForLogging = (urlStr: string): string => {\n  try {\n    const parsed = parseUrlSafely(urlStr);\n    const sensitiveKeys = SENSITIVE_QUERY_PARAMS.map(key => key.toLowerCase());\n\n    // Remove sensitive parameters (case-insensitive)\n    // URLSearchParams keys are case-sensitive, so we need to collect keys first\n    const keysToDelete: string[] = [];\n    for (const [key] of parsed.searchParams) {\n      if (sensitiveKeys.includes(key.toLowerCase())) {\n        keysToDelete.push(key);\n      }\n    }\n    keysToDelete.forEach(key => {\n      parsed.searchParams.delete(key);\n    });\n\n    // Deliberately drop URL fragment to avoid leaking tokens in logs\n    const hash = '';\n\n    // Return only pathname + remaining safe query params to avoid leaking origin/protocol\n    return parsed.pathname + (parsed.search ? parsed.search : '') + hash;\n  } catch {\n    // If URL parsing fails, return a redacted placeholder\n    return 'redacted-url';\n  }\n};\n\n/**\n * Module-level cache for useCachedFetch to persist across component lifecycles\n *\n * Note: For production applications, consider using:\n * - React Query (TanStack Query) for more sophisticated caching\n * - SWR for stale-while-revalidate caching strategy\n * - A context provider for app-wide cache management\n */\ninterface CacheEntry<T> {\n  result: Result<T, AppError>;\n  timestamp: number;\n  isStale: boolean;\n  version?: number;\n}\n\nconst CACHE_VERSION = 1;\n\nconst globalFetchCache = new Map<string, CacheEntry<unknown>>();\n\n/**\n * Note: In-memory cache has no persistence layer (localStorage/IndexedDB).\n * Cache is cleared on module reload. Versioning exists for future migration\n * if persisted storage is added later.\n */\n\n/**\n * Base configuration options for useFetch hook\n */\ninterface FetchOptionsBase<T = unknown> extends RequestInit {\n  /** Timeout in milliseconds */\n  timeout?: number;\n  /** Number of retries on failure */\n  retries?: number;\n  /** Delay between retries (ms) */\n  retryDelay?: number;\n  /** Whether to automatically retry on network errors */\n  retryOnNetworkError?: boolean;\n  /** Base URL to prepend to the endpoint */\n  baseURL?: string;\n  /** Transform error before returning */\n  transformError?: (error: AppError) => AppError;\n  /** When true, the request will only run when refetch is called */\n  manual?: boolean;\n}\n\n/**\n * Fetch options with transformResponse\n */\ninterface FetchOptionsWithTransform<T = unknown> extends FetchOptionsBase<T> {\n  /** Transform response data before returning */\n  transformResponse: (data: unknown) => T;\n  /** Validate transformed response data (Zod schema or transform) */\n  validateResponse?: z.ZodType<T>;\n}\n\n/**\n * Fetch options with validateResponse\n */\ninterface FetchOptionsWithValidate<T = unknown> extends FetchOptionsBase<T> {\n  /** Transform response data before returning */\n  transformResponse?: (data: unknown) => T;\n  /** Validate transformed response data (Zod schema or transform) */\n  validateResponse: z.ZodType<T>;\n}\n\n/**\n * Discriminated union type that requires at least one of transformResponse or validateResponse\n * This enforces compile-time type safety instead of runtime checks\n */\nexport type RequireTransformOrValidate<T = unknown> =\n  | FetchOptionsWithTransform<T>\n  | FetchOptionsWithValidate<T>;\n\n/**\n * Legacy type alias for backward compatibility\n * @deprecated Use RequireTransformOrValidate<T> instead for better type safety\n */\nexport type FetchOptions<T = unknown> = RequireTransformOrValidate<T>;\n\n/**\n * State of a fetch operation\n */\nexport interface FetchState<T> {\n  /** The fetched data */\n  data: T | null;\n  /** Whether data is currently being fetched */\n  loading: boolean;\n  /** Any error that occurred during fetching */\n  error: AppError | null;\n  /** Whether the operation is retrying */\n  retrying: boolean;\n  /** Refetch function */\n  refetch: () => AsyncResult<T, AppError>;\n  /** Latest Result<T, AppError> emitted by the hook */\n  result: Result<T, AppError> | null;\n}\n\n/**\n * Hook for making HTTP requests with Result-based error handling.\n *\n * Provides automatic error handling, retry logic, and payload transformation using\n * railway-oriented programming patterns.\n *\n * **IMPORTANT**: For type safety, you MUST provide either `transformResponse` or `validateResponse`\n * in the options. The type system enforces this requirement at compile-time, preventing\n * unsafe blind casting of response data to type T.\n *\n * @template T The expected response data type\n * @param url URL to fetch (pass `null` to pause requests)\n * @param options Optional configuration including retries, timeout, and transformers\n * @returns Fetch state with data, loading, error flags, and a refetch trigger\n * @example\n * ```typescript\n * // Recommended: Use validateResponse with Zod schema for full type safety\n * const { data, loading, error } = useFetch<ContactDTO[]>(\n *   '/contacts',\n *   {\n *     baseURL: apiBase,\n *     validateResponse: ContactDTOArraySchema\n *   }\n * );\n *\n * // Alternative: Use transformResponse for custom transformation\n * const { data } = useFetch<ContactDTO[]>(\n *   '/contacts',\n *   {\n *     baseURL: apiBase,\n *     transformResponse: (data) => data as ContactDTO[]\n *   }\n * );\n * ```\n */\nexport function useFetch<T = unknown>(\n  url: string | null,\n  options: RequireTransformOrValidate<T>\n): FetchState<T> {\n  // Destructure options for stable dependencies\n  const {\n    timeout = 10000,\n    retries = 3,\n    retryDelay = 1000,\n    retryOnNetworkError = true,\n    baseURL,\n    transformResponse,\n    validateResponse,\n    transformError,\n    manual = false,\n    ...fetchOptions\n  } = options;\n\n  // Enhanced fetch function with error handling and retry logic\n  const fetchData = useMemo(() => {\n    if (!url) {\n      return () => Promise.resolve(err(createNetworkError('No URL provided')));\n    }\n\n    return async (): Promise<Result<T, AppError>> => {\n      const fullUrl = baseURL ? new URL(url, baseURL).toString() : url;\n\n      for (let attempt = 0; attempt <= retries; attempt++) {\n        let timeoutId: ReturnType<typeof setTimeout> | undefined;\n        try {\n          // Create AbortController for timeout and cancellation\n          const controller = new AbortController();\n\n          // Set up timeout\n          timeoutId = setTimeout(() => {\n            controller.abort();\n          }, timeout);\n\n          const response = await fetch(fullUrl, {\n            ...fetchOptions,\n            signal: controller.signal,\n          });\n\n          clearTimeout(timeoutId);\n\n          if (!response.ok) {\n            const isRetryable =\n              retryOnNetworkError &&\n              attempt < retries &&\n              (response.status >= 500 || response.status === 408 || response.status === 429);\n\n            if (isRetryable) {\n              const ra = response.headers.get('retry-after');\n              const ms =\n                ra && /^\\d+$/.test(ra)\n                  ? parseInt(ra, 10) * 1000\n                  : retryDelay * Math.pow(2, attempt);\n              await new Promise(resolve => setTimeout(resolve, ms));\n              continue;\n            }\n\n            const error = createNetworkError(\n              `Request failed with status ${response.status}`,\n              { statusCode: response.status },\n              { retryable: isRetryable }\n            );\n            return err(transformError ? transformError(error) : error);\n          }\n\n          // Parse response\n          const contentType = response.headers.get('content-type')?.toLowerCase() ?? '';\n          let data: unknown;\n\n          if (contentType.includes('json')) {\n            data = (await response.json()) as unknown;\n          } else {\n            data = await response.text();\n          }\n\n          // Transform response if transformResponse is provided\n          let transformedData: T;\n          if (transformResponse) {\n            transformedData = transformResponse(data);\n          } else {\n            // If no transformResponse, we'll validate first (if validateResponse exists)\n            // or cast as a last resort (with warning already logged above)\n            transformedData = data as T;\n          }\n\n          // Validate transformed data if schema provided\n          // This runs AFTER transformation to validate the final shape\n          if (validateResponse) {\n            const validationResult = validateResponse.safeParse(transformedData);\n            if (!validationResult.success) {\n              // Extract validation paths and schema information for better diagnostics\n              const validationPaths = validationResult.error.issues.map(issue => ({\n                path: issue.path.join('.'),\n                code: issue.code,\n                message: issue.message,\n              }));\n\n              // Determine response shape for diagnostics\n              const responseShape =\n                typeof transformedData === 'object' && transformedData !== null\n                  ? Object.keys(transformedData as Record<string, unknown>)\n                  : typeof transformedData;\n\n              return err(\n                createBusinessLogicError(\n                  `Response validation failed: ${validationResult.error.message}`,\n                  {\n                    validationPaths,\n                    responseShape,\n                    // Use sanitized URL to prevent leaking sensitive query parameters\n                    url: sanitizeUrlForLogging(fullUrl),\n                  }\n                )\n              );\n            }\n            // Use validated data from Zod (which ensures type safety)\n            transformedData = validationResult.data;\n          }\n\n          return ok(transformedData);\n        } catch (error) {\n          const isAbort =\n            (typeof DOMException !== 'undefined' &&\n              error instanceof DOMException &&\n              error.name === 'AbortError') ||\n            (error instanceof Error && error.name === 'AbortError');\n          const isTypeErr = error instanceof TypeError;\n          const isNetworkError = isAbort || isTypeErr;\n\n          if (isNetworkError && retryOnNetworkError && attempt < retries) {\n            // Exponential backoff for network errors\n            await new Promise(resolve => setTimeout(resolve, retryDelay * Math.pow(2, attempt)));\n            continue;\n          }\n\n          // Create appropriate error\n          const netError = createNetworkError(\n            error instanceof Error ? error.message : 'Network request failed',\n            undefined,\n            {\n              retryable: isNetworkError && retryOnNetworkError,\n              cause: error instanceof Error ? error : undefined,\n            }\n          );\n\n          return err(transformError ? transformError(netError) : netError);\n        } finally {\n          // Always clear timeout\n          if (timeoutId !== undefined) {\n            clearTimeout(timeoutId);\n          }\n        }\n      }\n\n      // Should never reach here, but TypeScript requires it\n      return err(createNetworkError('Max retries exceeded'));\n    };\n  }, [\n    url,\n    timeout,\n    retries,\n    retryDelay,\n    retryOnNetworkError,\n    baseURL,\n    transformResponse,\n    validateResponse,\n    transformError,\n    // Use JSON.stringify for complex fetchOptions to detect changes\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    JSON.stringify(fetchOptions),\n  ]);\n\n  const dependencies: DependencyList = manual ? [] : url ? [url] : [];\n  const asyncState = useAsync<T, AppError>(fetchData, dependencies);\n\n  // Note: useFetch returns Result<T, AppError> via asyncState.result for FP patterns\n  // For consumers needing ApiResponseWrapper, wrap at the service boundary\n  return {\n    data: asyncState.result?.isOk() ? asyncState.result.value : null,\n    loading: asyncState.loading,\n    error: asyncState.result?.isErr() ? asyncState.result.error : null,\n    retrying: false, // Would need more complex state management for this\n    refetch: asyncState.execute,\n    result: asyncState.result,\n  };\n}\n\n/**\n * Helper type to extract optimistic-specific options from combined options\n * This allows better separation of concerns and avoids type casting\n */\ninterface OptimisticProps<T> {\n  initialData?: T;\n  optimisticUpdate?: (currentData: T | null) => Result<T, AppError>;\n  rollbackUpdate?: (optimisticData: T, error: AppError) => Result<T, AppError>;\n}\n\n/**\n * Combined options for useOptimisticFetch combining base fetch and optimistic props\n */\ntype OptimisticFetchOptions<T> = RequireTransformOrValidate<T> & OptimisticProps<T>;\n\n/**\n * Adds optimistic update helpers on top of `useFetch` for latency-sensitive flows.\n *\n * @template T Response data type\n * @param url URL to fetch (pass `null` to disable)\n * @param options Fetch options plus optimistic configuration\n * @returns Fetch state extended with optimistic helpers\n * @example\n * ```typescript\n * const fetchState = useOptimisticFetch<ContactDTO[]>('/contacts', {\n *   baseURL: apiBase,\n *   optimisticUpdate: current => ok([newContact, ...(current ?? [])]),\n *   rollbackUpdate: (_optimistic, error) => err(error),\n * });\n *\n * const handleCreate = async () => {\n *   const optimistic = fetchState.applyOptimisticUpdate();\n *   if (optimistic.isOk()) {\n *     await createContact(optimistic.value[0]);\n *     await fetchState.refetch();\n *   }\n * };\n * ```\n */\nexport function useOptimisticFetch<T>(url: string | null, options: OptimisticFetchOptions<T>) {\n  // Extract optimistic-specific properties from the combined options\n  const { initialData, optimisticUpdate, rollbackUpdate, ...fetchOptions } = options;\n\n  // Explicitly type baseFetchOptions for clarity and to document that it contains the required\n  // transformResponse or validateResponse from the original options (guaranteed by OptimisticFetchOptions extends RequireTransformOrValidate)\n  const baseFetchOptions: RequireTransformOrValidate<T> = fetchOptions;\n  const fetchState = useFetch<T>(url, baseFetchOptions);\n\n  const [optimisticResult, setOptimisticResult] = React.useState<Result<T, AppError> | null>(\n    initialData !== undefined ? ok(initialData) : null\n  );\n  const [isOptimistic, setIsOptimistic] = React.useState(false);\n  const [lastStableResult, setLastStableResult] = React.useState<Result<T, AppError> | null>(\n    initialData !== undefined ? ok(initialData) : null\n  );\n\n  const optimisticResultRef = React.useRef<Result<T, AppError> | null>(optimisticResult);\n  const lastStableResultRef = React.useRef<Result<T, AppError> | null>(lastStableResult);\n  const fetchResultRef = React.useRef<Result<T, AppError> | null>(fetchState.result ?? null);\n  const initialDataRef = React.useRef<T | undefined>(initialData);\n  const optimisticUpdateRef = React.useRef<typeof optimisticUpdate>(optimisticUpdate);\n  const isOptimisticRef = React.useRef<boolean>(isOptimistic);\n\n  React.useEffect(() => {\n    optimisticResultRef.current = optimisticResult;\n  }, [optimisticResult]);\n\n  React.useEffect(() => {\n    lastStableResultRef.current = lastStableResult;\n  }, [lastStableResult]);\n\n  React.useEffect(() => {\n    fetchResultRef.current = fetchState.result ?? null;\n  }, [fetchState.result]);\n\n  React.useEffect(() => {\n    initialDataRef.current = initialData;\n  }, [initialData]);\n\n  React.useEffect(() => {\n    optimisticUpdateRef.current = optimisticUpdate;\n  }, [optimisticUpdate]);\n\n  React.useEffect(() => {\n    isOptimisticRef.current = isOptimistic;\n  }, [isOptimistic]);\n\n  React.useEffect(() => {\n    if (fetchState.result?.isOk()) {\n      setLastStableResult(fetchState.result);\n      if (!isOptimistic) {\n        setOptimisticResult(null);\n      }\n    }\n  }, [fetchState.result, isOptimistic]);\n\n  const applyOptimisticUpdate = React.useCallback((): Result<T, AppError> => {\n    const updateFn = optimisticUpdateRef.current;\n    if (!updateFn) {\n      return err(createBusinessLogicError('No optimistic update handler provided'));\n    }\n\n    // Derive baseResult: use optimistic result when isOptimistic is true, otherwise use fetch or stable result\n    // Precedence: 1. if isOptimistic use optimisticResult, 2. otherwise prefer latest server fetchState.result, 3. fallback to lastStableResult\n    const baseResult =\n      (isOptimisticRef.current && optimisticResultRef.current\n        ? optimisticResultRef.current\n        : fetchResultRef.current) ?? lastStableResultRef.current;\n\n    // Compute currentValue from baseResult if it's ok, falling back to initialData or null\n    const currentValue = baseResult?.isOk() ? baseResult.value : (initialDataRef.current ?? null);\n\n    const updateResult = updateFn(currentValue);\n\n    // Always set the optimistic result\n    setOptimisticResult(updateResult);\n\n    // Only set isOptimistic to true when update succeeds, leave unchanged on error\n    if (updateResult.isOk()) {\n      setIsOptimistic(true);\n    }\n\n    return updateResult;\n  }, []);\n\n  const handleRollback = React.useCallback(\n    (error: AppError) => {\n      if (!optimisticResult?.isOk()) {\n        return;\n      }\n\n      let rollbackResult: Result<T, AppError>;\n      if (rollbackUpdate) {\n        rollbackResult = rollbackUpdate(optimisticResult.value, error);\n      } else {\n        rollbackResult = lastStableResult ?? err(error);\n      }\n\n      setOptimisticResult(rollbackResult);\n      if (rollbackResult.isOk()) {\n        setLastStableResult(rollbackResult);\n      }\n      setIsOptimistic(false);\n    },\n    [optimisticResult, rollbackUpdate, lastStableResult]\n  );\n\n  React.useEffect(() => {\n    if (!isOptimistic) {\n      return;\n    }\n\n    if (fetchState.result?.isOk()) {\n      setIsOptimistic(false);\n      setOptimisticResult(null);\n      return;\n    }\n\n    if (fetchState.error) {\n      handleRollback(fetchState.error);\n    }\n  }, [isOptimistic, fetchState.error, fetchState.result, handleRollback]);\n\n  const activeResult = useMemo(() => {\n    if (isOptimistic && optimisticResult) {\n      return optimisticResult;\n    }\n    return fetchState.result ?? optimisticResult ?? lastStableResult;\n  }, [isOptimistic, optimisticResult, fetchState.result, lastStableResult]);\n\n  // Consolidate data/error derivation from a single source of truth\n  const result = activeResult ?? fetchState.result ?? null;\n  const data = result?.isOk() ? result.value : null;\n  const error = result?.isErr() ? result.error : (fetchState.error ?? null);\n\n  return {\n    ...fetchState,\n    data,\n    error,\n    result: activeResult ?? fetchState.result,\n    applyOptimisticUpdate,\n    isOptimistic,\n  };\n}\n\n/**\n * Provides caching semantics for fetch operations with stale-time awareness.\n *\n * @template T Response data type\n * @param url URL to fetch (pass `null` to disable)\n * @param options Fetch options plus cache configuration\n * @returns Fetch state whose data is hydrated from cache when available\n * @example\n * ```typescript\n * const tenants = useCachedFetch<PaginatedTenantResponse>('/tenants', {\n *   baseURL: apiBase,\n *   cacheKey: 'tenants:list',\n *   cacheTime: CacheTTL.MEDIUM,\n * });\n *\n * useEffect(() => {\n *   tenants.refetch();\n * }, [tenants.refetch]);\n * ```\n */\nexport function useCachedFetch<T>(\n  url: string | null,\n  options?: RequireTransformOrValidate<T> & {\n    /** Cache key - required when url is null to avoid collisions across consumers */\n    cacheKey?: string;\n    /** Cache duration in milliseconds */\n    cacheTime?: number;\n    /** Whether to refetch in background */\n    refetchOnWindowFocus?: boolean;\n    /** Stale time before considering data stale */\n    staleTime?: number;\n  }\n) {\n  const {\n    cacheKey: providedCacheKey,\n    cacheTime = 5 * 60 * 1000, // 5 minutes\n    refetchOnWindowFocus = false,\n    staleTime = 0,\n    ...fetchOptions\n  } = options || {};\n\n  // Require explicit cacheKey when url is null to prevent accidental collisions\n  const cacheKey = providedCacheKey ?? url;\n  if (!cacheKey) {\n    throw new Error(\n      'useCachedFetch requires either a url or an explicit cacheKey to prevent cache collisions'\n    );\n  }\n\n  const [cacheVersion, setCacheVersion] = React.useState(0);\n\n  const cachedEntry = globalFetchCache.get(cacheKey) as CacheEntry<T> | undefined;\n  const now = Date.now();\n  const isCacheValid = cachedEntry && now - cachedEntry.timestamp < cacheTime;\n  const isCacheStale = cachedEntry && staleTime > 0 && now - cachedEntry.timestamp > staleTime;\n  const shouldUseCache = isCacheValid && !isCacheStale;\n\n  const fetchState = useFetch<T>(url, {\n    ...(fetchOptions as RequireTransformOrValidate<T>),\n    manual: shouldUseCache && !isCacheStale,\n  });\n\n  React.useEffect(() => {\n    if (!fetchState.loading && fetchState.result) {\n      globalFetchCache.set(cacheKey, {\n        result: fetchState.result,\n        timestamp: Date.now(),\n        isStale: false,\n        version: CACHE_VERSION,\n      });\n      setCacheVersion(version => version + 1);\n    }\n  }, [fetchState.loading, fetchState.result, cacheKey]);\n\n  const activeResult = shouldUseCache && cachedEntry ? cachedEntry.result : fetchState.result;\n\n  // Derive data: check activeResult first, then fetchState.result, then null\n  let data: T | null = null;\n  if (activeResult?.isOk()) {\n    data = activeResult.value;\n  } else if (fetchState.result?.isOk()) {\n    data = fetchState.result.value;\n  }\n\n  // Derive error: check activeResult first, then fetchState.result, then fetchState.error\n  let error: AppError | null = null;\n  if (activeResult?.isErr()) {\n    error = activeResult.error;\n  } else if (fetchState.result?.isErr()) {\n    error = fetchState.result.error;\n  } else if (fetchState.error) {\n    error = fetchState.error;\n  }\n\n  const loading = fetchState.loading && (!shouldUseCache || isCacheStale);\n\n  const refetch = useCallback((): AsyncResult<T, AppError> => {\n    if (globalFetchCache.has(cacheKey)) {\n      globalFetchCache.delete(cacheKey);\n      setCacheVersion(version => version + 1);\n    }\n    return fetchState.refetch();\n  }, [cacheKey, fetchState.refetch]);\n\n  React.useEffect(() => {\n    if (refetchOnWindowFocus) {\n      const handleFocus = () => {\n        const entry = globalFetchCache.get(cacheKey);\n        if (entry && isCacheStale) {\n          globalFetchCache.set(cacheKey, { ...entry, isStale: true });\n          setCacheVersion(version => version + 1);\n          refetch();\n        }\n      };\n      window.addEventListener('focus', handleFocus);\n      return () => {\n        window.removeEventListener('focus', handleFocus);\n      };\n    }\n  }, [refetchOnWindowFocus, cacheKey, isCacheStale, refetch]);\n\n  return {\n    ...fetchState,\n    data,\n    error,\n    result: activeResult ?? fetchState.result,\n    loading,\n    refetch,\n    isCached: shouldUseCache,\n    isStale: isCacheStale,\n  };\n}\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/hooks/useFormValidation.ts",
        "messages": [
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'Result' is defined but never used. Allowed unused vars must match /^_/u.",
                "line": 2,
                "column": 15,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 2,
                "endColumn": 21
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-type-parameters",
                "severity": 1,
                "message": "Type parameter K is used only once in the function signature.",
                "line": 42,
                "column": 23,
                "nodeType": "TSTypeParameter",
                "messageId": "sole",
                "endLine": 42,
                "endColumn": 40,
                "suggestions": [
                    {
                        "messageId": "replaceUsagesWithConstraint",
                        "fix": {
                            "range": [
                                1274,
                                1302
                            ],
                            "text": "(field: keyof T"
                        },
                        "desc": "Replace all usages of type parameter with its constraint."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, value is always truthy.",
                "line": 125,
                "column": 28,
                "nodeType": "MemberExpression",
                "messageId": "alwaysTruthy",
                "endLine": 125,
                "endColumn": 54
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected object value in conditional. The condition is always true.",
                "line": 125,
                "column": 28,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorObject",
                "endLine": 125,
                "endColumn": 54
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, value is always truthy.",
                "line": 153,
                "column": 17,
                "nodeType": "MemberExpression",
                "messageId": "alwaysTruthy",
                "endLine": 153,
                "endColumn": 43
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected object value in conditional. The condition is always true.",
                "line": 153,
                "column": 17,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorObject",
                "endLine": 153,
                "endColumn": 43
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, value is always truthy.",
                "line": 170,
                "column": 17,
                "nodeType": "MemberExpression",
                "messageId": "alwaysTruthy",
                "endLine": 170,
                "endColumn": 43
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected object value in conditional. The condition is always true.",
                "line": 170,
                "column": 17,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorObject",
                "endLine": 170,
                "endColumn": 43
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 307,
                "column": 26,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 307,
                "endColumn": 28,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                8696,
                                8698
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary optional chain on a non-nullish value.",
                "line": 318,
                "column": 58,
                "nodeType": "MemberExpression",
                "messageId": "neverOptionalChain",
                "endLine": 318,
                "endColumn": 60,
                "suggestions": [
                    {
                        "messageId": "suggestRemoveOptionalChain",
                        "fix": {
                            "range": [
                                8986,
                                8988
                            ],
                            "text": "."
                        },
                        "desc": "Remove unnecessary optional chain"
                    }
                ]
            },
            {
                "ruleId": "react-hooks/exhaustive-deps",
                "severity": 1,
                "message": "React Hook useEffect has missing dependencies: 'state.fields' and 'validateAndUpdateField'. Either include them or remove the dependency array.",
                "line": 333,
                "column": 6,
                "nodeType": "ArrayExpression",
                "endLine": 333,
                "endColumn": 8,
                "suggestions": [
                    {
                        "desc": "Update the dependencies array to be: [state.fields, validateAndUpdateField]",
                        "fix": {
                            "range": [
                                9406,
                                9408
                            ],
                            "text": "[state.fields, validateAndUpdateField]"
                        }
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 349,
                "column": 34,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 349,
                "endColumn": 36,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                9991,
                                9993
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-type-parameters",
                "severity": 1,
                "message": "Type parameter K is used only once in the function signature.",
                "line": 403,
                "column": 25,
                "nodeType": "TSTypeParameter",
                "messageId": "sole",
                "endLine": 403,
                "endColumn": 42,
                "suggestions": [
                    {
                        "messageId": "replaceUsagesWithConstraint",
                        "fix": {
                            "range": [
                                11252,
                                11280
                            ],
                            "text": "(field: keyof T"
                        },
                        "desc": "Replace all usages of type parameter with its constraint."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 473,
                "column": 8,
                "nodeType": "FunctionDeclaration",
                "messageId": "missingReturnType",
                "endLine": 473,
                "endColumn": 75
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.",
                "line": 493,
                "column": 44,
                "nodeType": "MemberExpression",
                "messageId": "neverNullish",
                "endLine": 493,
                "endColumn": 72
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.",
                "line": 494,
                "column": 43,
                "nodeType": "MemberExpression",
                "messageId": "neverNullish",
                "endLine": 494,
                "endColumn": 71
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 494,
                "column": 82,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 494,
                "endColumn": 84,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                13995,
                                13997
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 17,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "import { useMemo, useCallback, useReducer, useEffect, useRef } from 'react';\nimport type { Result } from '../types/fp';\nimport type { FormValidationError } from '../utils/formValidation';\nimport type { ValidationFn } from './useValidation';\n\n/**\n * Represents the state of a form field with its validation\n */\nexport interface FormField<T> {\n  /** Current value of the field */\n  value: T | undefined;\n  /** Whether the field has been touched (focused) */\n  touched: boolean;\n  /** Whether the field has been modified */\n  dirty: boolean;\n  /** Validation result */\n  validation: {\n    isValid: boolean;\n    error: FormValidationError | null;\n    errors: FormValidationError[];\n  };\n}\n\n/**\n * Complete form validation state\n */\nexport interface FormValidationState<T extends Record<string, unknown>> {\n  /** Form field states */\n  fields: { [K in keyof T]: FormField<T[K]> };\n  /** Overall form validation state */\n  form: {\n    isValid: boolean;\n    isDirty: boolean;\n    errors: Record<keyof T, FormValidationError[]>;\n    hasErrors: boolean;\n  };\n  /** Actions to manipulate form state */\n  actions: {\n    /** Set value for a specific field */\n    setFieldValue: <K extends keyof T>(field: K, value: T[K]) => void;\n    /** Mark a field as touched */\n    setFieldTouched: <K extends keyof T>(field: K, touched?: boolean) => void;\n    /** Validate a specific field */\n    validateField: <K extends keyof T>(\n      field: K\n    ) => {\n      isValid: boolean;\n      value: T[K] | null | undefined;\n      error: FormValidationError | null;\n      errors: FormValidationError[];\n    };\n    /** Validate all fields */\n    validateForm: () => {\n      isValid: boolean;\n      values: Partial<T>;\n      errors: Record<keyof T, FormValidationError[]>;\n    };\n    /** Reset form to initial state */\n    reset: () => void;\n    /** Set values for multiple fields at once */\n    setValues: (values: Partial<T>) => void;\n  };\n}\n\n/**\n * Configuration for form validation\n */\nexport interface FormValidationConfig<T extends Record<string, unknown>> {\n  /** Initial values for form fields */\n  initialValues: Partial<T>;\n  /** Validation functions for each field */\n  validators: {\n    [K in keyof T]?: ValidationFn<T[K], FormValidationError>[];\n  };\n  /** Validation mode */\n  mode?: 'onChange' | 'onBlur' | 'onSubmit';\n  /** Whether to validate on mount */\n  validateOnMount?: boolean;\n}\n\n// Form state stored in reducer\ninterface FormState<T extends Record<string, unknown>> {\n  fields: {\n    [K in keyof T]: {\n      value: T[K] | undefined;\n      touched: boolean;\n      dirty: boolean;\n      errors: FormValidationError[];\n    };\n  };\n  initialValues: Partial<T>;\n}\n\n// Actions for the reducer\ntype FormAction<T extends Record<string, unknown>> =\n  | { type: 'SET_FIELD_VALUE'; field: keyof T; value: T[keyof T] }\n  | { type: 'SET_FIELD_TOUCHED'; field: keyof T; touched: boolean }\n  | { type: 'SET_FIELD_ERRORS'; field: keyof T; errors: FormValidationError[] }\n  | { type: 'SET_VALUES'; values: Partial<T> }\n  | { type: 'RESET' };\n\nfunction createInitialState<T extends Record<string, unknown>>(\n  initialValues: Partial<T>\n): FormState<T> {\n  const fields = {} as FormState<T>['fields'];\n\n  for (const key of Object.keys(initialValues) as (keyof T)[]) {\n    fields[key] = {\n      value: initialValues[key],\n      touched: false,\n      dirty: false,\n      errors: [],\n    };\n  }\n\n  return { fields, initialValues };\n}\n\nfunction formReducer<T extends Record<string, unknown>>(\n  state: FormState<T>,\n  action: FormAction<T>\n): FormState<T> {\n  switch (action.type) {\n    case 'SET_FIELD_VALUE': {\n      const currentField = state.fields[action.field] || {\n        value: state.initialValues[action.field],\n        touched: false,\n        dirty: false,\n        errors: [],\n      };\n      const initialValue = state.initialValues[action.field];\n      const isDirty = action.value !== initialValue;\n\n      return {\n        ...state,\n        fields: {\n          ...state.fields,\n          [action.field]: {\n            ...currentField,\n            value: action.value,\n            dirty: isDirty,\n          },\n        },\n      };\n    }\n\n    case 'SET_FIELD_TOUCHED':\n      return {\n        ...state,\n        fields: {\n          ...state.fields,\n          [action.field]: {\n            ...(state.fields[action.field] || {\n              value: state.initialValues[action.field],\n              touched: false,\n              dirty: false,\n              errors: [],\n            }),\n            touched: action.touched,\n          },\n        },\n      };\n\n    case 'SET_FIELD_ERRORS':\n      return {\n        ...state,\n        fields: {\n          ...state.fields,\n          [action.field]: {\n            ...(state.fields[action.field] || {\n              value: state.initialValues[action.field],\n              touched: false,\n              dirty: false,\n            }),\n            errors: action.errors,\n          },\n        },\n      };\n\n    case 'SET_VALUES': {\n      const newFields = { ...state.fields };\n\n      for (const [key, value] of Object.entries(action.values) as [keyof T, T[keyof T]][]) {\n        const initialValue = state.initialValues[key];\n        const isDirty = value !== initialValue;\n\n        newFields[key] = {\n          ...newFields[key],\n          value,\n          dirty: isDirty,\n        };\n      }\n\n      return {\n        ...state,\n        fields: newFields,\n      };\n    }\n\n    case 'RESET':\n      return createInitialState(state.initialValues);\n\n    default:\n      return state;\n  }\n}\n\n/**\n * Railway-oriented form validation hook.\n *\n * Provides comprehensive form validation using Result-based validators. The hook tracks field\n * dirtiness, touch state, and aggregates validation errors so submit handlers can reason about\n * both per-field and global validity.\n *\n * @template T Shape of the form values\n * @param config Form validation configuration object\n * @returns Form validation state and action helpers\n * @example\n * ```typescript\n * const form = useFormValidation<LoginFormValues>({\n *   initialValues: { email: '', password: '' },\n *   validators: {\n *     email: [validateEmail],\n *     password: [validatePassword],\n *   },\n *   mode: 'onSubmit',\n * });\n *\n * const onSubmit = () => {\n *   const validation = form.actions.validateForm();\n *   if (validation.isValid) {\n *     authService.login(validation.values as LoginFormValues);\n *   }\n * };\n * ```\n */\nexport function useFormValidation<T extends Record<string, unknown>>(\n  config: FormValidationConfig<T>\n): FormValidationState<T> {\n  const { initialValues, validators, mode = 'onChange', validateOnMount = false } = config;\n\n  // Use reducer to manage form state\n  const [state, dispatch] = useReducer(formReducer<T>, initialValues, createInitialState);\n\n  // Capture initial validateOnMount value to avoid re-running effect\n  const initialValidateOnMount = useRef(validateOnMount);\n\n  // Validation function for a field\n  const validateFieldValue = useCallback(\n    <K extends keyof T>(\n      field: K,\n      value: T[K] | undefined\n    ): {\n      isValid: boolean;\n      value: T[K] | null | undefined;\n      error: FormValidationError | null;\n      errors: FormValidationError[];\n    } => {\n      const fieldValidators = validators[field] || [];\n      const errors: FormValidationError[] = [];\n      let currentValue: T[K] | undefined = value;\n\n      // Only enforce REQUIRED_FIELD error if validators exist\n      if ((value === undefined || value === null) && fieldValidators.length > 0) {\n        return {\n          isValid: false,\n          value: null,\n          error: {\n            type: 'REQUIRED_FIELD',\n            fieldName: String(field),\n          } as FormValidationError,\n          errors: [\n            {\n              type: 'REQUIRED_FIELD',\n              fieldName: String(field),\n            } as FormValidationError,\n          ],\n        };\n      }\n\n      // If no validators and value is null/undefined, consider it valid (optional field)\n      if ((value === undefined || value === null) && fieldValidators.length === 0) {\n        return {\n          isValid: true,\n          value: null,\n          error: null,\n          errors: [],\n        };\n      }\n\n      // Run all validators in sequence (only if value is defined)\n      if (currentValue !== undefined && currentValue !== null) {\n        for (const validator of fieldValidators) {\n          const result = validator(currentValue);\n          if (result.isErr()) {\n            errors.push(result.error);\n          } else {\n            currentValue = result.value;\n          }\n        }\n      }\n\n      const isValid = errors.length === 0;\n      return {\n        isValid,\n        value: isValid ? currentValue : null,\n        error: errors[0] || null,\n        errors,\n      };\n    },\n    [validators]\n  );\n\n  // Validate field and update errors\n  const validateAndUpdateField = useCallback(\n    <K extends keyof T>(field: K) => {\n      const fieldState = state.fields[field];\n      const result = validateFieldValue(field, fieldState?.value);\n      dispatch({ type: 'SET_FIELD_ERRORS', field, errors: result.errors });\n      return result;\n    },\n    [state.fields, validateFieldValue]\n  );\n\n  // Validate on mount if enabled (run only once)\n  useEffect(() => {\n    if (initialValidateOnMount.current) {\n      const keys = Object.keys(state.fields) as (keyof T)[];\n      for (const key of keys) {\n        validateAndUpdateField(key);\n      }\n    }\n  }, []); // Empty dependency array - run only once on mount\n\n  // Field states with validation info\n  const fieldStates = useMemo(() => {\n    const states: { [K in keyof T]: FormField<T[K]> } = {} as { [K in keyof T]: FormField<T[K]> };\n\n    for (const key of Object.keys(state.fields) as (keyof T)[]) {\n      const field = state.fields[key];\n      const hasErrors = field.errors.length > 0;\n\n      states[key] = {\n        value: field.value,\n        touched: field.touched,\n        dirty: field.dirty,\n        validation: {\n          isValid: !hasErrors,\n          error: field.errors[0] || null,\n          errors: field.errors,\n        },\n      };\n    }\n\n    return states;\n  }, [state.fields]);\n\n  // Overall form state\n  const formState = useMemo(() => {\n    const allErrors: Record<keyof T, FormValidationError[]> = {} as Record<\n      keyof T,\n      FormValidationError[]\n    >;\n    let isValid = true;\n    let isDirty = false;\n\n    for (const key of Object.keys(fieldStates) as (keyof T)[]) {\n      const field = fieldStates[key];\n      allErrors[key] = field.validation.errors;\n\n      if (!field.validation.isValid) {\n        isValid = false;\n      }\n\n      if (field.dirty) {\n        isDirty = true;\n      }\n    }\n\n    return {\n      isValid,\n      isDirty,\n      errors: allErrors,\n      hasErrors: !isValid,\n    };\n  }, [fieldStates]);\n\n  // Actions\n  const actions = useMemo(\n    () => ({\n      setFieldValue: <K extends keyof T>(field: K, value: T[K]) => {\n        dispatch({ type: 'SET_FIELD_VALUE', field, value });\n\n        // Validate on change if mode is onChange\n        if (mode === 'onChange') {\n          queueMicrotask(() => {\n            const result = validateFieldValue(field, value);\n            dispatch({ type: 'SET_FIELD_ERRORS', field, errors: result.errors });\n          });\n        }\n      },\n\n      setFieldTouched: <K extends keyof T>(field: K, touched = true) => {\n        dispatch({ type: 'SET_FIELD_TOUCHED', field, touched });\n\n        // Validate on blur if mode is onBlur and field is being touched\n        if (mode === 'onBlur' && touched) {\n          queueMicrotask(() => {\n            validateAndUpdateField(field);\n          });\n        }\n      },\n\n      validateField: validateAndUpdateField,\n\n      validateForm: () => {\n        const values: Partial<T> = {};\n        const errors: Record<keyof T, FormValidationError[]> = {} as Record<\n          keyof T,\n          FormValidationError[]\n        >;\n\n        let isValid = true;\n\n        for (const key of Object.keys(state.fields) as (keyof T)[]) {\n          const field = state.fields[key];\n          const result = validateFieldValue(key, field.value);\n\n          if (result.isValid && result.value !== null) {\n            values[key] = result.value;\n          } else {\n            isValid = false;\n          }\n\n          errors[key] = result.errors;\n          dispatch({ type: 'SET_FIELD_ERRORS', field: key, errors: result.errors });\n        }\n\n        return { isValid, values, errors };\n      },\n\n      reset: () => {\n        dispatch({ type: 'RESET' });\n      },\n\n      setValues: (newValues: Partial<T>) => {\n        dispatch({ type: 'SET_VALUES', values: newValues });\n\n        // Validate changed fields if mode is onChange\n        if (mode === 'onChange') {\n          queueMicrotask(() => {\n            for (const [key, value] of Object.entries(newValues) as [keyof T, T[keyof T]][]) {\n              const result = validateFieldValue(key, value);\n              dispatch({ type: 'SET_FIELD_ERRORS', field: key, errors: result.errors });\n            }\n          });\n        }\n      },\n    }),\n    [mode, state.fields, validateFieldValue, validateAndUpdateField]\n  );\n\n  return {\n    fields: fieldStates,\n    form: formState,\n    actions,\n  };\n}\n\n/**\n * Helper hook for simple form validation status\n */\nexport function useFormValidationStatus<T extends Record<string, unknown>>(\n  formState: FormValidationState<T>\n) {\n  // Memoize errorsCount separately to avoid expensive reduce on every render\n  const errorsCount = useMemo(\n    () =>\n      Object.values(formState.form.errors).reduce(\n        (count, fieldErrors) => count + fieldErrors.length,\n        0\n      ),\n    [formState.form.errors]\n  );\n\n  return useMemo(\n    () => ({\n      isValid: formState.form.isValid,\n      isInvalid: formState.form.hasErrors,\n      isDirty: formState.form.isDirty,\n      errorsCount,\n      fieldErrors: formState.form.errors,\n      hasFieldErrors: (field: keyof T) => (formState.form.errors[field] ?? []).length > 0,\n      getFieldError: (field: keyof T) => (formState.form.errors[field] ?? [])[0] || null,\n      canSubmit: formState.form.isValid && formState.form.isDirty,\n    }),\n    [\n      formState.form.isValid,\n      formState.form.hasErrors,\n      formState.form.isDirty,\n      errorsCount,\n      formState.form.errors,\n    ]\n  );\n}\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/hooks/useRealTimeNotifications.ts",
        "messages": [
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'Tenant' is defined but never used. Allowed unused vars must match /^_/u.",
                "line": 9,
                "column": 15,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 9,
                "endColumn": 21
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 31,
                "column": 81,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingReturnType",
                "endLine": 31,
                "endColumn": 83
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'notification' is assigned a value but never used. Allowed unused vars must match /^_/u.",
                "line": 32,
                "column": 11,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 32,
                "endColumn": 23
            },
            {
                "ruleId": "react-hooks/immutability",
                "severity": 2,
                "message": "Error: Cannot access variable before it is declared\n\n`startHeartbeat` is accessed before it is declared, which prevents the earlier access from updating when this value changes over time.\n\n/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/hooks/useRealTimeNotifications.ts:75:9\n  73 |\n  74 |         // Start heartbeat\n> 75 |         startHeartbeat();\n     |         ^^^^^^^^^^^^^^ `startHeartbeat` accessed before it is declared\n  76 |\n  77 |         // Send authentication if needed\n  78 |         const token = localStorage.getItem('authToken');\n\n/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/hooks/useRealTimeNotifications.ts:145:3\n  143 |\n  144 |   // Heartbeat to keep connection alive\n> 145 |   const startHeartbeat = useCallback(() => {\n      |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 146 |     if (heartbeatTimeoutRef.current) {\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 147 |       clearTimeout(heartbeatTimeoutRef.current);\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 148 |     }\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 149 |\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 150 |     heartbeatTimeoutRef.current = setTimeout(() => {\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 151 |       if (wsRef.current?.readyState === WebSocket.OPEN) {\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 152 |         wsRef.current.send(JSON.stringify({ type: 'ping' }));\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 153 |         startHeartbeat();\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 154 |       }\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 155 |     }, defaultConfig.heartbeatInterval);\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 156 |   }, [defaultConfig.heartbeatInterval]);\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `startHeartbeat` is declared here\n  157 |\n  158 |   // Handle incoming notifications\n  159 |   const handleNotification = useCallback(",
                "line": 75,
                "column": 9,
                "nodeType": null,
                "endLine": 75,
                "endColumn": 23
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 79,
                "column": 13,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 79,
                "endColumn": 18,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                2270,
                                2275
                            ],
                            "text": "token != null"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                2270,
                                2275
                            ],
                            "text": "token ?? \"\""
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                2270,
                                2275
                            ],
                            "text": "Boolean(token)"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 91,
                "column": 17,
                "nodeType": "VariableDeclarator",
                "messageId": "anyAssignment",
                "endLine": 91,
                "endColumn": 46
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-argument",
                "severity": 1,
                "message": "Unsafe argument of type `any` assigned to a parameter of type `string`.",
                "line": 91,
                "column": 35,
                "nodeType": "MemberExpression",
                "messageId": "unsafeArgument",
                "endLine": 91,
                "endColumn": 45
            },
            {
                "ruleId": "react-hooks/immutability",
                "severity": 2,
                "message": "Error: Cannot access variable before it is declared\n\n`handleNotification` is accessed before it is declared, which prevents the earlier access from updating when this value changes over time.\n\n/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/hooks/useRealTimeNotifications.ts:92:11\n  90 |         try {\n  91 |           const data = JSON.parse(event.data);\n> 92 |           handleNotification(data);\n     |           ^^^^^^^^^^^^^^^^^^ `handleNotification` accessed before it is declared\n  93 |         } catch (error) {\n  94 |           console.error('Failed to parse notification:', error);\n  95 |         }\n\n/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/hooks/useRealTimeNotifications.ts:159:3\n  157 |\n  158 |   // Handle incoming notifications\n> 159 |   const handleNotification = useCallback(\n      |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 160 |     (data: any) => {\n      | ^^^^^^^^^^^^^^^^^^^^\n> 161 |       const notification: NotificationMessage = {\n      | ^^^^^^^^^^^^^^^^^^^^\n> 162 |         id: data.id || Date.now().toString(),\n      | ^^^^^^^^^^^^^^^^^^^^\n> 163 |         type: data.type || 'info',\n      | ^^^^^^^^^^^^^^^^^^^^\n> 164 |         title: data.title || 'Notification',\n      | ^^^^^^^^^^^^^^^^^^^^\n> 165 |         message: data.message || '',\n      | ^^^^^^^^^^^^^^^^^^^^\n> 166 |         timestamp: new Date(data.timestamp || Date.now()),\n      | ^^^^^^^^^^^^^^^^^^^^\n> 167 |         tenantId: data.tenantId,\n      | ^^^^^^^^^^^^^^^^^^^^\n> 168 |         action: data.action,\n      | ^^^^^^^^^^^^^^^^^^^^\n> 169 |       };\n      | ^^^^^^^^^^^^^^^^^^^^\n> 170 |\n      | ^^^^^^^^^^^^^^^^^^^^\n> 171 |       // Add to notifications list\n      | ^^^^^^^^^^^^^^^^^^^^\n> 172 |       setNotifications(prev => [notification, ...prev.slice(0, 49)]); // Keep last 50\n      | ^^^^^^^^^^^^^^^^^^^^\n> 173 |\n      | ^^^^^^^^^^^^^^^^^^^^\n> 174 |       // Show notification based on type\n      | ^^^^^^^^^^^^^^^^^^^^\n> 175 |       switch (notification.type) {\n      | ^^^^^^^^^^^^^^^^^^^^\n> 176 |         case 'success':\n      | ^^^^^^^^^^^^^^^^^^^^\n> 177 |           tenantNotifications.showSuccessNotification(notification.title, notification.message);\n      | ^^^^^^^^^^^^^^^^^^^^\n> 178 |           break;\n      | ^^^^^^^^^^^^^^^^^^^^\n> 179 |         case 'error':\n      | ^^^^^^^^^^^^^^^^^^^^\n> 180 |           tenantNotifications.showErrorNotification(notification.title, notification.message);\n      | ^^^^^^^^^^^^^^^^^^^^\n> 181 |           break;\n      | ^^^^^^^^^^^^^^^^^^^^\n> 182 |         case 'warning':\n      | ^^^^^^^^^^^^^^^^^^^^\n> 183 |           tenantNotifications.showWarningNotification(notification.title, notification.message);\n      | ^^^^^^^^^^^^^^^^^^^^\n> 184 |           break;\n      | ^^^^^^^^^^^^^^^^^^^^\n> 185 |         case 'info':\n      | ^^^^^^^^^^^^^^^^^^^^\n> 186 |           tenantNotifications.showInfoNotification(notification.title, notification.message);\n      | ^^^^^^^^^^^^^^^^^^^^\n> 187 |           break;\n      | ^^^^^^^^^^^^^^^^^^^^\n> 188 |       }\n      | ^^^^^^^^^^^^^^^^^^^^\n> 189 |\n      | ^^^^^^^^^^^^^^^^^^^^\n> 190 |       // Show browser notification if permission granted\n      | ^^^^^^^^^^^^^^^^^^^^\n> 191 |       if (Notification.permission === 'granted') {\n      | ^^^^^^^^^^^^^^^^^^^^\n> 192 |         new Notification(notification.title, {\n      | ^^^^^^^^^^^^^^^^^^^^\n> 193 |           body: notification.message,\n      | ^^^^^^^^^^^^^^^^^^^^\n> 194 |           icon: '/favicon.ico',\n      | ^^^^^^^^^^^^^^^^^^^^\n> 195 |           tag: notification.id,\n      | ^^^^^^^^^^^^^^^^^^^^\n> 196 |         });\n      | ^^^^^^^^^^^^^^^^^^^^\n> 197 |       }\n      | ^^^^^^^^^^^^^^^^^^^^\n> 198 |     },\n      | ^^^^^^^^^^^^^^^^^^^^\n> 199 |     [tenantNotifications]\n      | ^^^^^^^^^^^^^^^^^^^^\n> 200 |   );\n      | ^^^^^ `handleNotification` is declared here\n  201 |\n  202 |   // Request notification permission\n  203 |   const requestNotificationPermission = useCallback(async () => {",
                "line": 92,
                "column": 11,
                "nodeType": null,
                "endLine": 92,
                "endColumn": 29
            },
            {
                "ruleId": "react-hooks/immutability",
                "severity": 2,
                "message": "Error: Cannot access variable before it is declared\n\n`connect` is accessed before it is declared, which prevents the earlier access from updating when this value changes over time.\n\n/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/hooks/useRealTimeNotifications.ts:109:13\n  107 |           reconnectAttemptsRef.current++;\n  108 |           reconnectTimeoutRef.current = setTimeout(() => {\n> 109 |             connect();\n      |             ^^^^^^^ `connect` accessed before it is declared\n  110 |           }, defaultConfig.reconnectInterval);\n  111 |         }\n  112 |       };\n\n/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/hooks/useRealTimeNotifications.ts:58:3\n   56 |\n   57 |   // WebSocket connection management\n>  58 |   const connect = useCallback(() => {\n      |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n>  59 |     if (wsRef.current?.readyState === WebSocket.OPEN) {\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n>  60 |       return;\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n>  61 |     }\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n>  62 |\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n>  63 |     setConnectionStatus('connecting');\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n>  64 |\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n>  65 |     try {\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n>  66 |       const ws = new WebSocket(defaultConfig.url);\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n>  67 |       wsRef.current = ws;\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n>  68 |\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n>  69 |       ws.onopen = () => {\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n>  70 |         setIsConnected(true);\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n>  71 |         setConnectionStatus('connected');\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n>  72 |         reconnectAttemptsRef.current = 0;\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n>  73 |\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n>  74 |         // Start heartbeat\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n>  75 |         startHeartbeat();\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n>  76 |\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n>  77 |         // Send authentication if needed\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n>  78 |         const token = localStorage.getItem('authToken');\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n>  79 |         if (token) {\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n>  80 |           ws.send(\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n>  81 |             JSON.stringify({\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n>  82 |               type: 'auth',\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n>  83 |               token,\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n>  84 |             })\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n>  85 |           );\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n>  86 |         }\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n>  87 |       };\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n>  88 |\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n>  89 |       ws.onmessage = event => {\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n>  90 |         try {\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n>  91 |           const data = JSON.parse(event.data);\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n>  92 |           handleNotification(data);\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n>  93 |         } catch (error) {\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n>  94 |           console.error('Failed to parse notification:', error);\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n>  95 |         }\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n>  96 |       };\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n>  97 |\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n>  98 |       ws.onclose = event => {\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n>  99 |         setIsConnected(false);\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 100 |         setConnectionStatus('disconnected');\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 101 |\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 102 |         // Attempt reconnection if not manually closed\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 103 |         if (\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 104 |           event.code !== 1000 &&\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 105 |           reconnectAttemptsRef.current < defaultConfig.maxReconnectAttempts\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 106 |         ) {\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 107 |           reconnectAttemptsRef.current++;\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 108 |           reconnectTimeoutRef.current = setTimeout(() => {\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 109 |             connect();\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 110 |           }, defaultConfig.reconnectInterval);\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 111 |         }\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 112 |       };\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 113 |\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 114 |       ws.onerror = error => {\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 115 |         console.error('WebSocket error:', error);\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 116 |         setConnectionStatus('error');\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 117 |       };\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 118 |     } catch (error) {\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 119 |       console.error('Failed to create WebSocket connection:', error);\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 120 |       setConnectionStatus('error');\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 121 |     }\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 122 |   }, [defaultConfig.url, defaultConfig.reconnectInterval, defaultConfig.maxReconnectAttempts]);\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `connect` is declared here\n  123 |\n  124 |   const disconnect = useCallback(() => {\n  125 |     if (reconnectTimeoutRef.current) {",
                "line": 109,
                "column": 13,
                "nodeType": null,
                "endLine": 109,
                "endColumn": 20
            },
            {
                "ruleId": "react-hooks/exhaustive-deps",
                "severity": 1,
                "message": "React Hook useCallback has missing dependencies: 'handleNotification' and 'startHeartbeat'. Either include them or remove the dependency array.",
                "line": 122,
                "column": 6,
                "nodeType": "ArrayExpression",
                "endLine": 122,
                "endColumn": 94,
                "suggestions": [
                    {
                        "desc": "Update the dependencies array to be: [defaultConfig.url, defaultConfig.maxReconnectAttempts, defaultConfig.reconnectInterval, startHeartbeat, handleNotification]",
                        "fix": {
                            "range": [
                                3417,
                                3505
                            ],
                            "text": "[defaultConfig.url, defaultConfig.maxReconnectAttempts, defaultConfig.reconnectInterval, startHeartbeat, handleNotification]"
                        }
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 160,
                "column": 12,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 160,
                "endColumn": 15,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                4575,
                                4578
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                4575,
                                4578
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 162,
                "column": 9,
                "nodeType": "Property",
                "messageId": "anyAssignment",
                "endLine": 162,
                "endColumn": 45
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected any value in conditional. An explicit comparison or type conversion is required.",
                "line": 162,
                "column": 13,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorAny",
                "endLine": 162,
                "endColumn": 20,
                "suggestions": [
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                4647,
                                4654
                            ],
                            "text": "(Boolean(data.id))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .id on an `any` value.",
                "line": 162,
                "column": 18,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 162,
                "endColumn": 20
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 162,
                "column": 21,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 162,
                "endColumn": 23,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                4655,
                                4657
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 163,
                "column": 9,
                "nodeType": "Property",
                "messageId": "anyAssignment",
                "endLine": 163,
                "endColumn": 34
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected any value in conditional. An explicit comparison or type conversion is required.",
                "line": 163,
                "column": 15,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorAny",
                "endLine": 163,
                "endColumn": 24,
                "suggestions": [
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                4695,
                                4704
                            ],
                            "text": "(Boolean(data.type))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .type on an `any` value.",
                "line": 163,
                "column": 20,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 163,
                "endColumn": 24
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 163,
                "column": 25,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 163,
                "endColumn": 27,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                4705,
                                4707
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 164,
                "column": 9,
                "nodeType": "Property",
                "messageId": "anyAssignment",
                "endLine": 164,
                "endColumn": 44
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected any value in conditional. An explicit comparison or type conversion is required.",
                "line": 164,
                "column": 16,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorAny",
                "endLine": 164,
                "endColumn": 26,
                "suggestions": [
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                4731,
                                4741
                            ],
                            "text": "(Boolean(data.title))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .title on an `any` value.",
                "line": 164,
                "column": 21,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 164,
                "endColumn": 26
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 164,
                "column": 27,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 164,
                "endColumn": 29,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                4742,
                                4744
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 165,
                "column": 9,
                "nodeType": "Property",
                "messageId": "anyAssignment",
                "endLine": 165,
                "endColumn": 36
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected any value in conditional. An explicit comparison or type conversion is required.",
                "line": 165,
                "column": 18,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorAny",
                "endLine": 165,
                "endColumn": 30,
                "suggestions": [
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                4778,
                                4790
                            ],
                            "text": "(Boolean(data.message))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .message on an `any` value.",
                "line": 165,
                "column": 23,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 165,
                "endColumn": 30
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 165,
                "column": 31,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 165,
                "endColumn": 33,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                4791,
                                4793
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-argument",
                "severity": 1,
                "message": "Unsafe argument of type `any` assigned to a parameter of type `string | number | Date`.",
                "line": 166,
                "column": 29,
                "nodeType": "LogicalExpression",
                "messageId": "unsafeArgument",
                "endLine": 166,
                "endColumn": 57
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected any value in conditional. An explicit comparison or type conversion is required.",
                "line": 166,
                "column": 29,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorAny",
                "endLine": 166,
                "endColumn": 43,
                "suggestions": [
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                4826,
                                4840
                            ],
                            "text": "(Boolean(data.timestamp))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .timestamp on an `any` value.",
                "line": 166,
                "column": 34,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 166,
                "endColumn": 43
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 166,
                "column": 44,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 166,
                "endColumn": 46,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                4841,
                                4843
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 167,
                "column": 9,
                "nodeType": "Property",
                "messageId": "anyAssignment",
                "endLine": 167,
                "endColumn": 32
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .tenantId on an `any` value.",
                "line": 167,
                "column": 24,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 167,
                "endColumn": 32
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 168,
                "column": 9,
                "nodeType": "Property",
                "messageId": "anyAssignment",
                "endLine": 168,
                "endColumn": 28
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .action on an `any` value.",
                "line": 168,
                "column": 22,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 168,
                "endColumn": 28
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 212,
                "column": 45,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 212,
                "endColumn": 48,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                6417,
                                6420
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                6417,
                                6420
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-floating-promises",
                "severity": 1,
                "message": "Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.",
                "line": 255,
                "column": 5,
                "nodeType": "ExpressionStatement",
                "messageId": "floatingVoid",
                "endLine": 255,
                "endColumn": 37,
                "suggestions": [
                    {
                        "messageId": "floatingFixVoid",
                        "fix": {
                            "range": [
                                7390,
                                7390
                            ],
                            "text": "void "
                        },
                        "desc": "Add void operator to ignore."
                    },
                    {
                        "messageId": "floatingFixAwait",
                        "fix": {
                            "range": [
                                7390,
                                7390
                            ],
                            "text": "await "
                        },
                        "desc": "Add await operator."
                    }
                ]
            }
        ],
        "suppressedMessages": [],
        "errorCount": 3,
        "fatalErrorCount": 0,
        "warningCount": 34,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "/**\n * Real-time Notifications Hook\n * Provides WebSocket-based real-time notifications for tenant operations\n */\n\nimport { useState, useEffect, useCallback, useRef } from 'react';\nimport { App } from 'antd';\nimport { useTenantNotifications } from './useTenantNotifications';\nimport type { Tenant } from '@/types/tenant';\n\ninterface NotificationMessage {\n  id: string;\n  type: 'success' | 'error' | 'warning' | 'info';\n  title: string;\n  message: string;\n  timestamp: Date;\n  tenantId?: string;\n  action?: {\n    label: string;\n    onClick: () => void;\n  };\n}\n\ninterface WebSocketConfig {\n  url: string;\n  reconnectInterval: number;\n  maxReconnectAttempts: number;\n  heartbeatInterval: number;\n}\n\nexport const useRealTimeNotifications = (config: Partial<WebSocketConfig> = {}) => {\n  const { notification } = App.useApp();\n  const tenantNotifications = useTenantNotifications();\n\n  const [isConnected, setIsConnected] = useState(false);\n  const [connectionStatus, setConnectionStatus] = useState<\n    'connecting' | 'connected' | 'disconnected' | 'error'\n  >('disconnected');\n  const [notifications, setNotifications] = useState<NotificationMessage[]>([]);\n\n  const wsRef = useRef<WebSocket | null>(null);\n  const reconnectTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n  const heartbeatTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n  const reconnectAttemptsRef = useRef(0);\n\n  const defaultConfig: WebSocketConfig = {\n    url:\n      process.env.NODE_ENV === 'production'\n        ? 'wss://api.yourdomain.com/notifications'\n        : 'ws://localhost:8080/notifications',\n    reconnectInterval: 5000,\n    maxReconnectAttempts: 5,\n    heartbeatInterval: 30000,\n    ...config,\n  };\n\n  // WebSocket connection management\n  const connect = useCallback(() => {\n    if (wsRef.current?.readyState === WebSocket.OPEN) {\n      return;\n    }\n\n    setConnectionStatus('connecting');\n\n    try {\n      const ws = new WebSocket(defaultConfig.url);\n      wsRef.current = ws;\n\n      ws.onopen = () => {\n        setIsConnected(true);\n        setConnectionStatus('connected');\n        reconnectAttemptsRef.current = 0;\n\n        // Start heartbeat\n        startHeartbeat();\n\n        // Send authentication if needed\n        const token = localStorage.getItem('authToken');\n        if (token) {\n          ws.send(\n            JSON.stringify({\n              type: 'auth',\n              token,\n            })\n          );\n        }\n      };\n\n      ws.onmessage = event => {\n        try {\n          const data = JSON.parse(event.data);\n          handleNotification(data);\n        } catch (error) {\n          console.error('Failed to parse notification:', error);\n        }\n      };\n\n      ws.onclose = event => {\n        setIsConnected(false);\n        setConnectionStatus('disconnected');\n\n        // Attempt reconnection if not manually closed\n        if (\n          event.code !== 1000 &&\n          reconnectAttemptsRef.current < defaultConfig.maxReconnectAttempts\n        ) {\n          reconnectAttemptsRef.current++;\n          reconnectTimeoutRef.current = setTimeout(() => {\n            connect();\n          }, defaultConfig.reconnectInterval);\n        }\n      };\n\n      ws.onerror = error => {\n        console.error('WebSocket error:', error);\n        setConnectionStatus('error');\n      };\n    } catch (error) {\n      console.error('Failed to create WebSocket connection:', error);\n      setConnectionStatus('error');\n    }\n  }, [defaultConfig.url, defaultConfig.reconnectInterval, defaultConfig.maxReconnectAttempts]);\n\n  const disconnect = useCallback(() => {\n    if (reconnectTimeoutRef.current) {\n      clearTimeout(reconnectTimeoutRef.current);\n      reconnectTimeoutRef.current = null;\n    }\n\n    if (heartbeatTimeoutRef.current) {\n      clearTimeout(heartbeatTimeoutRef.current);\n      heartbeatTimeoutRef.current = null;\n    }\n\n    if (wsRef.current) {\n      wsRef.current.close(1000, 'Manual disconnect');\n      wsRef.current = null;\n    }\n\n    setIsConnected(false);\n    setConnectionStatus('disconnected');\n  }, []);\n\n  // Heartbeat to keep connection alive\n  const startHeartbeat = useCallback(() => {\n    if (heartbeatTimeoutRef.current) {\n      clearTimeout(heartbeatTimeoutRef.current);\n    }\n\n    heartbeatTimeoutRef.current = setTimeout(() => {\n      if (wsRef.current?.readyState === WebSocket.OPEN) {\n        wsRef.current.send(JSON.stringify({ type: 'ping' }));\n        startHeartbeat();\n      }\n    }, defaultConfig.heartbeatInterval);\n  }, [defaultConfig.heartbeatInterval]);\n\n  // Handle incoming notifications\n  const handleNotification = useCallback(\n    (data: any) => {\n      const notification: NotificationMessage = {\n        id: data.id || Date.now().toString(),\n        type: data.type || 'info',\n        title: data.title || 'Notification',\n        message: data.message || '',\n        timestamp: new Date(data.timestamp || Date.now()),\n        tenantId: data.tenantId,\n        action: data.action,\n      };\n\n      // Add to notifications list\n      setNotifications(prev => [notification, ...prev.slice(0, 49)]); // Keep last 50\n\n      // Show notification based on type\n      switch (notification.type) {\n        case 'success':\n          tenantNotifications.showSuccessNotification(notification.title, notification.message);\n          break;\n        case 'error':\n          tenantNotifications.showErrorNotification(notification.title, notification.message);\n          break;\n        case 'warning':\n          tenantNotifications.showWarningNotification(notification.title, notification.message);\n          break;\n        case 'info':\n          tenantNotifications.showInfoNotification(notification.title, notification.message);\n          break;\n      }\n\n      // Show browser notification if permission granted\n      if (Notification.permission === 'granted') {\n        new Notification(notification.title, {\n          body: notification.message,\n          icon: '/favicon.ico',\n          tag: notification.id,\n        });\n      }\n    },\n    [tenantNotifications]\n  );\n\n  // Request notification permission\n  const requestNotificationPermission = useCallback(async () => {\n    if ('Notification' in window && Notification.permission === 'default') {\n      const permission = await Notification.requestPermission();\n      return permission === 'granted';\n    }\n    return Notification.permission === 'granted';\n  }, []);\n\n  // Send message to server\n  const sendMessage = useCallback((message: any) => {\n    if (wsRef.current?.readyState === WebSocket.OPEN) {\n      wsRef.current.send(JSON.stringify(message));\n    }\n  }, []);\n\n  // Subscribe to tenant events\n  const subscribeToTenant = useCallback(\n    (tenantId: string) => {\n      sendMessage({\n        type: 'subscribe',\n        resource: 'tenant',\n        id: tenantId,\n      });\n    },\n    [sendMessage]\n  );\n\n  // Unsubscribe from tenant events\n  const unsubscribeFromTenant = useCallback(\n    (tenantId: string) => {\n      sendMessage({\n        type: 'unsubscribe',\n        resource: 'tenant',\n        id: tenantId,\n      });\n    },\n    [sendMessage]\n  );\n\n  // Clear notifications\n  const clearNotifications = useCallback(() => {\n    setNotifications([]);\n  }, []);\n\n  // Remove specific notification\n  const removeNotification = useCallback((id: string) => {\n    setNotifications(prev => prev.filter(n => n.id !== id));\n  }, []);\n\n  // Initialize connection on mount\n  useEffect(() => {\n    connect();\n    requestNotificationPermission();\n\n    return () => {\n      disconnect();\n    };\n  }, [connect, disconnect, requestNotificationPermission]);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      if (reconnectTimeoutRef.current) {\n        clearTimeout(reconnectTimeoutRef.current);\n      }\n      if (heartbeatTimeoutRef.current) {\n        clearTimeout(heartbeatTimeoutRef.current);\n      }\n    };\n  }, []);\n\n  return {\n    // Connection status\n    isConnected,\n    connectionStatus,\n\n    // Notifications\n    notifications,\n    clearNotifications,\n    removeNotification,\n\n    // Connection management\n    connect,\n    disconnect,\n    sendMessage,\n\n    // Subscription management\n    subscribeToTenant,\n    unsubscribeFromTenant,\n\n    // Permission management\n    requestNotificationPermission,\n  };\n};\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/hooks/useTenantNotifications.ts",
        "messages": [
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 32,
                "column": 81,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingReturnType",
                "endLine": 32,
                "endColumn": 83
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 146,
                "column": 9,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 146,
                "endColumn": 19,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                3598,
                                3608
                            ],
                            "text": "(tenantName != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                3598,
                                3608
                            ],
                            "text": "(tenantName ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                3598,
                                3608
                            ],
                            "text": "(Boolean(tenantName))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/restrict-template-expressions",
                "severity": 1,
                "message": "Invalid type \"number\" of template literal expression.",
                "line": 197,
                "column": 56,
                "nodeType": "Identifier",
                "messageId": "invalidType",
                "endLine": 197,
                "endColumn": 68
            },
            {
                "ruleId": "@typescript-eslint/restrict-template-expressions",
                "severity": 1,
                "message": "Invalid type \"number\" of template literal expression.",
                "line": 202,
                "column": 29,
                "nodeType": "Identifier",
                "messageId": "invalidType",
                "endLine": 202,
                "endColumn": 41
            },
            {
                "ruleId": "@typescript-eslint/restrict-template-expressions",
                "severity": 1,
                "message": "Invalid type \"number\" of template literal expression.",
                "line": 202,
                "column": 48,
                "nodeType": "Identifier",
                "messageId": "invalidType",
                "endLine": 202,
                "endColumn": 58
            },
            {
                "ruleId": "@typescript-eslint/restrict-template-expressions",
                "severity": 1,
                "message": "Invalid type \"number\" of template literal expression.",
                "line": 202,
                "column": 71,
                "nodeType": "BinaryExpression",
                "messageId": "invalidType",
                "endLine": 202,
                "endColumn": 96
            },
            {
                "ruleId": "@typescript-eslint/restrict-template-expressions",
                "severity": 1,
                "message": "Invalid type \"number\" of template literal expression.",
                "line": 207,
                "column": 62,
                "nodeType": "Identifier",
                "messageId": "invalidType",
                "endLine": 207,
                "endColumn": 72
            },
            {
                "ruleId": "@typescript-eslint/restrict-template-expressions",
                "severity": 1,
                "message": "Invalid type \"number\" of template literal expression.",
                "line": 218,
                "column": 60,
                "nodeType": "Identifier",
                "messageId": "invalidType",
                "endLine": 218,
                "endColumn": 67
            },
            {
                "ruleId": "@typescript-eslint/restrict-template-expressions",
                "severity": 1,
                "message": "Invalid type \"number\" of template literal expression.",
                "line": 218,
                "column": 71,
                "nodeType": "Identifier",
                "messageId": "invalidType",
                "endLine": 218,
                "endColumn": 76
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 256,
                "column": 13,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 256,
                "endColumn": 25,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                7236,
                                7248
                            ],
                            "text": "result.error != null"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                7236,
                                7248
                            ],
                            "text": "result.error ?? \"\""
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                7236,
                                7248
                            ],
                            "text": "Boolean(result.error)"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 10,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "/**\n * Enhanced Tenant Notifications Hook\n * Provides comprehensive feedback for tenant operations\n */\n\nimport { useCallback } from 'react';\nimport { App } from 'antd';\nimport type { Tenant } from '@/types/tenant';\n\nexport interface TenantNotificationOptions {\n  showSuccess?: boolean;\n  showError?: boolean;\n  showWarning?: boolean;\n  showInfo?: boolean;\n  duration?: number;\n  placement?: 'top' | 'topLeft' | 'topRight' | 'bottom' | 'bottomLeft' | 'bottomRight';\n}\n\nexport interface TenantOperationResult {\n  success: boolean;\n  message: string;\n  tenant?: Tenant;\n  error?: string;\n  warnings?: string[];\n}\n\n/**\n * Hook for managing tenant-related notifications\n * @param options - Configuration options for notifications\n * @returns Object with notification methods\n */\nexport const useTenantNotifications = (options: TenantNotificationOptions = {}) => {\n  const { notification } = App.useApp();\n  const {\n    showSuccess = true,\n    showError = true,\n    showWarning = true,\n    showInfo = true,\n    duration = 4.5,\n    placement = 'topRight',\n  } = options;\n\n  const showSuccessNotification = useCallback(\n    (content: string, description?: string) => {\n      if (!showSuccess) return;\n\n      notification.success({\n        message: content,\n        description,\n        duration,\n        placement,\n        style: {\n          marginTop: 24,\n        },\n      });\n    },\n    [notification, showSuccess, duration, placement]\n  );\n\n  const showErrorNotification = useCallback(\n    (content: string, description?: string) => {\n      if (!showError) return;\n\n      notification.error({\n        message: content,\n        description,\n        duration: 0, // Error notifications stay until manually closed\n        placement,\n        style: {\n          marginTop: 24,\n        },\n      });\n    },\n    [notification, showError, placement]\n  );\n\n  const showWarningNotification = useCallback(\n    (content: string, description?: string) => {\n      if (!showWarning) return;\n\n      notification.warning({\n        message: content,\n        description,\n        duration,\n        placement,\n        style: {\n          marginTop: 24,\n        },\n      });\n    },\n    [notification, showWarning, duration, placement]\n  );\n\n  const showInfoNotification = useCallback(\n    (content: string, description?: string) => {\n      if (!showInfo) return;\n\n      notification.info({\n        message: content,\n        description,\n        duration,\n        placement,\n        style: {\n          marginTop: 24,\n        },\n      });\n    },\n    [notification, showInfo, duration, placement]\n  );\n\n  // Tenant-specific notification methods\n  const notifyTenantCreated = useCallback(\n    (tenant: Tenant) => {\n      showSuccessNotification(\n        'Tenant Created Successfully',\n        `Tenant \"${tenant.name}\" has been created and is ready to use.`\n      );\n    },\n    [showSuccessNotification]\n  );\n\n  const notifyTenantUpdated = useCallback(\n    (tenant: Tenant) => {\n      showSuccessNotification(\n        'Tenant Updated Successfully',\n        `Tenant \"${tenant.name}\" has been updated with new configuration.`\n      );\n    },\n    [showSuccessNotification]\n  );\n\n  const notifyTenantDeleted = useCallback(\n    (tenantName: string) => {\n      showSuccessNotification(\n        'Tenant Deleted Successfully',\n        `Tenant \"${tenantName}\" and all associated data have been removed.`\n      );\n    },\n    [showSuccessNotification]\n  );\n\n  const notifyTenantError = useCallback(\n    (operation: string, error: string, tenantName?: string) => {\n      showErrorNotification(\n        `Failed to ${operation} Tenant`,\n        tenantName\n          ? `Unable to ${operation.toLowerCase()} tenant \"${tenantName}\": ${error}`\n          : `Unable to ${operation.toLowerCase()} tenant: ${error}`\n      );\n    },\n    [showErrorNotification]\n  );\n\n  const notifyValidationError = useCallback(\n    (errors: Record<string, string>) => {\n      const errorMessages = Object.entries(errors).map(([field, error]) => `${field}: ${error}`);\n      showErrorNotification(\n        'Validation Failed',\n        `Please correct the following errors:\\n${errorMessages.join('\\n')}`\n      );\n    },\n    [showErrorNotification]\n  );\n\n  const notifyDatabaseConnectionWarning = useCallback(\n    (tenant: Tenant) => {\n      showWarningNotification(\n        'Database Connection Warning',\n        `Tenant \"${tenant.name}\" has an invalid or missing database URL. Please update the configuration.`\n      );\n    },\n    [showWarningNotification]\n  );\n\n  const notifyTenantHealthCheck = useCallback(\n    (tenant: Tenant, isHealthy: boolean) => {\n      if (isHealthy) {\n        showInfoNotification(\n          'Tenant Health Check Passed',\n          `Tenant \"${tenant.name}\" is running normally.`\n        );\n      } else {\n        showWarningNotification(\n          'Tenant Health Check Failed',\n          `Tenant \"${tenant.name}\" is experiencing issues. Please check the configuration.`\n        );\n      }\n    },\n    [showInfoNotification, showWarningNotification]\n  );\n\n  const notifyBulkOperation = useCallback(\n    (operation: string, successCount: number, totalCount: number) => {\n      if (successCount === totalCount) {\n        showSuccessNotification(\n          `Bulk ${operation} Completed`,\n          `Successfully ${operation.toLowerCase()}ed ${successCount} tenant${successCount !== 1 ? 's' : ''}.`\n        );\n      } else if (successCount > 0) {\n        showWarningNotification(\n          `Partial ${operation} Success`,\n          `${operation}ed ${successCount} of ${totalCount} tenants. ${totalCount - successCount} failed.`\n        );\n      } else {\n        showErrorNotification(\n          `Bulk ${operation} Failed`,\n          `Failed to ${operation.toLowerCase()} any of the ${totalCount} selected tenants.`\n        );\n      }\n    },\n    [showSuccessNotification, showWarningNotification, showErrorNotification]\n  );\n\n  const notifyTenantLimitReached = useCallback(\n    (current: number, limit: number) => {\n      showWarningNotification(\n        'Tenant Limit Reached',\n        `You have reached the maximum number of tenants (${current}/${limit}). Please upgrade your plan to create more tenants.`\n      );\n    },\n    [showWarningNotification]\n  );\n\n  const notifyTenantFeatureUnavailable = useCallback(\n    (feature: string, plan: string) => {\n      showInfoNotification(\n        'Feature Not Available',\n        `${feature} is not available in your current plan (${plan}). Please upgrade to access this feature.`\n      );\n    },\n    [showInfoNotification]\n  );\n\n  // Operation result handler\n  const handleOperationResult = useCallback(\n    (result: TenantOperationResult, operation: string) => {\n      if (result.success) {\n        if (result.tenant) {\n          switch (operation) {\n            case 'create':\n              notifyTenantCreated(result.tenant);\n              break;\n            case 'update':\n              notifyTenantUpdated(result.tenant);\n              break;\n            case 'delete':\n              notifyTenantDeleted(result.tenant.name);\n              break;\n            default:\n              showSuccessNotification(result.message);\n          }\n        } else {\n          showSuccessNotification(result.message);\n        }\n      } else {\n        if (result.error) {\n          notifyTenantError(operation, result.error, result.tenant?.name);\n        }\n\n        if (result.warnings && result.warnings.length > 0) {\n          result.warnings.forEach(warning => {\n            showWarningNotification('Warning', warning);\n          });\n        }\n      }\n    },\n    [\n      notifyTenantCreated,\n      notifyTenantUpdated,\n      notifyTenantDeleted,\n      notifyTenantError,\n      showSuccessNotification,\n      showWarningNotification,\n    ]\n  );\n\n  return {\n    // Basic notifications\n    showSuccessNotification,\n    showErrorNotification,\n    showWarningNotification,\n    showInfoNotification,\n\n    // Tenant-specific notifications\n    notifyTenantCreated,\n    notifyTenantUpdated,\n    notifyTenantDeleted,\n    notifyTenantError,\n    notifyValidationError,\n    notifyDatabaseConnectionWarning,\n    notifyTenantHealthCheck,\n    notifyBulkOperation,\n    notifyTenantLimitReached,\n    notifyTenantFeatureUnavailable,\n\n    // Result handler\n    handleOperationResult,\n  };\n};\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/hooks/useValidation.ts",
        "messages": [
            {
                "ruleId": "@typescript-eslint/no-non-null-assertion",
                "severity": 1,
                "message": "Forbidden non-null assertion.",
                "line": 146,
                "column": 35,
                "nodeType": "TSNonNullExpression",
                "messageId": "noNonNull",
                "endLine": 146,
                "endColumn": 45
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 1,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "import { useMemo, useCallback, useState } from 'react';\nimport type { Result } from '../types/fp';\n\n/**\n * Validation function type that returns a Result\n */\nexport type ValidationFn<T, E> = (value: T) => Result<T, E>;\n\n/**\n * Represents the result of a validation operation\n */\nexport interface ValidationResult<T, E> {\n  /** Whether the value is valid */\n  isValid: boolean;\n  /** The validated value if valid, null if invalid */\n  value: T | null;\n  /** The validation error if present */\n  error: E | null;\n  /** Array of all errors encountered */\n  errors: E[];\n}\n\n/**\n * State for validation operations\n */\nexport interface ValidationState<T, E> {\n  /** Current value being validated */\n  value: T | undefined;\n  /** Current validation result */\n  result: ValidationResult<T, E>;\n  /** Whether validation is currently running */\n  validating: boolean;\n  /** Function to validate a new value */\n  validate: (newValue: T | undefined) => ValidationResult<T, E>;\n  /** Function to reset validation state */\n  reset: () => void;\n  /** Function to set value conditionally triggers validation when validateOnChange is true */\n  setValue: (newValue: T | undefined) => void;\n}\n\n/**\n * Custom hook for managing validation with Result types.\n *\n * Provides synchronous validation using railway-oriented programming patterns. Validates values\n * and returns `Result<T, E>` for type-safe error handling.\n *\n * @param initialValue Initial value to validate\n * @param validators Array of validation functions (railway pattern)\n * @param options Optional configuration flags\n * @returns Validation state containing validation result and control functions\n * @example\n * ```typescript\n * const emailValidation = useValidation<string, ValidationError>(\n *   '',\n *   [validateEmail],\n *   { validateOnMount: true }\n * );\n *\n * const onChange = (value: string) => {\n *   emailValidation.setValue(value);\n * };\n *\n * if (emailValidation.result.isValid) {\n *   console.log('Email ready', emailValidation.result.value);\n * }\n * ```\n */\nexport function useValidation<T, E = string>(\n  initialValue?: T,\n  validators: ValidationFn<T, E>[] = [],\n  options: {\n    /** Whether to validate immediately on mount */\n    validateOnMount?: boolean;\n    /** Whether to validate on every value change */\n    validateOnChange?: boolean;\n    /** Custom error combiner for multiple validation errors */\n    errorCombiner?: (errors: E[]) => E;\n    /** Whether to stop validation after first error (default: false) */\n    shortCircuit?: boolean;\n    /** Error to return when value is undefined/null (required for type safety) */\n    requiredError?: E;\n    /** Factory function to create error when value is undefined/null */\n    requiredErrorFactory?: () => E;\n  } = {}\n): ValidationState<T, E> {\n  const {\n    validateOnMount = false,\n    validateOnChange = true,\n    errorCombiner,\n    shortCircuit = false,\n    requiredError,\n    requiredErrorFactory,\n  } = options;\n\n  // Memoized validators array\n  const memoizedValidators = useMemo(() => validators, [validators]);\n\n  // Validation function that runs all validators in sequence (railway pattern)\n  const validateValue = useCallback(\n    (value: T | undefined): ValidationResult<T, E> => {\n      // Handle undefined/null as a validation error with typed error\n      if (value === undefined || value === null) {\n        // Use provided requiredError or requiredErrorFactory for type safety\n        const undefinedError =\n          requiredError ??\n          (requiredErrorFactory ? requiredErrorFactory() : ('Value is required' as unknown as E));\n        return {\n          isValid: false,\n          value: null,\n          error: undefinedError,\n          errors: [undefinedError],\n        };\n      }\n\n      const errors: E[] = [];\n      let currentValue: T = value;\n\n      // Run all validators in sequence\n      for (const validator of memoizedValidators) {\n        try {\n          const result = validator(currentValue);\n          if (result.isErr()) {\n            errors.push(result.error);\n            // Break early if shortCircuit is enabled\n            if (shortCircuit) {\n              break;\n            }\n          } else {\n            // Update value if transformed by validator\n            currentValue = result.value;\n          }\n        } catch (e) {\n          // Convert thrown errors to validation errors\n          errors.push(e as E);\n          if (shortCircuit) {\n            break;\n          }\n        }\n      }\n\n      if (errors.length > 0) {\n        const combinedError = errorCombiner ? errorCombiner(errors) : errors[0];\n        return {\n          isValid: false,\n          value: null,\n          error: combinedError ?? errors[0]!, // Ensure error is always populated when validation fails\n          errors,\n        };\n      }\n\n      return {\n        isValid: true,\n        value: currentValue,\n        error: null,\n        errors: [],\n      };\n    },\n    [memoizedValidators, errorCombiner, shortCircuit, requiredError, requiredErrorFactory]\n  );\n\n  // Initial validation result\n  const initialResult = useMemo(() => {\n    if (validateOnMount && initialValue !== undefined) {\n      return validateValue(initialValue);\n    }\n    return {\n      isValid: false,\n      value: null,\n      error: null,\n      errors: [],\n    };\n  }, [initialValue, validateOnMount, validateValue]);\n\n  // Current validation state\n  const [result, setResult] = useState<ValidationResult<T, E>>(initialResult);\n  const [value, setValueState] = useState<T | undefined>(initialValue);\n  const [validating, setValidating] = useState(false);\n\n  // Helper to select transformed value or fallback to original\n  const selectValueFromResult = useCallback(\n    (validationResult: ValidationResult<T, E>, originalValue: T | undefined): T | undefined => {\n      return validationResult.isValid && validationResult.value !== null\n        ? validationResult.value\n        : originalValue;\n    },\n    []\n  );\n\n  // Validation function exposed to consumers\n  const validate = useCallback(\n    (newValue: T | undefined): ValidationResult<T, E> => {\n      setValidating(true);\n      try {\n        const validationResult = validateValue(newValue);\n        setResult(validationResult);\n        setValueState(selectValueFromResult(validationResult, newValue));\n        return validationResult;\n      } finally {\n        setValidating(false);\n      }\n    },\n    [validateValue, selectValueFromResult]\n  );\n\n  // Set value conditionally triggers validation when validateOnChange is true\n  // Clearing a field (undefined/null) will run validation so consumers know required-field errors may appear immediately\n  const setValue = useCallback(\n    (newValue: T | undefined) => {\n      if (validateOnChange) {\n        const validationResult = validateValue(newValue);\n        setResult(validationResult);\n        setValueState(selectValueFromResult(validationResult, newValue));\n      } else {\n        setValueState(newValue);\n      }\n    },\n    [validateOnChange, validateValue, selectValueFromResult]\n  );\n\n  // Reset validation state\n  const reset = useCallback(() => {\n    setValueState(initialValue);\n    setResult({\n      isValid: false,\n      value: null,\n      error: null,\n      errors: [],\n    });\n    setValidating(false);\n  }, [initialValue]);\n\n  return {\n    value,\n    result,\n    validating,\n    validate,\n    reset,\n    setValue,\n  };\n}\n\n/**\n * Helper hook for deriving boolean validation flags from `useValidation` state.\n *\n * @param validationState Validation state returned by `useValidation`\n * @returns Boolean flags and errors to simplify UI rendering\n * @example\n * ```typescript\n * const validation = useValidation(...);\n * const status = useValidationStatus(validation);\n *\n * return status.isInvalid ? <Error>{status.error?.message}</Error> : null;\n * ```\n */\nexport function useValidationStatus<T, E>(\n  validationState: ValidationState<T, E>\n): {\n  isValid: boolean;\n  isInvalid: boolean;\n  error: E | null;\n  errors: E[];\n  isValidating: boolean;\n} {\n  return useMemo(\n    () => ({\n      isValid: validationState.result.isValid,\n      isInvalid: !validationState.result.isValid && validationState.result.errors.length > 0,\n      error: validationState.result.error,\n      errors: validationState.result.errors,\n      isValidating: validationState.validating,\n    }),\n    [validationState.result, validationState.validating]\n  );\n}\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/main.tsx",
        "messages": [],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 0,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/pages/AddressBookPage.tsx",
        "messages": [
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'ContactListResponse' is defined but never used. Allowed unused vars must match /^_/u.",
                "line": 4,
                "column": 24,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 4,
                "endColumn": 43
            },
            {
                "ruleId": "react-refresh/only-export-components",
                "severity": 1,
                "message": "Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.",
                "line": 66,
                "column": 14,
                "nodeType": "Identifier",
                "messageId": "namedExport",
                "endLine": 66,
                "endColumn": 30
            },
            {
                "ruleId": "react-refresh/only-export-components",
                "severity": 1,
                "message": "Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.",
                "line": 85,
                "column": 14,
                "nodeType": "Identifier",
                "messageId": "namedExport",
                "endLine": 85,
                "endColumn": 30
            },
            {
                "ruleId": "react-refresh/only-export-components",
                "severity": 1,
                "message": "Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.",
                "line": 107,
                "column": 14,
                "nodeType": "Identifier",
                "messageId": "namedExport",
                "endLine": 107,
                "endColumn": 34
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, comparison is always true, since `\"other\" === \"other\"` is true.",
                "line": 115,
                "column": 5,
                "nodeType": "BinaryExpression",
                "messageId": "comparisonBetweenLiteralTypes",
                "endLine": 115,
                "endColumn": 39
            },
            {
                "ruleId": "react-refresh/only-export-components",
                "severity": 1,
                "message": "Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.",
                "line": 127,
                "column": 14,
                "nodeType": "Identifier",
                "messageId": "namedExport",
                "endLine": 127,
                "endColumn": 37
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'sorting' is assigned a value but never used. Allowed unused vars must match /^_/u.",
                "line": 171,
                "column": 10,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 171,
                "endColumn": 17
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 176,
                "column": 40,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingReturnType",
                "endLine": 176,
                "endColumn": 42
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 205,
                "column": 25,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 205,
                "endColumn": 45,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                6150,
                                6170
                            ],
                            "text": "(normalized.createdBy != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                6150,
                                6170
                            ],
                            "text": "(normalized.createdBy ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                6150,
                                6170
                            ],
                            "text": "(Boolean(normalized.createdBy))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 207,
                "column": 25,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 207,
                "endColumn": 45,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                6251,
                                6271
                            ],
                            "text": "(normalized.updatedBy != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                6251,
                                6271
                            ],
                            "text": "(normalized.updatedBy ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                6251,
                                6271
                            ],
                            "text": "(Boolean(normalized.updatedBy))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 231,
                "column": 62,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingReturnType",
                "endLine": 231,
                "endColumn": 64
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary optional chain on a non-nullish value.",
                "line": 285,
                "column": 39,
                "nodeType": "MemberExpression",
                "messageId": "neverOptionalChain",
                "endLine": 285,
                "endColumn": 41,
                "suggestions": [
                    {
                        "messageId": "suggestRemoveOptionalChain",
                        "fix": {
                            "range": [
                                8490,
                                8492
                            ],
                            "text": "."
                        },
                        "desc": "Remove unnecessary optional chain"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 297,
                "column": 31,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingReturnType",
                "endLine": 297,
                "endColumn": 33
            },
            {
                "ruleId": "@typescript-eslint/no-floating-promises",
                "severity": 1,
                "message": "Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.",
                "line": 300,
                "column": 5,
                "nodeType": "ExpressionStatement",
                "messageId": "floatingVoid",
                "endLine": 300,
                "endColumn": 16,
                "suggestions": [
                    {
                        "messageId": "floatingFixVoid",
                        "fix": {
                            "range": [
                                8912,
                                8912
                            ],
                            "text": "void "
                        },
                        "desc": "Add void operator to ignore."
                    },
                    {
                        "messageId": "floatingFixAwait",
                        "fix": {
                            "range": [
                                8912,
                                8912
                            ],
                            "text": "await "
                        },
                        "desc": "Add await operator."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary optional chain on a non-nullish value.",
                "line": 311,
                "column": 43,
                "nodeType": "MemberExpression",
                "messageId": "neverOptionalChain",
                "endLine": 311,
                "endColumn": 45,
                "suggestions": [
                    {
                        "messageId": "suggestRemoveOptionalChain",
                        "fix": {
                            "range": [
                                9233,
                                9235
                            ],
                            "text": "."
                        },
                        "desc": "Remove unnecessary optional chain"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
                "line": 314,
                "column": 37,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableBoolean",
                "endLine": 314,
                "endColumn": 49,
                "suggestions": [
                    {
                        "messageId": "conditionFixDefaultFalse",
                        "fix": {
                            "range": [
                                9467,
                                9479
                            ],
                            "text": "(matchesEmail ?? false)"
                        },
                        "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
                    },
                    {
                        "messageId": "conditionFixCompareTrue",
                        "fix": {
                            "range": [
                                9467,
                                9479
                            ],
                            "text": "(matchesEmail === true)"
                        },
                        "desc": "Change condition to check if true (`value === true`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 314,
                "column": 50,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 314,
                "endColumn": 52,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                9480,
                                9482
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 319,
                "column": 58,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingReturnType",
                "endLine": 319,
                "endColumn": 60
            },
            {
                "ruleId": "@typescript-eslint/no-non-null-assertion",
                "severity": 1,
                "message": "Forbidden non-null assertion.",
                "line": 326,
                "column": 41,
                "nodeType": "TSNonNullExpression",
                "messageId": "noNonNull",
                "endLine": 326,
                "endColumn": 56,
                "suggestions": [
                    {
                        "messageId": "suggestOptionalChain",
                        "fix": {
                            "range": [
                                9861,
                                9862
                            ],
                            "text": "?"
                        },
                        "desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 366,
                "column": 41,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingReturnType",
                "endLine": 366,
                "endColumn": 43
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.",
                "line": 375,
                "column": 12,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorNullableNumber",
                "endLine": 375,
                "endColumn": 23,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                11266,
                                11277
                            ],
                            "text": "(contact.age != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultZero",
                        "fix": {
                            "range": [
                                11266,
                                11277
                            ],
                            "text": "(contact.age ?? 0)"
                        },
                        "desc": "Explicitly treat nullish value the same as 0 (`value ?? 0`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                11266,
                                11277
                            ],
                            "text": "(Boolean(contact.age))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 375,
                "column": 24,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 375,
                "endColumn": 26,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                11278,
                                11280
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 387,
                "column": 44,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingReturnType",
                "endLine": 387,
                "endColumn": 46
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 392,
                "column": 34,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingReturnType",
                "endLine": 392,
                "endColumn": 36
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 420,
                "column": 27,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingReturnType",
                "endLine": 420,
                "endColumn": 29
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 425,
                "column": 31,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingReturnType",
                "endLine": 425,
                "endColumn": 33
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 509,
                "column": 6,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingReturnType",
                "endLine": 509,
                "endColumn": 8
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.",
                "line": 520,
                "column": 13,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorNullableNumber",
                "endLine": 520,
                "endColumn": 24,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                14871,
                                14882
                            ],
                            "text": "(params.page != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultZero",
                        "fix": {
                            "range": [
                                14871,
                                14882
                            ],
                            "text": "(params.page ?? 0)"
                        },
                        "desc": "Explicitly treat nullish value the same as 0 (`value ?? 0`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                14871,
                                14882
                            ],
                            "text": "(Boolean(params.page))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 520,
                "column": 25,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 520,
                "endColumn": 27,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                14883,
                                14885
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.",
                "line": 521,
                "column": 14,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorNullableNumber",
                "endLine": 521,
                "endColumn": 26,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                14902,
                                14914
                            ],
                            "text": "(params.limit != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultZero",
                        "fix": {
                            "range": [
                                14902,
                                14914
                            ],
                            "text": "(params.limit ?? 0)"
                        },
                        "desc": "Explicitly treat nullish value the same as 0 (`value ?? 0`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                14902,
                                14914
                            ],
                            "text": "(Boolean(params.limit))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 521,
                "column": 27,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 521,
                "endColumn": 29,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                14915,
                                14917
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 523,
                "column": 11,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 523,
                "endColumn": 27,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                14958,
                                14974
                            ],
                            "text": "(params.sortField != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                14958,
                                14974
                            ],
                            "text": "(params.sortField ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                14958,
                                14974
                            ],
                            "text": "(Boolean(params.sortField))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary optional chain on a non-nullish value.",
                "line": 547,
                "column": 39,
                "nodeType": "MemberExpression",
                "messageId": "neverOptionalChain",
                "endLine": 547,
                "endColumn": 41,
                "suggestions": [
                    {
                        "messageId": "suggestRemoveOptionalChain",
                        "fix": {
                            "range": [
                                15638,
                                15640
                            ],
                            "text": "."
                        },
                        "desc": "Remove unnecessary optional chain"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 587,
                "column": 8,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 587,
                "endColumn": 13,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                16822,
                                16827
                            ],
                            "text": "(error != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                16822,
                                16827
                            ],
                            "text": "(error ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                16822,
                                16827
                            ],
                            "text": "(Boolean(error))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 606,
                "column": 8,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 606,
                "endColumn": 22,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                17244,
                                17258
                            ],
                            "text": "(operationError != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                17244,
                                17258
                            ],
                            "text": "(operationError ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                17244,
                                17258
                            ],
                            "text": "(Boolean(operationError))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/restrict-template-expressions",
                "severity": 1,
                "message": "Invalid type \"number\" of template literal expression.",
                "line": 620,
                "column": 33,
                "nodeType": "MemberExpression",
                "messageId": "invalidType",
                "endLine": 620,
                "endColumn": 56
            },
            {
                "ruleId": "@typescript-eslint/no-floating-promises",
                "severity": 1,
                "message": "Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.",
                "line": 638,
                "column": 17,
                "nodeType": "ExpressionStatement",
                "messageId": "floatingVoid",
                "endLine": 638,
                "endColumn": 67,
                "suggestions": [
                    {
                        "messageId": "floatingFixVoid",
                        "fix": {
                            "range": [
                                18328,
                                18328
                            ],
                            "text": "void "
                        },
                        "desc": "Add void operator to ignore."
                    },
                    {
                        "messageId": "floatingFixAwait",
                        "fix": {
                            "range": [
                                18328,
                                18328
                            ],
                            "text": "await "
                        },
                        "desc": "Add await operator."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected value in conditional. A boolean expression is required.",
                "line": 643,
                "column": 19,
                "nodeType": "ChainExpression",
                "messageId": "conditionErrorOther",
                "endLine": 643,
                "endColumn": 38
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary optional chain on a non-nullish value.",
                "line": 643,
                "column": 54,
                "nodeType": "MemberExpression",
                "messageId": "neverOptionalChain",
                "endLine": 643,
                "endColumn": 56,
                "suggestions": [
                    {
                        "messageId": "suggestRemoveOptionalChain",
                        "fix": {
                            "range": [
                                18600,
                                18602
                            ],
                            "text": "."
                        },
                        "desc": "Remove unnecessary optional chain"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-floating-promises",
                "severity": 1,
                "message": "Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.",
                "line": 647,
                "column": 17,
                "nodeType": "ExpressionStatement",
                "messageId": "floatingVoid",
                "endLine": 652,
                "endColumn": 20,
                "suggestions": [
                    {
                        "messageId": "floatingFixVoid",
                        "fix": {
                            "range": [
                                18822,
                                18822
                            ],
                            "text": "void "
                        },
                        "desc": "Add void operator to ignore."
                    },
                    {
                        "messageId": "floatingFixAwait",
                        "fix": {
                            "range": [
                                18822,
                                18822
                            ],
                            "text": "await "
                        },
                        "desc": "Add await operator."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 702,
                "column": 12,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 702,
                "endColumn": 21,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                20408,
                                20417
                            ],
                            "text": "(formError != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                20408,
                                20417
                            ],
                            "text": "(formError ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                20408,
                                20417
                            ],
                            "text": "(Boolean(formError))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "no-useless-escape",
                "severity": 1,
                "message": "Unnecessary escape character: \\+.",
                "line": 741,
                "column": 29,
                "nodeType": "Literal",
                "messageId": "unnecessaryEscape",
                "endLine": 741,
                "endColumn": 30,
                "suggestions": [
                    {
                        "messageId": "removeEscape",
                        "fix": {
                            "range": [
                                21521,
                                21522
                            ],
                            "text": ""
                        },
                        "desc": "Remove the `\\`. This maintains the current functionality."
                    },
                    {
                        "messageId": "escapeBackslash",
                        "fix": {
                            "range": [
                                21521,
                                21521
                            ],
                            "text": "\\"
                        },
                        "desc": "Replace the `\\` with `\\\\` to include the actual backslash character."
                    }
                ]
            },
            {
                "ruleId": "no-useless-escape",
                "severity": 1,
                "message": "Unnecessary escape character: \\(.",
                "line": 741,
                "column": 40,
                "nodeType": "Literal",
                "messageId": "unnecessaryEscape",
                "endLine": 741,
                "endColumn": 41,
                "suggestions": [
                    {
                        "messageId": "removeEscape",
                        "fix": {
                            "range": [
                                21532,
                                21533
                            ],
                            "text": ""
                        },
                        "desc": "Remove the `\\`. This maintains the current functionality."
                    },
                    {
                        "messageId": "escapeBackslash",
                        "fix": {
                            "range": [
                                21532,
                                21532
                            ],
                            "text": "\\"
                        },
                        "desc": "Replace the `\\` with `\\\\` to include the actual backslash character."
                    }
                ]
            },
            {
                "ruleId": "no-useless-escape",
                "severity": 1,
                "message": "Unnecessary escape character: \\).",
                "line": 741,
                "column": 42,
                "nodeType": "Literal",
                "messageId": "unnecessaryEscape",
                "endLine": 741,
                "endColumn": 43,
                "suggestions": [
                    {
                        "messageId": "removeEscape",
                        "fix": {
                            "range": [
                                21534,
                                21535
                            ],
                            "text": ""
                        },
                        "desc": "Remove the `\\`. This maintains the current functionality."
                    },
                    {
                        "messageId": "escapeBackslash",
                        "fix": {
                            "range": [
                                21534,
                                21534
                            ],
                            "text": "\\"
                        },
                        "desc": "Replace the `\\` with `\\\\` to include the actual backslash character."
                    }
                ]
            },
            {
                "ruleId": "no-useless-escape",
                "severity": 1,
                "message": "Unnecessary escape character: \\..",
                "line": 741,
                "column": 44,
                "nodeType": "Literal",
                "messageId": "unnecessaryEscape",
                "endLine": 741,
                "endColumn": 45,
                "suggestions": [
                    {
                        "messageId": "removeEscape",
                        "fix": {
                            "range": [
                                21536,
                                21537
                            ],
                            "text": ""
                        },
                        "desc": "Remove the `\\`. This maintains the current functionality."
                    },
                    {
                        "messageId": "escapeBackslash",
                        "fix": {
                            "range": [
                                21536,
                                21536
                            ],
                            "text": "\\"
                        },
                        "desc": "Replace the `\\` with `\\\\` to include the actual backslash character."
                    }
                ]
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 45,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "import React, { useState, useEffect, useMemo, useCallback } from 'react';\nimport { useAuth } from '@/contexts/AuthContext';\nimport { ConfirmationModal } from '@/components/ConfirmationModal';\nimport type { Contact, ContactListResponse } from '@/types/contact';\nimport { Gender } from '@/types/contact';\nimport { normalizePersonDTO, type PersonDTO } from '@/types/person';\nimport { addressBookService } from '@/services/api';\nimport { getEnv } from '@/config/env';\nimport {\n  Button,\n  Input,\n  InputNumber,\n  Card,\n  Table,\n  Modal,\n  Form,\n  Alert,\n  Space,\n  Typography,\n  Divider,\n  App,\n  Spin,\n  Select,\n} from 'antd';\nimport { PlusOutlined, EditOutlined, DeleteOutlined, SearchOutlined } from '@ant-design/icons';\nimport { isApiSuccess } from '@/types/api';\nimport { asContactId, asTenantId, asUserId } from '@/types/ids';\n\ninterface AddressFormValues {\n  firstName: string;\n  lastName: string;\n  email?: string;\n  phone?: string;\n  gender?: Gender;\n  age: number;\n  street1: string;\n  street2?: string;\n  city: string;\n  state: string;\n  zipCode: string;\n  country: string;\n}\n\nlet cachedDefaultCountry: string | null = null;\n\nfunction getDefaultCountry(): string {\n  if (cachedDefaultCountry === null) {\n    try {\n      const value = getEnv().defaultCountry;\n      cachedDefaultCountry =\n        typeof value === 'string' && value.trim().length > 0 ? value.trim() : '';\n    } catch {\n      // Fallback if environment not available during tests\n      cachedDefaultCountry = '';\n    }\n  }\n  return cachedDefaultCountry;\n}\n\nconst DEFAULT_COUNTRY = getDefaultCountry();\n\n/**\n * Resolve the contact identifier from a backend person payload.\n * Expects a normalized PersonDTO - do not call normalizePersonDTO again.\n */\nexport const resolveContactId = (\n  normalized: PersonDTO,\n  fallback: () => Contact['id']\n): Contact['id'] => {\n  if (typeof normalized.id === 'string' && normalized.id.trim()) {\n    return asContactId(normalized.id.trim());\n  }\n\n  if (typeof normalized.id === 'number') {\n    return asContactId(normalized.id.toString());\n  }\n\n  return fallback();\n};\n\n/**\n * Parse the most complete name representation available from the person payload.\n * Expects a normalized PersonDTO - do not call normalizePersonDTO again.\n */\nexport const parseContactName = (\n  normalized: PersonDTO\n): { rawName: string; firstName: string; lastName: string } => {\n  const computedFullName =\n    normalized.fullName ??\n    [normalized.firstName, normalized.lastName]\n      .filter((segment): segment is string => Boolean(segment?.trim()))\n      .join(' ')\n      .trim();\n\n  const rawName = computedFullName;\n  const nameParts = rawName ? rawName.split(/\\s+/) : [];\n  const firstName = normalized.firstName ?? nameParts[0] ?? '';\n  const lastName = normalized.lastName ?? nameParts.slice(1).join(' ');\n\n  return { rawName, firstName, lastName };\n};\n\n/**\n * Resolve gender from multiple potential backend encodings.\n * Expects a normalized PersonDTO - do not call normalizePersonDTO again.\n */\nexport const resolveContactGender = (normalized: PersonDTO): Gender | undefined => {\n  if (normalized.gender === null || normalized.gender === undefined) {\n    return undefined;\n  }\n\n  if (\n    normalized.gender === Gender.male ||\n    normalized.gender === Gender.female ||\n    normalized.gender === Gender.other\n  ) {\n    return normalized.gender;\n  }\n\n  return undefined;\n};\n\n/**\n * Normalise address information into the Contact schema.\n * Expects a normalized PersonDTO - do not call normalizePersonDTO again.\n */\nexport const normalizeContactAddress = (\n  normalized: PersonDTO,\n  defaultCountry: string\n): Contact['address'] | undefined => {\n  const address = normalized.address;\n\n  if (!address) {\n    return undefined;\n  }\n\n  return {\n    street1: address.street1 ?? '',\n    street2: address.street2,\n    city: address.city ?? '',\n    state: address.state ?? '',\n    zipCode: address.zipCode ?? '',\n    country: address.country ?? defaultCountry,\n  };\n};\n\nexport const AddressBookPage: React.FC = () => {\n  const { tenant } = useAuth();\n  const { message } = App.useApp();\n  const [contacts, setContacts] = useState<Contact[]>([]);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const [operationError, setOperationError] = useState<string | null>(null);\n  const [formError, setFormError] = useState<string | null>(null);\n\n  const [searchTerm, setSearchTerm] = useState('');\n  const [isFormOpen, setIsFormOpen] = useState(false);\n  const [editingContact, setEditingContact] = useState<Contact | null>(null);\n  const [deleteContactId, setDeleteContactId] = useState<Contact['id'] | null>(null);\n  const [form] = Form.useForm();\n  const [isSubmitting, setIsSubmitting] = useState(false);\n\n  // Pagination state\n  const [paginationState, setPaginationState] = useState({\n    current: 1,\n    pageSize: 10,\n    total: 0,\n  });\n\n  // Sorting state\n  const [sorting, setSorting] = useState<{\n    field: string;\n    order: 'asc' | 'desc';\n  } | null>(null);\n  // Helper function to transform backend Person to frontend Contact\n  const generateFallbackContactId = () => `contact-${Math.random().toString(36).slice(2, 10)}`;\n\n  /**\n   * Transform backend PersonDTO to frontend Contact type\n   * @param person - Person data from backend API\n   * @returns Properly typed Contact object for frontend use\n   */\n  const personToContact = useCallback(\n    (person: PersonDTO): Contact => {\n      const normalized = normalizePersonDTO(person);\n\n      const resolvedId = resolveContactId(normalized, () =>\n        asContactId(generateFallbackContactId())\n      );\n\n      const resolvedTenantId = (() => {\n        if (typeof normalized.tenantId === 'string' && normalized.tenantId.trim()) {\n          return asTenantId(normalized.tenantId.trim());\n        }\n        if (tenant?.id) return tenant.id;\n        return asTenantId('tenant-fallback');\n      })();\n\n      const { rawName, firstName, lastName } = parseContactName(normalized);\n\n      const resolvedGender = resolveContactGender(normalized);\n\n      const resolvedAddress = normalizeContactAddress(normalized, DEFAULT_COUNTRY);\n\n      const createdBy = normalized.createdBy ? asUserId(normalized.createdBy) : asUserId('system');\n\n      const updatedBy = normalized.updatedBy ? asUserId(normalized.updatedBy) : createdBy;\n\n      return {\n        id: resolvedId,\n        tenantId: resolvedTenantId,\n        firstName,\n        lastName,\n        fullName: rawName || [firstName, lastName].filter(Boolean).join(' '),\n        email: normalized.email,\n        phone: normalized.phone,\n        gender: resolvedGender,\n        age: normalized.age,\n        address: resolvedAddress,\n        createdAt: normalized.createdAt ?? new Date(),\n        updatedAt: normalized.updatedAt ?? normalized.createdAt ?? new Date(),\n        createdBy,\n        updatedBy,\n        isActive: normalized.isActive ?? true,\n      };\n    },\n    [tenant]\n  );\n\n  // Helper function to transform frontend Contact to backend PersonDTO\n  const contactToPersonDTO = (formValues: AddressFormValues) => {\n    const name = `${formValues.firstName} ${formValues.lastName}`.trim();\n    const addressSegments = [\n      formValues.street1,\n      formValues.street2,\n      formValues.city,\n      formValues.state,\n      formValues.zipCode,\n      formValues.country,\n    ]\n      .map(segment => (segment ?? '').trim())\n      .filter(segment => segment.length > 0);\n\n    return {\n      name: name || formValues.street1,\n      address: addressSegments.join(', ') || formValues.street1,\n      phone: formValues.phone ?? '',\n      email: formValues.email ?? '',\n      gender: formValues.gender,\n      age: typeof formValues.age === 'number' ? formValues.age : 25,\n    };\n  };\n\n  const loadContacts = useCallback(async () => {\n    if (!tenant) {\n      setContacts([]);\n      setError(null);\n      return;\n    }\n\n    setLoading(true);\n    setError(null);\n\n    const result = await addressBookService.getAll();\n\n    if (result.isErr()) {\n      const errorMessage = 'Failed to load contacts';\n      setError(errorMessage);\n      message.error(errorMessage);\n      setLoading(false);\n      return;\n    }\n\n    const apiResponse = result.value;\n\n    if (!isApiSuccess(apiResponse)) {\n      const errorMessage = apiResponse.error.message || 'Failed to load contacts';\n      setError(errorMessage);\n      message.error(errorMessage);\n      setLoading(false);\n      return;\n    }\n\n    const data = apiResponse.data;\n    const records = Array.isArray(data?.contacts) ? data.contacts : [];\n    const transformedContacts = records.map(personToContact);\n    setContacts(transformedContacts);\n    setPaginationState({\n      current: data.page || 1,\n      pageSize: data.limit || 10,\n      total: data.total || 0,\n    });\n    setLoading(false);\n  }, [message, tenant, personToContact]);\n\n  useEffect(() => {\n    const loadData = async () => {\n      await loadContacts();\n    };\n    loadData();\n  }, [loadContacts]);\n\n  // Filter contacts based on search term\n  const normalizedSearch = searchTerm.trim().toLowerCase();\n  const filteredContacts = useMemo(() => {\n    if (!normalizedSearch) {\n      return contacts;\n    }\n\n    return contacts.filter(contact => {\n      const matchesName = contact.fullName?.toLowerCase().includes(normalizedSearch);\n      const matchesEmail = contact.email?.toLowerCase().includes(normalizedSearch);\n      const matchesPhone = contact.phone?.includes(normalizedSearch);\n      return Boolean(matchesName || matchesEmail || matchesPhone);\n    });\n  }, [contacts, normalizedSearch]);\n\n  // Handle form submission\n  const handleSubmit = async (values: AddressFormValues) => {\n    setIsSubmitting(true);\n    setFormError(null);\n    const dto = contactToPersonDTO(values);\n\n    const isUpdating = Boolean(editingContact);\n    const result = isUpdating\n      ? await addressBookService.update(editingContact!.id, dto)\n      : await addressBookService.create(dto);\n\n    if (result.isErr()) {\n      const errorMessage = 'Operation Failed';\n      setFormError(errorMessage);\n      setOperationError(errorMessage);\n      message.error(errorMessage);\n      setIsSubmitting(false);\n      // Don't close modal on error - let user see the error and retry\n      return;\n    }\n\n    const apiResponse = result.value;\n\n    if (!isApiSuccess(apiResponse)) {\n      const errorMessage = 'Operation Failed';\n      setFormError(errorMessage);\n      setOperationError(errorMessage);\n      message.error(errorMessage);\n      setIsSubmitting(false);\n      // Don't close modal on error - let user see the error and retry\n      return;\n    }\n\n    const successMsg =\n      apiResponse.message ??\n      (isUpdating ? 'Contact updated successfully!' : 'Contact created successfully!');\n    message.success(successMsg);\n\n    await loadContacts();\n\n    setEditingContact(null);\n    setIsFormOpen(false);\n    form.resetFields();\n    setIsSubmitting(false);\n    setOperationError(null); // Clear operation error on success\n  };\n\n  // Handle edit\n  const handleEdit = (contact: Contact) => {\n    setEditingContact(contact);\n    setFormError(null);\n    form.setFieldsValue({\n      firstName: contact.firstName,\n      lastName: contact.lastName,\n      email: contact.email,\n      phone: contact.phone,\n      gender: contact.gender,\n      age: contact.age || 25, // Default if not available\n      street1: contact.address?.street1,\n      street2: contact.address?.street2,\n      city: contact.address?.city,\n      state: contact.address?.state,\n      zipCode: contact.address?.zipCode,\n      country: contact.address?.country,\n    });\n    setIsFormOpen(true);\n  };\n\n  // Handle delete - open confirmation modal\n  const handleDelete = (id: Contact['id']) => {\n    setDeleteContactId(id);\n  };\n\n  // Confirm delete\n  const confirmDelete = async () => {\n    if (deleteContactId) {\n      const result = await addressBookService.delete(deleteContactId);\n\n      if (result.isErr()) {\n        const errorMessage = 'Operation Failed';\n        setOperationError(errorMessage);\n        message.error(errorMessage);\n        return;\n      }\n\n      const apiResponse = result.value;\n\n      if (!isApiSuccess(apiResponse)) {\n        const errorMessage = 'Operation Failed';\n        setOperationError(errorMessage);\n        message.error(errorMessage);\n        return;\n      }\n\n      setDeleteContactId(null);\n      await loadContacts();\n      message.success(apiResponse.message ?? 'Contact deleted successfully!');\n      setOperationError(null); // Clear operation error on success\n    }\n  };\n\n  // Cancel delete\n  const cancelDelete = () => {\n    setDeleteContactId(null);\n  };\n\n  // Open form for new contact\n  const handleNewContact = () => {\n    setEditingContact(null);\n    setFormError(null);\n    form.resetFields();\n    setIsFormOpen(true);\n  };\n\n  // Table columns for contacts display\n  const columns = [\n    {\n      title: 'Name',\n      dataIndex: 'fullName',\n      key: 'fullName',\n      sorter: (a: Contact, b: Contact) => a.fullName.localeCompare(b.fullName),\n    },\n    {\n      title: 'Email',\n      dataIndex: 'email',\n      key: 'email',\n    },\n    {\n      title: 'Phone',\n      dataIndex: 'phone',\n      key: 'phone',\n    },\n    {\n      title: 'Address',\n      dataIndex: 'address',\n      key: 'address',\n      render: (address: Contact['address']) => {\n        if (!address) return '-';\n\n        const parts = [];\n\n        if (address.street1) parts.push(address.street1);\n        if (address.city) parts.push(address.city);\n        if (address.state && address.zipCode) {\n          parts.push(`${address.state} ${address.zipCode}`);\n        } else {\n          if (address.state) parts.push(address.state);\n          if (address.zipCode) parts.push(address.zipCode);\n        }\n        if (address.country) parts.push(address.country);\n\n        return parts.length > 0 ? parts.join(', ') : '-';\n      },\n    },\n    {\n      title: 'Actions',\n      key: 'actions',\n      render: (_: unknown, contact: Contact) => (\n        <Space size=\"middle\">\n          <Button\n            type=\"link\"\n            icon={<EditOutlined />}\n            data-testid={`edit-${contact.id}`}\n            onClick={() => {\n              handleEdit(contact);\n            }}\n          >\n            Edit\n          </Button>\n          <Button\n            type=\"link\"\n            danger\n            icon={<DeleteOutlined />}\n            onClick={() => {\n              handleDelete(contact.id);\n            }}\n          >\n            Delete\n          </Button>\n        </Space>\n      ),\n    },\n  ];\n\n  // Define loadContactsWithParams\n  const loadContactsWithParams = async (params: {\n    page?: number;\n    limit?: number;\n    search?: string;\n    sortField?: string;\n    sortOrder?: 'asc' | 'desc';\n  }) => {\n    if (!tenant) {\n      setContacts([]);\n      setError(null);\n      return;\n    }\n\n    setLoading(true);\n    setError(null);\n\n    const fullParams = {\n      page: params.page || 1,\n      limit: params.limit || 10,\n      search: searchTerm,\n      ...(params.sortField &&\n        params.sortOrder && { sort: `${params.sortField},${params.sortOrder}` }),\n    };\n    const result = await addressBookService.getAll(fullParams);\n\n    if (result.isErr()) {\n      const errorMessage = 'Failed to load contacts';\n      setError(errorMessage);\n      message.error(errorMessage);\n      setLoading(false);\n      return;\n    }\n\n    const apiResponse = result.value;\n\n    if (!isApiSuccess(apiResponse)) {\n      const errorMessage = 'Failed to load contacts';\n      setError(errorMessage);\n      message.error(errorMessage);\n      setLoading(false);\n      return;\n    }\n\n    const data = apiResponse.data;\n    const records = Array.isArray(data?.contacts) ? data.contacts : [];\n    const transformedContacts = records.map(personToContact);\n    setContacts(transformedContacts);\n    setPaginationState({\n      current: data.page || 1,\n      pageSize: data.limit || 10,\n      total: data.total || 0,\n    });\n    setLoading(false);\n  };\n\n  return (\n    <Space direction=\"vertical\" size=\"large\" style={{ width: '100%' }}>\n      {/* Header */}\n      <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>\n        <div>\n          <Typography.Title level={2} style={{ margin: 0 }}>\n            Address Book\n          </Typography.Title>\n          <Typography.Text type=\"secondary\">Manage your contacts and addresses</Typography.Text>\n        </div>\n        <Button type=\"primary\" icon={<PlusOutlined />} onClick={handleNewContact}>\n          Add Contact\n        </Button>\n      </div>\n\n      <Divider />\n\n      {/* Search Bar */}\n      <Input\n        placeholder=\"Search contacts...\"\n        prefix={<SearchOutlined />}\n        value={searchTerm}\n        onChange={e => {\n          setSearchTerm(e.target.value);\n        }}\n        style={{ maxWidth: 400 }}\n      />\n\n      {/* Error Alert */}\n      {error && (\n        <Alert\n          message=\"Error Loading Contacts\"\n          description={error}\n          type=\"error\"\n          showIcon\n          closable\n          onClose={() => {\n            setError(null);\n          }}\n          action={\n            <Button size=\"small\" onClick={loadContacts}>\n              Retry\n            </Button>\n          }\n        />\n      )}\n\n      {/* Operation Error Alert */}\n      {operationError && (\n        <Alert\n          message=\"Operation Failed\"\n          description={operationError}\n          type=\"error\"\n          showIcon\n          closable\n          onClose={() => {\n            setOperationError(null);\n          }}\n        />\n      )}\n\n      {/* Contacts Table */}\n      <Card title={`Contacts (${filteredContacts.length})`}>\n        {loading ? (\n          <div style={{ textAlign: 'center', padding: '32px' }}>\n            <Spin size=\"large\" />\n            <Typography.Text style={{ marginLeft: 8 }}>Loading contacts...</Typography.Text>\n          </div>\n        ) : (\n          <Table\n            columns={columns}\n            dataSource={filteredContacts}\n            rowKey=\"id\"\n            pagination={{\n              current: paginationState.current,\n              pageSize: paginationState.pageSize,\n              total: paginationState.total,\n              onChange: (page, pageSize) => {\n                setPaginationState({ current: page, pageSize, total: paginationState.total });\n                // Reload with new params\n                loadContactsWithParams({ page, limit: pageSize });\n              },\n            }}\n            onChange={(pagination, filters, sorter) => {\n              const sorterResult = Array.isArray(sorter) ? sorter[0] : sorter;\n              if (sorterResult?.field && sorterResult?.order) {\n                const order = sorterResult.order === 'ascend' ? 'asc' : 'desc';\n                setSorting({ field: sorterResult.field as string, order });\n                // Reload with sorting\n                loadContactsWithParams({\n                  page: pagination.current,\n                  limit: pagination.pageSize,\n                  sortField: sorterResult.field as string,\n                  sortOrder: order,\n                });\n              }\n            }}\n            locale={{\n              emptyText:\n                contacts.length === 0 ? (\n                  <div style={{ textAlign: 'center', padding: '32px' }}>\n                    <Typography.Text>No contacts yet. Add your first contact!</Typography.Text>\n                    <br />\n                    <br />\n                    <Button type=\"primary\" onClick={handleNewContact}>\n                      Add Contact\n                    </Button>\n                  </div>\n                ) : (\n                  'No contacts match your search.'\n                ),\n            }}\n          />\n        )}\n      </Card>\n\n      {/* Contact Form Modal */}\n      <Modal\n        title={editingContact ? 'Edit Contact' : 'Add New Contact'}\n        open={isFormOpen}\n        onCancel={() => {\n          setIsFormOpen(false);\n        }}\n        footer={null}\n      >\n        <Form\n          form={form}\n          onFinish={handleSubmit}\n          layout=\"vertical\"\n          initialValues={{\n            firstName: '',\n            lastName: '',\n            email: '',\n            phone: '',\n            gender: undefined,\n            age: 25,\n            street1: '',\n            street2: '',\n            city: '',\n            state: '',\n            zipCode: '',\n            country: DEFAULT_COUNTRY,\n          }}\n        >\n          {formError && (\n            <Alert\n              message=\"Operation Failed\"\n              description={formError}\n              type=\"error\"\n              showIcon\n              closable\n              onClose={() => {\n                setFormError(null);\n              }}\n              style={{ marginBottom: 16 }}\n            />\n          )}\n          <Form.Item\n            name=\"firstName\"\n            label=\"First Name\"\n            rules={[{ required: true, message: 'Please enter first name' }]}\n          >\n            <Input />\n          </Form.Item>\n          <Form.Item\n            name=\"lastName\"\n            label=\"Last Name\"\n            rules={[{ required: true, message: 'Please enter last name' }]}\n          >\n            <Input />\n          </Form.Item>\n          <Form.Item\n            name=\"email\"\n            label=\"Email\"\n            rules={[{ type: 'email', message: 'Please enter a valid email' }]}\n          >\n            <Input />\n          </Form.Item>\n          <Form.Item\n            name=\"phone\"\n            label=\"Phone\"\n            rules={[\n              {\n                pattern: /^[\\+]?[\\d\\s\\-\\(\\)\\.]+$/,\n                message: 'Please enter a valid phone number',\n              },\n            ]}\n          >\n            <Input />\n          </Form.Item>\n\n          <Form.Item\n            name=\"gender\"\n            label=\"Gender\"\n            rules={[{ required: true, message: 'Please select gender' }]}\n          >\n            <Select style={{ width: '100%' }} placeholder=\"Select gender\" allowClear>\n              <Select.Option value=\"male\">Male</Select.Option>\n              <Select.Option value=\"female\">Female</Select.Option>\n              <Select.Option value=\"other\">Other</Select.Option>\n            </Select>\n          </Form.Item>\n\n          <Form.Item\n            name=\"age\"\n            label=\"Age\"\n            rules={[\n              { required: true, message: 'Please enter age' },\n              { type: 'number', min: 1, max: 120, message: 'Age must be between 1 and 120' },\n            ]}\n          >\n            <InputNumber min={1} max={120} style={{ width: '100%' }} />\n          </Form.Item>\n\n          <Divider>Address</Divider>\n\n          <Form.Item\n            name=\"street1\"\n            label=\"Street Address\"\n            rules={[{ required: true, message: 'Please enter street address' }]}\n          >\n            <Input />\n          </Form.Item>\n          <Form.Item name=\"street2\" label=\"Street Address 2\">\n            <Input />\n          </Form.Item>\n          <Form.Item\n            name=\"city\"\n            label=\"City\"\n            rules={[{ required: true, message: 'Please enter city' }]}\n          >\n            <Input />\n          </Form.Item>\n          <Form.Item\n            name=\"state\"\n            label=\"State\"\n            rules={[{ required: true, message: 'Please enter state' }]}\n          >\n            <Input />\n          </Form.Item>\n          <Form.Item\n            name=\"zipCode\"\n            label=\"ZIP Code\"\n            rules={[{ required: true, message: 'Please enter ZIP code' }]}\n          >\n            <Input />\n          </Form.Item>\n          <Form.Item\n            name=\"country\"\n            label=\"Country\"\n            rules={[{ required: true, message: 'Please enter country' }]}\n          >\n            <Input />\n          </Form.Item>\n\n          <Form.Item>\n            <Space>\n              <Button type=\"primary\" htmlType=\"submit\" loading={isSubmitting}>\n                {editingContact ? 'Update Contact' : 'Add Contact'}\n              </Button>\n              <Button\n                onClick={() => {\n                  setIsFormOpen(false);\n                }}\n              >\n                Cancel\n              </Button>\n            </Space>\n          </Form.Item>\n        </Form>\n      </Modal>\n\n      {/* Confirmation Modal */}\n      <ConfirmationModal\n        isOpen={deleteContactId !== null}\n        title=\"Delete Contact\"\n        message=\"Are you sure you want to delete this contact? This action cannot be undone.\"\n        confirmText=\"Delete\"\n        onConfirm={confirmDelete}\n        onCancel={cancelDelete}\n      />\n    </Space>\n  );\n};\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/pages/DashboardPage.tsx",
        "messages": [
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'Statistic' is defined but never used. Allowed unused vars must match /^_/u.",
                "line": 4,
                "column": 26,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 4,
                "endColumn": 35
            },
            {
                "ruleId": "@typescript-eslint/no-non-null-assertion",
                "severity": 1,
                "message": "Forbidden non-null assertion.",
                "line": 72,
                "column": 32,
                "nodeType": "TSNonNullExpression",
                "messageId": "noNonNull",
                "endLine": 72,
                "endColumn": 50
            },
            {
                "ruleId": "@typescript-eslint/restrict-template-expressions",
                "severity": 1,
                "message": "Invalid type \"string | undefined\" of template literal expression.",
                "line": 79,
                "column": 35,
                "nodeType": "LogicalExpression",
                "messageId": "invalidType",
                "endLine": 79,
                "endColumn": 68
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 79,
                "column": 35,
                "nodeType": "ChainExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 79,
                "endColumn": 50,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                1807,
                                1822
                            ],
                            "text": "((user?.firstName) != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                1807,
                                1822
                            ],
                            "text": "((user?.firstName) ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                1807,
                                1822
                            ],
                            "text": "(Boolean((user?.firstName)))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 79,
                "column": 51,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 79,
                "endColumn": 53,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                1823,
                                1825
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/restrict-template-expressions",
                "severity": 1,
                "message": "Invalid type \"string | undefined\" of template literal expression.",
                "line": 80,
                "column": 52,
                "nodeType": "ChainExpression",
                "messageId": "invalidType",
                "endLine": 80,
                "endColumn": 64
            },
            {
                "ruleId": "@typescript-eslint/restrict-template-expressions",
                "severity": 1,
                "message": "Invalid type \"TenantId | undefined\" of template literal expression.",
                "line": 80,
                "column": 69,
                "nodeType": "ChainExpression",
                "messageId": "invalidType",
                "endLine": 80,
                "endColumn": 79
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 136,
                "column": 42,
                "nodeType": "ChainExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 136,
                "endColumn": 65,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                3658,
                                3681
                            ],
                            "text": "((user?.roles?.join(', ')) != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                3658,
                                3681
                            ],
                            "text": "((user?.roles?.join(', ')) ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                3658,
                                3681
                            ],
                            "text": "(Boolean((user?.roles?.join(', '))))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary optional chain on a non-nullish value.",
                "line": 136,
                "column": 53,
                "nodeType": "MemberExpression",
                "messageId": "neverOptionalChain",
                "endLine": 136,
                "endColumn": 55,
                "suggestions": [
                    {
                        "messageId": "suggestRemoveOptionalChain",
                        "fix": {
                            "range": [
                                3669,
                                3671
                            ],
                            "text": "."
                        },
                        "desc": "Remove unnecessary optional chain"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 136,
                "column": 66,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 136,
                "endColumn": 68,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                3682,
                                3684
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 10,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "import React from 'react';\nimport { useAuth } from '@/contexts/AuthContext';\nimport { Link } from 'react-router-dom';\nimport { Card, Row, Col, Statistic, Alert, List, Avatar, Space, Button, Tag, Divider } from 'antd';\nimport {\n  ContactsOutlined,\n  HeartOutlined,\n  BarsOutlined,\n  CheckCircleOutlined,\n  DesktopOutlined,\n  ApiOutlined,\n  CodeOutlined,\n  ThunderboltOutlined,\n} from '@ant-design/icons';\n\nexport const DashboardPage: React.FC = () => {\n  const { user, tenant } = useAuth();\n\n  const recentActivities = [\n    {\n      title: 'Application started',\n      description: 'Multi-tenant React frontend with Bun',\n      time: 'Just now',\n    },\n    {\n      title: 'Authentication successful',\n      description: 'JWT token validated for tenant access',\n      time: 'Just now',\n    },\n    {\n      title: 'Dashboard loaded',\n      description: 'Application ready for use',\n      time: 'Just now',\n    },\n  ];\n\n  const technologies = [\n    {\n      name: 'TypeScript',\n      version: '5.9+',\n      icon: <DesktopOutlined />,\n      color: 'blue',\n    },\n    {\n      name: 'Bun',\n      version: '1.0+',\n      icon: <ThunderboltOutlined />,\n      color: 'gold',\n    },\n    {\n      name: 'React',\n      version: '18.3.1',\n      icon: <CodeOutlined />,\n      color: 'blue',\n    },\n    {\n      name: 'Actix Web',\n      version: 'Backend',\n      icon: <ApiOutlined />,\n      color: 'orange',\n    },\n  ];\n\n  const COLOR_MAP: Record<string, string> = {\n    blue: '#1890ff',\n    gold: '#faad14',\n    orange: '#fa8c16',\n    default: '#fa8c16',\n  };\n\n  const getColor = (color: string): string => {\n    return COLOR_MAP[color] ?? COLOR_MAP.default!;\n  };\n\n  return (\n    <Space direction=\"vertical\" size=\"large\" style={{ width: '100%' }}>\n      {/* Welcome Section */}\n      <Alert\n        message={`Welcome back, ${user?.firstName || user?.username}!`}\n        description={`You're logged in to tenant ${tenant?.name} (${tenant?.id})`}\n        type=\"success\"\n        showIcon\n        closable={false}\n      />\n\n      {/* Quick Stats */}\n      <Row gutter={[16, 16]}>\n        <Col xs={24} md={8}>\n          <Card\n            hoverable\n            actions={[\n              <Link to=\"/address-book\" key=\"view\">\n                <Button type=\"primary\" block>\n                  View Address Book\n                </Button>\n              </Link>,\n            ]}\n          >\n            <Card.Meta\n              avatar={<ContactsOutlined style={{ fontSize: 24 }} />}\n              title=\"Address Book\"\n              description=\"Manage your contacts and addresses\"\n            />\n          </Card>\n        </Col>\n        <Col xs={24} md={8}>\n          <Card hoverable>\n            <Card.Meta\n              avatar={<HeartOutlined style={{ fontSize: 24, color: 'green' }} />}\n              title=\"System Health\"\n              description=\"Check API and system status\"\n            />\n            <Divider />\n            <Space>\n              <CheckCircleOutlined style={{ color: 'green' }} />\n              <span>All systems operational</span>\n            </Space>\n          </Card>\n        </Col>\n        <Col xs={24} md={8}>\n          <Card hoverable>\n            <Card.Meta\n              avatar={<HeartOutlined style={{ fontSize: 24 }} />}\n              title=\"User Profile\"\n              description=\"Manage your account settings\"\n            />\n            <Divider />\n            <div style={{ fontSize: '12px' }}>\n              <div>\n                <strong>Email:</strong> {user?.email}\n              </div>\n              <div>\n                <strong>Username:</strong> {user?.username}\n              </div>\n              <div>\n                <strong>Roles:</strong> {user?.roles?.join(', ') || 'None'}\n              </div>\n            </div>\n          </Card>\n        </Col>\n      </Row>\n\n      {/* Recent Activity */}\n      <Card\n        title={\n          <>\n            <BarsOutlined style={{ marginRight: 8 }} />\n            Recent Activity\n          </>\n        }\n        hoverable\n      >\n        <List\n          dataSource={recentActivities}\n          renderItem={item => (\n            <List.Item>\n              <List.Item.Meta title={item.title} description={item.description} />\n              <Tag>{item.time}</Tag>\n            </List.Item>\n          )}\n        />\n      </Card>\n\n      {/* Technology Stack */}\n      <Card title=\"Technology Stack\" hoverable>\n        <Row gutter={[16, 16]}>\n          {technologies.map(tech => (\n            <Col xs={12} sm={6} key={tech.name}>\n              <Card size=\"small\" style={{ textAlign: 'center' }}>\n                <Avatar\n                  size=\"large\"\n                  icon={tech.icon}\n                  style={{ backgroundColor: getColor(tech.color) }}\n                />\n                <div style={{ marginTop: 8 }}>\n                  <div style={{ fontWeight: 500 }}>{tech.name}</div>\n                  <div style={{ fontSize: '12px', color: '#666' }}>{tech.version}</div>\n                </div>\n              </Card>\n            </Col>\n          ))}\n        </Row>\n      </Card>\n    </Space>\n  );\n};\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/pages/EnhancedAddressBookPage.tsx",
        "messages": [
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'Divider' is defined but never used. Allowed unused vars must match /^_/u.",
                "line": 13,
                "column": 3,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 13,
                "endColumn": 10
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'Input' is defined but never used. Allowed unused vars must match /^_/u.",
                "line": 14,
                "column": 3,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 14,
                "endColumn": 8
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'Affix' is defined but never used. Allowed unused vars must match /^_/u.",
                "line": 25,
                "column": 3,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 25,
                "endColumn": 8
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'ClearOutlined' is defined but never used. Allowed unused vars must match /^_/u.",
                "line": 35,
                "column": 3,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 35,
                "endColumn": 16
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'SortAscendingOutlined' is defined but never used. Allowed unused vars must match /^_/u.",
                "line": 38,
                "column": 3,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 38,
                "endColumn": 24
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'SortDescendingOutlined' is defined but never used. Allowed unused vars must match /^_/u.",
                "line": 39,
                "column": 3,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 39,
                "endColumn": 25
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'asContactId' is defined but never used. Allowed unused vars must match /^_/u.",
                "line": 47,
                "column": 10,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 47,
                "endColumn": 21
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'asTenantId' is defined but never used. Allowed unused vars must match /^_/u.",
                "line": 47,
                "column": 23,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 47,
                "endColumn": 33
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'asUserId' is defined but never used. Allowed unused vars must match /^_/u.",
                "line": 47,
                "column": 35,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 47,
                "endColumn": 43
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'SearchResults' is defined but never used. Allowed unused vars must match /^_/u.",
                "line": 54,
                "column": 3,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 54,
                "endColumn": 16
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'Panel' is assigned a value but never used. Allowed unused vars must match /^_/u.",
                "line": 67,
                "column": 9,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 67,
                "endColumn": 14
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'multiSearch' is assigned a value but never used. Allowed unused vars must match /^_/u.",
                "line": 99,
                "column": 9,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 99,
                "endColumn": 20
            },
            {
                "ruleId": "@typescript-eslint/require-await",
                "severity": 1,
                "message": "Async method 'searchFunction' has no 'await' expression.",
                "line": 109,
                "column": 5,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingAwait",
                "endLine": 109,
                "endColumn": 27,
                "suggestions": [
                    {
                        "messageId": "removeAsync",
                        "fix": {
                            "range": [
                                2632,
                                2638
                            ],
                            "text": ""
                        },
                        "desc": "Remove 'async'."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an error typed value.",
                "line": 115,
                "column": 13,
                "nodeType": "VariableDeclarator",
                "messageId": "anyAssignment",
                "endLine": 115,
                "endColumn": 57
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-call",
                "severity": 1,
                "message": "Unsafe call of a(n) `error` type typed value.",
                "line": 115,
                "column": 22,
                "nodeType": "MemberExpression",
                "messageId": "unsafeCall",
                "endLine": 115,
                "endColumn": 50
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected any value in conditional. An explicit comparison or type conversion is required.",
                "line": 118,
                "column": 11,
                "nodeType": "CallExpression",
                "messageId": "conditionErrorAny",
                "endLine": 118,
                "endColumn": 25,
                "suggestions": [
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                2891,
                                2905
                            ],
                            "text": "Boolean(result.isErr())"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-call",
                "severity": 1,
                "message": "Unsafe call of a(n) `error` type typed value.",
                "line": 118,
                "column": 11,
                "nodeType": "MemberExpression",
                "messageId": "unsafeCall",
                "endLine": 118,
                "endColumn": 23
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .isErr on an `error` typed value.",
                "line": 118,
                "column": 18,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 118,
                "endColumn": 23
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-argument",
                "severity": 1,
                "message": "Unsafe argument of type error typed assigned to a parameter of type `string | undefined`.",
                "line": 119,
                "column": 25,
                "nodeType": "MemberExpression",
                "messageId": "unsafeArgument",
                "endLine": 119,
                "endColumn": 44
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .error on an `error` typed value.",
                "line": 119,
                "column": 32,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 119,
                "endColumn": 37
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-return",
                "severity": 1,
                "message": "Unsafe return of a value of type error.",
                "line": 122,
                "column": 7,
                "nodeType": "ReturnStatement",
                "messageId": "unsafeReturn",
                "endLine": 122,
                "endColumn": 27
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .value on an `error` typed value.",
                "line": 122,
                "column": 21,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 122,
                "endColumn": 26
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'result' is defined but never used. Allowed unused args must match /^_/u.",
                "line": 130,
                "column": 23,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 130,
                "endColumn": 29
            },
            {
                "ruleId": "react-hooks/set-state-in-effect",
                "severity": 1,
                "message": "Error: Calling setState synchronously within an effect can trigger cascading renders\n\nEffects are intended to synchronize state between React and external systems such as manually updating the DOM, state management libraries, or other platform APIs. In general, the body of an effect should do one or both of the following:\n* Update external systems with the latest state from React.\n* Subscribe for updates from some external system, calling setState in a callback function when external state changes.\n\nCalling setState synchronously within an effect body causes cascading renders that can hurt performance, and is not recommended. (https://react.dev/learn/you-might-not-need-an-effect).\n\n/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/pages/EnhancedAddressBookPage.tsx:157:7\n  155 |     if (contacts.length > 0) {\n  156 |       const service = SearchServiceFactory.createContactService(contacts);\n> 157 |       setSearchService(service);\n      |       ^^^^^^^^^^^^^^^^ Avoid calling setState() directly within an effect\n  158 |     }\n  159 |   }, [contacts]);\n  160 |",
                "line": 157,
                "column": 7,
                "nodeType": null,
                "endLine": 157,
                "endColumn": 23
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary optional chain on a non-nullish value.",
                "line": 193,
                "column": 39,
                "nodeType": "MemberExpression",
                "messageId": "neverOptionalChain",
                "endLine": 193,
                "endColumn": 41,
                "suggestions": [
                    {
                        "messageId": "suggestRemoveOptionalChain",
                        "fix": {
                            "range": [
                                4786,
                                4788
                            ],
                            "text": "."
                        },
                        "desc": "Remove unnecessary optional chain"
                    }
                ]
            },
            {
                "ruleId": "react-hooks/set-state-in-effect",
                "severity": 1,
                "message": "Error: Calling setState synchronously within an effect can trigger cascading renders\n\nEffects are intended to synchronize state between React and external systems such as manually updating the DOM, state management libraries, or other platform APIs. In general, the body of an effect should do one or both of the following:\n* Update external systems with the latest state from React.\n* Subscribe for updates from some external system, calling setState in a callback function when external state changes.\n\nCalling setState synchronously within an effect body causes cascading renders that can hurt performance, and is not recommended. (https://react.dev/learn/you-might-not-need-an-effect).\n\n/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/pages/EnhancedAddressBookPage.tsx:206:5\n  204 |   // Load contacts on mount\n  205 |   useEffect(() => {\n> 206 |     loadContacts();\n      |     ^^^^^^^^^^^^ Avoid calling setState() directly within an effect\n  207 |   }, [loadContacts]);\n  208 |\n  209 |   // Handle search",
                "line": 206,
                "column": 5,
                "nodeType": null,
                "endLine": 206,
                "endColumn": 17
            },
            {
                "ruleId": "@typescript-eslint/no-floating-promises",
                "severity": 1,
                "message": "Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.",
                "line": 206,
                "column": 5,
                "nodeType": "ExpressionStatement",
                "messageId": "floatingVoid",
                "endLine": 206,
                "endColumn": 20,
                "suggestions": [
                    {
                        "messageId": "floatingFixVoid",
                        "fix": {
                            "range": [
                                5089,
                                5089
                            ],
                            "text": "void "
                        },
                        "desc": "Add void operator to ignore."
                    },
                    {
                        "messageId": "floatingFixAwait",
                        "fix": {
                            "range": [
                                5089,
                                5089
                            ],
                            "text": "await "
                        },
                        "desc": "Add await operator."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/restrict-template-expressions",
                "severity": 1,
                "message": "Invalid type \"number\" of template literal expression.",
                "line": 216,
                "column": 30,
                "nodeType": "CallExpression",
                "messageId": "invalidType",
                "endLine": 216,
                "endColumn": 40
            },
            {
                "ruleId": "@typescript-eslint/restrict-template-expressions",
                "severity": 1,
                "message": "Invalid type \"number\" of template literal expression.",
                "line": 227,
                "column": 32,
                "nodeType": "CallExpression",
                "messageId": "invalidType",
                "endLine": 227,
                "endColumn": 42
            },
            {
                "ruleId": "@typescript-eslint/no-floating-promises",
                "severity": 1,
                "message": "Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.",
                "line": 281,
                "column": 7,
                "nodeType": "ExpressionStatement",
                "messageId": "floatingVoid",
                "endLine": 281,
                "endColumn": 39,
                "suggestions": [
                    {
                        "messageId": "floatingFixVoid",
                        "fix": {
                            "range": [
                                7286,
                                7286
                            ],
                            "text": "void "
                        },
                        "desc": "Add void operator to ignore."
                    },
                    {
                        "messageId": "floatingFixAwait",
                        "fix": {
                            "range": [
                                7286,
                                7286
                            ],
                            "text": "await "
                        },
                        "desc": "Add await operator."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-floating-promises",
                "severity": 1,
                "message": "Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.",
                "line": 291,
                "column": 7,
                "nodeType": "ExpressionStatement",
                "messageId": "floatingVoid",
                "endLine": 291,
                "endColumn": 39,
                "suggestions": [
                    {
                        "messageId": "floatingFixVoid",
                        "fix": {
                            "range": [
                                7549,
                                7549
                            ],
                            "text": "void "
                        },
                        "desc": "Add void operator to ignore."
                    },
                    {
                        "messageId": "floatingFixAwait",
                        "fix": {
                            "range": [
                                7549,
                                7549
                            ],
                            "text": "await "
                        },
                        "desc": "Add await operator."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-return",
                "severity": 1,
                "message": "Unsafe return of a value of type error.",
                "line": 299,
                "column": 5,
                "nodeType": "ReturnStatement",
                "messageId": "unsafeReturn",
                "endLine": 299,
                "endColumn": 64
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-call",
                "severity": 1,
                "message": "Unsafe call of a(n) `error` type typed value.",
                "line": 299,
                "column": 12,
                "nodeType": "MemberExpression",
                "messageId": "unsafeCall",
                "endLine": 299,
                "endColumn": 40
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 313,
                "column": 14,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 313,
                "endColumn": 26,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                8159,
                                8171
                            ],
                            "text": "(record.email != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                8159,
                                8171
                            ],
                            "text": "(record.email ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                8159,
                                8171
                            ],
                            "text": "(Boolean(record.email))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 328,
                "column": 14,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 328,
                "endColumn": 26,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                8575,
                                8587
                            ],
                            "text": "(record.phone != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                8575,
                                8587
                            ],
                            "text": "(record.phone ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                8575,
                                8587
                            ],
                            "text": "(Boolean(record.phone))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 329,
                "column": 14,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 329,
                "endColumn": 27,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                8633,
                                8646
                            ],
                            "text": "(record.mobile != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                8633,
                                8646
                            ],
                            "text": "(record.mobile ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                8633,
                                8646
                            ],
                            "text": "(Boolean(record.mobile))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'record' is defined but never used. Allowed unused args must match /^_/u.",
                "line": 366,
                "column": 30,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 366,
                "endColumn": 36
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 387,
                "column": 7,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 387,
                "endColumn": 12,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                10478,
                                10483
                            ],
                            "text": "error != null"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                10478,
                                10483
                            ],
                            "text": "error ?? \"\""
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                10478,
                                10483
                            ],
                            "text": "Boolean(error)"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/restrict-template-expressions",
                "severity": 1,
                "message": "Invalid type \"number\" of template literal expression.",
                "line": 607,
                "column": 47,
                "nodeType": "MemberExpression",
                "messageId": "invalidType",
                "endLine": 607,
                "endColumn": 55
            },
            {
                "ruleId": "@typescript-eslint/restrict-template-expressions",
                "severity": 1,
                "message": "Invalid type \"number\" of template literal expression.",
                "line": 607,
                "column": 59,
                "nodeType": "MemberExpression",
                "messageId": "invalidType",
                "endLine": 607,
                "endColumn": 67
            },
            {
                "ruleId": "@typescript-eslint/restrict-template-expressions",
                "severity": 1,
                "message": "Invalid type \"number\" of template literal expression.",
                "line": 607,
                "column": 74,
                "nodeType": "Identifier",
                "messageId": "invalidType",
                "endLine": 607,
                "endColumn": 79
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected value in conditional. A boolean expression is required.",
                "line": 612,
                "column": 19,
                "nodeType": "ChainExpression",
                "messageId": "conditionErrorOther",
                "endLine": 612,
                "endColumn": 38
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary optional chain on a non-nullish value.",
                "line": 612,
                "column": 54,
                "nodeType": "MemberExpression",
                "messageId": "neverOptionalChain",
                "endLine": 612,
                "endColumn": 56,
                "suggestions": [
                    {
                        "messageId": "suggestRemoveOptionalChain",
                        "fix": {
                            "range": [
                                17345,
                                17347
                            ],
                            "text": "."
                        },
                        "desc": "Remove unnecessary optional chain"
                    }
                ]
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 43,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "/**\n * Enhanced Address Book Page with Advanced Search UX\n * Implements Ant Design Data List specifications for optimal search experience\n */\n\nimport React, { useState, useCallback, useMemo, useEffect } from 'react';\nimport {\n  Card,\n  Table,\n  Button,\n  Space,\n  Typography,\n  Divider,\n  Input,\n  Select,\n  Tag,\n  Badge,\n  Tooltip,\n  Empty,\n  Spin,\n  Alert,\n  Row,\n  Col,\n  Collapse,\n  Affix,\n  Statistic,\n  Progress,\n} from 'antd';\nimport {\n  PlusOutlined,\n  EditOutlined,\n  DeleteOutlined,\n  SearchOutlined,\n  FilterOutlined,\n  ClearOutlined,\n  ReloadOutlined,\n  SettingOutlined,\n  SortAscendingOutlined,\n  SortDescendingOutlined,\n  EyeOutlined,\n  DownloadOutlined,\n} from '@ant-design/icons';\nimport { App } from 'antd';\n\nimport { useAuth } from '@/contexts/AuthContext';\nimport { isApiSuccess } from '@/types/api';\nimport { asContactId, asTenantId, asUserId } from '@/types/ids';\nimport type { Contact } from '@/types/contact';\nimport { addressBookService } from '@/services/api';\nimport { type ContactSearchService, SearchServiceFactory } from '@/services/SearchService';\nimport {\n  SmartSearchInput,\n  AdvancedFilter,\n  SearchResults,\n  CONTACT_SEARCH_FIELDS,\n} from '@/components/SearchComponents';\nimport {\n  useSearchState,\n  useDebouncedSearch,\n  useMultiAttributeSearch,\n  useSearchPerformance,\n} from '@/hooks/useEnhancedSearch';\nimport type { SearchFilter, SearchQuery } from '@/components/SearchComponents';\n\nconst { Title, Text } = Typography;\nconst { Option } = Select;\nconst { Panel } = Collapse;\n\n/**\n * Enhanced Address Book Page Component\n */\nexport const EnhancedAddressBookPage: React.FC = () => {\n  const { tenant } = useAuth();\n  const { message } = App.useApp();\n\n  // Core state\n  const [contacts, setContacts] = useState<Contact[]>([]);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n\n  // Search state management\n  const searchState = useSearchState<Contact>({\n    pageSize: 10,\n    debounceMs: 300,\n    cacheResults: true,\n  });\n\n  // Search service\n  const [searchService, setSearchService] = useState<ContactSearchService | null>(null);\n\n  // Performance monitoring\n  const performance = useSearchPerformance({\n    enableMetrics: true,\n    logPerformance: true,\n    performanceThreshold: 100,\n  });\n\n  // Multi-attribute search\n  const multiSearch = useMultiAttributeSearch({\n    data: contacts,\n    searchFields: ['fullName', 'email', 'phone', 'company'],\n    caseSensitive: false,\n    exactMatch: false,\n    highlightMatches: true,\n  });\n\n  // Debounced search\n  const debouncedSearch = useDebouncedSearch<Contact>({\n    searchFunction: async (query: SearchQuery) => {\n      if (!searchService) {\n        throw new Error('Search service not initialized');\n      }\n\n      performance.startTimer();\n      const result = searchService.searchContacts(query);\n      performance.endTimer();\n\n      if (result.isErr()) {\n        throw new Error(result.error.reason);\n      }\n\n      return result.value;\n    },\n    debounceMs: 300,\n    cacheResults: true,\n    maxCacheSize: 50,\n    onSearchStart: () => {\n      setLoading(true);\n    },\n    onSearchComplete: result => {\n      setLoading(false);\n      setError(null);\n    },\n    onSearchError: error => {\n      setLoading(false);\n      setError(error.message);\n    },\n  });\n\n  // Search results state\n  const [searchResults, setSearchResults] = useState<Contact[]>([]);\n  const [searchStats, setSearchStats] = useState({\n    total: 0,\n    filtered: 0,\n    searchTime: 0,\n  });\n\n  // UI state\n  const [showAdvancedFilters, setShowAdvancedFilters] = useState(false);\n  const [selectedContacts, setSelectedContacts] = useState<Contact['id'][]>([]);\n  const [viewMode, setViewMode] = useState<'table' | 'cards'>('table');\n\n  // Initialize search service when contacts change\n  useEffect(() => {\n    if (contacts.length > 0) {\n      const service = SearchServiceFactory.createContactService(contacts);\n      setSearchService(service);\n    }\n  }, [contacts]);\n\n  // Load contacts from API\n  const loadContacts = useCallback(async () => {\n    if (!tenant) {\n      setContacts([]);\n      setError(null);\n      return;\n    }\n\n    setLoading(true);\n    setError(null);\n\n    const result = await addressBookService.getAll();\n\n    if (result.isErr()) {\n      const errorMessage = 'Failed to load contacts';\n      setError(errorMessage);\n      message.error(errorMessage);\n      setLoading(false);\n      return;\n    }\n\n    const apiResponse = result.value;\n\n    if (!isApiSuccess(apiResponse)) {\n      const errorMessage = apiResponse.error.message || 'Failed to load contacts';\n      setError(errorMessage);\n      message.error(errorMessage);\n      setLoading(false);\n      return;\n    }\n\n    const data = apiResponse.data;\n    const records = Array.isArray(data?.contacts) ? data.contacts : [];\n    setContacts(records);\n    setSearchResults(records);\n    setSearchStats({\n      total: records.length,\n      filtered: records.length,\n      searchTime: 0,\n    });\n    setLoading(false);\n  }, [tenant, message]);\n\n  // Load contacts on mount\n  useEffect(() => {\n    loadContacts();\n  }, [loadContacts]);\n\n  // Handle search\n  const handleSearch = useCallback(\n    async (query: string) => {\n      if (!searchService) return;\n\n      try {\n        const searchQuery: SearchQuery = {\n          queryId: `search-${Date.now()}`,\n          filters: searchState.filters,\n          sortBy: searchState.sortBy,\n          sortOrder: searchState.sortOrder,\n          page: searchState.page,\n          pageSize: searchState.pageSize,\n        };\n\n        // Add text search filter if query provided\n        if (query.trim()) {\n          const textFilter: SearchFilter = {\n            id: `text-search-${Date.now()}`,\n            field: 'fullName',\n            operator: 'contains',\n            value: query,\n          };\n          searchQuery.filters = [...searchQuery.filters, textFilter];\n        }\n\n        const result = await debouncedSearch.search(searchQuery);\n        setSearchResults(result.data);\n        setSearchStats({\n          total: result.total,\n          filtered: result.data.length,\n          searchTime: performance.getMetrics().averageSearchTime,\n        });\n      } catch (error) {\n        if (process.env.NODE_ENV === 'development') {\n          console.error('Search failed:', error);\n        }\n        message.error('Search failed. Please try again.');\n      }\n    },\n    [searchService, searchState, debouncedSearch, performance, message]\n  );\n\n  // Handle filter changes\n  const handleFiltersChange = useCallback(\n    (filters: SearchFilter[]) => {\n      searchState.setFilters(filters);\n    },\n    [searchState]\n  );\n\n  // Handle filter apply\n  const handleApplyFilters = useCallback(async () => {\n    await handleSearch(searchState.query);\n  }, [handleSearch, searchState.query]);\n\n  // Handle filter clear\n  const handleClearFilters = useCallback(() => {\n    searchState.clearFilters();\n    searchState.setQuery('');\n    setSearchResults(contacts);\n    setSearchStats({\n      total: contacts.length,\n      filtered: contacts.length,\n      searchTime: 0,\n    });\n  }, [searchState, contacts]);\n\n  // Handle sorting\n  const handleSort = useCallback(\n    (field: string, order: 'asc' | 'desc') => {\n      searchState.setSorting(field, order);\n      handleSearch(searchState.query);\n    },\n    [searchState, handleSearch]\n  );\n\n  // Handle pagination\n  const handlePageChange = useCallback(\n    (page: number, pageSize: number) => {\n      searchState.setPage(page);\n      searchState.setPageSize(pageSize);\n      handleSearch(searchState.query);\n    },\n    [searchState, handleSearch]\n  );\n\n  // Get contact suggestions for search\n  const getContactSuggestions = useCallback((): string[] => {\n    if (!searchService) return [];\n    return searchService.getSuggestions(searchState.query, 10);\n  }, [searchService, searchState.query]);\n\n  // Table columns\n  const columns = useMemo(\n    () => [\n      {\n        title: 'Name',\n        dataIndex: 'fullName',\n        key: 'fullName',\n        sorter: true,\n        render: (text: string, record: Contact) => (\n          <div>\n            <Text strong>{text}</Text>\n            {record.email && (\n              <div>\n                <Text type=\"secondary\" style={{ fontSize: '12px' }}>\n                  {record.email}\n                </Text>\n              </div>\n            )}\n          </div>\n        ),\n      },\n      {\n        title: 'Contact Info',\n        key: 'contact',\n        render: (_: unknown, record: Contact) => (\n          <Space direction=\"vertical\" size=\"small\">\n            {record.phone && <Text>{record.phone}</Text>}\n            {record.mobile && record.mobile !== record.phone && (\n              <Text type=\"secondary\">Mobile: {record.mobile}</Text>\n            )}\n          </Space>\n        ),\n      },\n      {\n        title: 'Address',\n        dataIndex: 'address',\n        key: 'address',\n        render: (address: Contact['address']) => {\n          if (!address) return <Text type=\"secondary\">No address</Text>;\n\n          const parts = [];\n          if (address.street1) parts.push(address.street1);\n          if (address.city) parts.push(address.city);\n          if (address.state) parts.push(address.state);\n          if (address.zipCode) parts.push(address.zipCode);\n\n          return <Text>{parts.length > 0 ? parts.join(', ') : 'Incomplete address'}</Text>;\n        },\n      },\n      {\n        title: 'Status',\n        key: 'status',\n        render: (_: unknown, record: Contact) => (\n          <Space>\n            <Tag color={record.isActive ? 'green' : 'red'}>\n              {record.isActive ? 'Active' : 'Inactive'}\n            </Tag>\n            {record.gender && <Tag color=\"blue\">{record.gender}</Tag>}\n          </Space>\n        ),\n      },\n      {\n        title: 'Actions',\n        key: 'actions',\n        render: (_: unknown, record: Contact) => (\n          <Space size=\"small\">\n            <Tooltip title=\"View Details\">\n              <Button type=\"text\" icon={<EyeOutlined />} size=\"small\" />\n            </Tooltip>\n            <Tooltip title=\"Edit Contact\">\n              <Button type=\"text\" icon={<EditOutlined />} size=\"small\" />\n            </Tooltip>\n            <Tooltip title=\"Delete Contact\">\n              <Button type=\"text\" danger icon={<DeleteOutlined />} size=\"small\" />\n            </Tooltip>\n          </Space>\n        ),\n      },\n    ],\n    []\n  );\n\n  // Performance metrics\n  const performanceMetrics = performance.getMetrics();\n\n  if (error) {\n    return (\n      <Card>\n        <Alert\n          message=\"Error Loading Contacts\"\n          description={error}\n          type=\"error\"\n          showIcon\n          action={\n            <Button size=\"small\" onClick={loadContacts}>\n              Retry\n            </Button>\n          }\n        />\n      </Card>\n    );\n  }\n\n  return (\n    <div style={{ padding: '24px' }}>\n      {/* Header */}\n      <div style={{ marginBottom: '24px' }}>\n        <Row justify=\"space-between\" align=\"middle\">\n          <Col>\n            <Title level={2} style={{ margin: 0 }}>\n              Address Book\n            </Title>\n            <Text type=\"secondary\">Manage your contacts with advanced search and filtering</Text>\n          </Col>\n          <Col>\n            <Space>\n              <Button\n                type=\"primary\"\n                icon={<PlusOutlined />}\n                onClick={() => {\n                  /* Handle new contact */\n                }}\n              >\n                Add Contact\n              </Button>\n              <Button icon={<ReloadOutlined />} onClick={loadContacts} loading={loading}>\n                Refresh\n              </Button>\n            </Space>\n          </Col>\n        </Row>\n      </div>\n\n      {/* Search and Filter Section */}\n      <Card\n        title={\n          <Space>\n            <SearchOutlined />\n            <Text>Search & Filter</Text>\n            <Badge count={searchState.filters.length} />\n          </Space>\n        }\n        size=\"small\"\n        style={{ marginBottom: '16px' }}\n        extra={\n          <Space>\n            <Button\n              type={showAdvancedFilters ? 'primary' : 'default'}\n              icon={<FilterOutlined />}\n              onClick={() => {\n                setShowAdvancedFilters(!showAdvancedFilters);\n              }}\n            >\n              {showAdvancedFilters ? 'Hide Filters' : 'Show Filters'}\n            </Button>\n            <Button\n              icon={<SettingOutlined />}\n              onClick={() => {\n                /* Handle settings */\n              }}\n            >\n              Settings\n            </Button>\n          </Space>\n        }\n      >\n        <Space direction=\"vertical\" style={{ width: '100%' }}>\n          {/* Smart Search Input */}\n          <SmartSearchInput\n            placeholder=\"Search contacts by name, email, phone, or company...\"\n            value={searchState.query}\n            onChange={searchState.setQuery}\n            onSearch={handleSearch}\n            onClear={handleClearFilters}\n            loading={loading}\n            suggestions={getContactSuggestions()}\n            style={{ maxWidth: '600px' }}\n          />\n\n          {/* Advanced Filters */}\n          {showAdvancedFilters && (\n            <AdvancedFilter\n              fields={CONTACT_SEARCH_FIELDS}\n              filters={searchState.filters}\n              onFiltersChange={handleFiltersChange}\n              onApply={handleApplyFilters}\n              onClear={handleClearFilters}\n              loading={loading}\n            />\n          )}\n        </Space>\n      </Card>\n\n      {/* Search Statistics */}\n      <Row gutter={16} style={{ marginBottom: '16px' }}>\n        <Col span={6}>\n          <Card size=\"small\">\n            <Statistic\n              title=\"Total Contacts\"\n              value={searchStats.total}\n              prefix={<SearchOutlined />}\n            />\n          </Card>\n        </Col>\n        <Col span={6}>\n          <Card size=\"small\">\n            <Statistic\n              title=\"Filtered Results\"\n              value={searchStats.filtered}\n              prefix={<FilterOutlined />}\n            />\n          </Card>\n        </Col>\n        <Col span={6}>\n          <Card size=\"small\">\n            <Statistic\n              title=\"Search Time\"\n              value={searchStats.searchTime}\n              suffix=\"ms\"\n              precision={2}\n            />\n          </Card>\n        </Col>\n        <Col span={6}>\n          <Card size=\"small\">\n            <Statistic\n              title=\"Performance Score\"\n              value={performanceMetrics.performanceScore}\n              suffix=\"%\"\n              precision={1}\n            />\n          </Card>\n        </Col>\n      </Row>\n\n      {/* Results Section */}\n      <Card\n        title={\n          <Space>\n            <Text>Contacts</Text>\n            <Badge count={searchResults.length} />\n            {searchState.filters.length > 0 && (\n              <Tag color=\"blue\">\n                {searchState.filters.length} filter{searchState.filters.length !== 1 ? 's' : ''}{' '}\n                applied\n              </Tag>\n            )}\n          </Space>\n        }\n        extra={\n          <Space>\n            <Select value={viewMode} onChange={setViewMode} style={{ width: 120 }}>\n              <Option value=\"table\">Table</Option>\n              <Option value=\"cards\">Cards</Option>\n            </Select>\n            <Button\n              icon={<DownloadOutlined />}\n              onClick={() => {\n                /* Handle export */\n              }}\n            >\n              Export\n            </Button>\n          </Space>\n        }\n      >\n        {loading ? (\n          <div style={{ textAlign: 'center', padding: '48px' }}>\n            <Spin size=\"large\" />\n            <div style={{ marginTop: '16px' }}>\n              <Text type=\"secondary\">Searching contacts...</Text>\n            </div>\n          </div>\n        ) : searchResults.length === 0 ? (\n          <Empty\n            image={Empty.PRESENTED_IMAGE_SIMPLE}\n            description={\n              <div>\n                <Title level={4}>\n                  {contacts.length === 0 ? 'No contacts found' : 'No matching contacts'}\n                </Title>\n                <Text type=\"secondary\">\n                  {contacts.length === 0\n                    ? 'Get started by adding your first contact.'\n                    : 'Try adjusting your search criteria or filters.'}\n                </Text>\n                <div style={{ marginTop: '16px' }}>\n                  <Button type=\"primary\" icon={<PlusOutlined />}>\n                    Add Contact\n                  </Button>\n                </div>\n              </div>\n            }\n          />\n        ) : (\n          <Table\n            columns={columns}\n            dataSource={searchResults}\n            rowKey=\"id\"\n            pagination={{\n              current: searchState.page,\n              pageSize: searchState.pageSize,\n              total: searchStats.total,\n              showSizeChanger: true,\n              showQuickJumper: true,\n              showTotal: (total, range) => `${range[0]}-${range[1]} of ${total} contacts`,\n              onChange: handlePageChange,\n            }}\n            onChange={(pagination, filters, sorter) => {\n              const sorterResult = Array.isArray(sorter) ? sorter[0] : sorter;\n              if (sorterResult?.field && sorterResult?.order) {\n                const order = sorterResult.order === 'ascend' ? 'asc' : 'desc';\n\n                // Type guard to safely handle different field types\n                let fieldKey: string;\n                if (typeof sorterResult.field === 'string') {\n                  fieldKey = sorterResult.field;\n                } else if (Array.isArray(sorterResult.field)) {\n                  // Convert array to dot-delimited string\n                  fieldKey = sorterResult.field.join('.');\n                } else if (typeof sorterResult.field === 'function') {\n                  // For function accessors, derive a stable identifier\n                  // This is a fallback - in practice, function accessors should be avoided\n                  fieldKey = 'custom_accessor';\n                } else {\n                  // Skip sorting for unknown field types\n                  return;\n                }\n\n                handleSort(fieldKey, order);\n              }\n            }}\n            rowSelection={{\n              selectedRowKeys: selectedContacts,\n              onChange: setSelectedContacts,\n            }}\n            scroll={{ x: 800 }}\n          />\n        )}\n      </Card>\n\n      {/* Performance Monitoring (Development) */}\n      {process.env.NODE_ENV === 'development' && (\n        <Card title=\"Performance Metrics\" size=\"small\" style={{ marginTop: '16px' }}>\n          <Row gutter={16}>\n            <Col span={8}>\n              <Text>Average Search Time: {performanceMetrics.averageSearchTime.toFixed(2)}ms</Text>\n            </Col>\n            <Col span={8}>\n              <Text>Total Searches: {performanceMetrics.totalSearches}</Text>\n            </Col>\n            <Col span={8}>\n              <Text>Slow Searches: {performanceMetrics.slowSearches}</Text>\n            </Col>\n          </Row>\n          <Progress\n            percent={performanceMetrics.performanceScore}\n            status={performanceMetrics.performanceScore > 80 ? 'success' : 'normal'}\n            style={{ marginTop: '8px' }}\n          />\n        </Card>\n      )}\n    </div>\n  );\n};\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/pages/EnhancedTenantsPage.tsx",
        "messages": [
            {
                "ruleId": "@typescript-eslint/require-await",
                "severity": 1,
                "message": "Async method 'searchFunction' has no 'await' expression.",
                "line": 62,
                "column": 5,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingAwait",
                "endLine": 62,
                "endColumn": 27,
                "suggestions": [
                    {
                        "messageId": "removeAsync",
                        "fix": {
                            "range": [
                                2203,
                                2209
                            ],
                            "text": ""
                        },
                        "desc": "Remove 'async'."
                    }
                ]
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 1,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "/**\n * Enhanced Tenants Page with Advanced Search UX\n * Implements Ant Design Data List specifications for optimal search experience\n */\n\nimport React, { useState, useCallback, useEffect } from 'react';\nimport { Card, Button, Space, Typography, Alert, Row, Col, Progress, Form } from 'antd';\nimport { PlusOutlined, ReloadOutlined } from '@ant-design/icons';\nimport { App } from 'antd';\n\nimport type { Tenant, UpdateTenantDTO, CreateTenantDTO } from '@/types/tenant';\nimport type { TenantSettings } from '@/types/auth';\nimport type { TenantId } from '@/types/ids';\nimport { isApiSuccess } from '@/types/api';\nimport { tenantService } from '@/services/api';\nimport { type TenantSearchService, SearchServiceFactory } from '@/services/SearchService';\nimport { TenantSettingsModal } from '@/components/TenantSettingsModal';\nimport { TenantSearchCard } from '@/components/TenantSearchCard';\nimport { TenantStatistics } from '@/components/TenantStatistics';\nimport { TenantTable } from '@/components/TenantTable';\nimport { TenantFormModal } from '@/components/TenantFormModal';\nimport {\n  useSearchState,\n  useDebouncedSearch,\n  useSearchPerformance,\n} from '@/hooks/useEnhancedSearch';\nimport type { SearchFilter, SearchQuery } from '@/components/SearchComponents';\n\nconst { Title, Text } = Typography;\n\n/**\n * Enhanced Tenants Page Component\n */\nexport const EnhancedTenantsPage: React.FC = () => {\n  const { message } = App.useApp();\n\n  // Core state\n  const [tenants, setTenants] = useState<Tenant[]>([]);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const [operationError, setOperationError] = useState<string | null>(null);\n\n  // Search state management\n  const searchState = useSearchState<Tenant>({\n    pageSize: 12,\n    debounceMs: 300,\n    cacheResults: true,\n  });\n\n  // Search service\n  const [searchService, setSearchService] = useState<TenantSearchService | null>(null);\n\n  // Performance monitoring\n  const performance = useSearchPerformance({\n    enableMetrics: true,\n    logPerformance: true,\n    performanceThreshold: 100,\n  });\n\n  // Debounced search\n  const debouncedSearch = useDebouncedSearch<Tenant>({\n    searchFunction: async (query: SearchQuery, _signal?: AbortSignal) => {\n      if (!searchService) {\n        throw new Error('Search service not initialized');\n      }\n\n      performance.startTimer();\n      const result = searchService.searchTenants(query);\n      performance.endTimer();\n\n      if (result.isErr()) {\n        const error = result.error;\n        const message =\n          'message' in error ? error.message : 'reason' in error ? error.reason : 'Search failed';\n        throw new Error(message);\n      }\n\n      return result.value;\n    },\n    debounceMs: 300,\n    cacheResults: true,\n    maxCacheSize: 50,\n    onSearchStart: () => {\n      setLoading(true);\n    },\n    onSearchComplete: _result => {\n      setLoading(false);\n      setError(null);\n    },\n    onSearchError: error => {\n      setLoading(false);\n      setError(error.message);\n    },\n  });\n\n  // Search results state\n  const [searchResults, setSearchResults] = useState<Tenant[]>([]);\n  const [searchStats, setSearchStats] = useState({\n    total: 0,\n    filtered: 0,\n    searchTime: 0,\n  });\n\n  // UI state\n  const [showAdvancedFilters, setShowAdvancedFilters] = useState(false);\n  const [selectedTenants, setSelectedTenants] = useState<Tenant['id'][]>([]);\n  const [isFormOpen, setIsFormOpen] = useState(false);\n  const [editingTenant, setEditingTenant] = useState<Tenant | null>(null);\n  const [form] = Form.useForm();\n\n  // Settings modal state\n  const [isSettingsModalOpen, setIsSettingsModalOpen] = useState(false);\n  const [currentTenantSettings, setCurrentTenantSettings] = useState<TenantSettings | undefined>(\n    undefined\n  );\n\n  // Initialize search service when tenants change\n  useEffect(() => {\n    if (tenants.length > 0) {\n      const service = SearchServiceFactory.createTenantService(tenants);\n      // Use setTimeout to avoid setState in effect\n      setTimeout(() => {\n        setSearchService(service);\n      }, 0);\n    }\n  }, [tenants]);\n\n  // Load tenants from API\n  const loadTenants = useCallback(async () => {\n    setLoading(true);\n    setError(null);\n\n    const result = await tenantService.getAllWithPagination({\n      offset: 0,\n      limit: 100, // Load more for better search experience\n    });\n\n    if (result.isErr()) {\n      const errorMessage = result.error.message;\n      setError(errorMessage);\n      message.error(errorMessage);\n      setLoading(false);\n      return;\n    }\n\n    const apiResponse = result.value;\n\n    if (!isApiSuccess(apiResponse)) {\n      const errorMessage = apiResponse.error.message;\n      setError(errorMessage);\n      message.error(errorMessage);\n      setLoading(false);\n      return;\n    }\n\n    const data = apiResponse.data;\n    setTenants(data.data);\n    setSearchResults(data.data);\n    setSearchStats({\n      total: data.data.length,\n      filtered: data.data.length,\n      searchTime: 0,\n    });\n    setLoading(false);\n  }, [message]);\n\n  // Load tenants on mount\n  useEffect(() => {\n    const loadTenantsAsync = async (): Promise<void> => {\n      await loadTenants();\n    };\n    void loadTenantsAsync();\n  }, [loadTenants]);\n\n  // Handle search\n  const handleSearch = useCallback(\n    async (query: string) => {\n      if (!searchService) return;\n\n      try {\n        const searchQuery: SearchQuery = {\n          queryId: `search-${Date.now().toString()}`,\n          filters: searchState.filters,\n          sortBy: searchState.sortBy,\n          sortOrder: searchState.sortOrder,\n          page: searchState.page,\n          pageSize: searchState.pageSize,\n        };\n\n        // Add text search filter if query provided\n        if (query.trim()) {\n          const textFilter: SearchFilter = {\n            id: `text-search-${Date.now().toString()}`,\n            field: 'name',\n            operator: 'contains',\n            value: query,\n          };\n          searchQuery.filters = [...searchQuery.filters, textFilter];\n        }\n\n        const result = await debouncedSearch.search(searchQuery);\n        setSearchResults(result.data);\n        setSearchStats({\n          total: result.total,\n          filtered: result.data.length,\n          searchTime: performance.getMetrics().averageSearchTime,\n        });\n      } catch (error) {\n        if (process.env.NODE_ENV === 'development') {\n          console.error('Search failed:', error);\n        }\n        message.error('Search failed. Please try again.');\n      }\n    },\n    [searchService, searchState, debouncedSearch, performance, message]\n  );\n\n  // Handle filter changes\n  const handleFiltersChange = useCallback(\n    (filters: SearchFilter[]) => {\n      searchState.setFilters(filters);\n    },\n    [searchState]\n  );\n\n  // Handle filter apply\n  const handleApplyFilters = useCallback(async () => {\n    await handleSearch(searchState.query);\n  }, [handleSearch, searchState.query]);\n\n  // Handle filter clear\n  const handleClearFilters = useCallback(() => {\n    searchState.clearFilters();\n    searchState.setQuery('');\n    setSearchResults(tenants);\n    setSearchStats({\n      total: tenants.length,\n      filtered: tenants.length,\n      searchTime: 0,\n    });\n  }, [searchState, tenants]);\n\n  // Handle sorting\n  const handleSort = useCallback(\n    (field: string, order: 'asc' | 'desc') => {\n      searchState.setSorting(field, order);\n      void handleSearch(searchState.query);\n    },\n    [searchState, handleSearch]\n  );\n\n  // Handle pagination\n  const handlePageChange = useCallback(\n    (page: number, pageSize: number) => {\n      searchState.setPage(page);\n      searchState.setPageSize(pageSize);\n      void handleSearch(searchState.query);\n    },\n    [searchState, handleSearch]\n  );\n\n  // Get tenant suggestions for search\n  const getTenantSuggestions = useCallback((): string[] => {\n    if (!searchService) return [];\n    return searchService.getSuggestions(searchState.query, 10);\n  }, [searchService, searchState.query]);\n\n  // Handle new tenant\n  const handleNewTenant = useCallback(() => {\n    setEditingTenant(null);\n    form.resetFields();\n    setIsFormOpen(true);\n  }, [form]);\n\n  // Handle edit tenant\n  const handleEditTenant = useCallback(\n    (tenant: Tenant) => {\n      setEditingTenant(tenant);\n      form.setFieldsValue({\n        name: tenant.name,\n        db_url: tenant.db_url,\n      });\n      setIsFormOpen(true);\n    },\n    [form]\n  );\n\n  // Handle delete tenant\n  const handleDeleteTenant = useCallback(\n    async (tenantId: Tenant['id']) => {\n      try {\n        setOperationError(null);\n        const result = await tenantService.delete(tenantId);\n\n        if (result.isErr()) {\n          const errorMessage = result.error.message;\n          setOperationError(errorMessage);\n          message.error(errorMessage);\n          return;\n        }\n\n        const apiResponse = result.value;\n        if (!isApiSuccess(apiResponse)) {\n          const errorMessage = apiResponse.error.message;\n          setOperationError(errorMessage);\n          message.error(errorMessage);\n          return;\n        }\n\n        message.success('Tenant deleted successfully');\n        await loadTenants();\n      } catch (_error) {\n        const errorMessage = 'Failed to delete tenant';\n        setOperationError(errorMessage);\n        message.error(errorMessage);\n      }\n    },\n    [message, loadTenants]\n  );\n\n  // Handle form submission\n  const handleFormSubmit = useCallback(\n    async (values: Record<string, unknown>) => {\n      try {\n        setOperationError(null);\n        if (editingTenant) {\n          // Update existing tenant\n          const result = await tenantService.update(editingTenant.id, values as UpdateTenantDTO);\n\n          if (result.isErr()) {\n            const errorMessage = result.error.message;\n            setOperationError(errorMessage);\n            message.error(errorMessage);\n            return;\n          }\n\n          const apiResponse = result.value;\n          if (!isApiSuccess(apiResponse)) {\n            const errorMessage = apiResponse.error.message;\n            setOperationError(errorMessage);\n            message.error(errorMessage);\n            return;\n          }\n\n          message.success('Tenant updated successfully');\n        } else {\n          // Create new tenant\n          const result = await tenantService.create(values as unknown as CreateTenantDTO);\n\n          if (result.isErr()) {\n            const errorMessage = result.error.message;\n            setOperationError(errorMessage);\n            message.error(errorMessage);\n            return;\n          }\n\n          const apiResponse = result.value;\n          if (!isApiSuccess(apiResponse)) {\n            const errorMessage = apiResponse.error.message;\n            setOperationError(errorMessage);\n            message.error(errorMessage);\n            return;\n          }\n\n          message.success('Tenant created successfully');\n        }\n\n        setIsFormOpen(false);\n        await loadTenants();\n      } catch (_error) {\n        const errorMessage = 'Failed to save tenant';\n        setOperationError(errorMessage);\n        message.error(errorMessage);\n      }\n    },\n    [editingTenant, message, loadTenants]\n  );\n\n  // Settings handlers\n  const handleSaveSettings = useCallback(\n    (_settings: TenantSettings) => {\n      try {\n        setOperationError(null);\n        // In a real implementation, you would save these settings to the backend\n        // For now, we'll just show a success message\n        message.success('Settings saved successfully');\n        setIsSettingsModalOpen(false);\n        setCurrentTenantSettings(undefined);\n      } catch (_error) {\n        const errorMessage = 'Failed to save settings';\n        setOperationError(errorMessage);\n        message.error(errorMessage);\n      }\n    },\n    [message]\n  );\n\n  const handleCloseSettings = useCallback(() => {\n    setIsSettingsModalOpen(false);\n    setCurrentTenantSettings(undefined);\n  }, []);\n\n  // Performance metrics\n  const performanceMetrics = performance.getMetrics();\n\n  if (error != null && error !== '') {\n    return (\n      <Card>\n        <Alert\n          message=\"Error Loading Tenants\"\n          description={error}\n          type=\"error\"\n          showIcon\n          action={\n            <Button size=\"small\" onClick={loadTenants}>\n              Retry\n            </Button>\n          }\n        />\n      </Card>\n    );\n  }\n\n  return (\n    <div style={{ padding: '24px' }}>\n      {/* Header */}\n      <div style={{ marginBottom: '24px' }}>\n        <Row justify=\"space-between\" align=\"middle\">\n          <Col>\n            <Title level={2} style={{ margin: 0 }}>\n              Tenants\n            </Title>\n            <Text type=\"secondary\">Manage tenant configurations and database connections</Text>\n          </Col>\n          <Col>\n            <Space>\n              <Button type=\"primary\" icon={<PlusOutlined />} onClick={handleNewTenant}>\n                Add Tenant\n              </Button>\n              <Button icon={<ReloadOutlined />} onClick={loadTenants} loading={loading}>\n                Refresh\n              </Button>\n            </Space>\n          </Col>\n        </Row>\n      </div>\n\n      {/* Operation Error Alert */}\n      {operationError != null && operationError !== '' && (\n        <Alert\n          message=\"Operation Error\"\n          description={operationError}\n          type=\"error\"\n          showIcon\n          closable\n          onClose={() => {\n            setOperationError(null);\n          }}\n          style={{ marginBottom: '16px' }}\n        />\n      )}\n\n      {/* Search and Filter Section */}\n      <TenantSearchCard\n        searchState={searchState}\n        showAdvancedFilters={showAdvancedFilters}\n        loading={loading}\n        onSearch={handleSearch}\n        onClearFilters={handleClearFilters}\n        onFiltersChange={handleFiltersChange}\n        onApplyFilters={handleApplyFilters}\n        onToggleAdvancedFilters={() => {\n          setShowAdvancedFilters(!showAdvancedFilters);\n        }}\n        onGetTenantSuggestions={getTenantSuggestions}\n      />\n\n      {/* Search Statistics */}\n      <TenantStatistics searchStats={searchStats} performanceMetrics={performanceMetrics} />\n\n      {/* Results Section */}\n      <TenantTable\n        searchResults={searchResults}\n        searchState={searchState}\n        searchStats={searchStats}\n        selectedTenants={selectedTenants}\n        loading={loading}\n        onEditTenant={handleEditTenant}\n        onDeleteTenant={(tenantId: string) => handleDeleteTenant(tenantId as TenantId)}\n        onPageChange={handlePageChange}\n        onSort={handleSort}\n        onSelectionChange={(keys: React.Key[]) => {\n          setSelectedTenants(keys.map(key => key as TenantId));\n        }}\n        onRefresh={loadTenants}\n        onNewTenant={handleNewTenant}\n      />\n\n      {/* Tenant Form Modal */}\n      <TenantFormModal\n        isOpen={isFormOpen}\n        editingTenant={editingTenant}\n        form={form}\n        onSubmit={handleFormSubmit}\n        onCancel={() => {\n          setIsFormOpen(false);\n        }}\n      />\n\n      {/* Performance Monitoring (Development) */}\n      {process.env.NODE_ENV === 'development' && (\n        <Card title=\"Performance Metrics\" size=\"small\" style={{ marginTop: '16px' }}>\n          <Row gutter={16}>\n            <Col span={8}>\n              <Text>Average Search Time: {performanceMetrics.averageSearchTime.toFixed(2)}ms</Text>\n            </Col>\n            <Col span={8}>\n              <Text>Total Searches: {performanceMetrics.totalSearches}</Text>\n            </Col>\n            <Col span={8}>\n              <Text>Slow Searches: {performanceMetrics.slowSearches}</Text>\n            </Col>\n          </Row>\n          <Progress\n            percent={performanceMetrics.performanceScore}\n            status={performanceMetrics.performanceScore > 80 ? 'success' : 'normal'}\n            style={{ marginTop: '8px' }}\n          />\n        </Card>\n      )}\n\n      {/* Tenant Settings Modal */}\n      <TenantSettingsModal\n        isOpen={isSettingsModalOpen}\n        onClose={handleCloseSettings}\n        onSave={handleSaveSettings}\n        currentSettings={currentTenantSettings}\n        loading={loading}\n      />\n    </div>\n  );\n};\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/pages/HomePage.tsx",
        "messages": [
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 40,
                "column": 31,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingReturnType",
                "endLine": 40,
                "endColumn": 33
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 44,
                "column": 27,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingReturnType",
                "endLine": 44,
                "endColumn": 29
            },
            {
                "ruleId": "@typescript-eslint/restrict-template-expressions",
                "severity": 1,
                "message": "Invalid type \"number\" of template literal expression.",
                "line": 135,
                "column": 53,
                "nodeType": "MemberExpression",
                "messageId": "invalidType",
                "endLine": 135,
                "endColumn": 63
            },
            {
                "ruleId": "@typescript-eslint/restrict-template-expressions",
                "severity": 1,
                "message": "Invalid type \"number\" of template literal expression.",
                "line": 154,
                "column": 72,
                "nodeType": "MemberExpression",
                "messageId": "invalidType",
                "endLine": 154,
                "endColumn": 82
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 4,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "import React from 'react';\nimport { Navigate, useNavigate } from 'react-router-dom';\nimport { useAuth } from '@/contexts/AuthContext';\nimport { Layout, Typography } from 'antd';\nimport { Button, Space, Divider } from 'antd';\nimport { Row, Col, Card } from 'antd';\nimport {\n  SecurityScanOutlined,\n  HomeOutlined,\n  ThunderboltOutlined,\n  HeartOutlined,\n} from '@ant-design/icons';\n\nconst styles = {\n  header: {\n    background: '#fafaf9',\n    borderBottom: '1px solid #d9d9d9',\n  },\n  headerContent: {\n    display: 'flex',\n    justifyContent: 'center',\n    alignItems: 'center',\n    height: '100%',\n  },\n  title: {\n    margin: 0,\n    color: '#1f6b3e',\n  },\n};\n\nexport const HomePage: React.FC = () => {\n  const { isAuthenticated } = useAuth();\n  const navigate = useNavigate();\n\n  // If authenticated, redirect to dashboard\n  if (isAuthenticated) {\n    return <Navigate to=\"/dashboard\" replace />;\n  }\n\n  const handleGetStarted = () => {\n    navigate('/register');\n  };\n\n  const handleSignIn = () => {\n    navigate('/login');\n  };\n\n  const features = [\n    {\n      id: 1,\n      icon: <SecurityScanOutlined style={{ fontSize: 32 }} />,\n      title: 'Secure Authentication',\n      description:\n        'JWT-based login system with comprehensive security measures and multi-tenant support.',\n    },\n    {\n      id: 2,\n      icon: <HomeOutlined style={{ fontSize: 32 }} />,\n      title: 'Multi-Tenant Architecture',\n      description:\n        'Complete tenant isolation ensuring data security and privacy across different organizations.',\n    },\n    {\n      id: 3,\n      icon: <ThunderboltOutlined style={{ fontSize: 32 }} />,\n      title: 'High Performance',\n      description:\n        'Built with Bun runtime for exceptional speed and TypeScript for reliable development.',\n    },\n  ];\n\n  return (\n    <Layout style={{ minHeight: '100vh' }}>\n      <Layout.Header style={styles.header}>\n        <div style={styles.headerContent}>\n          <Typography.Title level={4} style={styles.title}>\n            <HeartOutlined style={{ marginRight: 8 }} />\n            Natural Pharmacy System\n          </Typography.Title>\n        </div>\n      </Layout.Header>\n\n      <Layout.Content style={{ background: '#f7f4f0' }}>\n        {/* Hero Section */}\n        <div\n          style={{ padding: '64px 24px', textAlign: 'center', maxWidth: 1000, margin: '0 auto' }}\n        >\n          <Typography.Title level={1}>Welcome to the Natural Pharmacy System</Typography.Title>\n          <Typography.Paragraph style={{ fontSize: 18, marginBottom: 32 }}>\n            A modern, secure multi-tenant platform for managing pharmaceutical data with JWT\n            authentication and comprehensive tenant isolation.\n          </Typography.Paragraph>\n\n          <Space size=\"large\">\n            <Button\n              type=\"primary\"\n              size=\"large\"\n              onClick={handleGetStarted}\n              onKeyDown={e => {\n                if (e.key === 'Enter' || e.key === ' ') {\n                  e.preventDefault();\n                  handleGetStarted();\n                }\n              }}\n              aria-label=\"Get Started - Navigate to registration page\"\n            >\n              Get Started\n            </Button>\n            <Button\n              size=\"large\"\n              onClick={handleSignIn}\n              onKeyDown={e => {\n                if (e.key === 'Enter' || e.key === ' ') {\n                  e.preventDefault();\n                  handleSignIn();\n                }\n              }}\n              aria-label=\"Sign In - Navigate to login page\"\n            >\n              Sign In\n            </Button>\n          </Space>\n        </div>\n\n        <Divider />\n\n        {/* Features Section */}\n        <div style={{ background: '#fff', padding: '64px 24px' }}>\n          <Row gutter={[24, 24]}>\n            {features.map(feature => (\n              <Col xs={24} md={8} key={feature.id}>\n                <Card\n                  style={{ textAlign: 'center', height: '100%' }}\n                  hoverable\n                  aria-labelledby={`feature-title-${feature.id}`}\n                  cover={\n                    <div\n                      style={{\n                        padding: '24px 0',\n                        background: '#dcf2e6',\n                        display: 'flex',\n                        justifyContent: 'center',\n                        alignItems: 'center',\n                        margin: '0 0 24px 0',\n                      }}\n                      aria-label={`${feature.title} icon`}\n                    >\n                      {feature.icon}\n                    </div>\n                  }\n                >\n                  <Card.Meta\n                    title={\n                      <Typography.Title level={4} id={`feature-title-${feature.id}`}>\n                        {feature.title}\n                      </Typography.Title>\n                    }\n                    description={<Typography.Paragraph>{feature.description}</Typography.Paragraph>}\n                  />\n                </Card>\n              </Col>\n            ))}\n          </Row>\n        </div>\n      </Layout.Content>\n\n      <Layout.Footer style={{ textAlign: 'center', background: '#1c1917', color: '#fff' }}>\n         2025 Natural Pharmacy System. Built with React, TypeScript, and Bun runtime.\n      </Layout.Footer>\n    </Layout>\n  );\n};\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/pages/LoginPage.fp.tsx",
        "messages": [
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 180,
                "column": 16,
                "nodeType": "ChainExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 180,
                "endColumn": 45,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                4914,
                                4943
                            ],
                            "text": "((locationState?.from?.pathname) != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                4914,
                                4943
                            ],
                            "text": "((locationState?.from?.pathname) ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                4914,
                                4943
                            ],
                            "text": "(Boolean((locationState?.from?.pathname)))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 180,
                "column": 46,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 180,
                "endColumn": 48,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                4944,
                                4946
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-base-to-string",
                "severity": 1,
                "message": "'error.message || error' may use Object's default stringification format ('[object Object]') when stringified.",
                "line": 217,
                "column": 46,
                "nodeType": "LogicalExpression",
                "messageId": "baseToString",
                "endLine": 217,
                "endColumn": 68
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 247,
                "column": 52,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingReturnType",
                "endLine": 247,
                "endColumn": 54
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected object value in conditional. The condition is always true.",
                "line": 277,
                "column": 17,
                "nodeType": "Identifier",
                "messageId": "conditionErrorObject",
                "endLine": 277,
                "endColumn": 32
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, value is always truthy.",
                "line": 277,
                "column": 17,
                "nodeType": "Identifier",
                "messageId": "alwaysTruthy",
                "endLine": 277,
                "endColumn": 32
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 299,
                "column": 31,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingReturnType",
                "endLine": 299,
                "endColumn": 33
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 329,
                "column": 68,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingReturnType",
                "endLine": 329,
                "endColumn": 70
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 330,
                "column": 9,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 330,
                "endColumn": 31,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                9500,
                                9522
                            ],
                            "text": "fieldErrors[fieldName] != null"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                9500,
                                9522
                            ],
                            "text": "fieldErrors[fieldName] ?? \"\""
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                9500,
                                9522
                            ],
                            "text": "Boolean(fieldErrors[fieldName])"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 9,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "/**\n * Login Page - Functional Programming Implementation\n *\n * Implements railway-oriented programming with Result types for:\n * - Form validation pipeline\n * - Error handling with pattern matching\n * - Type-safe state management\n *\n * @module LoginPage\n */\n\nimport React, { useState } from 'react';\nimport { useNavigate, useLocation, Navigate } from 'react-router-dom';\nimport { useAuth } from '@/hooks/useAuth';\nimport type { LoginCredentials } from '@/types/auth';\nimport type { AuthFlowError } from '@/types/errors';\nimport { Card, Form, Input, Button, Checkbox, Typography, Alert, Flex } from 'antd';\nimport { type Result, ok, err } from 'neverthrow';\nimport { match } from 'ts-pattern';\nimport {\n  validateUsername,\n  validatePassword,\n  validateTenantId,\n  validateEmail,\n  formatCredentialValidationError,\n  type ValidatedUsername,\n  type ValidatedPassword,\n  type CredentialValidationError,\n  type ValidatedEmail,\n} from '@/utils/validation';\nimport type { TenantId } from '@/types/ids';\nimport {\n  createFormPipeline,\n  PipelineStates,\n  isPipelineLoading,\n  formatPipelineError,\n  type PipelineState,\n  type PipelineError,\n  type FormValidator,\n  type Transformer,\n  type Submitter,\n} from '@/utils/formPipeline';\n\n/**\n * Login form input types\n */\ninterface LoginFormData {\n  usernameOrEmail: string;\n  password: string;\n  tenantId: string;\n  rememberMe: boolean;\n}\n\n/**\n * Validated login credentials (branded types)\n */\ninterface ValidatedLoginData {\n  usernameOrEmail: ValidatedUsername | ValidatedEmail;\n  password: ValidatedPassword;\n  tenantId: TenantId;\n  rememberMe: boolean;\n}\n\n/**\n * Login DTO (matches API expectations)\n */\ninterface LoginDTO {\n  usernameOrEmail: string;\n  password: string;\n  tenantId: TenantId;\n  rememberMe: boolean;\n}\n\n/**\n * Login response type\n */\ninterface LoginResponse {\n  success: boolean;\n  message?: string;\n}\n\n/**\n * Form validation function\n * Validates all login form fields using Result types\n */\nconst validateLoginForm: FormValidator<\n  LoginFormData,\n  ValidatedLoginData,\n  CredentialValidationError\n> = (\n  formData: LoginFormData\n): Result<ValidatedLoginData, Record<string, CredentialValidationError>> => {\n  // Accept either email or username; try email first, then fall back to username validation\n  const usernameOrEmailResult = validateEmail(formData.usernameOrEmail).orElse(() =>\n    validateUsername(formData.usernameOrEmail)\n  );\n\n  const passwordResult = validatePassword(formData.password);\n  const tenantIdResult = validateTenantId(formData.tenantId);\n\n  // Collect all errors\n  const errors: Partial<Record<keyof LoginFormData, CredentialValidationError>> = {};\n\n  if (usernameOrEmailResult.isErr()) {\n    errors.usernameOrEmail = usernameOrEmailResult.error;\n  }\n  if (passwordResult.isErr()) {\n    errors.password = passwordResult.error;\n  }\n  if (tenantIdResult.isErr()) {\n    errors.tenantId = tenantIdResult.error;\n  }\n\n  // Return all errors if any exist\n  if (Object.keys(errors).length > 0) {\n    return err(errors as Record<string, CredentialValidationError>);\n  }\n\n  // All validations passed - use _unsafeUnwrap since we checked errors\n  return ok({\n    usernameOrEmail: usernameOrEmailResult._unsafeUnwrap(),\n    password: passwordResult._unsafeUnwrap(),\n    tenantId: tenantIdResult._unsafeUnwrap(),\n    rememberMe: formData.rememberMe,\n  });\n};\n\n/**\n * Transform validated data to API DTO\n */\nconst transformToLoginDTO: Transformer<ValidatedLoginData, LoginDTO, CredentialValidationError> = (\n  validated: ValidatedLoginData\n): Result<LoginDTO, PipelineError<CredentialValidationError>> => {\n  return ok({\n    usernameOrEmail: validated.usernameOrEmail,\n    password: validated.password,\n    tenantId: validated.tenantId,\n    rememberMe: validated.rememberMe,\n  });\n};\n\n/**\n * Type for location state\n */\ninterface LocationState {\n  from?: { pathname: string };\n}\n\nconst isLocationState = (state: unknown): state is LocationState => {\n  if (state === null || typeof state !== 'object') {\n    return false;\n  }\n\n  const candidate = state as { from?: unknown };\n  if (candidate.from === undefined || candidate.from === null) {\n    return true;\n  }\n\n  return typeof (candidate.from as { pathname?: unknown }).pathname === 'string';\n};\n\n/**\n * Login Page Component with FP Patterns\n */\nexport const LoginPageFP: React.FC = () => {\n  const { login, isAuthenticated, isLoading: authLoading } = useAuth();\n  const navigate = useNavigate();\n  const location = useLocation();\n  const locationState = isLocationState(location.state) ? location.state : null;\n  const [form] = Form.useForm<LoginFormData>();\n\n  // Pipeline state management using discriminated union\n  const [pipelineState, setPipelineState] = useState<\n    PipelineState<LoginResponse, CredentialValidationError>\n  >(PipelineStates.idle());\n\n  const [fieldErrors, setFieldErrors] = useState<Record<string, string>>({});\n\n  // Get the intended destination\n  const from = locationState?.from?.pathname || '/dashboard';\n\n  /**\n   * Submit function that wraps the login API call\n   */\n  const submitLogin: Submitter<LoginDTO, LoginResponse, CredentialValidationError> = async (\n    dto: LoginDTO\n  ): Promise<Result<LoginResponse, PipelineError<CredentialValidationError>>> => {\n    try {\n      const credentials: LoginCredentials = {\n        usernameOrEmail: dto.usernameOrEmail,\n        password: dto.password,\n        tenantId: dto.tenantId, // Already TenantId type, no conversion needed\n        rememberMe: dto.rememberMe,\n      };\n\n      // Await the login call and treat it as a Result\n      const loginResult: Result<void, AuthFlowError | CredentialValidationError> =\n        await login(credentials);\n\n      // Check if the result is Ok\n      if (loginResult.isOk()) {\n        return ok({\n          success: true,\n          message: 'Login successful',\n        });\n      }\n\n      // Map the error to a PipelineError (isErr() case)\n      const error = loginResult.error;\n      const statusCode =\n        'statusCode' in error && typeof error.statusCode === 'number'\n          ? error.statusCode\n          : undefined;\n\n      return err({\n        type: 'SUBMISSION_ERROR',\n        message: 'message' in error ? String(error.message || error) : 'Login failed',\n        statusCode,\n      });\n    } catch (error) {\n      // Keep try/catch only for unexpected exceptions\n      return err({\n        type: 'SUBMISSION_ERROR',\n        message: error instanceof Error ? error.message : 'Unexpected error occurred during login',\n      });\n    }\n  };\n\n  /**\n   * Create the complete form pipeline (without sanitization due to branded types)\n   */\n  const loginPipeline = createFormPipeline<\n    LoginFormData,\n    ValidatedLoginData,\n    LoginDTO,\n    LoginResponse,\n    CredentialValidationError\n  >({\n    validate: validateLoginForm,\n    transform: transformToLoginDTO,\n    submit: submitLogin,\n  });\n\n  /**\n   * Handle form submission with pipeline\n   */\n  const onSubmit = async (formData: LoginFormData) => {\n    // Reset errors\n    setFieldErrors({});\n    setPipelineState(PipelineStates.validating());\n\n    // Execute the complete pipeline\n    const result = await loginPipeline(formData);\n\n    // Pattern match on result - pipeline already returns Result, no need for try/catch\n    result.match(\n      // Success case\n      response => {\n        setPipelineState(PipelineStates.success(response));\n        navigate(from, { replace: true });\n      },\n      // Error case - use pattern matching for error handling\n      error => {\n        setPipelineState(PipelineStates.error(error));\n\n        // Extract field-level errors for display\n        if (error.type === 'VALIDATION_ERROR') {\n          const errors = error.errors;\n\n          if (typeof errors === 'object' && !('type' in errors)) {\n            // Multiple field errors\n            const formattedErrors: Record<string, string> = {};\n\n            for (const [field, validationError] of Object.entries(errors)) {\n              // Add runtime shape guard before casting\n              if (\n                validationError &&\n                typeof validationError === 'object' &&\n                'type' in validationError &&\n                typeof validationError.type === 'string'\n              ) {\n                formattedErrors[field] = formatCredentialValidationError(validationError);\n              } else {\n                // Fallback for unexpected shapes\n                formattedErrors[field] = 'Validation error occurred';\n              }\n            }\n\n            setFieldErrors(formattedErrors);\n          }\n        }\n      }\n    );\n  };\n\n  /**\n   * Render error message based on pipeline state\n   */\n  const renderErrorAlert = () => {\n    return match(pipelineState)\n      .with({ status: 'error' }, state => (\n        <Form.Item>\n          <Alert\n            message={formatPipelineError(state.error, formatCredentialValidationError)}\n            type=\"error\"\n            closable\n            onClose={() => {\n              setPipelineState(PipelineStates.idle());\n            }}\n            style={{\n              borderRadius: '8px',\n              border: '1px solid var(--danger-300)',\n              backgroundColor: 'var(--danger-50)',\n            }}\n          />\n        </Form.Item>\n      ))\n      .otherwise(() => null);\n  };\n\n  /**\n   * Get button loading state\n   */\n  const isFormLoading = authLoading || isPipelineLoading(pipelineState);\n\n  /**\n   * Get field-specific validation status\n   */\n  const getFieldValidationProps = (fieldName: keyof LoginFormData) => {\n    if (fieldErrors[fieldName]) {\n      return {\n        validateStatus: 'error' as const,\n        help: fieldErrors[fieldName],\n      };\n    }\n    return {};\n  };\n\n  // Redirect if already authenticated\n  if (isAuthenticated) {\n    return <Navigate to={from} replace />;\n  }\n\n  return (\n    <Flex\n      justify=\"center\"\n      align=\"center\"\n      style={{\n        minHeight: '100vh',\n        background:\n          'linear-gradient(135deg, var(--color-natural-light) 0%, var(--color-healing-light) 100%)',\n        padding: '20px',\n      }}\n    >\n      <Card\n        style={{\n          width: 420,\n          borderRadius: '16px',\n          border: '2px solid var(--primary-200)',\n          background:\n            'linear-gradient(145deg, rgba(255,255,255,0.95) 0%, rgba(247,242,240,0.9) 100%)',\n          boxShadow: '0 20px 40px rgba(38, 70, 83, 0.15), inset 0 1px 0 rgba(255, 255, 255, 0.8)',\n          backdropFilter: 'blur(10px)',\n        }}\n        title={\n          <Typography.Title\n            level={2}\n            style={{\n              color: 'var(--color-healing-dark)',\n              margin: 0,\n              textAlign: 'center',\n              fontSize: '2rem',\n              fontWeight: 700,\n            }}\n          >\n            Welcome Back\n          </Typography.Title>\n        }\n        styles={{\n          header: {\n            border: 'none',\n            padding: '40px 30px 20px',\n            textAlign: 'center',\n          },\n          body: {\n            padding: '30px',\n          },\n        }}\n      >\n        <Typography.Text\n          type=\"secondary\"\n          style={{\n            textAlign: 'center',\n            display: 'block',\n            fontSize: '16px',\n            marginBottom: '32px',\n            color: 'var(--primary-600)',\n          }}\n        >\n          Access your multi-tenant application\n        </Typography.Text>\n\n        <Form form={form} onFinish={onSubmit} size=\"large\" layout=\"vertical\">\n          <Form.Item\n            label={\n              <span style={{ color: 'var(--primary-700)', fontWeight: 600 }}>\n                Username or Email\n              </span>\n            }\n            name=\"usernameOrEmail\"\n            rules={[{ required: true, message: 'Username or email is required' }]}\n            {...getFieldValidationProps('usernameOrEmail')}\n          >\n            <Input\n              placeholder=\"Enter your username or email\"\n              className=\"login-input\"\n              disabled={isFormLoading}\n            />\n          </Form.Item>\n\n          <Form.Item\n            label={<span style={{ color: 'var(--primary-700)', fontWeight: 600 }}>Password</span>}\n            name=\"password\"\n            rules={[{ required: true, message: 'Password is required' }]}\n            {...getFieldValidationProps('password')}\n          >\n            <Input.Password\n              placeholder=\"Enter your password\"\n              className=\"login-input\"\n              disabled={isFormLoading}\n            />\n          </Form.Item>\n\n          <Form.Item\n            label={<span style={{ color: 'var(--primary-700)', fontWeight: 600 }}>Tenant ID</span>}\n            name=\"tenantId\"\n            rules={[{ required: true, message: 'Tenant ID is required' }]}\n            {...getFieldValidationProps('tenantId')}\n          >\n            <Input\n              placeholder=\"Enter your tenant ID\"\n              className=\"login-input\"\n              disabled={isFormLoading}\n            />\n          </Form.Item>\n\n          <Form.Item name=\"rememberMe\" valuePropName=\"checked\" initialValue={false}>\n            <div\n              style={{\n                display: 'flex',\n                alignItems: 'center',\n                justifyContent: 'space-between',\n                marginBottom: '16px',\n              }}\n            >\n              <Checkbox style={{ color: 'var(--primary-600)' }} disabled={isFormLoading}>\n                Remember me\n              </Checkbox>\n            </div>\n          </Form.Item>\n\n          {renderErrorAlert()}\n\n          <Form.Item>\n            <Button\n              type=\"primary\"\n              htmlType=\"submit\"\n              block\n              loading={isFormLoading}\n              className=\"login-submit-button\"\n            >\n              {authLoading\n                ? 'Signing In...'\n                : match(pipelineState)\n                    .with({ status: 'validating' }, () => 'Validating...')\n                    .otherwise(() => 'Sign In')}\n            </Button>\n          </Form.Item>\n        </Form>\n      </Card>\n\n      <Typography.Text\n        type=\"secondary\"\n        style={{\n          textAlign: 'center',\n          marginTop: '32px',\n          display: 'block',\n          maxWidth: '400px',\n          color: 'var(--primary-500)',\n          fontSize: '14px',\n          lineHeight: '1.5',\n        }}\n      >\n        Secure multi-tenant authentication powered by functional programming\n      </Typography.Text>\n    </Flex>\n  );\n};\n\nexport default LoginPageFP;\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/pages/LoginPage.new.tsx",
        "messages": [
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 29,
                "column": 9,
                "nodeType": "VariableDeclarator",
                "messageId": "anyAssignment",
                "endLine": 29,
                "endColumn": 62
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected any value in conditional. An explicit comparison or type conversion is required.",
                "line": 29,
                "column": 16,
                "nodeType": "ChainExpression",
                "messageId": "conditionErrorAny",
                "endLine": 29,
                "endColumn": 46,
                "suggestions": [
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                1095,
                                1125
                            ],
                            "text": "(Boolean((location.state?.from?.pathname)))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .from on an `any` value.",
                "line": 29,
                "column": 32,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 29,
                "endColumn": 36
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 29,
                "column": 47,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 29,
                "endColumn": 49,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                1126,
                                1128
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 46,
                "column": 50,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingReturnType",
                "endLine": 46,
                "endColumn": 52
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 81,
                "column": 59,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingReturnType",
                "endLine": 81,
                "endColumn": 61
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
                "line": 84,
                "column": 19,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableBoolean",
                "endLine": 84,
                "endColumn": 26,
                "suggestions": [
                    {
                        "messageId": "conditionFixDefaultFalse",
                        "fix": {
                            "range": [
                                2800,
                                2807
                            ],
                            "text": "(touched ?? false)"
                        },
                        "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
                    },
                    {
                        "messageId": "conditionFixCompareTrue",
                        "fix": {
                            "range": [
                                2800,
                                2807
                            ],
                            "text": "(touched === true)"
                        },
                        "desc": "Change condition to check if true (`value === true`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 100,
                "column": 6,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingReturnType",
                "endLine": 100,
                "endColumn": 8
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 111,
                "column": 60,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingReturnType",
                "endLine": 111,
                "endColumn": 62
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
                "line": 116,
                "column": 19,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableBoolean",
                "endLine": 116,
                "endColumn": 26,
                "suggestions": [
                    {
                        "messageId": "conditionFixDefaultFalse",
                        "fix": {
                            "range": [
                                3558,
                                3565
                            ],
                            "text": "(touched ?? false)"
                        },
                        "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
                    },
                    {
                        "messageId": "conditionFixCompareTrue",
                        "fix": {
                            "range": [
                                3558,
                                3565
                            ],
                            "text": "(touched === true)"
                        },
                        "desc": "Change condition to check if true (`value === true`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
                "line": 129,
                "column": 9,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableBoolean",
                "endLine": 129,
                "endColumn": 21,
                "suggestions": [
                    {
                        "messageId": "conditionFixDefaultFalse",
                        "fix": {
                            "range": [
                                3891,
                                3903
                            ],
                            "text": "isFieldValid ?? false"
                        },
                        "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
                    },
                    {
                        "messageId": "conditionFixCompareTrue",
                        "fix": {
                            "range": [
                                3891,
                                3903
                            ],
                            "text": "isFieldValid === true"
                        },
                        "desc": "Change condition to check if true (`value === true`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 163,
                "column": 26,
                "nodeType": "Identifier",
                "messageId": "anyAssignment",
                "endLine": 163,
                "endColumn": 30
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 311,
                "column": 12,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 311,
                "endColumn": 23,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                9044,
                                9055
                            ],
                            "text": "(submitError != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                9044,
                                9055
                            ],
                            "text": "(submitError ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                9044,
                                9055
                            ],
                            "text": "(Boolean(submitError))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 13,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "import React, { useState } from 'react';\nimport { useLocation, Navigate } from 'react-router-dom';\nimport { useForm } from 'react-hook-form';\nimport { zodResolver } from '@hookform/resolvers/zod';\nimport { useAuth } from '@/contexts/AuthContext';\nimport type { LoginCredentials } from '@/types/auth';\nimport { asTenantId } from '@/types/ids';\nimport { loginSchema } from '@/validation/schemas';\nimport { logger } from '@/utils/logger';\nimport type { z } from 'zod';\nimport { Card, Input, Button, Checkbox, Typography, Alert, Flex, Spin } from 'antd';\nimport {\n  CheckCircleOutlined,\n  CloseCircleOutlined,\n  EyeTwoTone,\n  EyeInvisibleOutlined,\n} from '@ant-design/icons';\n\ntype LoginFormData = z.infer<typeof loginSchema>;\n\nexport const LoginPage: React.FC = () => {\n  const { login, isAuthenticated, isLoading } = useAuth();\n  const location = useLocation();\n  const [submitError, setSubmitError] = useState<string | null>(null);\n  const [isSubmitting, setIsSubmitting] = useState(false);\n  const [rememberMe, setRememberMe] = useState(false);\n\n  // Get the intended destination\n  const from = location.state?.from?.pathname || '/dashboard';\n\n  const {\n    register,\n    handleSubmit,\n    formState: { errors, touchedFields, isSubmitted, isValid },\n    trigger,\n  } = useForm<LoginFormData>({\n    resolver: zodResolver(loginSchema),\n    mode: 'onChange',\n    defaultValues: {\n      usernameOrEmail: '',\n      password: '',\n      tenantId: '',\n    },\n  });\n\n  const onSubmit = async (values: LoginFormData) => {\n    setIsSubmitting(true);\n    try {\n      setSubmitError(null);\n      const credentials: LoginCredentials = {\n        usernameOrEmail: values.usernameOrEmail,\n        password: values.password,\n        tenantId: values.tenantId ? asTenantId(values.tenantId) : undefined,\n        rememberMe,\n      };\n      await login(credentials);\n      // Navigation will be handled by the declarative <Navigate> guard below\n    } catch (error) {\n      // Log detailed error information for diagnostics (handles production vs development)\n      logger.error('Login failed', {\n        error:\n          error instanceof Error\n            ? {\n                message: error.message,\n                stack: error.stack,\n                name: error.name,\n              }\n            : error,\n        timestamp: new Date().toISOString(),\n        userAgent: navigator.userAgent,\n        url: window.location.href,\n      });\n\n      // Set user-friendly error message (no sensitive details exposed to UI)\n      setSubmitError('Login failed. Please check your credentials and try again.');\n    } finally {\n      setIsSubmitting(false);\n    }\n  };\n\n  const getFieldStatus = (fieldName: keyof LoginFormData) => {\n    const error = errors[fieldName];\n    const touched = touchedFields[fieldName];\n    if (error && (touched || isSubmitted)) return 'error';\n    return undefined;\n  };\n\n  const FieldHelp = ({\n    id,\n    icon,\n    color,\n    children,\n    role,\n  }: {\n    id: string;\n    icon: React.ReactElement;\n    color: string;\n    children: React.ReactNode;\n    role?: string;\n  }) => (\n    <div\n      id={id}\n      role={role}\n      style={{ display: 'flex', alignItems: 'center', gap: '8px', marginTop: '4px' }}\n    >\n      {React.cloneElement(icon, { style: { color } })}\n      <span style={{ color, fontSize: '14px' }}>{children}</span>\n    </div>\n  );\n\n  const renderFieldHelp = (fieldName: keyof LoginFormData) => {\n    const error = errors[fieldName];\n    const touched = touchedFields[fieldName];\n    const isFieldValid = !error && touched;\n\n    if (error && (touched || isSubmitted)) {\n      return (\n        <FieldHelp\n          id={`${fieldName}-help`}\n          icon={<CloseCircleOutlined />}\n          color=\"var(--color-danger)\"\n          role=\"alert\"\n        >\n          {typeof error.message === 'string' ? error.message : 'Invalid input'}\n        </FieldHelp>\n      );\n    }\n\n    if (isFieldValid) {\n      return (\n        <FieldHelp\n          id={`${fieldName}-help`}\n          icon={<CheckCircleOutlined />}\n          color=\"var(--color-success)\"\n        >\n          Valid\n        </FieldHelp>\n      );\n    }\n\n    return null;\n  };\n\n  // Show loading spinner while authentication status is being resolved\n  if (isLoading) {\n    return (\n      <Flex\n        justify=\"center\"\n        align=\"center\"\n        style={{\n          minHeight: '100vh',\n          background:\n            'linear-gradient(135deg, var(--color-natural-light) 0%, var(--color-healing-light) 100%)',\n        }}\n      >\n        <Spin size=\"large\" />\n      </Flex>\n    );\n  }\n\n  // Don't render if already authenticated\n  if (isAuthenticated) {\n    return <Navigate to={from} replace />;\n  }\n\n  return (\n    <Flex\n      justify=\"center\"\n      align=\"center\"\n      style={{\n        minHeight: '100vh',\n        background:\n          'linear-gradient(135deg, var(--color-natural-light) 0%, var(--color-healing-light) 100%)',\n        padding: '20px',\n      }}\n    >\n      <Card\n        style={{\n          width: 420,\n          borderRadius: '16px',\n          border: '2px solid var(--primary-200)',\n          background:\n            'linear-gradient(145deg, rgba(255,255,255,0.95) 0%, rgba(247,242,240,0.9) 100%)',\n          boxShadow: '0 20px 40px rgba(38, 70, 83, 0.15), inset 0 1px 0 rgba(255, 255, 255, 0.8)',\n          backdropFilter: 'blur(10px)',\n        }}\n        title={\n          <Typography.Title\n            level={2}\n            style={{\n              color: 'var(--color-healing-dark)',\n              margin: 0,\n              textAlign: 'center',\n              fontSize: '2rem',\n              fontWeight: 700,\n            }}\n          >\n            Welcome Back\n          </Typography.Title>\n        }\n        styles={{\n          header: {\n            border: 'none',\n            padding: '40px 30px 20px',\n            textAlign: 'center',\n          },\n          body: {\n            padding: '30px',\n          },\n        }}\n      >\n        <Typography.Text\n          type=\"secondary\"\n          style={{\n            textAlign: 'center',\n            display: 'block',\n            fontSize: '16px',\n            marginBottom: '32px',\n            color: 'var(--primary-600)',\n          }}\n        >\n          Access your multi-tenant application\n        </Typography.Text>\n\n        <form onSubmit={handleSubmit(onSubmit)} style={{ width: '100%' }}>\n          <div style={{ marginBottom: '24px' }}>\n            <label\n              htmlFor=\"usernameOrEmail\"\n              style={{\n                color: 'var(--primary-700)',\n                fontWeight: 600,\n                display: 'block',\n                marginBottom: '8px',\n              }}\n            >\n              Username or Email\n            </label>\n            <Input\n              id=\"usernameOrEmail\"\n              {...register('usernameOrEmail')}\n              placeholder=\"Enter your username or email\"\n              size=\"large\"\n              status={getFieldStatus('usernameOrEmail')}\n              aria-describedby=\"usernameOrEmail-help\"\n              onBlur={() => trigger('usernameOrEmail')}\n            />\n            {renderFieldHelp('usernameOrEmail')}\n          </div>\n\n          <div style={{ marginBottom: '24px' }}>\n            <label\n              htmlFor=\"password\"\n              style={{\n                color: 'var(--primary-700)',\n                fontWeight: 600,\n                display: 'block',\n                marginBottom: '8px',\n              }}\n            >\n              Password\n            </label>\n            <Input.Password\n              id=\"password\"\n              {...register('password')}\n              placeholder=\"Enter your password\"\n              size=\"large\"\n              status={getFieldStatus('password')}\n              aria-describedby=\"password-help\"\n              iconRender={visible => (visible ? <EyeTwoTone /> : <EyeInvisibleOutlined />)}\n              onBlur={() => trigger('password')}\n            />\n            {renderFieldHelp('password')}\n          </div>\n\n          <div style={{ marginBottom: '24px' }}>\n            <label\n              htmlFor=\"tenantId\"\n              style={{\n                color: 'var(--primary-700)',\n                fontWeight: 600,\n                display: 'block',\n                marginBottom: '8px',\n              }}\n            >\n              Tenant ID\n            </label>\n            <Input\n              id=\"tenantId\"\n              {...register('tenantId')}\n              placeholder=\"Enter your tenant ID\"\n              size=\"large\"\n              status={getFieldStatus('tenantId')}\n              aria-describedby=\"tenantId-help\"\n              onBlur={() => trigger('tenantId')}\n            />\n            {renderFieldHelp('tenantId')}\n          </div>\n\n          <div style={{ marginBottom: '32px' }}>\n            <Checkbox\n              checked={rememberMe}\n              onChange={e => {\n                setRememberMe(e.target.checked);\n              }}\n              style={{ color: 'var(--primary-600)' }}\n            >\n              Remember me\n            </Checkbox>\n          </div>\n\n          {submitError && (\n            <Alert\n              message={submitError}\n              type=\"error\"\n              closable\n              onClose={() => {\n                setSubmitError(null);\n              }}\n              style={{\n                borderRadius: '8px',\n                border: '1px solid var(--danger-300)',\n                backgroundColor: 'var(--danger-50)',\n                marginBottom: '24px',\n              }}\n            />\n          )}\n\n          <Button\n            type=\"primary\"\n            htmlType=\"submit\"\n            block\n            size=\"large\"\n            loading={isSubmitting}\n            disabled={!isValid && isSubmitted}\n          >\n            Sign In\n          </Button>\n        </form>\n      </Card>\n\n      <Typography.Text\n        type=\"secondary\"\n        style={{\n          textAlign: 'center',\n          marginTop: '32px',\n          display: 'block',\n          maxWidth: '400px',\n          color: 'var(--primary-500)',\n          fontSize: '14px',\n          lineHeight: '1.5',\n        }}\n      >\n        Use your account credentials and tenant ID to sign in to your secure workspace\n      </Typography.Text>\n    </Flex>\n  );\n};\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/pages/LoginPage.tsx",
        "messages": [
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 24,
                "column": 9,
                "nodeType": "VariableDeclarator",
                "messageId": "anyAssignment",
                "endLine": 24,
                "endColumn": 62
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected any value in conditional. An explicit comparison or type conversion is required.",
                "line": 24,
                "column": 16,
                "nodeType": "ChainExpression",
                "messageId": "conditionErrorAny",
                "endLine": 24,
                "endColumn": 46,
                "suggestions": [
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                880,
                                910
                            ],
                            "text": "(Boolean((location.state?.from?.pathname)))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .from on an `any` value.",
                "line": 24,
                "column": 32,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 24,
                "endColumn": 36
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 24,
                "column": 47,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 24,
                "endColumn": 49,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                911,
                                913
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 26,
                "column": 52,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingReturnType",
                "endLine": 26,
                "endColumn": 54
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-argument",
                "severity": 1,
                "message": "Unsafe argument of type `any` assigned to a parameter of type `To`.",
                "line": 43,
                "column": 16,
                "nodeType": "Identifier",
                "messageId": "unsafeArgument",
                "endLine": 43,
                "endColumn": 20
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 54,
                "column": 26,
                "nodeType": "Identifier",
                "messageId": "anyAssignment",
                "endLine": 54,
                "endColumn": 30
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 191,
                "column": 12,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 191,
                "endColumn": 23,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                5736,
                                5747
                            ],
                            "text": "(submitError != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                5736,
                                5747
                            ],
                            "text": "(submitError ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                5736,
                                5747
                            ],
                            "text": "(Boolean(submitError))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 8,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "import React, { useState } from 'react';\nimport { useNavigate, useLocation, Navigate } from 'react-router-dom';\nimport { useAuth } from '@/contexts/AuthContext';\nimport type { LoginCredentials } from '@/types/auth';\nimport { asTenantId } from '@/types/ids';\nimport { Card, Form, Button, Checkbox, Typography, Alert, Flex, Input } from 'antd';\n\ninterface LoginFormValues {\n  usernameOrEmail: string;\n  password: string;\n  tenantId: string;\n}\n\nexport const LoginPage: React.FC = () => {\n  const { login, isAuthenticated, isLoading } = useAuth();\n  const navigate = useNavigate();\n  const location = useLocation();\n  const [form] = Form.useForm();\n  const [submitError, setSubmitError] = useState<string | null>(null);\n  const [rememberMe, setRememberMe] = useState(false);\n  const [isSubmitting, setIsSubmitting] = useState(false);\n\n  // Get the intended destination\n  const from = location.state?.from?.pathname || '/dashboard';\n\n  const onSubmit = async (values: LoginFormValues) => {\n    // Early return if already submitting\n    if (isSubmitting) {\n      return;\n    }\n\n    setIsSubmitting(true);\n\n    try {\n      setSubmitError(null);\n      const credentials: LoginCredentials = {\n        usernameOrEmail: values.usernameOrEmail,\n        password: values.password,\n        tenantId: values.tenantId ? asTenantId(values.tenantId) : undefined,\n        rememberMe,\n      };\n      await login(credentials);\n      navigate(from, { replace: true });\n    } catch (error) {\n      console.error('Login error occurred', error);\n      setSubmitError(error instanceof Error ? error.message : 'Login failed');\n    } finally {\n      setIsSubmitting(false);\n    }\n  };\n\n  // Don't render if already authenticated\n  if (isAuthenticated) {\n    return <Navigate to={from} replace />;\n  }\n\n  return (\n    <Flex\n      justify=\"center\"\n      align=\"center\"\n      style={{\n        minHeight: '100vh',\n        background:\n          'linear-gradient(135deg, var(--color-natural-light) 0%, var(--color-healing-light) 100%)',\n        padding: '20px',\n      }}\n    >\n      <Card\n        style={{\n          width: 420,\n          borderRadius: '16px',\n          border: '2px solid var(--primary-200)',\n          background:\n            'linear-gradient(145deg, rgba(255,255,255,0.95) 0%, rgba(247,242,240,0.9) 100%)',\n          boxShadow: '0 20px 40px rgba(38, 70, 83, 0.15), inset 0 1px 0 rgba(255, 255, 255, 0.8)',\n          backdropFilter: 'blur(10px)',\n        }}\n        title={\n          <Typography.Title\n            level={2}\n            style={{\n              color: 'var(--color-healing-dark)',\n              margin: 0,\n              textAlign: 'center',\n              fontSize: '2rem',\n              fontWeight: 700,\n            }}\n          >\n            Login\n          </Typography.Title>\n        }\n        styles={{\n          header: {\n            border: 'none',\n            padding: '40px 30px 20px',\n            textAlign: 'center',\n          },\n          body: {\n            padding: '30px',\n          },\n        }}\n      >\n        <Typography.Text\n          type=\"secondary\"\n          style={{\n            textAlign: 'center',\n            display: 'block',\n            fontSize: '16px',\n            marginBottom: '32px',\n            color: 'var(--primary-600)',\n          }}\n        >\n          Access your multi-tenant application\n        </Typography.Text>\n\n        <Form\n          form={form}\n          onFinish={onSubmit}\n          size=\"large\"\n          layout=\"vertical\"\n          data-testid=\"login-form\"\n        >\n          <Form.Item\n            label={\n              <span style={{ color: 'var(--primary-700)', fontWeight: 600 }}>\n                Username or Email\n              </span>\n            }\n            name=\"usernameOrEmail\"\n            rules={[{ required: true, message: 'Username or email is required' }]}\n          >\n            <Input\n              placeholder=\"Enter your username or email\"\n              className=\"login-input\"\n              aria-label=\"Username or Email\"\n              data-testid=\"username-input\"\n              maxLength={254}\n            />\n          </Form.Item>\n\n          <Form.Item\n            label={<span style={{ color: 'var(--primary-700)', fontWeight: 600 }}>Password</span>}\n            name=\"password\"\n            rules={[{ required: true, message: 'Password is required' }]}\n          >\n            <Input.Password\n              placeholder=\"Enter your password\"\n              className=\"login-input\"\n              aria-label=\"Password\"\n              data-testid=\"password-input\"\n              maxLength={128}\n            />\n          </Form.Item>\n\n          <Form.Item\n            label={<span style={{ color: 'var(--primary-700)', fontWeight: 600 }}>Tenant ID</span>}\n            name=\"tenantId\"\n            rules={[{ required: true, message: 'Tenant ID is required' }]}\n          >\n            <Input\n              placeholder=\"Enter your tenant ID\"\n              className=\"login-input\"\n              aria-label=\"Tenant ID\"\n              data-testid=\"tenant-input\"\n              maxLength={64}\n            />\n          </Form.Item>\n\n          <Form.Item>\n            <div\n              style={{\n                display: 'flex',\n                alignItems: 'center',\n                justifyContent: 'space-between',\n                marginBottom: '16px',\n              }}\n            >\n              <Checkbox\n                checked={rememberMe}\n                onChange={e => {\n                  setRememberMe(e.target.checked);\n                }}\n                style={{ color: 'var(--primary-600)' }}\n                data-testid=\"remember-me-checkbox\"\n              >\n                Remember me\n              </Checkbox>\n            </div>\n          </Form.Item>\n\n          {submitError && (\n            <Form.Item>\n              <Alert\n                message={submitError}\n                type=\"error\"\n                closable\n                onClose={() => {\n                  setSubmitError(null);\n                }}\n                role=\"alert\"\n                aria-live=\"polite\"\n                aria-atomic=\"true\"\n                style={{\n                  borderRadius: '8px',\n                  border: '1px solid var(--danger-300)',\n                  backgroundColor: 'var(--danger-50)',\n                }}\n              />\n            </Form.Item>\n          )}\n\n          <Form.Item>\n            <Button\n              type=\"primary\"\n              htmlType=\"submit\"\n              block\n              loading={isLoading || isSubmitting}\n              disabled={isLoading || isSubmitting}\n              className=\"login-submit-button\"\n              data-testid=\"submit-button\"\n            >\n              Sign In\n            </Button>\n          </Form.Item>\n        </Form>\n      </Card>\n\n      <Typography.Text\n        type=\"secondary\"\n        style={{\n          textAlign: 'center',\n          marginTop: '32px',\n          display: 'block',\n          maxWidth: '400px',\n          color: 'var(--primary-500)',\n          fontSize: '14px',\n          lineHeight: '1.5',\n        }}\n      >\n        Use your account credentials and tenant ID to sign in to your secure workspace\n      </Typography.Text>\n    </Flex>\n  );\n};\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/pages/NotFoundPage.tsx",
        "messages": [
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 8,
                "column": 27,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingReturnType",
                "endLine": 8,
                "endColumn": 29
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 12,
                "column": 27,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingReturnType",
                "endLine": 12,
                "endColumn": 29
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .idx on an `any` value.",
                "line": 13,
                "column": 31,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 13,
                "endColumn": 34
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 3,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "import React from 'react';\nimport { Result, Button } from 'antd';\nimport { useNavigate } from 'react-router-dom';\n\nexport const NotFoundPage: React.FC = () => {\n  const navigate = useNavigate();\n\n  const handleGoHome = () => {\n    navigate('/');\n  };\n\n  const handleGoBack = () => {\n    if (window.history.state?.idx > 0) {\n      navigate(-1);\n    } else {\n      navigate('/');\n    }\n  };\n\n  return (\n    <div className=\"min-h-screen flex items-center justify-center bg-neutral-50\">\n      <Result\n        status=\"404\"\n        title=\"404\"\n        subTitle=\"Sorry, the page you visited does not exist.\"\n        extra={[\n          <Button type=\"primary\" key=\"home\" onClick={handleGoHome}>\n            Go Home\n          </Button>,\n          <Button key=\"back\" onClick={handleGoBack}>\n            Go Back\n          </Button>,\n        ]}\n      />\n    </div>\n  );\n};\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/pages/TenantManagementPage.tsx",
        "messages": [
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'selectedTenant' is assigned a value but never used. Allowed unused vars must match /^_/u.",
                "line": 31,
                "column": 10,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 31,
                "endColumn": 24
            },
            {
                "ruleId": "@typescript-eslint/no-floating-promises",
                "severity": 1,
                "message": "Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.",
                "line": 71,
                "column": 5,
                "nodeType": "ExpressionStatement",
                "messageId": "floatingVoid",
                "endLine": 71,
                "endColumn": 19,
                "suggestions": [
                    {
                        "messageId": "floatingFixVoid",
                        "fix": {
                            "range": [
                                2354,
                                2354
                            ],
                            "text": "void "
                        },
                        "desc": "Add void operator to ignore."
                    },
                    {
                        "messageId": "floatingFixAwait",
                        "fix": {
                            "range": [
                                2354,
                                2354
                            ],
                            "text": "await "
                        },
                        "desc": "Add await operator."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 171,
                "column": 7,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 171,
                "endColumn": 12,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                5110,
                                5115
                            ],
                            "text": "error != null"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                5110,
                                5115
                            ],
                            "text": "error ?? \"\""
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                5110,
                                5115
                            ],
                            "text": "Boolean(error)"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 3,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "/**\n * Comprehensive Tenant Management Page\n * Integrates dashboard, search, and management functionality\n */\n\nimport React, { useState, useCallback, useEffect } from 'react';\nimport { Tabs, Card, Space, Button, Typography, Badge, Alert, Row, Col } from 'antd';\nimport {\n  DashboardOutlined,\n  SearchOutlined,\n  SettingOutlined,\n  BarChartOutlined,\n  TeamOutlined,\n} from '@ant-design/icons';\n\nimport { TenantDashboard } from '@/components/TenantDashboard';\nimport { EnhancedTenantsPage } from './EnhancedTenantsPage';\nimport { TenantForm } from '@/components/TenantForm';\nimport { useTenantNotifications } from '@/hooks/useTenantNotifications';\nimport type { Tenant, CreateTenantDTO, UpdateTenantDTO } from '@/types/tenant';\nimport { tenantService } from '@/services/api';\nimport { isApiSuccess } from '@/types/api';\n\nconst { Title, Text } = Typography;\nconst { TabPane } = Tabs;\n\nexport const TenantManagementPage: React.FC = () => {\n  const [tenants, setTenants] = useState<Tenant[]>([]);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const [selectedTenant, setSelectedTenant] = useState<Tenant | null>(null);\n  const [isFormOpen, setIsFormOpen] = useState(false);\n  const [editingTenant, setEditingTenant] = useState<Tenant | null>(null);\n  const [activeTab, setActiveTab] = useState('dashboard');\n\n  const notifications = useTenantNotifications();\n\n  // Load tenants\n  const loadTenants = useCallback(async () => {\n    setLoading(true);\n    setError(null);\n\n    try {\n      const result = await tenantService.getAllWithPagination();\n\n      if (result.isErr()) {\n        setError(result.error.message);\n        notifications.notifyTenantError('load', result.error.message);\n        return;\n      }\n\n      const apiResponse = result.value;\n      if (!isApiSuccess(apiResponse)) {\n        setError(apiResponse.error.message);\n        notifications.notifyTenantError('load', apiResponse.error.message);\n        return;\n      }\n\n      setTenants(apiResponse.data.data);\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n      setError(errorMessage);\n      notifications.notifyTenantError('load', errorMessage);\n    } finally {\n      setLoading(false);\n    }\n  }, [notifications]);\n\n  // Load tenants on mount\n  useEffect(() => {\n    loadTenants();\n  }, [loadTenants]);\n\n  // Handle tenant selection\n  const handleTenantSelect = useCallback((tenant: Tenant) => {\n    setSelectedTenant(tenant);\n    setActiveTab('details');\n  }, []);\n\n  // Handle tenant edit\n  const handleTenantEdit = useCallback((tenant: Tenant) => {\n    setEditingTenant(tenant);\n    setIsFormOpen(true);\n  }, []);\n\n  // Handle tenant delete\n  const handleTenantDelete = useCallback(\n    async (tenant: Tenant) => {\n      try {\n        const result = await tenantService.delete(tenant.id);\n\n        if (result.isErr()) {\n          notifications.notifyTenantError('delete', result.error.message, tenant.name);\n          return;\n        }\n\n        const apiResponse = result.value;\n        if (!isApiSuccess(apiResponse)) {\n          notifications.notifyTenantError('delete', apiResponse.error.message, tenant.name);\n          return;\n        }\n\n        notifications.notifyTenantDeleted(tenant.name);\n        await loadTenants();\n      } catch (error) {\n        const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n        notifications.notifyTenantError('delete', errorMessage, tenant.name);\n      }\n    },\n    [notifications, loadTenants]\n  );\n\n  // Handle tenant create\n  const handleTenantCreate = useCallback(() => {\n    setEditingTenant(null);\n    setIsFormOpen(true);\n  }, []);\n\n  // Handle form submission\n  const handleFormSubmit = useCallback(\n    async (values: CreateTenantDTO | UpdateTenantDTO) => {\n      try {\n        let result;\n\n        if (editingTenant) {\n          result = await tenantService.update(editingTenant.id, values as UpdateTenantDTO);\n        } else {\n          result = await tenantService.create(values as CreateTenantDTO);\n        }\n\n        if (result.isErr()) {\n          return {\n            success: false,\n            message: 'Operation failed',\n            error: result.error.message,\n          };\n        }\n\n        const apiResponse = result.value;\n        if (!isApiSuccess(apiResponse)) {\n          return {\n            success: false,\n            message: 'Operation failed',\n            error: apiResponse.error.message,\n          };\n        }\n\n        await loadTenants();\n        return {\n          success: true,\n          message: editingTenant ? 'Tenant updated successfully' : 'Tenant created successfully',\n          tenant: apiResponse.data,\n        };\n      } catch (error) {\n        return {\n          success: false,\n          message: 'Operation failed',\n          error: error instanceof Error ? error.message : 'Unknown error',\n        };\n      }\n    },\n    [editingTenant, loadTenants]\n  );\n\n  // Handle form close\n  const handleFormClose = useCallback(() => {\n    setIsFormOpen(false);\n    setEditingTenant(null);\n  }, []);\n\n  if (error) {\n    return (\n      <Card>\n        <Alert\n          message=\"Error Loading Tenants\"\n          description={error}\n          type=\"error\"\n          showIcon\n          action={<Button onClick={loadTenants}>Retry</Button>}\n        />\n      </Card>\n    );\n  }\n\n  return (\n    <div style={{ padding: '24px' }}>\n      {/* Header */}\n      <div style={{ marginBottom: '24px' }}>\n        <Row justify=\"space-between\" align=\"middle\">\n          <Col>\n            <Title level={2} style={{ margin: 0 }}>\n              Tenant Management\n            </Title>\n            <Text type=\"secondary\">Comprehensive tenant administration and monitoring</Text>\n          </Col>\n          <Col>\n            <Space>\n              <Button type=\"primary\" onClick={handleTenantCreate} loading={loading}>\n                Create Tenant\n              </Button>\n            </Space>\n          </Col>\n        </Row>\n      </div>\n\n      {/* Main Content */}\n      <Tabs activeKey={activeTab} onChange={setActiveTab} type=\"card\" size=\"large\">\n        <TabPane\n          tab={\n            <Space>\n              <DashboardOutlined />\n              <span>Dashboard</span>\n              <Badge count={tenants.length} />\n            </Space>\n          }\n          key=\"dashboard\"\n        >\n          <TenantDashboard\n            tenants={tenants}\n            onTenantSelect={handleTenantSelect}\n            onTenantEdit={handleTenantEdit}\n            onTenantDelete={handleTenantDelete}\n            onTenantCreate={handleTenantCreate}\n            loading={loading}\n          />\n        </TabPane>\n\n        <TabPane\n          tab={\n            <Space>\n              <SearchOutlined />\n              <span>Search & Filter</span>\n            </Space>\n          }\n          key=\"search\"\n        >\n          <EnhancedTenantsPage />\n        </TabPane>\n\n        <TabPane\n          tab={\n            <Space>\n              <SettingOutlined />\n              <span>Settings</span>\n            </Space>\n          }\n          key=\"settings\"\n        >\n          <Card>\n            <Title level={4}>Tenant Settings</Title>\n            <Text type=\"secondary\">\n              Global tenant management settings and configuration options.\n            </Text>\n            {/* Settings content will be implemented */}\n          </Card>\n        </TabPane>\n\n        <TabPane\n          tab={\n            <Space>\n              <BarChartOutlined />\n              <span>Analytics</span>\n            </Space>\n          }\n          key=\"analytics\"\n        >\n          <Card>\n            <Title level={4}>Tenant Analytics</Title>\n            <Text type=\"secondary\">\n              Comprehensive analytics and reporting for tenant usage and performance.\n            </Text>\n            {/* Analytics content will be implemented */}\n          </Card>\n        </TabPane>\n\n        <TabPane\n          tab={\n            <Space>\n              <TeamOutlined />\n              <span>Users</span>\n            </Space>\n          }\n          key=\"users\"\n        >\n          <Card>\n            <Title level={4}>User Management</Title>\n            <Text type=\"secondary\">Manage user access and permissions across tenants.</Text>\n            {/* User management content will be implemented */}\n          </Card>\n        </TabPane>\n      </Tabs>\n\n      {/* Tenant Form Modal */}\n      <TenantForm\n        open={isFormOpen}\n        onClose={handleFormClose}\n        onSubmit={handleFormSubmit}\n        initialValues={\n          editingTenant\n            ? {\n                name: editingTenant.name,\n                db_url: editingTenant.db_url,\n              }\n            : undefined\n        }\n        mode={editingTenant ? 'edit' : 'create'}\n        loading={loading}\n      />\n    </div>\n  );\n};\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/pages/TenantsPage.tsx",
        "messages": [
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'ConfirmationModal' is defined but never used. Allowed unused vars must match /^_/u.",
                "line": 4,
                "column": 10,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 4,
                "endColumn": 27
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 70,
                "column": 76,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingReturnType",
                "endLine": 70,
                "endColumn": 78
            },
            {
                "ruleId": "@typescript-eslint/no-floating-promises",
                "severity": 1,
                "message": "Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.",
                "line": 105,
                "column": 5,
                "nodeType": "ExpressionStatement",
                "messageId": "floatingVoid",
                "endLine": 105,
                "endColumn": 60,
                "suggestions": [
                    {
                        "messageId": "floatingFixVoid",
                        "fix": {
                            "range": [
                                3066,
                                3066
                            ],
                            "text": "void "
                        },
                        "desc": "Add void operator to ignore."
                    },
                    {
                        "messageId": "floatingFixAwait",
                        "fix": {
                            "range": [
                                3066,
                                3066
                            ],
                            "text": "await "
                        },
                        "desc": "Add await operator."
                    }
                ]
            },
            {
                "ruleId": "react-hooks/exhaustive-deps",
                "severity": 1,
                "message": "React Hook useEffect has missing dependencies: 'loadTenants' and 'pagination.pageSize'. Either include them or remove the dependency array.",
                "line": 106,
                "column": 6,
                "nodeType": "ArrayExpression",
                "endLine": 106,
                "endColumn": 8,
                "suggestions": [
                    {
                        "desc": "Update the dependencies array to be: [loadTenants, pagination.pageSize]",
                        "fix": {
                            "range": [
                                3127,
                                3129
                            ],
                            "text": "[loadTenants, pagination.pageSize]"
                        }
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 109,
                "column": 73,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingReturnType",
                "endLine": 109,
                "endColumn": 75
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 131,
                "column": 57,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingReturnType",
                "endLine": 131,
                "endColumn": 59
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 195,
                "column": 45,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingReturnType",
                "endLine": 195,
                "endColumn": 47
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 205,
                "column": 49,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingReturnType",
                "endLine": 205,
                "endColumn": 51
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'confirmDelete' is assigned a value but never used. Allowed unused vars must match /^_/u.",
                "line": 210,
                "column": 9,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 210,
                "endColumn": 22
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 210,
                "column": 34,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingReturnType",
                "endLine": 210,
                "endColumn": 36
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'cancelDelete' is assigned a value but never used. Allowed unused vars must match /^_/u.",
                "line": 236,
                "column": 9,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 236,
                "endColumn": 21
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 236,
                "column": 27,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingReturnType",
                "endLine": 236,
                "endColumn": 29
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 241,
                "column": 30,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingReturnType",
                "endLine": 241,
                "endColumn": 32
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 248,
                "column": 24,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingReturnType",
                "endLine": 248,
                "endColumn": 26
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 252,
                "column": 40,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingReturnType",
                "endLine": 252,
                "endColumn": 42
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'dayjsToIso' is assigned a value but never used. Allowed unused vars must match /^_/u.",
                "line": 282,
                "column": 9,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 282,
                "endColumn": 19
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 329,
                "column": 33,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingReturnType",
                "endLine": 329,
                "endColumn": 35
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 393,
                "column": 33,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingReturnType",
                "endLine": 393,
                "endColumn": 35
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 400,
                "column": 43,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingReturnType",
                "endLine": 400,
                "endColumn": 45
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 411,
                "column": 37,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingReturnType",
                "endLine": 411,
                "endColumn": 39
            },
            {
                "ruleId": "@typescript-eslint/restrict-template-expressions",
                "severity": 1,
                "message": "Invalid type \"number\" of template literal expression.",
                "line": 557,
                "column": 46,
                "nodeType": "Identifier",
                "messageId": "invalidType",
                "endLine": 557,
                "endColumn": 51
            },
            {
                "ruleId": "@typescript-eslint/restrict-template-expressions",
                "severity": 1,
                "message": "Invalid type \"number\" of template literal expression.",
                "line": 566,
                "column": 57,
                "nodeType": "Identifier",
                "messageId": "invalidType",
                "endLine": 566,
                "endColumn": 62
            },
            {
                "ruleId": "@typescript-eslint/restrict-template-expressions",
                "severity": 1,
                "message": "Invalid type \"number\" of template literal expression.",
                "line": 582,
                "column": 60,
                "nodeType": "Identifier",
                "messageId": "invalidType",
                "endLine": 582,
                "endColumn": 65
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected object value in conditional. The condition is always true.",
                "line": 599,
                "column": 29,
                "nodeType": "Identifier",
                "messageId": "conditionErrorObject",
                "endLine": 599,
                "endColumn": 33
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, value is always truthy.",
                "line": 599,
                "column": 29,
                "nodeType": "Identifier",
                "messageId": "alwaysTruthy",
                "endLine": 599,
                "endColumn": 33
            },
            {
                "ruleId": "@typescript-eslint/prefer-optional-chain",
                "severity": 2,
                "message": "Prefer using an optional chain expression instead, as it's more concise and easier to read.",
                "line": 599,
                "column": 29,
                "nodeType": null,
                "messageId": "preferOptionalChain",
                "endLine": 599,
                "endColumn": 51,
                "suggestions": [
                    {
                        "fix": {
                            "range": [
                                18813,
                                18835
                            ],
                            "text": "date?.isValid()"
                        },
                        "messageId": "optionalChainSuggest",
                        "desc": "Change to an optional chain."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/restrict-template-expressions",
                "severity": 1,
                "message": "Invalid type \"number\" of template literal expression.",
                "line": 606,
                "column": 57,
                "nodeType": "Identifier",
                "messageId": "invalidType",
                "endLine": 606,
                "endColumn": 62
            },
            {
                "ruleId": "@typescript-eslint/restrict-template-expressions",
                "severity": 1,
                "message": "Invalid type \"number\" of template literal expression.",
                "line": 616,
                "column": 58,
                "nodeType": "Identifier",
                "messageId": "invalidType",
                "endLine": 616,
                "endColumn": 63
            },
            {
                "ruleId": "@typescript-eslint/restrict-template-expressions",
                "severity": 1,
                "message": "Invalid type \"number\" of template literal expression.",
                "line": 628,
                "column": 51,
                "nodeType": "Identifier",
                "messageId": "invalidType",
                "endLine": 628,
                "endColumn": 56
            },
            {
                "ruleId": "@typescript-eslint/restrict-template-expressions",
                "severity": 1,
                "message": "Invalid type \"number\" of template literal expression.",
                "line": 675,
                "column": 32,
                "nodeType": "MemberExpression",
                "messageId": "invalidType",
                "endLine": 675,
                "endColumn": 46
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected any value in conditional. An explicit comparison or type conversion is required.",
                "line": 728,
                "column": 24,
                "nodeType": "Identifier",
                "messageId": "conditionErrorAny",
                "endLine": 728,
                "endColumn": 29,
                "suggestions": [
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                22989,
                                22994
                            ],
                            "text": "(Boolean(value))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-argument",
                "severity": 1,
                "message": "Unsafe argument of type `any` assigned to a parameter of type `string`.",
                "line": 732,
                "column": 58,
                "nodeType": "Identifier",
                "messageId": "unsafeArgument",
                "endLine": 732,
                "endColumn": 63
            }
        ],
        "suppressedMessages": [],
        "errorCount": 1,
        "fatalErrorCount": 0,
        "warningCount": 31,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "import React, { useState, useEffect } from 'react';\nimport dayjs from 'dayjs';\nimport type { Dayjs } from 'dayjs';\nimport { ConfirmationModal } from '@/components/ConfirmationModal';\nimport type { Tenant as TenantRecord, CreateTenantDTO } from '@/types/tenant';\nimport { isApiSuccess } from '@/types/api';\nimport {\n  Button,\n  Input,\n  Card,\n  Table,\n  Modal,\n  Form,\n  Space,\n  Typography,\n  Divider,\n  Select,\n  App,\n  DatePicker,\n  Spin,\n} from 'antd';\nimport {\n  PlusOutlined,\n  EditOutlined,\n  DeleteOutlined,\n  PlusCircleOutlined,\n  MinusCircleOutlined,\n} from '@ant-design/icons';\nimport { tenantService } from '@/services/api';\nimport { isValidPostgresConnectionString } from '@/validation/schemas';\n\n/**\n * Form values for tenant creation (excluding id which is auto-generated)\n */\ntype TenantFormValues = Omit<CreateTenantDTO, 'id'>;\n\n// Field type constants to avoid duplication\nconst TEXT_FIELDS = ['id', 'name', 'db_url'] as const;\nconst DATE_FIELDS = ['created_at', 'updated_at'] as const;\n\nconst operatorLabels: Record<string, string> = {\n  contains: 'Contains',\n  equals: 'Equals',\n  gt: 'Greater Than',\n  gte: 'Greater or Equal',\n  lt: 'Less Than',\n  lte: 'Less or Equal',\n};\n\nexport const TenantsPage: React.FC = () => {\n  const [tenants, setTenants] = useState<TenantRecord[]>([]);\n  const { message } = App.useApp();\n\n  const [isFormOpen, setIsFormOpen] = useState(false);\n  const [editingTenant, setEditingTenant] = useState<TenantRecord | null>(null);\n  const [deleteTenantId, setDeleteTenantId] = useState<TenantRecord['id'] | null>(null);\n  const [form] = Form.useForm<TenantFormValues>();\n  const [isSubmitting, setIsSubmitting] = useState(false);\n  const [loading, setLoading] = useState(false);\n  const [powerFilters, setPowerFilters] = useState<\n    { field: string; operator: string; value: string }[]\n  >([{ field: 'name', operator: 'contains', value: '' }]);\n  const [pagination, setPagination] = useState({\n    current: 1,\n    pageSize: 12,\n    total: 0,\n  });\n\n  // Load tenants from API with pagination\n  const loadTenants = async (params?: { offset?: number; limit?: number }) => {\n    try {\n      setLoading(true);\n      const result = await tenantService.getAllWithPagination(params);\n\n      if (result.isErr()) {\n        message.error(result.error.message);\n        setTenants([]);\n        setPagination(prev => ({ ...prev, total: 0 }));\n        return;\n      }\n\n      const apiResponse = result.value;\n\n      if (!isApiSuccess(apiResponse)) {\n        message.error(apiResponse.error.message);\n        setTenants([]);\n        setPagination(prev => ({ ...prev, total: 0 }));\n        return;\n      }\n\n      const data = apiResponse.data;\n      setTenants(data.data);\n      setPagination(prev => ({ ...prev, total: data.total }));\n    } catch (error) {\n      message.error(error instanceof Error ? error.message : 'Failed to load tenants');\n      setTenants([]);\n      setPagination(prev => ({ ...prev, total: 0 }));\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // Load tenants on component mount\n  useEffect(() => {\n    loadTenants({ offset: 0, limit: pagination.pageSize });\n  }, []);\n\n  // Handle pagination changes (page size and page number)\n  const handlePaginationChange = async (page: number, pageSize: number) => {\n    setPagination(prev => ({ ...prev, current: page, pageSize }));\n\n    // Calculate offset for backend API\n    const offset = (page - 1) * pageSize;\n    await loadTenants({ offset, limit: pageSize });\n  };\n\n  // Custom pagination config that extends pharmacyPaginationConfig with dynamic values\n  const tablePagination = {\n    current: pagination.current,\n    pageSize: pagination.pageSize,\n    total: pagination.total,\n    onChange: handlePaginationChange,\n    showSizeChanger: false,\n    showQuickJumper: false,\n  };\n\n  /**\n   * Handle form submission for creating or updating a tenant\n   * @param values - Form values from Ant Design Form (without id)\n   */\n  const handleSubmit = async (values: TenantFormValues) => {\n    setIsSubmitting(true);\n\n    try {\n      if (editingTenant) {\n        // Update existing tenant - omit db_url if empty to keep it optional\n        const updateResult = await tenantService.update(editingTenant.id, {\n          name: values.name,\n          ...(values.db_url && { db_url: values.db_url }),\n        });\n        if (updateResult.isErr()) {\n          throw new Error(updateResult.error.message);\n        }\n\n        if (!isApiSuccess(updateResult.value)) {\n          throw new Error(updateResult.value.error.message);\n        }\n        // Refresh the current page\n        await loadTenants({\n          offset: (pagination.current - 1) * pagination.pageSize,\n          limit: pagination.pageSize,\n        });\n      } else {\n        // Create new tenant with cryptographically secure UUID\n        const createResult = await tenantService.create({\n          id: crypto.randomUUID(),\n          name: values.name,\n          db_url: values.db_url,\n        });\n\n        if (createResult.isErr()) {\n          throw new Error(createResult.error.message);\n        }\n\n        if (!isApiSuccess(createResult.value)) {\n          throw new Error(createResult.value.error.message);\n        }\n        // Refresh the current page\n        await loadTenants({\n          offset: (pagination.current - 1) * pagination.pageSize,\n          limit: pagination.pageSize,\n        });\n      }\n\n      // Success message\n      const successMsg = editingTenant\n        ? 'Tenant updated successfully!'\n        : 'Tenant created successfully!';\n      message.success(successMsg);\n\n      // Reset form and close modal on success\n      setEditingTenant(null);\n      setIsFormOpen(false);\n      form.resetFields();\n    } catch (error) {\n      message.error(\n        error instanceof Error ? error.message : 'An error occurred while saving the tenant.'\n      );\n    } finally {\n      setIsSubmitting(false);\n    }\n  };\n\n  // Handle edit\n  const handleEdit = (tenant: TenantRecord) => {\n    setEditingTenant(tenant);\n    form.setFieldsValue({\n      name: tenant.name,\n      db_url: tenant.db_url,\n    });\n    setIsFormOpen(true);\n  };\n\n  // Handle delete - open confirmation modal\n  const handleDelete = (id: TenantRecord['id']) => {\n    setDeleteTenantId(id);\n  };\n\n  // Confirm delete\n  const confirmDelete = async () => {\n    if (deleteTenantId) {\n      try {\n        const deleteResult = await tenantService.delete(deleteTenantId);\n        if (deleteResult.isErr()) {\n          throw new Error(deleteResult.error.message);\n        }\n\n        if (!isApiSuccess(deleteResult.value)) {\n          throw new Error(deleteResult.value.error.message);\n        }\n        // Update tenants state after successful API response\n        await loadTenants({\n          offset: (pagination.current - 1) * pagination.pageSize,\n          limit: pagination.pageSize,\n        });\n        message.success('Tenant deleted successfully!');\n      } catch (error) {\n        message.error(error instanceof Error ? error.message : 'Failed to delete tenant');\n      } finally {\n        setDeleteTenantId(null);\n      }\n    }\n  };\n\n  // Cancel delete\n  const cancelDelete = () => {\n    setDeleteTenantId(null);\n  };\n\n  // Open form for new tenant\n  const handleNewTenant = () => {\n    setEditingTenant(null);\n    form.resetFields();\n    setIsFormOpen(true);\n  };\n\n  // Power search functions\n  const addFilter = () => {\n    setPowerFilters([...powerFilters, { field: 'name', operator: 'contains', value: '' }]);\n  };\n\n  const removeFilter = (index: number) => {\n    setPowerFilters(powerFilters.filter((_, i) => i !== index));\n  };\n\n  // Helper function to get valid operators for a field type\n  const getOperatorsForField = (field: string): string[] => {\n    if ((TEXT_FIELDS as readonly string[]).includes(field)) {\n      return ['contains', 'equals'];\n    } else if ((DATE_FIELDS as readonly string[]).includes(field)) {\n      return ['equals', 'gt', 'gte', 'lt', 'lte'];\n    }\n\n    // Default fallback\n    return ['contains', 'equals'];\n  };\n\n  // Helper function to check if a field is a date field\n  const isDateField = (field: string): boolean =>\n    (DATE_FIELDS as readonly string[]).includes(field);\n\n  // Helper function to convert ISO string to dayjs object\n  const isoToDayjs = (isoString: string): Dayjs | null => {\n    if (!isoString) return null;\n    const d = dayjs(isoString);\n    return d.isValid() ? d : null;\n  };\n\n  // Helper function to convert dayjs object to ISO string\n  // Type guarantee: dayjsObj is Dayjs | null; null case returns empty string,\n  // so the remaining path guarantees dayjsObj is a valid Dayjs instance.\n  const dayjsToIso = (dayjsObj: Dayjs | null): string => {\n    if (!dayjsObj) return '';\n    return dayjsObj.toISOString();\n  };\n\n  const updateFilter = (\n    index: number,\n    key: 'field' | 'operator' | 'value',\n    value: string\n  ): void => {\n    const updated = [...powerFilters];\n    const currentFilter = updated[index];\n\n    if (!currentFilter) {\n      return;\n    }\n\n    // If field is changing, check if current operator is still valid and clear stale values\n    if (key === 'field') {\n      const validOperators = getOperatorsForField(value);\n      const currentOperator = currentFilter.operator;\n      const isDateFieldValue = isDateField(value);\n      const wasDateField = isDateField(currentFilter.field);\n\n      // If field type changed (date <-> text), clear the value\n      const shouldClearValue = isDateFieldValue !== wasDateField;\n\n      // If current operator is not valid for the new field, reset to first valid operator\n      if (!validOperators.includes(currentOperator)) {\n        updated[index] = Object.assign({}, currentFilter, {\n          [key]: value,\n          operator: validOperators[0],\n          value: shouldClearValue ? '' : currentFilter.value,\n        });\n      } else {\n        updated[index] = Object.assign({}, currentFilter, {\n          [key]: value,\n          value: shouldClearValue ? '' : currentFilter.value,\n        });\n      }\n    } else {\n      updated[index] = Object.assign({}, currentFilter, { [key]: value });\n    }\n\n    setPowerFilters(updated);\n  };\n\n  const applyFilters = async () => {\n    try {\n      setLoading(true);\n      const validFilters = powerFilters.filter(f => f.value.trim() !== '');\n      if (validFilters.length === 0) {\n        // No filters, load all\n        setPagination(prev => ({ ...prev, current: 1 })); // Reset to first page\n        await loadTenants({ offset: 0, limit: pagination.pageSize });\n        return;\n      }\n\n      // Validate date fields before sending\n      const validatedFilters = validFilters.map(filter => {\n        if (isDateField(filter.field)) {\n          // Validate date format for date fields\n          const dateValue = new Date(filter.value);\n          if (isNaN(dateValue.getTime())) {\n            throw new Error(`Invalid date format for field ${filter.field}: ${filter.value}`);\n          }\n          return {\n            ...filter,\n            value: dateValue.toISOString(),\n          };\n        }\n        return filter;\n      });\n\n      const response = await tenantService.filter({\n        filters: validatedFilters,\n        limit: pagination.pageSize, // Use current page size for filtered results\n      });\n\n      if (response.isErr()) {\n        throw new Error(response.error.message);\n      }\n\n      const apiResponse = response.value;\n\n      if (!isApiSuccess(apiResponse)) {\n        throw new Error(apiResponse.error.message);\n      }\n\n      const data = apiResponse.data;\n\n      if (Array.isArray(data)) {\n        // Data is already TenantRecord[] from the API\n        setTenants(data);\n        setPagination(prev => ({ ...prev, current: 1, total: data.length }));\n      } else {\n        const paginated = data;\n        setTenants(paginated.data);\n        setPagination(prev => ({\n          ...prev,\n          current: 1,\n          total: paginated.total,\n        }));\n      }\n    } catch (error) {\n      message.error(error instanceof Error ? error.message : 'Failed to filter tenants');\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const clearFilters = async () => {\n    setPowerFilters([{ field: 'name', operator: 'contains', value: '' }]);\n    setPagination(prev => ({ ...prev, current: 1 })); // Reset to first page\n    await loadTenants({ offset: 0, limit: pagination.pageSize });\n  };\n\n  // Format date for display\n  const formatDate = (dateString: string) => {\n    return new Date(dateString).toLocaleString('en-US', {\n      year: 'numeric',\n      month: 'short',\n      day: 'numeric',\n      hour: '2-digit',\n      minute: '2-digit',\n    });\n  };\n\n  // Format database URL for display (hide password if present)\n  const formatDbUrl = (url: string) => {\n    try {\n      // Hide password from display\n      const displayUrl = url.replace(/:\\/\\/([^:]+):[^@]+@/, '://$1:***@');\n      return displayUrl;\n    } catch {\n      return '<invalid-db-url>';\n    }\n  };\n\n  // Table columns for tenants display\n  const columns = [\n    {\n      title: 'ID',\n      dataIndex: 'id',\n      key: 'id',\n      width: 200,\n      ellipsis: true,\n    },\n    {\n      title: 'Name',\n      dataIndex: 'name',\n      key: 'name',\n      sorter: (a: TenantRecord, b: TenantRecord) => a.name.localeCompare(b.name),\n    },\n    {\n      title: 'Database URL',\n      dataIndex: 'db_url',\n      key: 'db_url',\n      width: 250,\n      ellipsis: true,\n      render: (dbUrl: string) => {\n        const masked = formatDbUrl(dbUrl);\n        return (\n          <span\n            title={masked}\n            style={{\n              fontSize: '12px',\n              color: 'var(--tertiary-600)',\n              fontFamily: 'monospace',\n            }}\n          >\n            {masked.length > 30 ? masked.substring(0, 27) + '...' : masked}\n          </span>\n        );\n      },\n    },\n    {\n      title: 'Created',\n      dataIndex: 'created_at',\n      key: 'created_at',\n      render: (date: string) => formatDate(date),\n      sorter: (a: TenantRecord, b: TenantRecord) =>\n        new Date(a.created_at).getTime() - new Date(b.created_at).getTime(),\n    },\n    {\n      title: 'Updated',\n      dataIndex: 'updated_at',\n      key: 'updated_at',\n      render: (date: string) => formatDate(date),\n      sorter: (a: TenantRecord, b: TenantRecord) =>\n        new Date(a.updated_at).getTime() - new Date(b.updated_at).getTime(),\n    },\n    {\n      title: 'Actions',\n      key: 'actions',\n      width: 100,\n      render: (_: unknown, tenant: TenantRecord) => (\n        <Space size=\"small\">\n          <Button\n            type=\"text\"\n            size=\"small\"\n            icon={<EditOutlined />}\n            onClick={() => {\n              handleEdit(tenant);\n            }}\n            style={{\n              color: '#1890ff',\n            }}\n          />\n          <Button\n            type=\"text\"\n            danger\n            size=\"small\"\n            icon={<DeleteOutlined />}\n            onClick={() => {\n              handleDelete(tenant.id);\n            }}\n          />\n        </Space>\n      ),\n    },\n  ];\n\n  // For filter validation, add error state for invalid dates\n  // Filter errors handled in applyFilters\n\n  return (\n    <Space direction=\"vertical\" size=\"large\" style={{ width: '100%' }}>\n      {loading ? (\n        <div style={{ textAlign: 'center', padding: '48px' }}>\n          <Spin tip=\"Loading tenants...\" />\n        </div>\n      ) : tenants.length === 0 ? (\n        <Card>\n          <div style={{ textAlign: 'center', padding: 48 }}>\n            <Typography.Title level={4}>No Tenants Found</Typography.Title>\n            <Typography.Text type=\"secondary\">\n              Create your first tenant to get started.\n            </Typography.Text>\n            <Button type=\"primary\" onClick={handleNewTenant} style={{ marginTop: 16 }}>\n              Create Tenant\n            </Button>\n          </div>\n        </Card>\n      ) : (\n        <>\n          {/* Header */}\n          <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>\n            <div>\n              <Typography.Title level={2} style={{ margin: 0 }}>\n                Tenants\n              </Typography.Title>\n              <Typography.Text type=\"secondary\">\n                Manage tenant configurations and database connections\n              </Typography.Text>\n            </div>\n            <Button type=\"primary\" icon={<PlusOutlined />} onClick={handleNewTenant}>\n              Add Tenant\n            </Button>\n          </div>\n\n          <Divider />\n\n          {/* Search Filters */}\n          <Card\n            title=\"Search Filters\"\n            size=\"small\"\n            style={{ borderRadius: '8px', marginTop: '16px' }}\n            data-testid=\"search-filters-card\"\n          >\n            <Space direction=\"vertical\" size=\"middle\" style={{ width: '100%' }}>\n              {powerFilters.map((filter, index) => (\n                <div\n                  key={index}\n                  style={{ display: 'flex', alignItems: 'center', gap: '12px', flexWrap: 'wrap' }}\n                  data-testid={`filter-row-${index}`}\n                >\n                  <Select\n                    style={{ width: 150 }}\n                    value={filter.field}\n                    onChange={value => {\n                      updateFilter(index, 'field', value);\n                    }}\n                    placeholder=\"Field\"\n                    data-testid={`filter-field-select-${index}`}\n                  >\n                    <Select.Option value=\"id\">ID</Select.Option>\n                    <Select.Option value=\"name\">Name</Select.Option>\n                    <Select.Option value=\"db_url\">Database URL</Select.Option>\n                    <Select.Option value=\"created_at\">Created At</Select.Option>\n                    <Select.Option value=\"updated_at\">Updated At</Select.Option>\n                  </Select>\n\n                  <Select\n                    style={{ width: 120 }}\n                    value={filter.operator}\n                    onChange={value => {\n                      updateFilter(index, 'operator', value);\n                    }}\n                    placeholder=\"Operator\"\n                    data-testid={`filter-operator-select-${index}`}\n                  >\n                    {getOperatorsForField(filter.field).map(op => (\n                      <Select.Option key={op} value={op}>\n                        {operatorLabels[op] ?? op}\n                      </Select.Option>\n                    ))}\n                  </Select>\n\n                  {isDateField(filter.field) ? (\n                    <DatePicker\n                      style={{ width: 200, flex: 1, minWidth: '150px' }}\n                      placeholder=\"Select date\"\n                      showTime\n                      allowClear\n                      value={isoToDayjs(filter.value)}\n                      onChange={date => {\n                        if (date && date.isValid()) {\n                          const iso = date.toDate().toISOString();\n                          updateFilter(index, 'value', iso);\n                        } else {\n                          updateFilter(index, 'value', '');\n                        }\n                      }}\n                      data-testid={`filter-value-date-${index}`}\n                    />\n                  ) : (\n                    <Input\n                      style={{ width: 200, flex: 1, minWidth: '150px' }}\n                      placeholder=\"Value\"\n                      value={filter.value}\n                      onChange={e => {\n                        updateFilter(index, 'value', e.target.value);\n                      }}\n                      data-testid={`filter-value-input-${index}`}\n                    />\n                  )}\n\n                  <Button\n                    type=\"text\"\n                    danger\n                    icon={<MinusCircleOutlined />}\n                    onClick={() => {\n                      removeFilter(index);\n                    }}\n                    disabled={powerFilters.length <= 1}\n                    data-testid={`remove-filter-${index}`}\n                  >\n                    Remove\n                  </Button>\n\n                  {index === powerFilters.length - 1 && (\n                    <Button\n                      type=\"text\"\n                      icon={<PlusCircleOutlined />}\n                      onClick={addFilter}\n                      data-testid=\"add-filter-button\"\n                    >\n                      Add Filter\n                    </Button>\n                  )}\n                </div>\n              ))}\n\n              <Divider style={{ margin: '8px 0' }} />\n\n              <Space>\n                <Button\n                  type=\"primary\"\n                  onClick={applyFilters}\n                  disabled={loading}\n                  data-testid=\"apply-filters-button\"\n                >\n                  Apply Filters\n                </Button>\n                <Button\n                  onClick={clearFilters}\n                  disabled={loading}\n                  data-testid=\"clear-filters-button\"\n                >\n                  Clear All\n                </Button>\n              </Space>\n\n              <div style={{ fontSize: '14px', color: '#666' }}>\n                <Typography.Text strong>Note:</Typography.Text> Pick a date/time; it's sent as\n                ISO-8601 (UTC). Empty values are ignored.\n              </div>\n            </Space>\n          </Card>\n\n          {/* Tenants Table */}\n          <Card\n            title={`Tenants (${tenants.length})`}\n            style={{ borderRadius: '8px', boxShadow: '0 2px 8px rgba(0,0,0,0.1)' }}\n          >\n            <Table\n              columns={columns}\n              dataSource={tenants}\n              rowKey=\"id\"\n              loading={loading}\n              rowClassName={(record, index) => (index % 2 === 0 ? 'stripe-row' : '')}\n              pagination={tablePagination}\n              data-testid=\"tenants-table\"\n              locale={{ emptyText: 'No tenants match your search.' }}\n              style={{\n                border: '1px solid #e8e8e8',\n                borderRadius: '8px',\n                overflow: 'hidden',\n              }}\n            />\n          </Card>\n        </>\n      )}\n\n      {/* Tenant Form Modal */}\n      <Modal\n        title={editingTenant ? 'Edit Tenant' : 'Add New Tenant'}\n        open={isFormOpen}\n        onCancel={() => {\n          setIsFormOpen(false);\n        }}\n        footer={null}\n      >\n        <Form\n          form={form}\n          onFinish={handleSubmit}\n          layout=\"vertical\"\n          initialValues={{\n            name: '',\n            db_url: '',\n          }}\n        >\n          <Form.Item\n            name=\"name\"\n            label=\"Tenant Name\"\n            rules={[{ required: true, message: 'Please enter tenant name' }]}\n          >\n            <Input />\n          </Form.Item>\n          <Form.Item\n            name=\"db_url\"\n            label=\"Database URL\"\n            rules={[\n              {\n                validator: (_rule, value) => {\n                  if (!value)\n                    return editingTenant\n                      ? Promise.resolve()\n                      : Promise.reject(new Error('Please enter database URL'));\n                  return isValidPostgresConnectionString(value)\n                    ? Promise.resolve()\n                    : Promise.reject(new Error('Invalid PostgreSQL connection string'));\n                },\n              },\n            ]}\n          >\n            <Input placeholder=\"postgres://localhost:5432/mydb or key=value format\" />\n          </Form.Item>\n          <Form.Item>\n            <Button type=\"primary\" htmlType=\"submit\" loading={isSubmitting}>\n              {editingTenant ? 'Update' : 'Add'} Tenant\n            </Button>\n          </Form.Item>\n        </Form>\n      </Modal>\n    </Space>\n  );\n};\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/pages/__tests__/AddressBookPage.test.tsx",
        "messages": [
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 55,
                "column": 13,
                "nodeType": "VariableDeclarator",
                "messageId": "anyAssignment",
                "endLine": 55,
                "endColumn": 54
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 55,
                "column": 51,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 55,
                "endColumn": 54,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                1711,
                                1714
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                1711,
                                1714
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-argument",
                "severity": 1,
                "message": "Unsafe argument of type `any` assigned to a parameter of type `PersonDTO`.",
                "line": 57,
                "column": 39,
                "nodeType": "Identifier",
                "messageId": "unsafeArgument",
                "endLine": 57,
                "endColumn": 49
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 62,
                "column": 13,
                "nodeType": "VariableDeclarator",
                "messageId": "anyAssignment",
                "endLine": 62,
                "endColumn": 44
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 62,
                "column": 41,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 62,
                "endColumn": 44,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                2009,
                                2012
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                2009,
                                2012
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-argument",
                "severity": 1,
                "message": "Unsafe argument of type `any` assigned to a parameter of type `PersonDTO`.",
                "line": 64,
                "column": 39,
                "nodeType": "Identifier",
                "messageId": "unsafeArgument",
                "endLine": 64,
                "endColumn": 49
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 69,
                "column": 13,
                "nodeType": "VariableDeclarator",
                "messageId": "anyAssignment",
                "endLine": 69,
                "endColumn": 45
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 69,
                "column": 42,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 69,
                "endColumn": 45,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                2297,
                                2300
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                2297,
                                2300
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-argument",
                "severity": 1,
                "message": "Unsafe argument of type `any` assigned to a parameter of type `PersonDTO`.",
                "line": 71,
                "column": 39,
                "nodeType": "Identifier",
                "messageId": "unsafeArgument",
                "endLine": 71,
                "endColumn": 49
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 76,
                "column": 13,
                "nodeType": "VariableDeclarator",
                "messageId": "anyAssignment",
                "endLine": 76,
                "endColumn": 43
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 76,
                "column": 40,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 76,
                "endColumn": 43,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                2593,
                                2596
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                2593,
                                2596
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-argument",
                "severity": 1,
                "message": "Unsafe argument of type `any` assigned to a parameter of type `PersonDTO`.",
                "line": 78,
                "column": 39,
                "nodeType": "Identifier",
                "messageId": "unsafeArgument",
                "endLine": 78,
                "endColumn": 49
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 85,
                "column": 13,
                "nodeType": "VariableDeclarator",
                "messageId": "anyAssignment",
                "endLine": 89,
                "endColumn": 15
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 89,
                "column": 12,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 89,
                "endColumn": 15,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                3003,
                                3006
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                3003,
                                3006
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-argument",
                "severity": 1,
                "message": "Unsafe argument of type `any` assigned to a parameter of type `PersonDTO`.",
                "line": 90,
                "column": 39,
                "nodeType": "Identifier",
                "messageId": "unsafeArgument",
                "endLine": 90,
                "endColumn": 49
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 99,
                "column": 13,
                "nodeType": "VariableDeclarator",
                "messageId": "anyAssignment",
                "endLine": 102,
                "endColumn": 15
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 102,
                "column": 12,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 102,
                "endColumn": 15,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                3352,
                                3355
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                3352,
                                3355
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-argument",
                "severity": 1,
                "message": "Unsafe argument of type `any` assigned to a parameter of type `PersonDTO`.",
                "line": 103,
                "column": 39,
                "nodeType": "Identifier",
                "messageId": "unsafeArgument",
                "endLine": 103,
                "endColumn": 49
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 112,
                "column": 13,
                "nodeType": "VariableDeclarator",
                "messageId": "anyAssignment",
                "endLine": 114,
                "endColumn": 15
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 114,
                "column": 12,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 114,
                "endColumn": 15,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                3653,
                                3656
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                3653,
                                3656
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-argument",
                "severity": 1,
                "message": "Unsafe argument of type `any` assigned to a parameter of type `PersonDTO`.",
                "line": 115,
                "column": 39,
                "nodeType": "Identifier",
                "messageId": "unsafeArgument",
                "endLine": 115,
                "endColumn": 49
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 124,
                "column": 13,
                "nodeType": "VariableDeclarator",
                "messageId": "anyAssignment",
                "endLine": 128,
                "endColumn": 15
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 128,
                "column": 12,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 128,
                "endColumn": 15,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                3992,
                                3995
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                3992,
                                3995
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-argument",
                "severity": 1,
                "message": "Unsafe argument of type `any` assigned to a parameter of type `PersonDTO`.",
                "line": 129,
                "column": 39,
                "nodeType": "Identifier",
                "messageId": "unsafeArgument",
                "endLine": 129,
                "endColumn": 49
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 140,
                "column": 13,
                "nodeType": "VariableDeclarator",
                "messageId": "anyAssignment",
                "endLine": 140,
                "endColumn": 56
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 140,
                "column": 53,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 140,
                "endColumn": 56,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                4317,
                                4320
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                4317,
                                4320
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-argument",
                "severity": 1,
                "message": "Unsafe argument of type `any` assigned to a parameter of type `PersonDTO`.",
                "line": 141,
                "column": 43,
                "nodeType": "Identifier",
                "messageId": "unsafeArgument",
                "endLine": 141,
                "endColumn": 53
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 146,
                "column": 13,
                "nodeType": "VariableDeclarator",
                "messageId": "anyAssignment",
                "endLine": 146,
                "endColumn": 49
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 146,
                "column": 46,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 146,
                "endColumn": 49,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                4529,
                                4532
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                4529,
                                4532
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-argument",
                "severity": 1,
                "message": "Unsafe argument of type `any` assigned to a parameter of type `PersonDTO`.",
                "line": 147,
                "column": 43,
                "nodeType": "Identifier",
                "messageId": "unsafeArgument",
                "endLine": 147,
                "endColumn": 53
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 152,
                "column": 13,
                "nodeType": "VariableDeclarator",
                "messageId": "anyAssignment",
                "endLine": 152,
                "endColumn": 54
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 152,
                "column": 51,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 152,
                "endColumn": 54,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                4747,
                                4750
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                4747,
                                4750
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-argument",
                "severity": 1,
                "message": "Unsafe argument of type `any` assigned to a parameter of type `PersonDTO`.",
                "line": 153,
                "column": 43,
                "nodeType": "Identifier",
                "messageId": "unsafeArgument",
                "endLine": 153,
                "endColumn": 53
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 160,
                "column": 13,
                "nodeType": "VariableDeclarator",
                "messageId": "anyAssignment",
                "endLine": 169,
                "endColumn": 15
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 169,
                "column": 12,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 169,
                "endColumn": 15,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                5199,
                                5202
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                5199,
                                5202
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-argument",
                "severity": 1,
                "message": "Unsafe argument of type `any` assigned to a parameter of type `PersonDTO`.",
                "line": 170,
                "column": 46,
                "nodeType": "Identifier",
                "messageId": "unsafeArgument",
                "endLine": 170,
                "endColumn": 56
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 182,
                "column": 13,
                "nodeType": "VariableDeclarator",
                "messageId": "anyAssignment",
                "endLine": 182,
                "endColumn": 35
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 182,
                "column": 32,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 182,
                "endColumn": 35,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                5566,
                                5569
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                5566,
                                5569
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-argument",
                "severity": 1,
                "message": "Unsafe argument of type `any` assigned to a parameter of type `PersonDTO`.",
                "line": 183,
                "column": 46,
                "nodeType": "Identifier",
                "messageId": "unsafeArgument",
                "endLine": 183,
                "endColumn": 56
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 188,
                "column": 13,
                "nodeType": "VariableDeclarator",
                "messageId": "anyAssignment",
                "endLine": 195,
                "endColumn": 15
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 195,
                "column": 12,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 195,
                "endColumn": 15,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                5944,
                                5947
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                5944,
                                5947
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-argument",
                "severity": 1,
                "message": "Unsafe argument of type `any` assigned to a parameter of type `PersonDTO`.",
                "line": 196,
                "column": 46,
                "nodeType": "Identifier",
                "messageId": "unsafeArgument",
                "endLine": 196,
                "endColumn": 56
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 241,
                "column": 13,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 241,
                "endColumn": 22,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                7288,
                                7297
                            ],
                            "text": "sortParam != null"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                7288,
                                7297
                            ],
                            "text": "sortParam ?? \"\""
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                7288,
                                7297
                            ],
                            "text": "Boolean(sortParam)"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/restrict-template-expressions",
                "severity": 1,
                "message": "Invalid type \"string | null | undefined\" of template literal expression.",
                "line": 245,
                "column": 32,
                "nodeType": "MemberExpression",
                "messageId": "invalidType",
                "endLine": 245,
                "endColumn": 44
            },
            {
                "ruleId": "@typescript-eslint/restrict-template-expressions",
                "severity": 1,
                "message": "Invalid type \"string | null | undefined\" of template literal expression.",
                "line": 245,
                "column": 48,
                "nodeType": "MemberExpression",
                "messageId": "invalidType",
                "endLine": 245,
                "endColumn": 59
            },
            {
                "ruleId": "@typescript-eslint/restrict-template-expressions",
                "severity": 1,
                "message": "Invalid type \"string | null | undefined\" of template literal expression.",
                "line": 246,
                "column": 32,
                "nodeType": "MemberExpression",
                "messageId": "invalidType",
                "endLine": 246,
                "endColumn": 44
            },
            {
                "ruleId": "@typescript-eslint/restrict-template-expressions",
                "severity": 1,
                "message": "Invalid type \"string | null | undefined\" of template literal expression.",
                "line": 246,
                "column": 48,
                "nodeType": "MemberExpression",
                "messageId": "invalidType",
                "endLine": 246,
                "endColumn": 59
            },
            {
                "ruleId": "@typescript-eslint/no-non-null-assertion",
                "severity": 1,
                "message": "Forbidden non-null assertion.",
                "line": 571,
                "column": 26,
                "nodeType": "TSNonNullExpression",
                "messageId": "noNonNull",
                "endLine": 571,
                "endColumn": 36
            },
            {
                "ruleId": "@typescript-eslint/no-non-null-assertion",
                "severity": 1,
                "message": "Forbidden non-null assertion.",
                "line": 597,
                "column": 26,
                "nodeType": "TSNonNullExpression",
                "messageId": "noNonNull",
                "endLine": 597,
                "endColumn": 36
            },
            {
                "ruleId": "@typescript-eslint/no-non-null-assertion",
                "severity": 1,
                "message": "Forbidden non-null assertion.",
                "line": 608,
                "column": 26,
                "nodeType": "TSNonNullExpression",
                "messageId": "noNonNull",
                "endLine": 608,
                "endColumn": 39
            },
            {
                "ruleId": "@typescript-eslint/no-non-null-assertion",
                "severity": 1,
                "message": "Forbidden non-null assertion.",
                "line": 629,
                "column": 24,
                "nodeType": "TSNonNullExpression",
                "messageId": "noNonNull",
                "endLine": 629,
                "endColumn": 34
            },
            {
                "ruleId": "@typescript-eslint/no-non-null-assertion",
                "severity": 1,
                "message": "Forbidden non-null assertion.",
                "line": 659,
                "column": 24,
                "nodeType": "TSNonNullExpression",
                "messageId": "noNonNull",
                "endLine": 659,
                "endColumn": 37
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary optional chain on a non-nullish value.",
                "line": 827,
                "column": 72,
                "nodeType": "MemberExpression",
                "messageId": "neverOptionalChain",
                "endLine": 827,
                "endColumn": 74,
                "suggestions": [
                    {
                        "messageId": "suggestRemoveOptionalChain",
                        "fix": {
                            "range": [
                                28221,
                                28223
                            ],
                            "text": "."
                        },
                        "desc": "Remove unnecessary optional chain"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-non-null-assertion",
                "severity": 1,
                "message": "Forbidden non-null assertion.",
                "line": 830,
                "column": 24,
                "nodeType": "TSNonNullExpression",
                "messageId": "noNonNull",
                "endLine": 830,
                "endColumn": 38
            },
            {
                "ruleId": "@typescript-eslint/no-non-null-assertion",
                "severity": 1,
                "message": "Forbidden non-null assertion.",
                "line": 852,
                "column": 24,
                "nodeType": "TSNonNullExpression",
                "messageId": "noNonNull",
                "endLine": 852,
                "endColumn": 34
            },
            {
                "ruleId": "@typescript-eslint/no-non-null-assertion",
                "severity": 1,
                "message": "Forbidden non-null assertion.",
                "line": 878,
                "column": 24,
                "nodeType": "TSNonNullExpression",
                "messageId": "noNonNull",
                "endLine": 878,
                "endColumn": 37
            },
            {
                "ruleId": "@typescript-eslint/no-non-null-assertion",
                "severity": 1,
                "message": "Forbidden non-null assertion.",
                "line": 897,
                "column": 24,
                "nodeType": "TSNonNullExpression",
                "messageId": "noNonNull",
                "endLine": 897,
                "endColumn": 34
            },
            {
                "ruleId": "@typescript-eslint/no-non-null-assertion",
                "severity": 1,
                "message": "Forbidden non-null assertion.",
                "line": 923,
                "column": 24,
                "nodeType": "TSNonNullExpression",
                "messageId": "noNonNull",
                "endLine": 923,
                "endColumn": 37
            },
            {
                "ruleId": "@typescript-eslint/no-non-null-assertion",
                "severity": 1,
                "message": "Forbidden non-null assertion.",
                "line": 943,
                "column": 26,
                "nodeType": "TSNonNullExpression",
                "messageId": "noNonNull",
                "endLine": 943,
                "endColumn": 36
            },
            {
                "ruleId": "@typescript-eslint/no-non-null-assertion",
                "severity": 1,
                "message": "Forbidden non-null assertion.",
                "line": 953,
                "column": 24,
                "nodeType": "TSNonNullExpression",
                "messageId": "noNonNull",
                "endLine": 953,
                "endColumn": 37
            },
            {
                "ruleId": "@typescript-eslint/no-non-null-assertion",
                "severity": 1,
                "message": "Forbidden non-null assertion.",
                "line": 954,
                "column": 24,
                "nodeType": "TSNonNullExpression",
                "messageId": "noNonNull",
                "endLine": 954,
                "endColumn": 37
            },
            {
                "ruleId": "@typescript-eslint/no-non-null-assertion",
                "severity": 1,
                "message": "Forbidden non-null assertion.",
                "line": 1041,
                "column": 26,
                "nodeType": "TSNonNullExpression",
                "messageId": "noNonNull",
                "endLine": 1041,
                "endColumn": 36
            },
            {
                "ruleId": "@typescript-eslint/no-non-null-assertion",
                "severity": 1,
                "message": "Forbidden non-null assertion.",
                "line": 1076,
                "column": 24,
                "nodeType": "TSNonNullExpression",
                "messageId": "noNonNull",
                "endLine": 1076,
                "endColumn": 37
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary optional chain on a non-nullish value.",
                "line": 1191,
                "column": 72,
                "nodeType": "MemberExpression",
                "messageId": "neverOptionalChain",
                "endLine": 1191,
                "endColumn": 74,
                "suggestions": [
                    {
                        "messageId": "suggestRemoveOptionalChain",
                        "fix": {
                            "range": [
                                41908,
                                41910
                            ],
                            "text": "."
                        },
                        "desc": "Remove unnecessary optional chain"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-non-null-assertion",
                "severity": 1,
                "message": "Forbidden non-null assertion.",
                "line": 1194,
                "column": 24,
                "nodeType": "TSNonNullExpression",
                "messageId": "noNonNull",
                "endLine": 1194,
                "endColumn": 38
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.",
                "line": 1242,
                "column": 27,
                "nodeType": "ChainExpression",
                "messageId": "neverNullish",
                "endLine": 1242,
                "endColumn": 56
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary optional chain on a non-nullish value.",
                "line": 1242,
                "column": 48,
                "nodeType": "MemberExpression",
                "messageId": "neverOptionalChain",
                "endLine": 1242,
                "endColumn": 50,
                "suggestions": [
                    {
                        "messageId": "suggestRemoveOptionalChain",
                        "fix": {
                            "range": [
                                43566,
                                43568
                            ],
                            "text": "."
                        },
                        "desc": "Remove unnecessary optional chain"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-non-null-assertion",
                "severity": 1,
                "message": "Forbidden non-null assertion.",
                "line": 1265,
                "column": 24,
                "nodeType": "TSNonNullExpression",
                "messageId": "noNonNull",
                "endLine": 1265,
                "endColumn": 34
            },
            {
                "ruleId": "@typescript-eslint/no-non-null-assertion",
                "severity": 1,
                "message": "Forbidden non-null assertion.",
                "line": 1293,
                "column": 26,
                "nodeType": "TSNonNullExpression",
                "messageId": "noNonNull",
                "endLine": 1293,
                "endColumn": 36
            },
            {
                "ruleId": "@typescript-eslint/require-await",
                "severity": 1,
                "message": "Async arrow function has no 'await' expression.",
                "line": 1360,
                "column": 57,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingAwait",
                "endLine": 1360,
                "endColumn": 59,
                "suggestions": [
                    {
                        "messageId": "removeAsync",
                        "fix": {
                            "range": [
                                47788,
                                47794
                            ],
                            "text": ""
                        },
                        "desc": "Remove 'async'."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-non-null-assertion",
                "severity": 1,
                "message": "Forbidden non-null assertion.",
                "line": 1388,
                "column": 26,
                "nodeType": "TSNonNullExpression",
                "messageId": "noNonNull",
                "endLine": 1388,
                "endColumn": 36
            },
            {
                "ruleId": "@typescript-eslint/no-non-null-assertion",
                "severity": 1,
                "message": "Forbidden non-null assertion.",
                "line": 1413,
                "column": 26,
                "nodeType": "TSNonNullExpression",
                "messageId": "noNonNull",
                "endLine": 1413,
                "endColumn": 39
            },
            {
                "ruleId": "@typescript-eslint/no-non-null-assertion",
                "severity": 1,
                "message": "Forbidden non-null assertion.",
                "line": 1435,
                "column": 26,
                "nodeType": "TSNonNullExpression",
                "messageId": "noNonNull",
                "endLine": 1435,
                "endColumn": 36
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 1541,
                "column": 27,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingReturnType",
                "endLine": 1541,
                "endColumn": 29
            }
        ],
        "suppressedMessages": [
            {
                "ruleId": "@typescript-eslint/no-empty-function",
                "severity": 2,
                "message": "Unexpected empty arrow function.",
                "line": 1206,
                "column": 36,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "unexpected",
                "endLine": 1206,
                "endColumn": 38,
                "suggestions": [
                    {
                        "messageId": "suggestComment",
                        "data": {
                            "name": "arrow function"
                        },
                        "fix": {
                            "range": [
                                42471,
                                42471
                            ],
                            "text": " /* empty */ "
                        },
                        "desc": "Add comment inside empty arrow function."
                    }
                ],
                "suppressions": [
                    {
                        "kind": "directive",
                        "justification": ""
                    }
                ]
            }
        ],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 74,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "import { describe, it, expect, beforeEach } from 'bun:test';\nimport { screen, waitFor, act, within } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport { http, HttpResponse } from 'msw';\nimport { server } from '../../test-utils/mocks/server';\nimport { renderWithAuth } from '../../test-utils/render';\nimport {\n  AddressBookPage,\n  resolveContactId,\n  parseContactName,\n  resolveContactGender,\n  normalizeContactAddress,\n} from '../AddressBookPage';\nimport type { ContactApiDTO } from '../../transformers/dto';\nimport { getEnv } from '../../config/env';\nimport { Gender } from '../../types/contact';\nimport { asContactId } from '../../types/ids';\nimport type { ContactId } from '../../types/ids';\n\nconst API_BASE_URL = getEnv().apiUrl;\n\n// Mock data - using backend API format (snake_case)\nlet mockContacts: ContactApiDTO[] = [\n  {\n    id: 1,\n    tenant_id: 'tenant-1',\n    first_name: 'John',\n    last_name: 'Doe',\n    email: 'john@example.com',\n    phone: '555-0100',\n    age: 30,\n    gender: 'male',\n    address: '123 Main St, Springfield, IL 62701, USA',\n    created_at: new Date().toISOString(),\n    updated_at: new Date().toISOString(),\n  },\n  {\n    id: 2,\n    tenant_id: 'tenant-1',\n    first_name: 'Jane',\n    last_name: 'Smith',\n    email: 'jane@example.com',\n    phone: '555-0101',\n    age: 28,\n    gender: 'female',\n    address: '456 Oak Ave, Shelbyville, IL 62702, USA',\n    created_at: new Date().toISOString(),\n    updated_at: new Date().toISOString(),\n  },\n];\n\ndescribe('AddressBookPage Utility Functions', () => {\n  describe('resolveContactId', () => {\n    it('should return string ID when valid', () => {\n      const normalized = { id: 'contact-123' } as any;\n      const fallback = (): ContactId => asContactId('fallback');\n      const result = resolveContactId(normalized, fallback);\n      expect(result).toBe(asContactId('contact-123'));\n    });\n\n    it('should return number ID as string when valid', () => {\n      const normalized = { id: 123 } as any;\n      const fallback = (): ContactId => asContactId('fallback');\n      const result = resolveContactId(normalized, fallback);\n      expect(result).toBe(asContactId('123'));\n    });\n\n    it('should return fallback when ID is invalid', () => {\n      const normalized = { id: null } as any;\n      const fallback = (): ContactId => asContactId('fallback');\n      const result = resolveContactId(normalized, fallback);\n      expect(result).toBe(asContactId('fallback'));\n    });\n\n    it('should return fallback when ID is empty string', () => {\n      const normalized = { id: '' } as any;\n      const fallback = (): ContactId => asContactId('fallback');\n      const result = resolveContactId(normalized, fallback);\n      expect(result).toBe(asContactId('fallback'));\n    });\n  });\n\n  describe('parseContactName', () => {\n    it('should use fullName when available', () => {\n      const normalized = {\n        fullName: 'John Doe',\n        firstName: 'John',\n        lastName: 'Doe',\n      } as any;\n      const result = parseContactName(normalized);\n      expect(result).toEqual({\n        rawName: 'John Doe',\n        firstName: 'John',\n        lastName: 'Doe',\n      });\n    });\n\n    it('should construct fullName from firstName and lastName', () => {\n      const normalized = {\n        firstName: 'John',\n        lastName: 'Doe',\n      } as any;\n      const result = parseContactName(normalized);\n      expect(result).toEqual({\n        rawName: 'John Doe',\n        firstName: 'John',\n        lastName: 'Doe',\n      });\n    });\n\n    it('should handle missing lastName', () => {\n      const normalized = {\n        firstName: 'John',\n      } as any;\n      const result = parseContactName(normalized);\n      expect(result).toEqual({\n        rawName: 'John',\n        firstName: 'John',\n        lastName: '',\n      });\n    });\n\n    it('should handle empty fullName', () => {\n      const normalized = {\n        fullName: '',\n        firstName: 'John',\n        lastName: 'Doe',\n      } as any;\n      const result = parseContactName(normalized);\n      expect(result).toEqual({\n        rawName: '',\n        firstName: 'John',\n        lastName: 'Doe',\n      });\n    });\n  });\n\n  describe('resolveContactGender', () => {\n    it('should return valid gender', () => {\n      const normalized = { gender: Gender.male } as any;\n      const result = resolveContactGender(normalized);\n      expect(result).toBe(Gender.male);\n    });\n\n    it('should return undefined for null gender', () => {\n      const normalized = { gender: null } as any;\n      const result = resolveContactGender(normalized);\n      expect(result).toBeUndefined();\n    });\n\n    it('should return undefined for invalid gender', () => {\n      const normalized = { gender: 'invalid' } as any;\n      const result = resolveContactGender(normalized);\n      expect(result).toBeUndefined();\n    });\n  });\n\n  describe('normalizeContactAddress', () => {\n    it('should return address when available', () => {\n      const normalized = {\n        address: {\n          street1: '123 Main St',\n          street2: 'Apt 1',\n          city: 'Springfield',\n          state: 'IL',\n          zipCode: '62701',\n          country: 'USA',\n        },\n      } as any;\n      const result = normalizeContactAddress(normalized, 'USA');\n      expect(result).toEqual({\n        street1: '123 Main St',\n        street2: 'Apt 1',\n        city: 'Springfield',\n        state: 'IL',\n        zipCode: '62701',\n        country: 'USA',\n      });\n    });\n\n    it('should return undefined when no address', () => {\n      const normalized = {} as any;\n      const result = normalizeContactAddress(normalized, 'USA');\n      expect(result).toBeUndefined();\n    });\n\n    it('should use default country when address country is missing', () => {\n      const normalized = {\n        address: {\n          street1: '123 Main St',\n          city: 'Springfield',\n          state: 'IL',\n          zipCode: '62701',\n        },\n      } as any;\n      const result = normalizeContactAddress(normalized, 'USA');\n      expect(result?.country).toBe('USA');\n    });\n  });\n});\n\ndescribe.skip('AddressBookPage Component', () => {\n  beforeEach(() => {\n    // Reset mockContacts to initial state before each test\n    mockContacts = [\n      {\n        id: 1,\n        tenant_id: 'tenant-1',\n        first_name: 'John',\n        last_name: 'Doe',\n        email: 'john@example.com',\n        phone: '555-0100',\n        age: 30,\n        gender: 'male',\n        address: '123 Main St, Springfield, IL 62701, USA',\n        created_at: new Date().toISOString(),\n        updated_at: new Date().toISOString(),\n      },\n      {\n        id: 2,\n        tenant_id: 'tenant-1',\n        first_name: 'Jane',\n        last_name: 'Smith',\n        email: 'jane@example.com',\n        phone: '555-0101',\n        age: 28,\n        gender: 'female',\n        address: '456 Oak Ave, Shelbyville, IL 62702, USA',\n        created_at: new Date().toISOString(),\n        updated_at: new Date().toISOString(),\n      },\n    ];\n\n    // Setup test-specific handlers using the global server\n    server.use(\n      http.get(`${API_BASE_URL}/address-book`, ({ request }) => {\n        const url = new URL(request.url);\n        const sortParam = url.searchParams.get('sort');\n        const sortedContacts = [...mockContacts];\n\n        if (sortParam) {\n          const [field, order] = sortParam.split(',');\n          if (field === 'fullName') {\n            sortedContacts.sort((a, b) => {\n              const nameA = `${a.first_name} ${a.last_name}`;\n              const nameB = `${b.first_name} ${b.last_name}`;\n              return order === 'asc' ? nameA.localeCompare(nameB) : nameB.localeCompare(nameA);\n            });\n          }\n        }\n\n        return HttpResponse.json({\n          status: 'success',\n          message: 'Contacts retrieved',\n          data: {\n            contacts: sortedContacts,\n            total: mockContacts.length,\n            currentPage: 1,\n            totalPages: 1,\n            limit: mockContacts.length,\n            hasNext: false,\n            hasPrev: false,\n          },\n        });\n      }),\n\n      http.post(`${API_BASE_URL}/address-book`, async ({ request }) => {\n        const body = (await request.json()) as {\n          name?: string;\n          email?: string;\n          phone?: string;\n          gender?: string;\n          age?: number;\n          address?: string;\n        };\n        const nameParts = (body.name ?? 'Unknown User').split(' ');\n        const newContact: ContactApiDTO = {\n          id: mockContacts.length + 1,\n          tenant_id: 'tenant-1',\n          first_name: nameParts[0] ?? 'Unknown',\n          last_name: nameParts.slice(1).join(' ') || 'User',\n          email: body.email ?? '',\n          phone: body.phone ?? '',\n          age: body.age ?? 25,\n          gender: body.gender ?? 'male',\n          address: body.address ?? '',\n          created_at: new Date().toISOString(),\n          updated_at: new Date().toISOString(),\n        };\n        mockContacts.push(newContact);\n        return HttpResponse.json({\n          status: 'success',\n          message: 'Contact created',\n          data: newContact,\n        });\n      }),\n\n      http.put(`${API_BASE_URL}/address-book/:id`, async ({ request, params }) => {\n        const contactId = Number(params.id);\n        const body = (await request.json()) as {\n          name?: string;\n          email?: string;\n          phone?: string;\n          gender?: string;\n          age?: number;\n          address?: string;\n        };\n        const contactIndex = mockContacts.findIndex(c => c.id === contactId);\n        if (contactIndex === -1) {\n          return HttpResponse.json({ message: 'Contact not found', data: null }, { status: 404 });\n        }\n\n        // Apply updates by creating a new object\n        const existingContact = mockContacts[contactIndex];\n        if (!existingContact) {\n          return HttpResponse.json({ message: 'Contact not found', data: null }, { status: 404 });\n        }\n        const updatedContact: ContactApiDTO = {\n          ...existingContact,\n          updated_at: new Date().toISOString(),\n          ...(body.name != null &&\n            typeof body.name === 'string' &&\n            body.name.trim() !== '' && {\n              first_name: body.name.split(' ')[0] ?? 'Unknown',\n              last_name: body.name.split(' ').slice(1).join(' ') || 'User',\n            }),\n          ...(body.email !== undefined && { email: body.email }),\n          ...(body.phone !== undefined && { phone: body.phone }),\n          ...(body.age !== undefined && { age: body.age }),\n          ...(body.gender !== undefined && { gender: body.gender }),\n          ...(body.address !== undefined && { address: body.address }),\n        };\n\n        mockContacts[contactIndex] = updatedContact;\n        return HttpResponse.json({\n          status: 'success',\n          message: 'Contact updated',\n          data: mockContacts[contactIndex],\n        });\n      }),\n\n      http.delete(`${API_BASE_URL}/address-book/:id`, ({ params }) => {\n        const contactId = Number(params.id);\n        const contactIndex = mockContacts.findIndex(c => c.id === contactId);\n        if (contactIndex === -1) {\n          return HttpResponse.json({ message: 'Contact not found', data: null }, { status: 404 });\n        }\n        // Remove the contact from the array\n        mockContacts.splice(contactIndex, 1);\n        return HttpResponse.json({\n          status: 'success',\n          message: 'Contact deleted',\n          data: null,\n        });\n      })\n    );\n  });\n\n  describe('Rendering', () => {\n    it('should render the page title', async () => {\n      renderWithAuth(<AddressBookPage />);\n\n      expect(await screen.findByText(/address book/i)).toBeInTheDocument();\n    });\n\n    it('should display add contact button', () => {\n      renderWithAuth(<AddressBookPage />);\n\n      expect(screen.getByRole('button', { name: /add/i })).toBeInTheDocument();\n    });\n\n    it('should display search input', () => {\n      renderWithAuth(<AddressBookPage />);\n\n      expect(screen.getByPlaceholderText(/search/i)).toBeInTheDocument();\n    });\n\n    it('should render contacts table', async () => {\n      renderWithAuth(<AddressBookPage />);\n\n      await waitFor(() => {\n        expect(screen.getByRole('table')).toBeInTheDocument();\n      });\n    });\n  });\n\n  describe('Loading Contacts', () => {\n    it('should fetch contacts from API on mount', async () => {\n      renderWithAuth(<AddressBookPage />);\n\n      await waitFor(() => {\n        expect(screen.getByText('John Doe')).toBeInTheDocument();\n        expect(screen.getByText('Jane Smith')).toBeInTheDocument();\n      });\n    });\n\n    it('should render table with correct structure and row count', async () => {\n      renderWithAuth(<AddressBookPage />);\n\n      await waitFor(() => {\n        // Verify table structure\n        expect(screen.getByRole('table')).toBeInTheDocument();\n\n        // Verify table headers are present\n        expect(screen.getByRole('columnheader', { name: /name/i })).toBeInTheDocument();\n        expect(screen.getByRole('columnheader', { name: /email/i })).toBeInTheDocument();\n\n        // Verify correct number of data rows (2 contacts + 1 header row = 3 total rows)\n        const rows = screen.getAllByRole('row');\n        expect(rows).toHaveLength(3);\n\n        // Verify specific contact data in table cells\n        expect(screen.getByRole('cell', { name: 'John Doe' })).toBeInTheDocument();\n        expect(screen.getByRole('cell', { name: 'Jane Smith' })).toBeInTheDocument();\n      });\n    });\n\n    it('should display contact emails in table', async () => {\n      renderWithAuth(<AddressBookPage />);\n\n      await waitFor(() => {\n        expect(screen.getByText('john@example.com')).toBeInTheDocument();\n        expect(screen.getByText('jane@example.com')).toBeInTheDocument();\n      });\n    });\n  });\n\n  describe('Search Functionality', () => {\n    it('should filter contacts by search term', async () => {\n      const user = userEvent.setup();\n      renderWithAuth(<AddressBookPage />);\n\n      await waitFor(() => {\n        expect(screen.getByText('John Doe')).toBeInTheDocument();\n        expect(screen.getByText('Jane Smith')).toBeInTheDocument();\n      });\n\n      const searchInput = screen.getByPlaceholderText(/search contacts/i);\n      await user.type(searchInput, 'John');\n      await waitFor(() => {\n        expect(screen.getByText('John Doe')).toBeInTheDocument();\n        expect(screen.queryByText('Jane Smith')).not.toBeInTheDocument();\n      });\n    });\n\n    it('should filter contacts by email', async () => {\n      const user = userEvent.setup();\n      renderWithAuth(<AddressBookPage />);\n\n      await waitFor(() => {\n        expect(screen.getByText('John Doe')).toBeInTheDocument();\n        expect(screen.getByText('Jane Smith')).toBeInTheDocument();\n      });\n\n      const searchInput = screen.getByPlaceholderText(/search contacts/i);\n      await user.type(searchInput, 'jane@example.com');\n      await waitFor(() => {\n        expect(screen.getByText('Jane Smith')).toBeInTheDocument();\n        expect(screen.queryByText('John Doe')).not.toBeInTheDocument();\n      });\n    });\n\n    it('should filter contacts by phone', async () => {\n      const user = userEvent.setup();\n      renderWithAuth(<AddressBookPage />);\n\n      await waitFor(() => {\n        expect(screen.getByText('John Doe')).toBeInTheDocument();\n        expect(screen.getByText('Jane Smith')).toBeInTheDocument();\n      });\n\n      const searchInput = screen.getByPlaceholderText(/search contacts/i);\n      await user.type(searchInput, '555-0100');\n      await waitFor(() => {\n        expect(screen.getByText('John Doe')).toBeInTheDocument();\n        expect(screen.queryByText('Jane Smith')).not.toBeInTheDocument();\n      });\n    });\n\n    it('should clear search results', async () => {\n      const user = userEvent.setup();\n      renderWithAuth(<AddressBookPage />);\n\n      await waitFor(() => {\n        expect(screen.getByText('John Doe')).toBeInTheDocument();\n        expect(screen.getByText('Jane Smith')).toBeInTheDocument();\n      });\n\n      const searchInput = screen.getByPlaceholderText(/search contacts/i);\n      await user.type(searchInput, 'Jane');\n      await waitFor(() => {\n        expect(screen.getByText('Jane Smith')).toBeInTheDocument();\n        expect(screen.queryByText('John Doe')).not.toBeInTheDocument();\n      });\n\n      await user.clear(searchInput);\n      await waitFor(() => {\n        expect(screen.getByText('John Doe')).toBeInTheDocument();\n        expect(screen.getByText('Jane Smith')).toBeInTheDocument();\n      });\n    });\n\n    it('should show no results message when no matches', async () => {\n      const user = userEvent.setup();\n      renderWithAuth(<AddressBookPage />);\n\n      await waitFor(() => {\n        expect(screen.getByText('John Doe')).toBeInTheDocument();\n        expect(screen.getByText('Jane Smith')).toBeInTheDocument();\n      });\n\n      const searchInput = screen.getByPlaceholderText(/search contacts/i);\n      await user.type(searchInput, 'NonExistent');\n      await waitFor(() => {\n        expect(screen.getByText(/no contacts match your search/i)).toBeInTheDocument();\n      });\n    });\n\n    it('should be case insensitive', async () => {\n      const user = userEvent.setup();\n      renderWithAuth(<AddressBookPage />);\n\n      await waitFor(() => {\n        expect(screen.getByText('John Doe')).toBeInTheDocument();\n        expect(screen.getByText('Jane Smith')).toBeInTheDocument();\n      });\n\n      const searchInput = screen.getByPlaceholderText(/search contacts/i);\n      await user.type(searchInput, 'JOHN');\n      await waitFor(() => {\n        expect(screen.getByText('John Doe')).toBeInTheDocument();\n        expect(screen.queryByText('Jane Smith')).not.toBeInTheDocument();\n      });\n    });\n  });\n\n  describe('Create Contact', () => {\n    it('should open create modal on add button click', async () => {\n      const user = userEvent.setup();\n      renderWithAuth(<AddressBookPage />);\n\n      await waitFor(() => {\n        expect(screen.getByText('John Doe')).toBeInTheDocument();\n      });\n\n      const addButton = screen.getByRole('button', { name: /add contact/i });\n      expect(addButton).toBeInTheDocument();\n\n      await act(async () => {\n        await user.click(addButton);\n      });\n\n      await waitFor(() => {\n        expect(screen.getByText('Add New Contact')).toBeInTheDocument();\n      });\n    });\n\n    it('should have form fields in create modal', async () => {\n      const user = userEvent.setup();\n      renderWithAuth(<AddressBookPage />);\n\n      await waitFor(() => {\n        expect(screen.getByText('John Doe')).toBeInTheDocument();\n      });\n\n      // Use more specific selector to avoid multiple matches\n      const addButtons = screen.getAllByRole('button', { name: /add contact/i });\n      const addButton = addButtons.find(btn => btn.getAttribute('type') === 'button');\n      expect(addButton).toBeInTheDocument();\n      await act(async () => {\n        await user.click(addButton!);\n      });\n\n      await waitFor(() => {\n        expect(screen.getByLabelText('First Name')).toBeInTheDocument();\n        expect(screen.getByLabelText('Last Name')).toBeInTheDocument();\n        expect(screen.getByLabelText('Email')).toBeInTheDocument();\n        expect(screen.getByLabelText('Phone')).toBeInTheDocument();\n        expect(screen.getByLabelText('Gender')).toBeInTheDocument();\n        expect(screen.getByLabelText('Age')).toBeInTheDocument();\n      });\n    });\n\n    it('should validate required fields', async () => {\n      const user = userEvent.setup();\n      renderWithAuth(<AddressBookPage />);\n\n      await waitFor(() => {\n        expect(screen.getByText('John Doe')).toBeInTheDocument();\n      });\n\n      // Use more specific selector to avoid multiple matches\n      const addButtons = screen.getAllByRole('button', { name: /add contact/i });\n      const addButton = addButtons.find(btn => btn.getAttribute('type') === 'button');\n      expect(addButton).toBeInTheDocument();\n      await act(async () => {\n        await user.click(addButton!);\n      });\n\n      await waitFor(() => {\n        expect(screen.getByText('Add New Contact')).toBeInTheDocument();\n      });\n\n      const submitButtons = screen.getAllByRole('button', { name: /add contact/i });\n      const submitButton = submitButtons.find(btn => btn.getAttribute('type') === 'submit');\n      expect(submitButton).toBeInTheDocument();\n      await act(async () => {\n        await user.click(submitButton!);\n      });\n\n      await waitFor(() => {\n        const errorMessages = screen.getAllByText(/please enter/i);\n        expect(errorMessages.length).toBeGreaterThan(0);\n      });\n    });\n\n    it('should create contact successfully', async () => {\n      const user = userEvent.setup();\n      renderWithAuth(<AddressBookPage />);\n\n      await waitFor(() => {\n        expect(screen.getByText('John Doe')).toBeInTheDocument();\n      });\n\n      // Use more specific selector to avoid multiple matches\n      const addButtons = screen.getAllByRole('button', { name: /add contact/i });\n      const addButton = addButtons.find(btn => btn.getAttribute('type') === 'button');\n      expect(addButton).toBeInTheDocument();\n      await user.click(addButton!);\n\n      await waitFor(() => {\n        expect(screen.getByText('Add New Contact')).toBeInTheDocument();\n      });\n\n      // Fill out the form\n      await user.type(screen.getByLabelText('First Name'), 'New');\n      await user.type(screen.getByLabelText('Last Name'), 'Contact');\n      await user.type(screen.getByLabelText('Email'), 'new@example.com');\n      await user.type(screen.getByLabelText('Phone'), '555-9999');\n\n      // Handle gender selection - click the select to open dropdown, then click Male\n      await user.click(screen.getByLabelText('Gender'));\n      await waitFor(() => {\n        expect(screen.getByText('Male')).toBeInTheDocument();\n      });\n      await user.click(screen.getByText('Male'));\n\n      await user.clear(screen.getByLabelText('Age'));\n      await user.type(screen.getByLabelText('Age'), '25');\n      await user.type(screen.getByLabelText('Street Address'), '789 New St');\n      await user.type(screen.getByLabelText('City'), 'New City');\n      await user.type(screen.getByLabelText('State'), 'NY');\n      await user.type(screen.getByLabelText('ZIP Code'), '10001');\n      await user.type(screen.getByLabelText('Country'), 'USA');\n\n      const submitButtons = screen.getAllByRole('button', { name: /add contact/i });\n      const submitButton = submitButtons.find(btn => btn.getAttribute('type') === 'submit');\n      expect(submitButton).toBeInTheDocument();\n      await user.click(submitButton!);\n\n      await waitFor(() => {\n        expect(screen.getByText('New Contact')).toBeInTheDocument();\n      });\n    });\n  });\n\n  describe('Edit Contact', () => {\n    it('should open edit modal when clicking edit action', async () => {\n      const user = userEvent.setup();\n      renderWithAuth(<AddressBookPage />);\n\n      await waitFor(() => {\n        expect(screen.getByText('John Doe')).toBeInTheDocument();\n      });\n\n      const editButtons = screen.getAllByRole('button', { name: /edit/i });\n      expect(editButtons.length).toBeGreaterThan(0);\n      const editButton = editButtons[0];\n      if (!editButton) {\n        throw new Error('Edit button not found');\n      }\n      await user.click(editButton);\n      await waitFor(() => {\n        expect(screen.getByText('Edit Contact')).toBeInTheDocument();\n        expect(screen.getByDisplayValue('John')).toBeInTheDocument();\n        expect(screen.getByDisplayValue('Doe')).toBeInTheDocument();\n      });\n    });\n\n    it.skip('should update contact successfully', async () => {\n      const user = userEvent.setup();\n      renderWithAuth(<AddressBookPage />);\n\n      await waitFor(() => {\n        expect(screen.getByText('John Doe')).toBeInTheDocument();\n      });\n\n      const editButtons = screen.getAllByRole('button', { name: /edit/i });\n      const editButton = editButtons[0];\n      if (!editButton) {\n        throw new Error('Edit button not found');\n      }\n      await user.click(editButton);\n\n      await waitFor(() => {\n        expect(screen.getByText('Edit Contact')).toBeInTheDocument();\n      });\n\n      // Update the form\n      const firstNameInput = screen.getByDisplayValue('John');\n      await user.clear(firstNameInput);\n      await user.type(firstNameInput, 'Johnny');\n\n      const submitButton = screen.getByRole('button', { name: /update contact/i });\n      await user.click(submitButton);\n\n      await waitFor(() => {\n        expect(screen.getByText('Johnny Doe')).toBeInTheDocument();\n      });\n    });\n\n    it('should cancel edit without saving', async () => {\n      const user = userEvent.setup();\n      renderWithAuth(<AddressBookPage />);\n\n      await waitFor(() => {\n        expect(screen.getByText('John Doe')).toBeInTheDocument();\n      });\n\n      const editButtons = screen.getAllByRole('button', { name: /edit/i });\n      const editButton = editButtons[0];\n      if (!editButton) {\n        throw new Error('Edit button not found');\n      }\n      await user.click(editButton);\n\n      await waitFor(() => {\n        expect(screen.getByText('Edit Contact')).toBeInTheDocument();\n      });\n\n      // Update the form\n      const firstNameInput = screen.getByDisplayValue('John');\n      await user.clear(firstNameInput);\n      await user.type(firstNameInput, 'Johnny');\n\n      const cancelButton = screen.getByRole('button', { name: /cancel/i });\n      await user.click(cancelButton);\n\n      await waitFor(() => {\n        expect(screen.getByText('John Doe')).toBeInTheDocument();\n        expect(screen.queryByText('Johnny Doe')).not.toBeInTheDocument();\n      });\n    });\n  });\n\n  describe('Delete Contact', () => {\n    it('should show delete confirmation modal', async () => {\n      const user = userEvent.setup();\n      renderWithAuth(<AddressBookPage />);\n\n      await waitFor(() => {\n        expect(screen.getByText('John Doe')).toBeInTheDocument();\n      });\n\n      const deleteButtons = screen.getAllByRole('button', { name: /delete/i });\n      expect(deleteButtons.length).toBeGreaterThan(0);\n      const deleteButton = deleteButtons[0];\n      if (!deleteButton) {\n        throw new Error('Delete button not found');\n      }\n      await user.click(deleteButton);\n      await waitFor(() => {\n        expect(screen.getByText('Delete Contact')).toBeInTheDocument();\n        expect(screen.getByText(/are you sure/i)).toBeInTheDocument();\n      });\n    });\n\n    it.skip('should cancel delete when clicking cancel', async () => {\n      const user = userEvent.setup();\n      renderWithAuth(<AddressBookPage />);\n\n      await waitFor(() => {\n        expect(screen.getByText('John Doe')).toBeInTheDocument();\n      });\n\n      const deleteButtons = screen.getAllByRole('button', { name: /delete/i });\n      const deleteButton = deleteButtons[0];\n      if (!deleteButton) {\n        throw new Error('Delete button not found');\n      }\n      await user.click(deleteButton);\n\n      await waitFor(() => {\n        expect(screen.getByText('Delete Contact')).toBeInTheDocument();\n      });\n\n      const cancelButton = screen.getByRole('button', { name: /cancel/i });\n      await user.click(cancelButton);\n\n      await waitFor(() => {\n        expect(screen.queryByText('Delete Contact')).not.toBeInTheDocument();\n        expect(screen.getByText('John Doe')).toBeInTheDocument();\n      });\n    });\n\n    it.skip('should delete contact successfully', async () => {\n      const user = userEvent.setup();\n      renderWithAuth(<AddressBookPage />);\n\n      await waitFor(() => {\n        expect(screen.getByText('John Doe')).toBeInTheDocument();\n      });\n\n      const deleteButtons = screen.getAllByRole('button', { name: /delete/i });\n      const deleteButton = deleteButtons[0];\n      if (!deleteButton) {\n        throw new Error('Delete button not found');\n      }\n      await user.click(deleteButton);\n\n      await waitFor(() => {\n        expect(screen.getByText('Delete Contact')).toBeInTheDocument();\n      });\n\n      const confirmButtons = screen.getAllByRole('button', { name: /delete/i });\n      const confirmButton = confirmButtons.find(\n        btn => btn.getAttribute('type') === 'button' && btn.textContent?.includes('Delete')\n      );\n      expect(confirmButton).toBeInTheDocument();\n      await user.click(confirmButton!);\n\n      await waitFor(() => {\n        expect(screen.queryByText('John Doe')).not.toBeInTheDocument();\n        expect(screen.getByText('Jane Smith')).toBeInTheDocument();\n      });\n    });\n  });\n\n  describe('Validation', () => {\n    it('should validate email format', async () => {\n      const user = userEvent.setup();\n      renderWithAuth(<AddressBookPage />);\n\n      await waitFor(() => {\n        expect(screen.getByText('John Doe')).toBeInTheDocument();\n      });\n\n      // Use more specific selector to avoid multiple matches\n      const addButtons = screen.getAllByRole('button', { name: /add contact/i });\n      const addButton = addButtons.find(btn => btn.getAttribute('type') === 'button');\n      expect(addButton).toBeInTheDocument();\n      await user.click(addButton!);\n\n      await waitFor(() => {\n        expect(screen.getByText('Add New Contact')).toBeInTheDocument();\n      });\n\n      // Fill required fields first\n      await user.type(screen.getByLabelText('First Name'), 'Test');\n      await user.type(screen.getByLabelText('Last Name'), 'User');\n      await user.type(screen.getByLabelText('Email'), 'invalid-email');\n      await user.click(screen.getByLabelText('Gender'));\n      await waitFor(() => {\n        expect(screen.getByText('Male')).toBeInTheDocument();\n      });\n      await user.click(screen.getByText('Male'));\n      await user.clear(screen.getByLabelText('Age'));\n      await user.type(screen.getByLabelText('Age'), '25');\n      await user.type(screen.getByLabelText('Street Address'), '123 Test St');\n      await user.type(screen.getByLabelText('City'), 'Test City');\n      await user.type(screen.getByLabelText('State'), 'TS');\n      await user.type(screen.getByLabelText('ZIP Code'), '12345');\n      await user.type(screen.getByLabelText('Country'), 'USA');\n\n      const submitButtons = screen.getAllByRole('button', { name: /add contact/i });\n      const submitButton = submitButtons.find(btn => btn.getAttribute('type') === 'submit');\n      expect(submitButton).toBeInTheDocument();\n      await user.click(submitButton!);\n\n      await waitFor(() => {\n        expect(screen.getByText(/please enter a valid email/i)).toBeInTheDocument();\n      });\n    });\n\n    it.skip('should validate age range', async () => {\n      const user = userEvent.setup();\n      renderWithAuth(<AddressBookPage />);\n\n      await waitFor(() => {\n        expect(screen.getByText('John Doe')).toBeInTheDocument();\n      });\n\n      // Use more specific selector to avoid multiple matches\n      const addButtons = screen.getAllByRole('button', { name: /add contact/i });\n      const addButton = addButtons.find(btn => btn.getAttribute('type') === 'button');\n      expect(addButton).toBeInTheDocument();\n      await user.click(addButton!);\n\n      await waitFor(() => {\n        expect(screen.getByText('Add New Contact')).toBeInTheDocument();\n      });\n\n      // Fill required fields first\n      await user.type(screen.getByLabelText('First Name'), 'Test');\n      await user.type(screen.getByLabelText('Last Name'), 'User');\n      await user.type(screen.getByLabelText('Email'), 'test@example.com');\n      await user.click(screen.getByLabelText('Gender'));\n      await waitFor(() => {\n        expect(screen.getByText('Male')).toBeInTheDocument();\n      });\n      await user.click(screen.getByText('Male'));\n      await user.clear(screen.getByLabelText('Age'));\n      await user.type(screen.getByLabelText('Age'), '150'); // Invalid age\n      await user.type(screen.getByLabelText('Street Address'), '123 Test St');\n      await user.type(screen.getByLabelText('City'), 'Test City');\n      await user.type(screen.getByLabelText('State'), 'TS');\n      await user.type(screen.getByLabelText('ZIP Code'), '12345');\n      await user.type(screen.getByLabelText('Country'), 'USA');\n\n      const submitButtons = screen.getAllByRole('button', { name: /add contact/i });\n      const submitButton = submitButtons.find(btn => btn.getAttribute('type') === 'submit');\n      expect(submitButton).toBeInTheDocument();\n      await user.click(submitButton!);\n\n      await waitFor(() => {\n        expect(screen.getByText(/age must be between 1 and 120/i)).toBeInTheDocument();\n      });\n    });\n\n    it.skip('should validate required fields', async () => {\n      const user = userEvent.setup();\n      renderWithAuth(<AddressBookPage />);\n\n      await waitFor(() => {\n        expect(screen.getByText('John Doe')).toBeInTheDocument();\n      });\n\n      // Use more specific selector to avoid multiple matches\n      const addButtons = screen.getAllByRole('button', { name: /add contact/i });\n      const addButton = addButtons.find(btn => btn.getAttribute('type') === 'button');\n      expect(addButton).toBeInTheDocument();\n      await act(async () => {\n        await user.click(addButton!);\n      });\n\n      await waitFor(() => {\n        expect(screen.getByText('Add New Contact')).toBeInTheDocument();\n      });\n\n      const submitButtons = screen.getAllByRole('button', { name: /add contact/i });\n      const submitButton = submitButtons.find(btn => btn.getAttribute('type') === 'submit');\n      expect(submitButton).toBeInTheDocument();\n      await user.click(submitButton!);\n      await user.click(submitButton!);\n\n      await waitFor(() => {\n        expect(screen.getByText(/please enter first name/i)).toBeInTheDocument();\n        expect(screen.getByText(/please enter last name/i)).toBeInTheDocument();\n        expect(screen.getByText(/please select gender/i)).toBeInTheDocument();\n        expect(screen.getByText(/please enter age/i)).toBeInTheDocument();\n        expect(screen.getByText(/please enter street address/i)).toBeInTheDocument();\n        expect(screen.getByText(/please enter city/i)).toBeInTheDocument();\n        expect(screen.getByText(/please enter state/i)).toBeInTheDocument();\n        expect(screen.getByText(/please enter zip code/i)).toBeInTheDocument();\n        expect(screen.getByText(/please enter country/i)).toBeInTheDocument();\n      });\n    });\n  });\n\n  describe('Error Handling', () => {\n    it.skip('should display error when API fails to load contacts', async () => {\n      server.use(\n        http.get(`${API_BASE_URL}/address-book`, () => {\n          return HttpResponse.json(\n            { message: 'Failed to load contacts', data: null },\n            { status: 500 }\n          );\n        })\n      );\n\n      renderWithAuth(<AddressBookPage />);\n\n      await waitFor(() => {\n        expect(screen.getByText('Error Loading Contacts')).toBeInTheDocument();\n        expect(screen.getByText('Failed to load contacts')).toBeInTheDocument();\n      });\n    });\n\n    it.skip('should provide retry option on error', async () => {\n      server.use(\n        http.get(`${API_BASE_URL}/address-book`, () => {\n          return HttpResponse.json({ message: 'Failed to load', data: null }, { status: 500 });\n        })\n      );\n\n      renderWithAuth(<AddressBookPage />);\n\n      await waitFor(() => {\n        expect(screen.getByRole('button', { name: /retry/i })).toBeInTheDocument();\n      });\n    });\n\n    it.skip('should handle create contact API error', async () => {\n      server.resetHandlers();\n      server.use(\n        http.get(`${API_BASE_URL}/address-book`, () => {\n          return HttpResponse.json({\n            status: 'success',\n            message: 'Contacts retrieved',\n            data: {\n              contacts: mockContacts,\n              total: mockContacts.length,\n              currentPage: 1,\n              totalPages: 1,\n              limit: mockContacts.length,\n              hasNext: false,\n              hasPrev: false,\n            },\n          });\n        }),\n        http.post(`${API_BASE_URL}/address-book`, () => {\n          return HttpResponse.json(\n            { message: 'Failed to create contact', data: null },\n            { status: 500 }\n          );\n        })\n      );\n\n      const user = userEvent.setup();\n      renderWithAuth(<AddressBookPage />);\n\n      await waitFor(() => {\n        expect(screen.getByText('John Doe')).toBeInTheDocument();\n      });\n\n      // Use more specific selector to avoid multiple matches\n      const addButtons = screen.getAllByRole('button', { name: /add contact/i });\n      const addButton = addButtons.find(btn => btn.getAttribute('type') === 'button');\n      expect(addButton).toBeInTheDocument();\n      await act(async () => {\n        await user.click(addButton!);\n      });\n\n      await waitFor(() => {\n        expect(screen.getByText('Add New Contact')).toBeInTheDocument();\n      });\n\n      // Fill out the form\n      await user.type(screen.getByLabelText('First Name'), 'New');\n      await user.type(screen.getByLabelText('Last Name'), 'Contact');\n      await user.type(screen.getByLabelText('Email'), 'new@example.com');\n      await user.type(screen.getByLabelText('Phone'), '555-9999');\n\n      // Handle gender selection\n      await act(async () => {\n        await user.click(screen.getByLabelText('Gender'));\n      });\n      await waitFor(() => {\n        expect(screen.getByText('Male')).toBeInTheDocument();\n      });\n      await act(async () => {\n        await user.click(screen.getByText('Male'));\n      });\n\n      await user.clear(screen.getByLabelText('Age'));\n      await user.type(screen.getByLabelText('Age'), '25');\n      await user.type(screen.getByLabelText('Street Address'), '789 New St');\n      await user.type(screen.getByLabelText('City'), 'New City');\n      await user.type(screen.getByLabelText('State'), 'NY');\n      await user.type(screen.getByLabelText('ZIP Code'), '10001');\n      await user.type(screen.getByLabelText('Country'), 'USA');\n\n      const submitButtons = screen.getAllByRole('button', { name: /add contact/i });\n      const submitButton = submitButtons.find(btn => btn.getAttribute('type') === 'submit');\n      expect(submitButton).toBeInTheDocument();\n      await user.click(submitButton!);\n\n      await waitFor(() => {\n        expect(screen.getByText('Failed to create contact')).toBeInTheDocument();\n      });\n    });\n\n    it.skip('should handle update contact API error', async () => {\n      server.resetHandlers();\n      server.use(\n        http.get(`${API_BASE_URL}/address-book`, () => {\n          return HttpResponse.json({\n            status: 'success',\n            message: 'Contacts retrieved',\n            data: {\n              contacts: mockContacts,\n              total: mockContacts.length,\n              currentPage: 1,\n              totalPages: 1,\n              limit: mockContacts.length,\n              hasNext: false,\n              hasPrev: false,\n            },\n          });\n        }),\n        http.put(`${API_BASE_URL}/address-book/:id`, () => {\n          return HttpResponse.json(\n            { message: 'Failed to update contact', data: null },\n            { status: 500 }\n          );\n        })\n      );\n\n      const user = userEvent.setup();\n      renderWithAuth(<AddressBookPage />);\n\n      await waitFor(() => {\n        expect(screen.getByText('John Doe')).toBeInTheDocument();\n      });\n\n      const editButtons = screen.getAllByRole('button', { name: /edit/i });\n      const editButton = editButtons[0];\n      if (!editButton) {\n        throw new Error('Edit button not found');\n      }\n      await user.click(editButton);\n\n      await waitFor(() => {\n        expect(screen.getByText('Edit Contact')).toBeInTheDocument();\n      });\n\n      // Update the form\n      const firstNameInput = screen.getByDisplayValue('John');\n      await user.clear(firstNameInput);\n      await user.type(firstNameInput, 'Johnny');\n\n      const submitButton = screen.getByRole('button', { name: /update contact/i });\n      await user.click(submitButton);\n\n      await waitFor(() => {\n        expect(screen.getByText('Operation Failed')).toBeInTheDocument();\n        expect(screen.getByText('Failed to update contact')).toBeInTheDocument();\n      });\n    });\n\n    it.skip('should handle delete contact API error', async () => {\n      server.resetHandlers();\n      server.use(\n        http.get(`${API_BASE_URL}/address-book`, () => {\n          return HttpResponse.json({\n            status: 'success',\n            message: 'Contacts retrieved',\n            data: {\n              contacts: mockContacts,\n              total: mockContacts.length,\n              currentPage: 1,\n              totalPages: 1,\n              limit: mockContacts.length,\n              hasNext: false,\n              hasPrev: false,\n            },\n          });\n        }),\n        http.delete(`${API_BASE_URL}/address-book/:id`, () => {\n          return HttpResponse.json(\n            { message: 'Failed to delete contact', data: null },\n            { status: 500 }\n          );\n        })\n      );\n\n      const user = userEvent.setup();\n      renderWithAuth(<AddressBookPage />);\n\n      await waitFor(() => {\n        expect(screen.getByText('John Doe')).toBeInTheDocument();\n      });\n\n      const deleteButtons = screen.getAllByRole('button', { name: /delete/i });\n      const deleteButton = deleteButtons[0];\n      if (!deleteButton) {\n        throw new Error('Delete button not found');\n      }\n      await user.click(deleteButton);\n\n      // Wait for the modal to appear and get the modal element\n      const modal = await screen.findByRole('dialog');\n      expect(modal).toBeInTheDocument();\n\n      // Use within to scope the query to the modal\n      const queries = within(modal);\n      expect(queries.getByText('Delete Contact')).toBeInTheDocument();\n\n      const confirmButtons = screen.getAllByRole('button', { name: /delete/i });\n      const confirmButton = confirmButtons.find(\n        btn => btn.getAttribute('type') === 'button' && btn.textContent?.includes('Delete')\n      );\n      expect(confirmButton).toBeInTheDocument();\n      await user.click(confirmButton!);\n\n      await waitFor(() => {\n        expect(screen.getByText('Operation Failed')).toBeInTheDocument();\n        expect(screen.getByText('Failed to delete contact')).toBeInTheDocument();\n      });\n    });\n\n    it('should handle network timeout', async () => {\n      server.use(\n        http.get(`${API_BASE_URL}/address-book`, () => {\n          // eslint-disable-next-line @typescript-eslint/no-empty-function\n          return new Promise(() => {}); // Never resolves\n        })\n      );\n\n      renderWithAuth(<AddressBookPage />);\n\n      // Should show loading state\n      await waitFor(() => {\n        expect(screen.getByText('Loading contacts...')).toBeInTheDocument();\n      });\n    });\n  });\n\n  describe('Accessibility', () => {\n    it('should have proper table semantics', async () => {\n      renderWithAuth(<AddressBookPage />);\n\n      await waitFor(() => {\n        expect(screen.getByRole('table')).toBeInTheDocument();\n      });\n    });\n\n    it('should have accessible buttons with proper labels', async () => {\n      const user = userEvent.setup();\n      renderWithAuth(<AddressBookPage />);\n\n      await waitFor(() => {\n        expect(screen.getByText('John Doe')).toBeInTheDocument();\n      });\n\n      const addButton = screen.getByRole('button', { name: /add contact/i });\n      expect(addButton).toBeInTheDocument();\n      await user.click(addButton);\n\n      // Get the descriptive text from aria-label or textContent\n      const ariaLabel = addButton.getAttribute('aria-label');\n      const textContent = addButton.textContent?.trim() ?? '';\n      const descriptiveText = ariaLabel ?? textContent;\n\n      // Verify we have a descriptive string and it matches a meaningful pattern\n      expect(descriptiveText).toBeTruthy();\n      expect(descriptiveText).toMatch(/add contact/i);\n    });\n\n    it('should support keyboard navigation', async () => {\n      const user = userEvent.setup();\n      renderWithAuth(<AddressBookPage />);\n\n      // Wait for the component to load\n      await waitFor(() => {\n        expect(screen.getByPlaceholderText(/search contacts/i)).toBeInTheDocument();\n      });\n\n      // Get the expected tabbable elements using case-insensitive regex selectors\n      const searchInput = screen.getByPlaceholderText(/search contacts/i);\n      // Use more specific selector to avoid multiple matches\n      const addButtons = screen.getAllByRole('button', { name: /add contact/i });\n      const addButton = addButtons.find(btn => btn.getAttribute('type') === 'button');\n      expect(addButton).toBeInTheDocument();\n      await user.click(addButton!);\n\n      // Test initial tab - should focus on one of the expected interactive elements\n      await user.tab();\n      const firstFocusedElement = document.activeElement as HTMLElement;\n      expect([searchInput, addButton]).toContain(firstFocusedElement);\n\n      // Second tab should move to next focusable element\n      await user.tab();\n      // Verify focus moved to a focusable element, not stuck on body\n      expect(document.activeElement).not.toBe(document.body);\n      // Table headers (TH) are also focusable in some browsers, so allow them\n      expect(document.activeElement?.tagName).toMatch(/BUTTON|INPUT|A|TH/);\n    });\n\n    it('should have proper form labels', async () => {\n      const user = userEvent.setup();\n      renderWithAuth(<AddressBookPage />);\n\n      await waitFor(() => {\n        expect(screen.getByText('John Doe')).toBeInTheDocument();\n      });\n\n      // Use more specific selector to avoid multiple matches\n      const addButtons = screen.getAllByRole('button', { name: /add contact/i });\n      const addButton = addButtons.find(btn => btn.getAttribute('type') === 'button');\n      expect(addButton).toBeInTheDocument();\n      await act(async () => {\n        await user.click(addButton!);\n      });\n\n      await waitFor(() => {\n        expect(screen.getByText('Add New Contact')).toBeInTheDocument();\n      });\n\n      // Check that all form fields have proper labels\n      expect(screen.getByLabelText('First Name')).toBeInTheDocument();\n      expect(screen.getByLabelText('Last Name')).toBeInTheDocument();\n      expect(screen.getByLabelText('Email')).toBeInTheDocument();\n      expect(screen.getByLabelText('Phone')).toBeInTheDocument();\n      expect(screen.getByLabelText('Gender')).toBeInTheDocument();\n      expect(screen.getByLabelText('Age')).toBeInTheDocument();\n    });\n  });\n\n  describe('Empty State', () => {\n    it('should display empty state when no contacts exist', async () => {\n      server.use(\n        http.get(`${API_BASE_URL}/address-book`, () => {\n          return HttpResponse.json({\n            status: 'success',\n            message: 'Contacts retrieved',\n            data: {\n              contacts: [],\n              total: 0,\n              currentPage: 1,\n              totalPages: 0,\n              limit: 10,\n              hasNext: false,\n              hasPrev: false,\n            },\n          });\n        })\n      );\n\n      renderWithAuth(<AddressBookPage />);\n\n      await waitFor(() => {\n        expect(screen.getByText(/no contacts yet/i)).toBeInTheDocument();\n      });\n    });\n  });\n\n  describe('Edge Cases', () => {\n    it('should handle malformed API response', async () => {\n      server.use(\n        http.get(`${API_BASE_URL}/address-book`, () => {\n          return HttpResponse.json({\n            status: 'success',\n            message: 'Contacts retrieved',\n            data: {\n              contacts: null, // Malformed response\n              total: 0,\n            },\n          });\n        })\n      );\n\n      renderWithAuth(<AddressBookPage />);\n\n      await waitFor(() => {\n        expect(screen.getByText(/no contacts yet/i)).toBeInTheDocument();\n      });\n    });\n\n    it('should handle missing tenant context', async () => {\n      // This test would require mocking the AuthContext to return null tenant\n      // For now, we'll test the component behavior when tenant is undefined\n      renderWithAuth(<AddressBookPage />);\n\n      // Should still render the component structure\n      expect(screen.getByText('Address Book')).toBeInTheDocument();\n    });\n\n    it.skip('should handle form submission with network error', async () => {\n      server.use(\n        http.post(`${API_BASE_URL}/address-book`, () => {\n          return HttpResponse.error();\n        })\n      );\n\n      const user = userEvent.setup();\n      renderWithAuth(<AddressBookPage />);\n\n      await waitFor(() => {\n        expect(screen.getByText('John Doe')).toBeInTheDocument();\n      });\n\n      // Use more specific selector to avoid multiple matches\n      const addButtons = screen.getAllByRole('button', { name: /add contact/i });\n      const addButton = addButtons.find(btn => btn.getAttribute('type') === 'button');\n      expect(addButton).toBeInTheDocument();\n      await act(async () => {\n        await user.click(addButton!);\n      });\n\n      await waitFor(() => {\n        expect(screen.getByText('Add New Contact')).toBeInTheDocument();\n      });\n\n      // Fill out the form\n      await user.type(screen.getByLabelText('First Name'), 'New');\n      await user.type(screen.getByLabelText('Last Name'), 'Contact');\n      await user.type(screen.getByLabelText('Email'), 'new@example.com');\n      await user.click(screen.getByLabelText('Gender'));\n      await user.click(screen.getByText('Male'));\n      await user.clear(screen.getByLabelText('Age'));\n      await user.type(screen.getByLabelText('Age'), '25');\n      await user.type(screen.getByLabelText('Street Address'), '789 New St');\n      await user.type(screen.getByLabelText('City'), 'New City');\n      await user.type(screen.getByLabelText('State'), 'NY');\n      await user.type(screen.getByLabelText('ZIP Code'), '10001');\n      await user.type(screen.getByLabelText('Country'), 'USA');\n\n      const submitButtons = screen.getAllByRole('button', { name: /add contact/i });\n      const submitButton = submitButtons.find(btn => btn.getAttribute('type') === 'submit');\n      expect(submitButton).toBeInTheDocument();\n      await act(async () => {\n        await user.click(submitButton!);\n      });\n\n      // Should handle the network error gracefully\n      await waitFor(() => {\n        expect(screen.getByText(/an error occurred/i)).toBeInTheDocument();\n      });\n    });\n\n    it.skip('should handle concurrent form submissions', async () => {\n      const user = userEvent.setup();\n      renderWithAuth(<AddressBookPage />);\n\n      await waitFor(() => {\n        expect(screen.getByText('John Doe')).toBeInTheDocument();\n      });\n\n      // Use more specific selector to avoid multiple matches\n      const addButtons = screen.getAllByRole('button', { name: /add contact/i });\n      const addButton = addButtons.find(btn => btn.getAttribute('type') === 'button');\n      expect(addButton).toBeInTheDocument();\n      await act(async () => {\n        await user.click(addButton!);\n      });\n\n      await waitFor(() => {\n        expect(screen.getByText('Add New Contact')).toBeInTheDocument();\n      });\n\n      // Fill out the form\n      await user.type(screen.getByLabelText('First Name'), 'New');\n      await user.type(screen.getByLabelText('Last Name'), 'Contact');\n      await user.type(screen.getByLabelText('Email'), 'new@example.com');\n      await user.click(screen.getByLabelText('Gender'));\n      await user.click(screen.getByText('Male'));\n      await user.clear(screen.getByLabelText('Age'));\n      await user.type(screen.getByLabelText('Age'), '25');\n      await user.type(screen.getByLabelText('Street Address'), '789 New St');\n      await user.type(screen.getByLabelText('City'), 'New City');\n      await user.type(screen.getByLabelText('State'), 'NY');\n      await user.type(screen.getByLabelText('ZIP Code'), '10001');\n      await user.type(screen.getByLabelText('Country'), 'USA');\n\n      const submitButtons = screen.getAllByRole('button', { name: /add contact/i });\n      const submitButton = submitButtons.find(btn => btn.getAttribute('type') === 'submit');\n      expect(submitButton).toBeInTheDocument();\n      if (!submitButton) {\n        throw new Error('Submit button not found');\n      }\n      await user.click(submitButton);\n\n      // Click submit multiple times rapidly\n      await user.click(submitButton);\n      await user.click(submitButton);\n      await user.click(submitButton);\n\n      // Should handle concurrent submissions gracefully\n      await waitFor(() => {\n        expect(screen.getByText('New Contact')).toBeInTheDocument();\n      });\n    });\n  });\n\n  describe('Pagination', () => {\n    it.skip('should handle pagination', () => {\n      // TODO: Implement pagination test after backend supports limit/offset\n      const _user = userEvent.setup();\n      renderWithAuth(<AddressBookPage />);\n      // Pagination implementation needed\n    });\n  });\n\n  describe('Sorting', () => {\n    it('should sort contacts by column', async () => {\n      // Override mockContacts with a sortable set\n      mockContacts = [\n        {\n          id: 1,\n          tenant_id: 'tenant-1',\n          first_name: 'Zoe',\n          last_name: 'Zeller',\n          email: 'zoe@example.com',\n          phone: '555-0001',\n          age: 25,\n          gender: 'female',\n          address: '111 A St',\n          created_at: new Date().toISOString(),\n          updated_at: new Date().toISOString(),\n        },\n        {\n          id: 2,\n          tenant_id: 'tenant-1',\n          first_name: 'Alice',\n          last_name: 'Anderson',\n          email: 'alice@example.com',\n          phone: '555-0002',\n          age: 35,\n          gender: 'female',\n          address: '222 B St',\n          created_at: new Date().toISOString(),\n          updated_at: new Date().toISOString(),\n        },\n        {\n          id: 3,\n          tenant_id: 'tenant-1',\n          first_name: 'Mike',\n          last_name: 'Miller',\n          email: 'mike@example.com',\n          phone: '555-0003',\n          age: 30,\n          gender: 'male',\n          address: '333 C St',\n          created_at: new Date().toISOString(),\n          updated_at: new Date().toISOString(),\n        },\n      ];\n\n      const user = userEvent.setup();\n      renderWithAuth(<AddressBookPage />);\n\n      // Wait for initial load\n      await waitFor(() => {\n        expect(screen.getByText('Zoe Zeller')).toBeInTheDocument();\n        expect(screen.getByText('Alice Anderson')).toBeInTheDocument();\n        expect(screen.getByText('Mike Miller')).toBeInTheDocument();\n      });\n\n      // Get all rows except the header\n      const getNames = () =>\n        screen\n          .getAllByRole('row')\n          .slice(1)\n          .map(row => {\n            const cell = row.querySelector('td');\n            return cell ? cell.textContent : '';\n          });\n\n      // Initial order should match mockContacts (Zoe, Alice, Mike)\n      let names = getNames();\n      expect(names).toEqual(['Zoe Zeller', 'Alice Anderson', 'Mike Miller']);\n\n      // Click the \"Name\" column header to sort (assuming ascending)\n      const nameHeader = screen.getByRole('columnheader', { name: /name/i });\n      await user.click(nameHeader);\n\n      // Wait for the order to change (should be Alice, Mike, Zoe)\n      await waitFor(() => {\n        names = getNames();\n        expect(names).toEqual(['Alice Anderson', 'Mike Miller', 'Zoe Zeller']);\n      });\n\n      // Click again to sort descending\n      await user.click(nameHeader);\n\n      await waitFor(() => {\n        names = getNames();\n        expect(names).toEqual(['Zoe Zeller', 'Mike Miller', 'Alice Anderson']);\n      });\n    });\n  });\n});\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/pages/__tests__/ContactManagementFlow.test.tsx",
        "messages": [
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.",
                "line": 90,
                "column": 23,
                "nodeType": "TSAsExpression",
                "messageId": "neverNullish",
                "endLine": 90,
                "endColumn": 46
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.",
                "line": 91,
                "column": 36,
                "nodeType": "TSAsExpression",
                "messageId": "neverNullish",
                "endLine": 91,
                "endColumn": 59
            },
            {
                "ruleId": "@typescript-eslint/require-await",
                "severity": 1,
                "message": "Async arrow function has no 'await' expression.",
                "line": 106,
                "column": 43,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingAwait",
                "endLine": 106,
                "endColumn": 45,
                "suggestions": [
                    {
                        "messageId": "removeAsync",
                        "fix": {
                            "range": [
                                3554,
                                3560
                            ],
                            "text": ""
                        },
                        "desc": "Remove 'async'."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 116,
                "column": 9,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 116,
                "endColumn": 21,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                3850,
                                3862
                            ],
                            "text": "currentToken != null"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                3850,
                                3862
                            ],
                            "text": "currentToken ?? \"\""
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                3850,
                                3862
                            ],
                            "text": "Boolean(currentToken)"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 139,
                "column": 10,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 139,
                "endColumn": 20,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                4494,
                                4505
                            ],
                            "text": "(authHeader == null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                4495,
                                4505
                            ],
                            "text": "(authHeader ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                4494,
                                4505
                            ],
                            "text": "(!Boolean(authHeader))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 139,
                "column": 25,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 139,
                "endColumn": 37,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                4509,
                                4522
                            ],
                            "text": "(currentToken == null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                4510,
                                4522
                            ],
                            "text": "(currentToken ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                4509,
                                4522
                            ],
                            "text": "(!Boolean(currentToken))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 142,
                "column": 22,
                "nodeType": "CallExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 142,
                "endColumn": 56,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                4647,
                                4681
                            ],
                            "text": "(request.headers.get('x-tenant-id') != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                4647,
                                4681
                            ],
                            "text": "(request.headers.get('x-tenant-id') ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                4647,
                                4681
                            ],
                            "text": "(Boolean(request.headers.get('x-tenant-id')))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 142,
                "column": 57,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 142,
                "endColumn": 59,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                4682,
                                4684
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 143,
                "column": 47,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 143,
                "endColumn": 49,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                4743,
                                4745
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 149,
                "column": 22,
                "nodeType": "CallExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 149,
                "endColumn": 56,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                4956,
                                4990
                            ],
                            "text": "(request.headers.get('x-tenant-id') != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                4956,
                                4990
                            ],
                            "text": "(request.headers.get('x-tenant-id') ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                4956,
                                4990
                            ],
                            "text": "(Boolean(request.headers.get('x-tenant-id')))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 149,
                "column": 57,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 149,
                "endColumn": 59,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                4991,
                                4993
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 150,
                "column": 59,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 150,
                "endColumn": 62,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                5064,
                                5067
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                5064,
                                5067
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected any value in conditional. An explicit comparison or type conversion is required.",
                "line": 152,
                "column": 10,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorAny",
                "endLine": 152,
                "endColumn": 24,
                "suggestions": [
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                5124,
                                5138
                            ],
                            "text": "(Boolean(body.firstName))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, value is always truthy.",
                "line": 158,
                "column": 18,
                "nodeType": "MemberExpression",
                "messageId": "alwaysTruthy",
                "endLine": 158,
                "endColumn": 42
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 162,
                "column": 7,
                "nodeType": "Property",
                "messageId": "anyAssignment",
                "endLine": 162,
                "endColumn": 32
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 163,
                "column": 7,
                "nodeType": "Property",
                "messageId": "anyAssignment",
                "endLine": 163,
                "endColumn": 36
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected any value in conditional. An explicit comparison or type conversion is required.",
                "line": 163,
                "column": 17,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorAny",
                "endLine": 163,
                "endColumn": 30,
                "suggestions": [
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                5528,
                                5541
                            ],
                            "text": "(Boolean(body.lastName))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 163,
                "column": 31,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 163,
                "endColumn": 33,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                5542,
                                5544
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/restrict-template-expressions",
                "severity": 1,
                "message": "Invalid type \"any\" of template literal expression.",
                "line": 164,
                "column": 20,
                "nodeType": "MemberExpression",
                "messageId": "invalidType",
                "endLine": 164,
                "endColumn": 34
            },
            {
                "ruleId": "@typescript-eslint/restrict-template-expressions",
                "severity": 1,
                "message": "Invalid type \"any\" of template literal expression.",
                "line": 164,
                "column": 38,
                "nodeType": "LogicalExpression",
                "messageId": "invalidType",
                "endLine": 164,
                "endColumn": 57
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected any value in conditional. An explicit comparison or type conversion is required.",
                "line": 164,
                "column": 38,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorAny",
                "endLine": 164,
                "endColumn": 51,
                "suggestions": [
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                5586,
                                5599
                            ],
                            "text": "(Boolean(body.lastName))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 164,
                "column": 52,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 164,
                "endColumn": 54,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                5600,
                                5602
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 165,
                "column": 7,
                "nodeType": "Property",
                "messageId": "anyAssignment",
                "endLine": 165,
                "endColumn": 30
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected any value in conditional. An explicit comparison or type conversion is required.",
                "line": 165,
                "column": 14,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorAny",
                "endLine": 165,
                "endColumn": 24,
                "suggestions": [
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                5629,
                                5639
                            ],
                            "text": "(Boolean(body.email))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 165,
                "column": 25,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 165,
                "endColumn": 27,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                5640,
                                5642
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 166,
                "column": 7,
                "nodeType": "Property",
                "messageId": "anyAssignment",
                "endLine": 166,
                "endColumn": 30
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected any value in conditional. An explicit comparison or type conversion is required.",
                "line": 166,
                "column": 14,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorAny",
                "endLine": 166,
                "endColumn": 24,
                "suggestions": [
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                5660,
                                5670
                            ],
                            "text": "(Boolean(body.phone))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 166,
                "column": 25,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 166,
                "endColumn": 27,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                5671,
                                5673
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 167,
                "column": 7,
                "nodeType": "Property",
                "messageId": "anyAssignment",
                "endLine": 167,
                "endColumn": 32
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected any value in conditional. An explicit comparison or type conversion is required.",
                "line": 167,
                "column": 15,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorAny",
                "endLine": 167,
                "endColumn": 26,
                "suggestions": [
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                5692,
                                5703
                            ],
                            "text": "(Boolean(body.mobile))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 167,
                "column": 27,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 167,
                "endColumn": 29,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                5704,
                                5706
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 168,
                "column": 7,
                "nodeType": "Property",
                "messageId": "anyAssignment",
                "endLine": 168,
                "endColumn": 36
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected any value in conditional. An explicit comparison or type conversion is required.",
                "line": 168,
                "column": 15,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorAny",
                "endLine": 168,
                "endColumn": 26,
                "suggestions": [
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                5725,
                                5736
                            ],
                            "text": "(Boolean(body.gender))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 168,
                "column": 27,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 168,
                "endColumn": 29,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                5737,
                                5739
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 169,
                "column": 7,
                "nodeType": "Property",
                "messageId": "anyAssignment",
                "endLine": 169,
                "endColumn": 94
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected any value in conditional. An explicit comparison or type conversion is required.",
                "line": 169,
                "column": 16,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorAny",
                "endLine": 169,
                "endColumn": 28,
                "suggestions": [
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                5763,
                                5775
                            ],
                            "text": "(Boolean(body.address))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 169,
                "column": 29,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 169,
                "endColumn": 31,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                5776,
                                5778
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 182,
                "column": 22,
                "nodeType": "CallExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 182,
                "endColumn": 56,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                6238,
                                6272
                            ],
                            "text": "(request.headers.get('x-tenant-id') != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                6238,
                                6272
                            ],
                            "text": "(request.headers.get('x-tenant-id') ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                6238,
                                6272
                            ],
                            "text": "(Boolean(request.headers.get('x-tenant-id')))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 182,
                "column": 57,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 182,
                "endColumn": 59,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                6273,
                                6275
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 184,
                "column": 42,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 184,
                "endColumn": 44,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                6355,
                                6357
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-non-null-assertion",
                "severity": 1,
                "message": "Forbidden non-null assertion.",
                "line": 199,
                "column": 29,
                "nodeType": "TSNonNullExpression",
                "messageId": "noNonNull",
                "endLine": 199,
                "endColumn": 38
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.",
                "line": 204,
                "column": 19,
                "nodeType": "TSAsExpression",
                "messageId": "neverNullish",
                "endLine": 204,
                "endColumn": 43
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.",
                "line": 205,
                "column": 18,
                "nodeType": "TSAsExpression",
                "messageId": "neverNullish",
                "endLine": 205,
                "endColumn": 41
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 214,
                "column": 22,
                "nodeType": "CallExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 214,
                "endColumn": 56,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                7470,
                                7504
                            ],
                            "text": "(request.headers.get('x-tenant-id') != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                7470,
                                7504
                            ],
                            "text": "(request.headers.get('x-tenant-id') ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                7470,
                                7504
                            ],
                            "text": "(Boolean(request.headers.get('x-tenant-id')))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 214,
                "column": 57,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 214,
                "endColumn": 59,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                7505,
                                7507
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 215,
                "column": 42,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 215,
                "endColumn": 44,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                7561,
                                7563
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 262,
                "column": 8,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 262,
                "endColumn": 18,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                9001,
                                9012
                            ],
                            "text": "(authHeader == null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                9002,
                                9012
                            ],
                            "text": "(authHeader ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                9001,
                                9012
                            ],
                            "text": "(!Boolean(authHeader))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 262,
                "column": 23,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 262,
                "endColumn": 35,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                9016,
                                9029
                            ],
                            "text": "(currentToken == null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                9017,
                                9029
                            ],
                            "text": "(currentToken ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                9016,
                                9029
                            ],
                            "text": "(!Boolean(currentToken))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 267,
                "column": 47,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 267,
                "endColumn": 49,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                9197,
                                9199
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected any value in conditional. An explicit comparison or type conversion is required.",
                "line": 288,
                "column": 12,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorAny",
                "endLine": 288,
                "endColumn": 26,
                "suggestions": [
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                9942,
                                9956
                            ],
                            "text": "(Boolean(body.firstName))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, the types have no overlap.",
                "line": 288,
                "column": 30,
                "nodeType": "BinaryExpression",
                "messageId": "noOverlapBooleanExpression",
                "endLine": 288,
                "endColumn": 53
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, value is always truthy.",
                "line": 294,
                "column": 20,
                "nodeType": "MemberExpression",
                "messageId": "alwaysTruthy",
                "endLine": 294,
                "endColumn": 44
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.",
                "line": 299,
                "column": 20,
                "nodeType": "TSAsExpression",
                "messageId": "neverNullish",
                "endLine": 299,
                "endColumn": 43
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.",
                "line": 300,
                "column": 51,
                "nodeType": "TSAsExpression",
                "messageId": "neverNullish",
                "endLine": 300,
                "endColumn": 74
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.",
                "line": 301,
                "column": 17,
                "nodeType": "TSAsExpression",
                "messageId": "neverNullish",
                "endLine": 301,
                "endColumn": 37
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.",
                "line": 302,
                "column": 17,
                "nodeType": "TSAsExpression",
                "messageId": "neverNullish",
                "endLine": 302,
                "endColumn": 37
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.",
                "line": 303,
                "column": 18,
                "nodeType": "TSAsExpression",
                "messageId": "neverNullish",
                "endLine": 303,
                "endColumn": 39
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.",
                "line": 304,
                "column": 19,
                "nodeType": "TSAsExpression",
                "messageId": "neverNullish",
                "endLine": 304,
                "endColumn": 40
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.",
                "line": 305,
                "column": 19,
                "nodeType": "TSAsExpression",
                "messageId": "neverNullish",
                "endLine": 305,
                "endColumn": 42
            },
            {
                "ruleId": "@typescript-eslint/no-non-null-assertion",
                "severity": 1,
                "message": "Forbidden non-null assertion.",
                "line": 342,
                "column": 31,
                "nodeType": "TSNonNullExpression",
                "messageId": "noNonNull",
                "endLine": 342,
                "endColumn": 40
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable boolean value in array predicate return type. Please handle the nullish case explicitly.",
                "line": 480,
                "column": 52,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "conditionErrorNullableBoolean",
                "endLine": 481,
                "endColumn": 94,
                "suggestions": [
                    {
                        "messageId": "conditionFixDefaultFalse",
                        "fix": {
                            "range": [
                                17052,
                                17137
                            ],
                            "text": "(button.closest('[data-testid=\"contact-row\"]')?.textContent?.includes('Bobby Builder')) ?? false"
                        },
                        "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
                    },
                    {
                        "messageId": "conditionFixCompareTrue",
                        "fix": {
                            "range": [
                                17052,
                                17137
                            ],
                            "text": "(button.closest('[data-testid=\"contact-row\"]')?.textContent?.includes('Bobby Builder')) === true"
                        },
                        "desc": "Change condition to check if true (`value === true`)"
                    },
                    {
                        "messageId": "explicitBooleanReturnType",
                        "fix": {
                            "range": [
                                17034,
                                17040
                            ],
                            "text": "(button): boolean"
                        },
                        "desc": "Add an explicit `boolean` return type annotation."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary optional chain on a non-nullish value.",
                "line": 481,
                "column": 67,
                "nodeType": "MemberExpression",
                "messageId": "neverOptionalChain",
                "endLine": 481,
                "endColumn": 69,
                "suggestions": [
                    {
                        "messageId": "suggestRemoveOptionalChain",
                        "fix": {
                            "range": [
                                17110,
                                17112
                            ],
                            "text": "."
                        },
                        "desc": "Remove unnecessary optional chain"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 529,
                "column": 13,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 529,
                "endColumn": 25,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                18832,
                                18844
                            ],
                            "text": "storedTenant != null"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                18832,
                                18844
                            ],
                            "text": "storedTenant ?? \"\""
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                18832,
                                18844
                            ],
                            "text": "Boolean(storedTenant)"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 561,
                "column": 16,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 561,
                "endColumn": 26,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                19876,
                                19887
                            ],
                            "text": "authHeader == null"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                19877,
                                19887
                            ],
                            "text": "(authHeader ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                19876,
                                19887
                            ],
                            "text": "!Boolean(authHeader)"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 564,
                "column": 28,
                "nodeType": "CallExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 564,
                "endColumn": 62,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                20030,
                                20064
                            ],
                            "text": "(request.headers.get('x-tenant-id') != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                20030,
                                20064
                            ],
                            "text": "(request.headers.get('x-tenant-id') ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                20030,
                                20064
                            ],
                            "text": "(Boolean(request.headers.get('x-tenant-id')))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 564,
                "column": 63,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 564,
                "endColumn": 65,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                20065,
                                20067
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 565,
                "column": 53,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 565,
                "endColumn": 55,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                20132,
                                20134
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/require-await",
                "severity": 1,
                "message": "Async arrow function has no 'await' expression.",
                "line": 572,
                "column": 49,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingAwait",
                "endLine": 572,
                "endColumn": 51,
                "suggestions": [
                    {
                        "messageId": "removeAsync",
                        "fix": {
                            "range": [
                                20343,
                                20349
                            ],
                            "text": ""
                        },
                        "desc": "Remove 'async'."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 643,
                "column": 16,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 643,
                "endColumn": 26,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                22726,
                                22737
                            ],
                            "text": "authHeader == null"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                22727,
                                22737
                            ],
                            "text": "(authHeader ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                22726,
                                22737
                            ],
                            "text": "!Boolean(authHeader)"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 646,
                "column": 28,
                "nodeType": "CallExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 646,
                "endColumn": 62,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                22880,
                                22914
                            ],
                            "text": "(request.headers.get('x-tenant-id') != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                22880,
                                22914
                            ],
                            "text": "(request.headers.get('x-tenant-id') ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                22880,
                                22914
                            ],
                            "text": "(Boolean(request.headers.get('x-tenant-id')))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 646,
                "column": 63,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 646,
                "endColumn": 65,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                22915,
                                22917
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 647,
                "column": 53,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 647,
                "endColumn": 55,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                22982,
                                22984
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/require-await",
                "severity": 1,
                "message": "Async arrow function has no 'await' expression.",
                "line": 654,
                "column": 49,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingAwait",
                "endLine": 654,
                "endColumn": 51,
                "suggestions": [
                    {
                        "messageId": "removeAsync",
                        "fix": {
                            "range": [
                                23193,
                                23199
                            ],
                            "text": ""
                        },
                        "desc": "Remove 'async'."
                    }
                ]
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 73,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "import { describe, it, expect, beforeEach, afterEach } from 'bun:test';\nimport { screen, waitFor, cleanup, within } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport { http, HttpResponse } from 'msw';\nimport type { HttpHandler } from 'msw';\nimport { setupServer } from 'msw/node';\nimport { renderWithAuth, renderWithoutAuth } from '../../test-utils/render';\nimport { LoginPage } from '../../pages/LoginPage';\nimport { AddressBookPage } from '../../pages/AddressBookPage';\nimport { asContactId, asTenantId, asUserId } from '../../types/ids';\nimport type { Contact } from '../../types/contact';\nimport type { Gender } from '../../types/person';\nimport type { Address } from '../../types/contact';\nimport { createMockAuthJwt } from '../../test-utils/jwt';\nimport { decodeJwtPayload } from '../../utils/parsing';\nimport { mockUser, mockTenant } from '../../test-utils/render';\n\n// Test environment variables are set via vitest globals\n// VITE_API_URL defaults to API_URL constant\n// VITE_DEFAULT_COUNTRY defaults to empty string\n\n// Multi-tenant mock stores\n// Use mockTenant.id (tenant-1) as the primary tenant to match the shared fixture\n// Stable ID generator to avoid duplicate IDs after deletions\nlet nextContactId = 1000;\n\nconst tenantContacts: Record<string, Contact[]> = {\n  'tenant-1': [\n    {\n      id: asContactId('101'),\n      tenantId: mockTenant.id,\n      firstName: 'John',\n      lastName: 'Doe',\n      fullName: 'John Doe',\n      email: 'john@t1.example.com',\n      phone: '555-0100',\n      mobile: '555-0100',\n      gender: 'male',\n      address: {\n        street1: '123 Main St',\n        city: 'Springfield',\n        state: 'IL',\n        zipCode: '62701',\n        country: 'USA',\n      },\n      createdAt: new Date('2025-01-01T00:00:00Z'),\n      updatedAt: new Date('2025-01-01T00:00:00Z'),\n      createdBy: asUserId('user1'),\n      updatedBy: asUserId('user1'),\n      isActive: true,\n    },\n  ],\n  'tenant-2': [\n    {\n      id: asContactId('1'),\n      tenantId: asTenantId('tenant-2'),\n      firstName: 'Alice',\n      lastName: 'Jones',\n      fullName: 'Alice Jones',\n      email: 'alice@t2.example.com',\n      phone: '555-0200',\n      mobile: '555-0200',\n      gender: 'female',\n      address: {\n        street1: '789 Pine Rd',\n        city: 'Metropolis',\n        state: 'NY',\n        zipCode: '10001',\n        country: 'USA',\n      },\n      createdAt: new Date('2025-01-01T00:00:00Z'),\n      updatedAt: new Date('2025-01-01T00:00:00Z'),\n      createdBy: asUserId('user2'),\n      updatedBy: asUserId('user2'),\n      isActive: true,\n    },\n  ],\n};\n\n// Simple session token store to simulate expiration/refresh\nlet currentToken: string | null = null;\nlet refreshTokenValid = true;\n\nconst server = setupServer(\n  // Auth login endpoint\n  http.post('/api/auth/login', async ({ request }) => {\n    const body = (await request.json()) as Record<string, unknown>;\n    // Accept any credentials for testing; include tenant_id if provided\n    // Default to tenant-1 to match mockTenant fixture\n    const tenantId = (body.tenantId as string) ?? 'tenant-1';\n    const jwt = createMockAuthJwt((body.username as string) ?? 'test', tenantId);\n    currentToken = jwt;\n    refreshTokenValid = true;\n    return HttpResponse.json({\n      success: true,\n      message: 'Logged in',\n      data: {\n        token: jwt,\n        user: { ...mockUser, tenantId: asTenantId(tenantId) },\n        tenant: { ...mockTenant, id: asTenantId(tenantId) },\n      },\n    });\n  }),\n\n  // Refresh token\n  http.post('/api/auth/refresh', async () => {\n    if (!refreshTokenValid) {\n      return HttpResponse.json(\n        { success: false, message: 'Refresh token expired' },\n        { status: 401 }\n      );\n    }\n\n    // Decode current token to extract tenant_id, fallback to mockTenant.id\n    let tenantId = mockTenant.id;\n    if (currentToken) {\n      const decodeResult = decodeJwtPayload(currentToken);\n      if (decodeResult.isOk()) {\n        tenantId = asTenantId(decodeResult.value.tenant_id);\n      }\n    }\n\n    const jwt = createMockAuthJwt('test', tenantId);\n    currentToken = jwt;\n    return HttpResponse.json({\n      success: true,\n      message: 'Token refreshed',\n      data: {\n        token: jwt,\n        user: { ...mockUser, tenantId },\n        tenant: { ...mockTenant, id: tenantId },\n      },\n    });\n  }),\n\n  // Get contacts per tenant\n  http.get('/api/address-book', ({ request }) => {\n    const authHeader = request.headers.get('Authorization');\n    if (!authHeader || !currentToken) {\n      return HttpResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });\n    }\n    const tenantId = request.headers.get('x-tenant-id') || 'tenant-1';\n    const contacts = tenantContacts[tenantId] || [];\n    return HttpResponse.json({ success: true, message: 'Contacts retrieved', data: { contacts } });\n  }),\n\n  // Create contact\n  http.post('/api/address-book', async ({ request }) => {\n    const tenantId = request.headers.get('x-tenant-id') || 'tenant-1';\n    const body = (await request.json()) as Record<string, any>;\n    // simulate server-side validation error\n    if (!body.firstName) {\n      return HttpResponse.json(\n        { success: false, message: 'First name required', errors: { firstName: 'required' } },\n        { status: 400 }\n      );\n    }\n    const arr = (tenantContacts[tenantId] ||= []);\n    const newContact: Contact = {\n      id: asContactId(String(++nextContactId)),\n      tenantId: asTenantId(tenantId),\n      firstName: body.firstName,\n      lastName: body.lastName || '',\n      fullName: `${body.firstName} ${body.lastName || ''}`.trim(),\n      email: body.email || '',\n      phone: body.phone || '',\n      mobile: body.mobile || '',\n      gender: body.gender || 'male',\n      address: body.address || { street1: '', city: '', state: '', zipCode: '', country: '' },\n      createdAt: new Date(),\n      updatedAt: new Date(),\n      createdBy: asUserId('test'),\n      updatedBy: asUserId('test'),\n      isActive: true,\n    };\n    arr.push(newContact);\n    return HttpResponse.json({ success: true, message: 'Contact created', data: newContact });\n  }),\n\n  // Update contact\n  http.put('/api/address-book/:id', async ({ request, params }) => {\n    const tenantId = request.headers.get('x-tenant-id') || 'tenant-1';\n    const id = params.id;\n    const arr = tenantContacts[tenantId] || [];\n    const body = (await request.json()) as Record<string, unknown>;\n\n    // Validate required fields\n    if (\n      body.firstName !== undefined &&\n      (body.firstName === null || body.firstName === '' || body.firstName === false)\n    ) {\n      return HttpResponse.json({ success: false, message: 'First name required' }, { status: 400 });\n    }\n\n    const idx = arr.findIndex(c => c.id === id);\n    if (idx === -1)\n      return HttpResponse.json({ success: false, message: 'Not found' }, { status: 404 });\n\n    const existingContact = arr[idx]!; // Contact is guaranteed to exist since idx !== -1\n\n    // Only update allowed fields\n    arr[idx] = {\n      ...existingContact,\n      firstName: (body.firstName as string) ?? existingContact.firstName,\n      lastName: (body.lastName as string) ?? existingContact.lastName,\n      // ... other safe fields\n      updatedAt: new Date(),\n    } as Contact;\n    return HttpResponse.json({ success: true, message: 'Contact updated', data: arr[idx] });\n  }),\n\n  // Delete contact\n  http.delete('/api/address-book/:id', ({ request, params }) => {\n    const tenantId = request.headers.get('x-tenant-id') || 'tenant-1';\n    const arr = tenantContacts[tenantId] || [];\n    const idx = arr.findIndex(c => c.id === params.id);\n    if (idx === -1)\n      return HttpResponse.json({ success: false, message: 'Not found' }, { status: 404 });\n    arr.splice(idx, 1);\n    return HttpResponse.json({ success: true, message: 'Contact deleted' });\n  }),\n\n  // Tenants list\n  http.get('/api/tenants', () => {\n    return HttpResponse.json({\n      success: true,\n      message: 'Tenants',\n      data: [\n        { id: 'tenant-1', name: 'Tenant One' },\n        { id: 'tenant-2', name: 'Tenant Two' },\n      ],\n    });\n  })\n);\n\n// Common test helpers\nconst createAuthToken = (username = 'test', tenantId = 'tenant-1'): string => {\n  return createMockAuthJwt(username, tenantId);\n};\n\nconst setupAuthenticatedState = (tenantId = 'tenant-1'): void => {\n  const token = createAuthToken('testuser', tenantId);\n  localStorage.setItem('auth_token', JSON.stringify({ token }));\n  localStorage.setItem('user', JSON.stringify({ ...mockUser, tenantId: asTenantId(tenantId) }));\n  localStorage.setItem('tenant', JSON.stringify({ ...mockTenant, id: asTenantId(tenantId) }));\n};\n\nconst resetTokenState = (): void => {\n  currentToken = null;\n  refreshTokenValid = true;\n};\n\n// Shared helper for authorization and tenant validation\nconst validateAuthAndGetTenantContacts = (\n  request: Request,\n  tenantId: string\n): {\n  error?: Response;\n  contacts?: Contact[];\n} => {\n  const authHeader = request.headers.get('Authorization');\n  if (!authHeader || !currentToken) {\n    return {\n      error: HttpResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 }),\n    };\n  }\n  return { contacts: tenantContacts[tenantId] || [] };\n};\n\nconst createContactCRUDHandlers = (tenantId = 'tenant-1'): HttpHandler[] => {\n  return [\n    http.get('/api/address-book', ({ request }) => {\n      const authResult = validateAuthAndGetTenantContacts(request, tenantId);\n      if (authResult.error) return authResult.error;\n\n      const contacts = authResult.contacts;\n      return HttpResponse.json({\n        success: true,\n        message: 'Contacts retrieved',\n        data: { contacts },\n      });\n    }),\n    http.post('/api/address-book', async ({ request }) => {\n      const authResult = validateAuthAndGetTenantContacts(request, tenantId);\n      if (authResult.error) return authResult.error;\n\n      const body = (await request.json()) as Record<string, unknown>;\n      if (!body.firstName || body.firstName === null || body.firstName === '') {\n        return HttpResponse.json(\n          { success: false, message: 'First name required', errors: { firstName: 'required' } },\n          { status: 400 }\n        );\n      }\n      const arr = (tenantContacts[tenantId] ||= []);\n      const newContact: Contact = {\n        id: asContactId(String(++nextContactId)),\n        tenantId: asTenantId(tenantId),\n        firstName: body.firstName as string,\n        lastName: (body.lastName as string) ?? '',\n        fullName: `${body.firstName as string} ${(body.lastName as string) ?? ''}`.trim(),\n        email: (body.email as string) ?? '',\n        phone: (body.phone as string) ?? '',\n        mobile: (body.mobile as string) ?? '',\n        gender: ((body.gender as string) ?? 'male') as Gender,\n        address: (body.address as Address) ?? {\n          street1: '',\n          city: '',\n          state: '',\n          zipCode: '',\n          country: '',\n        },\n        createdAt: new Date(),\n        updatedAt: new Date(),\n        createdBy: asUserId('test'),\n        updatedBy: asUserId('test'),\n        isActive: true,\n      };\n      arr.push(newContact);\n      return HttpResponse.json({ success: true, message: 'Contact created', data: newContact });\n    }),\n    http.put('/api/address-book/:id', async ({ request, params }) => {\n      const authResult = validateAuthAndGetTenantContacts(request, tenantId);\n      if (authResult.error) return authResult.error;\n\n      const id = params.id;\n      const arr = authResult.contacts ?? [];\n      const body = (await request.json()) as Record<string, unknown>;\n\n      if (\n        body.firstName !== undefined &&\n        (body.firstName === null || body.firstName === '' || body.firstName === false)\n      ) {\n        return HttpResponse.json(\n          { success: false, message: 'First name required' },\n          { status: 400 }\n        );\n      }\n\n      const idx = arr.findIndex(c => c.id === id);\n      if (idx === -1)\n        return HttpResponse.json({ success: false, message: 'Not found' }, { status: 404 });\n      const existingContact = arr[idx]!; // Contact is guaranteed to exist since idx !== -1\n      const updatedContact: Contact = {\n        ...existingContact,\n        firstName: typeof body.firstName === 'string' ? body.firstName : existingContact.firstName,\n        lastName: typeof body.lastName === 'string' ? body.lastName : existingContact.lastName,\n        updatedAt: new Date(),\n      } as Contact;\n      arr[idx] = updatedContact;\n      return HttpResponse.json({ success: true, message: 'Contact updated', data: arr[idx] });\n    }),\n    http.delete('/api/address-book/:id', ({ request, params }) => {\n      const authResult = validateAuthAndGetTenantContacts(request, tenantId);\n      if (authResult.error) return authResult.error;\n\n      const arr = authResult.contacts ?? [];\n      const idx = arr.findIndex(c => c.id === params.id);\n      if (idx === -1)\n        return HttpResponse.json({ success: false, message: 'Not found' }, { status: 404 });\n      arr.splice(idx, 1);\n      return HttpResponse.json({ success: true, message: 'Contact deleted' });\n    }),\n  ];\n};\n\ndescribe.skip('Contact Management Flow - Integration', () => {\n  beforeEach(() => {\n    localStorage.clear();\n    server.listen();\n    resetTokenState();\n  });\n  afterEach(() => {\n    server.resetHandlers();\n    server.close();\n  });\n\n  describe('Login + Initial Contacts', () => {\n    it('should handle login flow and load initial tenant contacts', async () => {\n      const user = userEvent.setup();\n\n      // Login flow\n      renderWithoutAuth(<LoginPage />);\n\n      const username = screen.getByPlaceholderText(/username|email/i);\n      const password = screen.getByPlaceholderText(/password/i);\n\n      await user.type(username, 'testuser');\n      await user.type(password, 'password');\n\n      const loginButton = screen.getByRole('button', { name: /sign in/i });\n      await user.click(loginButton);\n\n      // Wait for login to complete\n      await waitFor(() => {\n        const storedAuth = localStorage.getItem('auth_token');\n        expect(storedAuth).toBeTruthy();\n      });\n\n      // After login completes, render AddressBookPage\n      cleanup();\n      renderWithAuth(<AddressBookPage />);\n\n      // Verify tenant-1 contacts are shown (John)\n      await waitFor(() => {\n        expect(screen.getByText('John Doe')).toBeInTheDocument();\n      });\n    });\n  });\n\n  describe('Contact CRUD Operations', () => {\n    it('should handle create, edit, and delete contact operations', async () => {\n      const user = userEvent.setup();\n\n      // Set up authenticated state\n      setupAuthenticatedState('tenant-1');\n\n      // Use CRUD handlers for tenant-1\n      server.use(...createContactCRUDHandlers('tenant-1'));\n\n      renderWithAuth(<AddressBookPage />);\n\n      // Verify initial contact is shown\n      await waitFor(() => {\n        expect(screen.getByText('John Doe')).toBeInTheDocument();\n      });\n\n      // Create new contact with missing firstName -> expect backend validation error\n      const addButton = screen.getByRole('button', { name: /add contact/i });\n      await user.click(addButton);\n\n      const dialog = await screen.findByRole('dialog');\n      const modal = within(dialog);\n\n      const emailInput = modal.getByLabelText(/email/i);\n      await user.type(emailInput, 'new@t1.example.com');\n\n      const submit = modal.getByRole('button', { name: /add contact/i });\n      await user.click(submit);\n\n      await waitFor(() => {\n        expect(screen.getByText(/please enter first name/i)).toBeInTheDocument();\n      });\n\n      // Fill valid data and create\n      const firstNameInput = modal.getByLabelText(/first name/i);\n      const lastNameInput = modal.getByLabelText(/last name/i);\n      await user.type(firstNameInput, 'Bob');\n      await user.type(lastNameInput, 'Builder');\n      await user.click(submit);\n\n      // Verify created contact appears\n      await waitFor(() => {\n        expect(screen.getByText('Bob Builder')).toBeInTheDocument();\n      });\n\n      // Edit the contact - find Bob Builder's edit button by looking for the one in the row containing \"Bob Builder\"\n      const editButtons = screen.getAllByRole('button', { name: /edit/i });\n      const bobEditButton = editButtons.find(button => {\n        const row = button.closest('tr');\n        return row?.textContent.includes('Bob Builder') ?? false;\n      });\n      expect(bobEditButton).toBeTruthy();\n      if (bobEditButton) {\n        await user.click(bobEditButton);\n      }\n\n      const editFirstNameInput = await screen.findByDisplayValue('Bob');\n      await user.clear(editFirstNameInput);\n      await user.type(editFirstNameInput, 'Bobby');\n\n      const saveButton = screen.getByRole('button', { name: /save/i });\n      await user.click(saveButton);\n\n      await waitFor(() => {\n        expect(screen.getByText('Bobby Builder')).toBeInTheDocument();\n      });\n\n      // Delete the contact\n      const deleteButtons = screen.getAllByRole('button', { name: /delete/i });\n      const bobbyDeleteButton = deleteButtons.find(button =>\n        button.closest('[data-testid=\"contact-row\"]')?.textContent?.includes('Bobby Builder')\n      );\n      expect(bobbyDeleteButton).toBeTruthy();\n      if (bobbyDeleteButton) {\n        await user.click(bobbyDeleteButton);\n      }\n\n      const confirmDelete = screen.getByRole('button', { name: /confirm|yes|delete/i });\n      await user.click(confirmDelete);\n\n      await waitFor(() => {\n        expect(screen.queryByText('Bobby Builder')).not.toBeInTheDocument();\n      });\n    });\n  });\n\n  describe('Tenant Switching', () => {\n    it('should handle switching between tenants and display tenant-specific contacts', async () => {\n      const user = userEvent.setup();\n\n      // Start with tenant-1\n      setupAuthenticatedState('tenant-1');\n      server.use(...createContactCRUDHandlers('tenant-1'));\n\n      renderWithAuth(<AddressBookPage />);\n\n      // Verify tenant-1 contacts are displayed\n      await waitFor(() => {\n        expect(screen.getByText('John Doe')).toBeInTheDocument();\n      });\n\n      // Switch to tenant-2 by logging in as different tenant\n      cleanup();\n      renderWithoutAuth(<LoginPage />);\n\n      const tenant2UsernameInput = screen.getByLabelText(/username/i);\n      const tenant2PasswordInput = screen.getByLabelText(/password/i);\n      const tenant2TenantIdInput = screen.getByLabelText(/tenant.*id/i);\n      const tenant2LoginButton = screen.getByRole('button', { name: /log in/i });\n\n      await user.type(tenant2UsernameInput, 'tenant2user');\n      await user.type(tenant2PasswordInput, 'password123');\n      await user.type(tenant2TenantIdInput, 'tenant-2');\n      await user.click(tenant2LoginButton);\n\n      // Wait for tenant-2 login to complete\n      await waitFor(() => {\n        const storedTenant = localStorage.getItem('tenant');\n        if (storedTenant) {\n          const tenant = JSON.parse(storedTenant) as { id: string };\n          expect(tenant.id).toBe('tenant-2');\n        }\n      });\n\n      // Render AddressBookPage for tenant-2\n      renderWithAuth(<AddressBookPage />, {\n        authValue: {\n          tenant: { ...mockTenant, id: asTenantId('tenant-2'), name: 'Tenant Two' },\n          user: { ...mockUser, tenantId: asTenantId('tenant-2') },\n        },\n      });\n\n      // Verify tenant-2 contacts are displayed\n      await waitFor(() => {\n        expect(screen.getByText('Alice Jones')).toBeInTheDocument();\n      });\n    });\n  });\n\n  describe('Token Refresh', () => {\n    it('should handle session expiration and successful token refresh', async () => {\n      // Set up initial authenticated state\n      setupAuthenticatedState('tenant-2');\n\n      // Mock endpoints to track calls\n      let refreshCallCount = 0;\n\n      server.use(\n        http.get('/api/address-book', ({ request }) => {\n          const authHeader = request.headers.get('Authorization');\n          if (!authHeader) {\n            return HttpResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });\n          }\n          const tenantId = request.headers.get('x-tenant-id') || 'tenant-2';\n          const contacts = tenantContacts[tenantId] || [];\n          return HttpResponse.json({\n            success: true,\n            message: 'Contacts retrieved',\n            data: { contacts },\n          });\n        }),\n        http.post('/api/auth/refresh', async () => {\n          refreshCallCount++;\n          if (!refreshTokenValid) {\n            return HttpResponse.json(\n              { success: false, message: 'Refresh token expired' },\n              { status: 401 }\n            );\n          }\n          const jwt = createMockAuthJwt('testuser', 'tenant-2');\n          currentToken = jwt;\n          return HttpResponse.json({\n            success: true,\n            message: 'Token refreshed',\n            data: {\n              token: jwt,\n              user: { ...mockUser, tenantId: asTenantId('tenant-2') },\n              tenant: { ...mockTenant, id: asTenantId('tenant-2') },\n            },\n          });\n        })\n      );\n\n      renderWithAuth(<AddressBookPage />, {\n        authValue: {\n          tenant: { ...mockTenant, id: asTenantId('tenant-2') },\n        },\n      });\n\n      // Wait for the refresh to complete and contacts to load\n      await waitFor(() => {\n        expect(screen.getByText('Alice Jones')).toBeInTheDocument();\n      });\n\n      // Assert that refresh was called\n      expect(refreshCallCount).toBe(1);\n\n      // Assert that a new token was saved to localStorage\n      const storedAuth = JSON.parse(localStorage.getItem('auth_token') ?? '{}') as {\n        token: string;\n      };\n      expect(storedAuth.token).toBeDefined();\n      expect(typeof storedAuth.token).toBe('string');\n\n      // Assert that the UI displays the expected address book data after successful refresh\n      expect(screen.getByText('Alice Jones')).toBeInTheDocument();\n      expect(screen.getByText('alice@t2.example.com')).toBeInTheDocument();\n    });\n\n    it('should handle session expiration with failed refresh', async () => {\n      // Set up initial authenticated state\n      setupAuthenticatedState('tenant-1');\n\n      renderWithAuth(<AddressBookPage />);\n\n      // Verify initial state\n      await waitFor(() => {\n        expect(screen.getByText('John Doe')).toBeInTheDocument();\n      });\n\n      // Simulate session expiration\n      localStorage.removeItem('auth_token');\n      refreshTokenValid = false; // Refresh will fail\n\n      // Mock endpoints to track calls\n      let addressBookCallCount = 0;\n      let refreshCallCount = 0;\n\n      server.use(\n        http.get('/api/address-book', ({ request }) => {\n          addressBookCallCount++;\n          const authHeader = request.headers.get('Authorization');\n          if (!authHeader) {\n            return HttpResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });\n          }\n          const tenantId = request.headers.get('x-tenant-id') || 'tenant-1';\n          const contacts = tenantContacts[tenantId] || [];\n          return HttpResponse.json({\n            success: true,\n            message: 'Contacts retrieved',\n            data: { contacts },\n          });\n        }),\n        http.post('/api/auth/refresh', async () => {\n          refreshCallCount++;\n          return HttpResponse.json(\n            { success: false, message: 'Refresh token expired' },\n            { status: 401 }\n          );\n        })\n      );\n\n      // Trigger API call by re-rendering\n      cleanup();\n      renderWithAuth(<AddressBookPage />);\n\n      // Wait for redirect to login (assuming the app redirects on auth failure)\n      await waitFor(() => {\n        expect(screen.getByRole('button', { name: 'Sign In' })).toBeInTheDocument();\n      });\n\n      // Assert that refresh was attempted\n      expect(refreshCallCount).toBe(1);\n\n      // Assert that no new token was saved\n      expect(localStorage.getItem('auth_token')).toBeNull();\n\n      // Assert that the address book API was called once (failed, no retry)\n      expect(addressBookCallCount).toBe(1);\n    });\n  });\n});\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/pages/__tests__/DashboardPage.test.tsx",
        "messages": [
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary optional chain on a non-nullish value.",
                "line": 29,
                "column": 45,
                "nodeType": "MemberExpression",
                "messageId": "neverOptionalChain",
                "endLine": 29,
                "endColumn": 47,
                "suggestions": [
                    {
                        "messageId": "suggestRemoveOptionalChain",
                        "fix": {
                            "range": [
                                1042,
                                1044
                            ],
                            "text": "."
                        },
                        "desc": "Remove unnecessary optional chain"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-non-null-assertion",
                "severity": 1,
                "message": "Forbidden non-null assertion.",
                "line": 126,
                "column": 25,
                "nodeType": "TSNonNullExpression",
                "messageId": "noNonNull",
                "endLine": 126,
                "endColumn": 34
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary optional chain on a non-nullish value.",
                "line": 170,
                "column": 35,
                "nodeType": "MemberExpression",
                "messageId": "neverOptionalChain",
                "endLine": 170,
                "endColumn": 37,
                "suggestions": [
                    {
                        "messageId": "suggestRemoveOptionalChain",
                        "fix": {
                            "range": [
                                6269,
                                6271
                            ],
                            "text": "."
                        },
                        "desc": "Remove unnecessary optional chain"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 180,
                "column": 56,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 180,
                "endColumn": 74,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                6680,
                                6698
                            ],
                            "text": "(mockUser.firstName != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                6680,
                                6698
                            ],
                            "text": "(mockUser.firstName ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                6680,
                                6698
                            ],
                            "text": "(Boolean(mockUser.firstName))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 180,
                "column": 75,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 180,
                "endColumn": 77,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                6699,
                                6701
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 5,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "import { describe, it, expect } from 'bun:test';\nimport { screen } from '@testing-library/react';\nimport { renderWithAuth, mockUser, mockTenant } from '../../test-utils/render';\nimport { DashboardPage } from '../DashboardPage';\n\ndescribe('DashboardPage Component', () => {\n  describe('Rendering', () => {\n    it('displays welcome message with user name', () => {\n      renderWithAuth(<DashboardPage />);\n\n      expect(\n        screen.getByText(`Welcome back, ${mockUser.firstName ?? 'User'}!`)\n      ).toBeInTheDocument();\n    });\n\n    it('displays tenant information', () => {\n      renderWithAuth(<DashboardPage />);\n\n      expect(\n        screen.getByText(`You're logged in to tenant ${mockTenant.name} (${mockTenant.id})`)\n      ).toBeInTheDocument();\n    });\n\n    it('displays user profile information', () => {\n      renderWithAuth(<DashboardPage />);\n\n      expect(screen.getByText(mockUser.email)).toBeInTheDocument();\n      expect(screen.getByText(mockUser.username)).toBeInTheDocument();\n      expect(screen.getByText(mockUser.roles?.join(', ') || 'None')).toBeInTheDocument();\n    });\n\n    it('displays main feature cards', () => {\n      renderWithAuth(<DashboardPage />);\n\n      expect(screen.getByText('Address Book')).toBeInTheDocument();\n      expect(screen.getByText('Manage your contacts and addresses')).toBeInTheDocument();\n\n      expect(screen.getByText('System Health')).toBeInTheDocument();\n      expect(screen.getByText('Check API and system status')).toBeInTheDocument();\n\n      expect(screen.getByText('User Profile')).toBeInTheDocument();\n      expect(screen.getByText('Manage your account settings')).toBeInTheDocument();\n    });\n\n    it('displays recent activity section', () => {\n      renderWithAuth(<DashboardPage />);\n\n      expect(screen.getByText('Recent Activity')).toBeInTheDocument();\n      expect(screen.getByText(/Application started|successful login/)).toBeInTheDocument();\n    });\n\n    it('displays technology stack', () => {\n      renderWithAuth(<DashboardPage />);\n\n      expect(screen.getByText('Technology Stack')).toBeInTheDocument();\n      expect(screen.getByText('TypeScript')).toBeInTheDocument();\n      expect(screen.getByText('React')).toBeInTheDocument();\n      expect(screen.getByText('Actix Web')).toBeInTheDocument();\n      expect(screen.getByText('Bun')).toBeInTheDocument();\n    });\n\n    it('displays authentication status alert', () => {\n      renderWithAuth(<DashboardPage />);\n\n      const alert = screen.getByRole('alert');\n      expect(alert).toBeInTheDocument();\n      expect(alert).toHaveTextContent('Welcome');\n    });\n  });\n\n  describe('Behavior', () => {\n    it('renders content during loading state', () => {\n      renderWithAuth(<DashboardPage />, {\n        authValue: { isLoading: true },\n      });\n\n      expect(screen.getByText(/Welcome back/)).toBeInTheDocument();\n    });\n\n    it.skip('updates content when user data changes', () => {\n      // TODO: rerenderWithAuth doesn't properly support changing auth context values\n      // because React Router doesn't allow multiple routers. This should be tested\n      // with a different approach or in integration tests instead.\n    });\n\n    it('handles missing user name gracefully', () => {\n      renderWithAuth(<DashboardPage />, {\n        authValue: { user: { ...mockUser, firstName: undefined } },\n      });\n\n      expect(screen.getByText(/Welcome back/)).toBeInTheDocument();\n    });\n\n    it('handles empty tenant name gracefully', () => {\n      renderWithAuth(<DashboardPage />, {\n        authValue: { tenant: { ...mockTenant, name: '' } },\n      });\n\n      expect(screen.getByText(/Welcome back/)).toBeInTheDocument();\n    });\n\n    it('displays welcome message with long user names correctly', () => {\n      const longName = 'A'.repeat(100);\n      renderWithAuth(<DashboardPage />, {\n        authValue: { user: { ...mockUser, firstName: longName } },\n      });\n\n      // Verify the welcome message contains the user's name\n      const welcomeElement = screen.getByText(new RegExp(`Welcome back, ${longName}!`));\n      expect(welcomeElement).toBeInTheDocument();\n\n      // Verify the full name is accessible in the text content\n      expect(welcomeElement.textContent).toContain(longName);\n\n      // Note: Accessibility fallbacks (title/aria-label) are optional and not implemented\n      // The component displays long names directly in the alert message\n    });\n\n    it('provides navigation links', () => {\n      renderWithAuth(<DashboardPage />);\n\n      const links = screen.getAllByRole('link');\n      expect(links.length).toBeGreaterThan(0);\n\n      // Verify first link has proper attributes\n      const firstLink = links[0]!;\n      const href = firstLink.getAttribute('href');\n      expect(href).toBeTruthy();\n      expect(href).toMatch(/^(\\/|https?:\\/\\/)/);\n    });\n  });\n\n  describe('Accessibility', () => {\n    it('has proper heading hierarchy', () => {\n      renderWithAuth(<DashboardPage />);\n\n      const headings = screen.getAllByRole('heading');\n      expect(headings.length).toBeGreaterThan(0);\n\n      // Map heading elements to their numeric levels (H1 -> 1, H2 -> 2, etc.)\n      const headingLevels = headings.map(heading => {\n        const tagName = heading.tagName.toLowerCase();\n        return parseInt(tagName.replace('h', ''), 10);\n      });\n\n      // Verify all headings exist (at least one heading must be present)\n      expect(headingLevels.length).toBeGreaterThan(0);\n\n      // Assert the sequence never skips levels when going deeper\n      // (can go from H2 to H3 but not H2 to H4)\n      for (let i = 1; i < headingLevels.length; i++) {\n        const prevLevel = headingLevels[i - 1];\n        const currentLevel = headingLevels[i];\n\n        // When going deeper (increasing level number), can only increase by 1\n        if (\n          typeof prevLevel === 'number' &&\n          typeof currentLevel === 'number' &&\n          !Number.isNaN(prevLevel) &&\n          !Number.isNaN(currentLevel) &&\n          currentLevel > prevLevel\n        ) {\n          expect(currentLevel - prevLevel).toBeLessThanOrEqual(1);\n        }\n        // Going back up (decreasing) or staying same is always allowed\n      }\n\n      // Verify all headings have non-empty text\n      headings.forEach(heading => {\n        expect(heading.textContent?.trim().length).toBeGreaterThan(0);\n      });\n    });\n\n    it('provides accessible user and tenant information', () => {\n      renderWithAuth(<DashboardPage />);\n\n      // First assertion: REQUIRE the welcome message via the alert role (semantic, accessible element)\n      const alert = screen.getByRole('alert');\n      expect(alert).toBeInTheDocument();\n      expect(alert).toHaveTextContent(`Welcome back, ${mockUser.firstName || 'User'}!`);\n\n      // Second assertion: REQUIRE accessible role name for tenant information within the alert\n      // The tenant info must be accessible within the alert (via role-based query or text that doesn't fall back to plain text)\n      expect(alert).toHaveTextContent(new RegExp(`tenant ${mockTenant.name}`));\n\n      // Third assertion: Verify alert has proper ARIA attributes for accessibility\n      // Alert role should be assertive by default (set explicitly or by default browser behavior)\n      const ariaLiveValue = alert.getAttribute('aria-live');\n      expect(ariaLiveValue === 'assertive' || ariaLiveValue === null).toBe(true);\n    });\n\n    it('uses semantic HTML elements', () => {\n      renderWithAuth(<DashboardPage />);\n\n      expect(screen.getByRole('alert')).toBeInTheDocument();\n    });\n  });\n});\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/pages/__tests__/HomePage.test.tsx",
        "messages": [
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 253,
                "column": 11,
                "nodeType": "ChainExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 253,
                "endColumn": 38,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                10065,
                                10092
                            ],
                            "text": "(nextFocusedElement?.tagName) != null"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                10065,
                                10092
                            ],
                            "text": "(nextFocusedElement?.tagName) ?? \"\""
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                10065,
                                10092
                            ],
                            "text": "Boolean((nextFocusedElement?.tagName))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 1,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "import { describe, it, expect, beforeEach, mock } from 'bun:test';\nimport { screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport { renderWithoutAuth, renderWithAuthAndNavigation } from '../../test-utils/render';\nimport { HomePage } from '../HomePage';\n\n// Mock navigation tracking\nlet mockNavigate: ReturnType<typeof mock>;\n\n// Mock react-router-dom navigation\nvoid mock.module('react-router-dom', () => ({\n  Link: ({\n    to,\n    children,\n    ...props\n  }: {\n    to: string;\n    children: React.ReactNode;\n    [key: string]: unknown;\n  }) => {\n    const handleClick = (e: React.MouseEvent): void => {\n      e.preventDefault();\n      mockNavigate(to);\n    };\n    return (\n      <a href={to} onClick={handleClick} {...props}>\n        {children}\n      </a>\n    );\n  },\n  Navigate: ({ to }: { to: string }) => <div data-testid=\"navigate\" data-to={to} />,\n  useNavigate: () => mockNavigate,\n}));\n\ndescribe('HomePage Component', () => {\n  beforeEach(() => {\n    mockNavigate = mock();\n  });\n\n  describe('Rendering', () => {\n    it('should render home page with features', () => {\n      renderWithoutAuth(<HomePage />);\n\n      // Should display each feature individually\n      expect(screen.getByText('Secure Authentication')).toBeInTheDocument();\n      expect(screen.getByText('Multi-Tenant Architecture')).toBeInTheDocument();\n      expect(screen.getByText('High Performance')).toBeInTheDocument();\n    });\n  });\n\n  describe('Feature Sections', () => {\n    it('should display all features with proper structure and accessibility', () => {\n      renderWithoutAuth(<HomePage />);\n\n      // Test that we can find the main welcome text (this should fail if we're redirected)\n      expect(screen.getByText('Welcome to the Natural Pharmacy System')).toBeInTheDocument();\n\n      // Test that we can find the feature titles\n      expect(screen.getByText('Secure Authentication')).toBeInTheDocument();\n      expect(screen.getByText('Multi-Tenant Architecture')).toBeInTheDocument();\n      expect(screen.getByText('High Performance')).toBeInTheDocument();\n\n      // Test that we can find the feature icons by their accessible labels\n      expect(screen.getByLabelText('Secure Authentication icon')).toBeInTheDocument();\n      expect(screen.getByLabelText('Multi-Tenant Architecture icon')).toBeInTheDocument();\n      expect(screen.getByLabelText('High Performance icon')).toBeInTheDocument();\n\n      // Test that we can find feature descriptions with key terms (using getAllBy for multiple matches)\n      const jwtElements = screen.getAllByText(/JWT.*authentication/i);\n      expect(jwtElements.length).toBeGreaterThan(0);\n\n      const tenantElements = screen.getAllByText(/tenant.*isolation/i);\n      expect(tenantElements.length).toBeGreaterThan(0);\n\n      const bunElements = screen.getAllByText(/Bun.*TypeScript/i);\n      expect(bunElements.length).toBeGreaterThan(0);\n    });\n  });\n\n  describe('Authentication Redirect', () => {\n    it.skip('should redirect authenticated users to dashboard', () => {\n      // SKIPPED: Environment-specific rendering issue\n      // The Navigate component doesn't properly set testids in test environment\n      // Functionality verified through E2E testing\n      renderWithAuthAndNavigation(<HomePage />, {\n        initialRoute: '/',\n      });\n\n      // HomePage redirects authenticated users to /dashboard\n      // Check for the Navigate component with the correct destination\n      const navigateElement = screen.getByTestId('navigate');\n      expect(navigateElement).toBeInTheDocument();\n      expect(navigateElement).toHaveAttribute('data-to', '/dashboard');\n    });\n\n    it('should show home page for unauthenticated users', () => {\n      renderWithoutAuth(<HomePage />);\n\n      // Should display the specific welcome message\n      const welcomeHeading = screen.getByRole('heading', {\n        name: /Welcome to the Natural Pharmacy System/i,\n      });\n      expect(welcomeHeading).toBeInTheDocument();\n\n      // Should display features\n      const elements = screen.getAllByRole('heading');\n      expect(elements.length).toBeGreaterThan(0);\n    });\n  });\n\n  describe('Navigation', () => {\n    it('should have login button', () => {\n      renderWithoutAuth(<HomePage />);\n\n      const loginButton = screen.getByRole('button', { name: /login|sign in/i });\n      expect(loginButton).toBeInTheDocument();\n    });\n  });\n\n  describe('Content', () => {\n    it('should display technology stack', () => {\n      renderWithoutAuth(<HomePage />);\n\n      // Should mention React, Rust, etc.\n      const elements = screen.getAllByText(/React|Rust|TypeScript|Bun/i);\n      expect(elements.length).toBeGreaterThan(0);\n    });\n  });\n\n  describe('Layout Structure', () => {\n    it('should have proper semantic layout structure', () => {\n      renderWithoutAuth(<HomePage />);\n\n      // Test for hero H1 heading (main page title)\n      const heroHeading = screen.getByRole('heading', { level: 1 });\n      expect(heroHeading).toBeInTheDocument();\n      expect(heroHeading).toHaveTextContent(/Welcome to.*Natural Pharmacy System/i);\n      // Test for feature sections using accessible content\n      // There are 4 headings total: 1 h1 (welcome), 1 h4 (header title), 3 h4 (features)\n      const allHeadings = screen.getAllByRole('heading');\n      expect(allHeadings.length).toBeGreaterThanOrEqual(4);\n\n      // Verify specific feature titles are present\n      expect(screen.getByText('Secure Authentication')).toBeInTheDocument();\n      expect(screen.getByText('Multi-Tenant Architecture')).toBeInTheDocument();\n      expect(screen.getByText('High Performance')).toBeInTheDocument();\n    });\n\n    it('should have feature cards with accessible structure', () => {\n      renderWithoutAuth(<HomePage />);\n\n      // Test for feature content using user-visible text\n      const featureDescriptions = screen.getAllByText(\n        /JWT.*authentication|tenant.*isolation|Bun.*TypeScript/i\n      );\n      expect(featureDescriptions).toHaveLength(3);\n\n      // Test for feature icons using their accessible labels\n      expect(screen.getByLabelText('Secure Authentication icon')).toBeInTheDocument();\n      expect(screen.getByLabelText('Multi-Tenant Architecture icon')).toBeInTheDocument();\n      expect(screen.getByLabelText('High Performance icon')).toBeInTheDocument();\n    });\n  });\n\n  describe('Accessibility', () => {\n    it('should have proper heading structure', () => {\n      renderWithoutAuth(<HomePage />);\n\n      // Wait for the component to render and get all headings\n      const allHeadings = screen.getAllByRole('heading');\n      expect(allHeadings.length).toBeGreaterThan(0);\n\n      // Assert there is a level-1 heading (h1)\n      const h1Heading = allHeadings.find(heading => heading.tagName === 'H1');\n      expect(h1Heading).toBeInTheDocument();\n      expect(h1Heading).toHaveTextContent(/Welcome to the Natural Pharmacy System/i);\n\n      // Assert there is at least one subheading (h2, h3, or h4)\n      const h2Headings = allHeadings.filter(heading => heading.tagName === 'H2');\n      const h3Headings = allHeadings.filter(heading => heading.tagName === 'H3');\n      const h4Headings = allHeadings.filter(heading => heading.tagName === 'H4');\n\n      const subHeadings = [...h2Headings, ...h3Headings, ...h4Headings];\n      expect(subHeadings.length).toBeGreaterThan(0);\n    });\n\n    it('should have accessible buttons with proper labels and roles', () => {\n      renderWithoutAuth(<HomePage />);\n\n      // Test \"Get Started\" button\n      const getStartedButton = screen.getByRole('button', { name: /get started/i });\n      expect(getStartedButton).toBeInTheDocument();\n      expect(getStartedButton).toBeVisible();\n      expect(getStartedButton).toHaveAttribute('type', 'button');\n\n      // Test \"Sign In\" button\n      const signInButton = screen.getByRole('button', { name: /sign in/i });\n      expect(signInButton).toBeInTheDocument();\n      expect(signInButton).toBeVisible();\n      expect(signInButton).toHaveAttribute('type', 'button');\n\n      // Verify all buttons have accessible names (either visible text or aria-label)\n      const allButtons = screen.getAllByRole('button');\n      allButtons.forEach(button => {\n        const accessibleName = button.getAttribute('aria-label') ?? button.textContent;\n        expect(accessibleName).toBeTruthy();\n        if (accessibleName) {\n          expect(accessibleName.trim().length).toBeGreaterThan(0);\n        }\n      });\n    });\n\n    // Skipped: Requires stable DOM focus handling and test environment configuration.\n    // The test fails intermittently due to focus state management timing issues.\n    // Candidates for re-enabling after adding jest-dom focus helpers or switching to jsdom/happy-dom with proper focus support.\n    it.skip('should support keyboard navigation for buttons', async () => {\n      const user = userEvent.setup();\n      renderWithoutAuth(<HomePage />);\n\n      // Test \"Get Started\" button keyboard interaction\n      const getStartedButton = screen.getByRole('button', { name: /get started/i });\n\n      // Focus the button\n      getStartedButton.focus();\n      expect(getStartedButton).toHaveFocus();\n\n      // Test keyboard activation (Enter key)\n      await user.keyboard('{Enter}');\n\n      // Assert that navigation was triggered for Get Started button\n      expect(mockNavigate).toHaveBeenCalledWith('/register');\n\n      // Test \"Sign In\" button keyboard interaction\n      const signInButton = screen.getByRole('button', { name: /sign in/i });\n\n      // Focus the button\n      signInButton.focus();\n      expect(signInButton).toHaveFocus();\n\n      // Test keyboard activation (Space key)\n      await user.keyboard(' ');\n\n      // Assert that navigation was triggered for Sign In button\n      expect(mockNavigate).toHaveBeenCalledWith('/login');\n\n      // Test Tab navigation between buttons\n      await user.tab();\n\n      const nextFocusedElement = document.activeElement;\n      expect(nextFocusedElement).not.toBe(signInButton);\n\n      // Verify the focused element is interactive (button, link, or input)\n      if (nextFocusedElement?.tagName) {\n        expect(['BUTTON', 'A', 'INPUT']).toContain(nextFocusedElement.tagName);\n      }\n    });\n  });\n});\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/pages/__tests__/LoginPage.test.tsx",
        "messages": [
            {
                "ruleId": "@typescript-eslint/require-await",
                "severity": 1,
                "message": "Async method 'login' has no 'await' expression.",
                "line": 362,
                "column": 11,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingAwait",
                "endLine": 362,
                "endColumn": 24,
                "suggestions": [
                    {
                        "messageId": "removeAsync",
                        "fix": {
                            "range": [
                                12120,
                                12126
                            ],
                            "text": ""
                        },
                        "desc": "Remove 'async'."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/require-await",
                "severity": 1,
                "message": "Async method 'login' has no 'await' expression.",
                "line": 390,
                "column": 11,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingAwait",
                "endLine": 390,
                "endColumn": 24,
                "suggestions": [
                    {
                        "messageId": "removeAsync",
                        "fix": {
                            "range": [
                                13131,
                                13137
                            ],
                            "text": ""
                        },
                        "desc": "Remove 'async'."
                    }
                ]
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 2,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "import { describe, it, expect, beforeEach, mock } from 'bun:test';\nimport { screen, waitFor } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport { http, HttpResponse } from 'msw';\nimport { getServer } from '../../test-utils/mocks/server';\nimport { renderWithoutAuth, createDeferred } from '../../test-utils/render';\nimport { LoginPage } from '../LoginPage';\nimport type { LoginCredentials } from '../../types/auth';\n\n// Mock react-router-dom\nconst mockNavigate = mock();\nvoid mock.module('react-router-dom', () => ({\n  useNavigate: () => mockNavigate,\n}));\n\nconst mockLoginResponse = {\n  success: true,\n  message: 'Login successful',\n  data: {\n    token:\n      'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoidGVzdHVzZXIiLCJ0ZW5hbnRfaWQiOiJ0ZW5hbnQxIiwiZXhwIjoxNjk2MDAwMDAwfQ.signature',\n    user: {\n      id: 'user1',\n      username: 'testuser',\n      email: 'test@example.com',\n      tenantId: 'tenant1',\n    },\n  },\n};\n\ndescribe('LoginPage Component', () => {\n  beforeEach(() => {\n    // Clear all mocks before each test\n    mockNavigate.mockClear();\n\n    // Use the global MSW server (already set up by test-utils/setup.ts)\n    // Add handler for login endpoint\n    getServer().use(\n      http.post('/api/auth/login', async ({ request }) => {\n        const body = (await request.json()) as LoginCredentials;\n\n        // Simulate validation\n        if (!body.usernameOrEmail || !body.password || !body.tenantId) {\n          return HttpResponse.json(\n            {\n              success: false,\n              message: 'Missing required fields',\n            },\n            { status: 400 }\n          );\n        }\n\n        // Validate email format when @ is present\n        if (\n          body.usernameOrEmail.includes('@') &&\n          !/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(body.usernameOrEmail)\n        ) {\n          return HttpResponse.json(\n            {\n              success: false,\n              message: 'Invalid email format',\n            },\n            { status: 400 }\n          );\n        }\n\n        if (body.usernameOrEmail === 'failuser') {\n          return HttpResponse.json(\n            {\n              success: false,\n              message: 'Invalid credentials',\n            },\n            { status: 401 }\n          );\n        }\n\n        return HttpResponse.json(mockLoginResponse);\n      })\n    );\n  });\n\n  describe('Rendering', () => {\n    it('should render login form with title', () => {\n      renderWithoutAuth(<LoginPage />);\n\n      expect(screen.getByText('Login')).toBeInTheDocument();\n    });\n\n    it('should render username/email input field', () => {\n      renderWithoutAuth(<LoginPage />);\n\n      expect(screen.getByPlaceholderText(/username|email/i)).toBeInTheDocument();\n    });\n\n    it('should render password input field', () => {\n      renderWithoutAuth(<LoginPage />);\n\n      expect(screen.getByPlaceholderText(/password/i)).toBeInTheDocument();\n    });\n\n    it('should render tenant input field', () => {\n      renderWithoutAuth(<LoginPage />);\n\n      expect(screen.getByPlaceholderText(/tenant/i)).toBeInTheDocument();\n    });\n\n    it('should render submit button', () => {\n      renderWithoutAuth(<LoginPage />);\n\n      expect(screen.getByRole('button', { name: /login|sign in|submit/i })).toBeInTheDocument();\n    });\n\n    it('should render remember me checkbox', () => {\n      renderWithoutAuth(<LoginPage />);\n\n      expect(screen.getByRole('checkbox')).toBeInTheDocument();\n    });\n  });\n\n  describe('Form Validation - Empty Submission', () => {\n    it('should show error when submitting empty form', async () => {\n      const user = userEvent.setup();\n      renderWithoutAuth(<LoginPage />);\n\n      const submitButton = screen.getByRole('button', { name: /login|sign in/i });\n      await user.click(submitButton);\n\n      await waitFor(() => {\n        const errors = screen.queryAllByText(/required|please enter|cannot be empty/i);\n        expect(errors.length).toBeGreaterThan(0);\n      });\n    });\n\n    it('should display specific error for missing username', async () => {\n      const user = userEvent.setup();\n      renderWithoutAuth(<LoginPage />);\n\n      const passwordInput = screen.getByPlaceholderText(/password/i);\n      const tenantInput = screen.getByPlaceholderText(/tenant/i);\n\n      await user.type(passwordInput, 'password123');\n      await user.type(tenantInput, 'tenant1');\n\n      const submitButton = screen.getByRole('button', { name: /login|sign in/i });\n      await user.click(submitButton);\n\n      await waitFor(() => {\n        const errorMsg = screen.queryByText(/username.*email.*required/i);\n        expect(errorMsg).toBeInTheDocument();\n      });\n    });\n\n    it('should display error for missing password', async () => {\n      const user = userEvent.setup();\n      renderWithoutAuth(<LoginPage />);\n\n      const usernameInput = screen.getByPlaceholderText(/username|email/i);\n      const tenantInput = screen.getByPlaceholderText(/tenant/i);\n\n      await user.type(usernameInput, 'testuser');\n      await user.type(tenantInput, 'tenant1');\n\n      const submitButton = screen.getByRole('button', { name: /login|sign in/i });\n      await user.click(submitButton);\n\n      await waitFor(() => {\n        const errorMsg = screen.queryByText(/password.*required/i);\n        expect(errorMsg).toBeInTheDocument();\n      });\n    });\n\n    it('should display error for missing tenant', async () => {\n      const user = userEvent.setup();\n      renderWithoutAuth(<LoginPage />);\n\n      const usernameInput = screen.getByPlaceholderText(/username|email/i);\n      const passwordInput = screen.getByPlaceholderText(/password/i);\n\n      await user.type(usernameInput, 'testuser');\n      await user.type(passwordInput, 'password123');\n\n      const submitButton = screen.getByRole('button', { name: /login|sign in/i });\n      await user.click(submitButton);\n\n      await waitFor(() => {\n        const errorMsg = screen.queryByText(/tenant.*required/i);\n        expect(errorMsg).toBeInTheDocument();\n      });\n    });\n  });\n\n  describe('Form Validation - Email Format', () => {\n    it('should validate email format in username field', async () => {\n      const user = userEvent.setup();\n      renderWithoutAuth(<LoginPage />);\n\n      const usernameInput = screen.getByPlaceholderText(/username|email/i);\n      const passwordInput = screen.getByPlaceholderText(/password/i);\n      const tenantInput = screen.getByPlaceholderText(/tenant/i);\n\n      await user.type(usernameInput, 'invalid@');\n      await user.type(passwordInput, 'password123');\n      await user.type(tenantInput, 'tenant1');\n\n      const submitButton = screen.getByRole('button', { name: /login|sign in/i });\n      await user.click(submitButton);\n\n      await waitFor(() => {\n        const errorMsg = screen.queryByText(/email|format|invalid/i);\n        expect(errorMsg).toBeInTheDocument();\n      });\n    });\n  });\n\n  describe('Form Validation - Error Clearing', () => {\n    it('should clear error messages when user types', async () => {\n      const user = userEvent.setup();\n      renderWithoutAuth(<LoginPage />);\n\n      // Submit empty form to show errors\n      const submitButton = screen.getByRole('button', { name: /login|sign in/i });\n      await user.click(submitButton);\n\n      await waitFor(() => {\n        const errorMsgs = screen.queryAllByText(/required/i);\n        expect(errorMsgs.length).toBeGreaterThan(0);\n      });\n\n      // Get the input fields\n      const usernameInput = screen.getByPlaceholderText(/username|email/i);\n      const passwordInput = screen.getByPlaceholderText(/password/i);\n\n      // Type into the username/email field\n      await user.type(usernameInput, 'testuser@example.com');\n\n      // Wait for the error to be cleared for the username field\n      await waitFor(() => {\n        const errorMsgs = screen.queryAllByText(/required/i);\n        // Should have fewer errors now (at least one field is filled)\n        expect(errorMsgs.length).toBeLessThan(3); // Originally had errors for username, password, and tenant\n      });\n\n      // Type into the password field\n      await user.type(passwordInput, 'password123');\n\n      // Wait for the password error to be cleared as well\n      await waitFor(() => {\n        const errorMsgs = screen.queryAllByText(/required/i);\n        // Should have even fewer errors now (username and password are filled)\n        expect(errorMsgs.length).toBeLessThan(2);\n      });\n    });\n  });\n\n  describe('Successful Login', () => {\n    it('should call login handler on successful form submission', async () => {\n      const user = userEvent.setup();\n\n      // Mock the login function to track calls\n      const mockLogin = mock(() => Promise.resolve());\n\n      renderWithoutAuth(<LoginPage />, {\n        authValue: {\n          isAuthenticated: false,\n          user: null,\n          tenant: null,\n          login: mockLogin,\n        },\n      });\n\n      const usernameInput = screen.getByPlaceholderText(/username|email/i);\n      const passwordInput = screen.getByPlaceholderText(/password/i);\n      const tenantInput = screen.getByPlaceholderText(/tenant/i);\n\n      await user.type(usernameInput, 'testuser');\n      await user.type(passwordInput, 'password123');\n      await user.type(tenantInput, 'tenant1');\n\n      const submitButton = screen.getByRole('button', { name: /login|sign in/i });\n      await user.click(submitButton);\n\n      // Wait for login function to be called with correct credentials\n      await waitFor(() => {\n        expect(mockLogin).toHaveBeenCalledWith({\n          usernameOrEmail: 'testuser',\n          password: 'password123',\n          tenantId: 'tenant1',\n          rememberMe: false,\n        });\n      });\n\n      // Wait for navigation to be called with correct route\n      await waitFor(() => {\n        expect(mockNavigate).toHaveBeenCalledWith('/dashboard', { replace: true });\n      });\n    });\n\n    it('should show loading state during submission', async () => {\n      const user = userEvent.setup();\n      const deferred = createDeferred<undefined>();\n\n      renderWithoutAuth(<LoginPage />, {\n        authValue: {\n          login: async () => {\n            await deferred.promise;\n          },\n          isLoading: false,\n        },\n      });\n\n      const usernameInput = screen.getByPlaceholderText(/username|email/i);\n      const passwordInput = screen.getByPlaceholderText(/password/i);\n      const tenantInput = screen.getByPlaceholderText(/tenant/i);\n\n      await user.type(usernameInput, 'testuser');\n      await user.type(passwordInput, 'password123');\n      await user.type(tenantInput, 'tenant1');\n\n      const submitButton = screen.getByRole('button', { name: /login|sign in/i });\n      await user.click(submitButton);\n\n      // Button should show loading state during submission\n      await waitFor(() => {\n        const buttonClasses = submitButton.className || '';\n        expect(\n          buttonClasses.includes('ant-btn-loading') ||\n            submitButton.getAttribute('aria-busy') === 'true'\n        ).toBe(true);\n      });\n\n      deferred.resolve(undefined);\n      await deferred.promise;\n    });\n  });\n\n  describe('Login Failure', () => {\n    it('should display error on invalid credentials', async () => {\n      const user = userEvent.setup();\n      renderWithoutAuth(<LoginPage />);\n\n      const usernameInput = screen.getByPlaceholderText(/username|email/i);\n      const passwordInput = screen.getByPlaceholderText(/password/i);\n      const tenantInput = screen.getByPlaceholderText(/tenant/i);\n\n      await user.type(usernameInput, 'failuser');\n      await user.type(passwordInput, 'wrongpassword');\n      await user.type(tenantInput, 'tenant1');\n\n      const submitButton = screen.getByRole('button', { name: /login|sign in/i });\n      await user.click(submitButton);\n\n      await waitFor(() => {\n        const errorMsg = screen.getByText(/invalid|failed|error|credentials/i);\n        expect(errorMsg).toBeInTheDocument();\n      });\n    });\n\n    it('should display alert on API error', async () => {\n      const user = userEvent.setup({ delay: null });\n      renderWithoutAuth(<LoginPage />, {\n        authValue: {\n          login: async () => {\n            throw new Error('Server error');\n          },\n        },\n      });\n\n      const usernameInput = screen.getByPlaceholderText(/username|email/i);\n      const passwordInput = screen.getByPlaceholderText(/password/i);\n      const tenantInput = screen.getByPlaceholderText(/tenant/i);\n\n      await user.type(usernameInput, 'testuser');\n      await user.type(passwordInput, 'password123');\n      await user.type(tenantInput, 'tenant1');\n\n      const submitButton = screen.getByRole('button', { name: /login|sign in/i });\n      await user.click(submitButton);\n\n      // Wait for the alert to appear with a reasonable timeout\n      const alert = await screen.findByRole('alert', {}, { timeout: 2000 });\n      expect(alert).toHaveTextContent(/server error/i);\n    }, 8000);\n\n    it('should allow user to retry after error', async () => {\n      const user = userEvent.setup({ delay: null });\n      let attempt = 0;\n\n      renderWithoutAuth(<LoginPage />, {\n        authValue: {\n          login: async () => {\n            attempt += 1;\n            if (attempt === 1) {\n              throw new Error('Temporary error');\n            }\n          },\n        },\n      });\n\n      const usernameInput = screen.getByPlaceholderText(/username|email/i);\n      const passwordInput = screen.getByPlaceholderText(/password/i);\n      const tenantInput = screen.getByPlaceholderText(/tenant/i);\n\n      await user.type(usernameInput, 'testuser');\n      await user.type(passwordInput, 'password123');\n      await user.type(tenantInput, 'tenant1');\n\n      const submitButton = screen.getByRole('button', { name: /login|sign in/i });\n      await user.click(submitButton);\n\n      // Wait for the alert to appear\n      const alert = await screen.findByRole('alert', {}, { timeout: 2000 });\n      expect(alert).toHaveTextContent(/temporary error/i);\n\n      // Simulate realistic retry - user just clicks submit again without clearing inputs\n      await user.click(submitButton);\n\n      // Wait for the alert to disappear (error was fixed on retry)\n      await waitFor(\n        () => {\n          expect(screen.queryByRole('alert')).toBeNull();\n        },\n        { timeout: 2000 }\n      );\n    }, 8000);\n  });\n\n  describe('Remember Me Checkbox', () => {\n    it('should have remember me checkbox', () => {\n      renderWithoutAuth(<LoginPage />);\n\n      const checkbox = screen.getByRole('checkbox');\n      expect(checkbox).toBeInTheDocument();\n    });\n\n    it('should toggle remember me checkbox', async () => {\n      const user = userEvent.setup();\n      renderWithoutAuth(<LoginPage />);\n\n      const checkbox = screen.getByRole('checkbox');\n      const initialState = (checkbox as HTMLInputElement).checked;\n\n      await user.click(checkbox);\n\n      expect((checkbox as HTMLInputElement).checked).toBe(!initialState);\n    });\n  });\n\n  describe('Form Fields Interaction', () => {\n    it('should accept username input', async () => {\n      const user = userEvent.setup();\n      renderWithoutAuth(<LoginPage />);\n\n      const input = screen.getByPlaceholderText(/username|email/i);\n      await user.type(input, 'testuser');\n\n      expect((input as HTMLInputElement).value).toBe('testuser');\n    });\n\n    it('should accept password input', async () => {\n      const user = userEvent.setup();\n      renderWithoutAuth(<LoginPage />);\n\n      const input = screen.getByPlaceholderText(/password/i);\n      await user.type(input, 'password123');\n\n      expect((input as HTMLInputElement).value).toBe('password123');\n    });\n\n    it('should accept tenant input', async () => {\n      const user = userEvent.setup();\n      renderWithoutAuth(<LoginPage />);\n\n      const input = screen.getByPlaceholderText(/tenant/i);\n      await user.type(input, 'tenant1');\n\n      expect((input as HTMLInputElement).value).toBe('tenant1');\n    });\n\n    it('should have form labels', () => {\n      renderWithoutAuth(<LoginPage />);\n\n      // Check that inputs are properly associated with their labels using accessible queries\n      const usernameInput = screen.getByLabelText('Username or Email');\n      const passwordInput = screen.getByLabelText('Password');\n      const tenantInput = screen.getByLabelText('Tenant ID');\n\n      expect(usernameInput).toBeInTheDocument();\n      expect(passwordInput).toBeInTheDocument();\n      expect(tenantInput).toBeInTheDocument();\n    });\n\n    it('should be keyboard navigable', async () => {\n      const user = userEvent.setup();\n      renderWithoutAuth(<LoginPage />);\n\n      const usernameInput = screen.getByPlaceholderText(/username|email/i);\n      usernameInput.focus();\n\n      await user.keyboard('{Tab}');\n      const activeElement = document.activeElement;\n      expect(activeElement).toBeInTheDocument();\n    });\n\n    it('should have proper heading hierarchy', () => {\n      renderWithoutAuth(<LoginPage />);\n\n      const heading = screen.getByText('Login');\n      expect(heading).toBeInTheDocument();\n    });\n\n    it('should announce validation errors to screen readers', async () => {\n      const user = userEvent.setup();\n      renderWithoutAuth(<LoginPage />);\n\n      const submitButton = screen.getByRole('button', { name: /login|sign in/i });\n      await user.click(submitButton);\n\n      await waitFor(() => {\n        const errors = screen.queryAllByText(/required/i);\n        expect(errors.length).toBeGreaterThan(0);\n      });\n    });\n  });\n\n  describe('Edge Cases', () => {\n    it('should handle special characters in input', async () => {\n      const user = userEvent.setup();\n      renderWithoutAuth(<LoginPage />);\n\n      const usernameInput = screen.getByPlaceholderText(/username|email/i);\n      await user.type(usernameInput, '<script>alert(\"xss\")</script>');\n\n      expect((usernameInput as HTMLInputElement).value).toBe('<script>alert(\"xss\")</script>');\n    });\n\n    it('should handle rapid form submissions', async () => {\n      const user = userEvent.setup({ delay: null });\n      const deferred = createDeferred<undefined>();\n      let loginCallCount = 0;\n\n      renderWithoutAuth(<LoginPage />, {\n        authValue: {\n          login: async () => {\n            loginCallCount += 1;\n            await deferred.promise;\n          },\n          isLoading: false,\n        },\n      });\n\n      const usernameInput = screen.getByPlaceholderText(/username|email/i);\n      const passwordInput = screen.getByPlaceholderText(/password/i);\n      const tenantInput = screen.getByPlaceholderText(/tenant/i);\n\n      await user.type(usernameInput, 'testuser');\n      await user.type(passwordInput, 'password123');\n      await user.type(tenantInput, 'tenant1');\n\n      const submitButton = screen.getByRole('button', { name: /login|sign in/i });\n\n      // Click the button multiple times rapidly while the first submission is pending\n      await user.click(submitButton);\n      await user.click(submitButton);\n      await user.click(submitButton);\n\n      // Wait for the login call count to reach 1 (deterministic wait instead of arbitrary delay)\n      await waitFor(\n        () => {\n          expect(loginCallCount).toBe(1);\n        },\n        { timeout: 1000 }\n      );\n\n      // Verify that only one login was actually called (due to isSubmitting guard)\n      expect(loginCallCount).toBe(1);\n\n      deferred.resolve(undefined);\n      await deferred.promise;\n    }, 8000);\n\n    it('should handle very long input', async () => {\n      const user = userEvent.setup({ delay: null });\n      renderWithoutAuth(<LoginPage />);\n\n      const usernameInput = screen.getByPlaceholderText(/username|email/i);\n      const longText = 'x'.repeat(300); // Type more than the 254 character limit\n      await user.type(usernameInput, longText);\n\n      // HTML input with maxLength=254 should automatically truncate\n      expect((usernameInput as HTMLInputElement).value.length).toBe(254);\n    }, 8000);\n  });\n});\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/pages/__tests__/TenantsPage.test.tsx",
        "messages": [
            {
                "ruleId": "@typescript-eslint/no-non-null-assertion",
                "severity": 1,
                "message": "Forbidden non-null assertion.",
                "line": 131,
                "column": 24,
                "nodeType": "TSNonNullExpression",
                "messageId": "noNonNull",
                "endLine": 131,
                "endColumn": 37
            },
            {
                "ruleId": "@typescript-eslint/no-non-null-assertion",
                "severity": 1,
                "message": "Forbidden non-null assertion.",
                "line": 148,
                "column": 24,
                "nodeType": "TSNonNullExpression",
                "messageId": "noNonNull",
                "endLine": 148,
                "endColumn": 37
            },
            {
                "ruleId": "@typescript-eslint/no-non-null-assertion",
                "severity": 1,
                "message": "Forbidden non-null assertion.",
                "line": 166,
                "column": 24,
                "nodeType": "TSNonNullExpression",
                "messageId": "noNonNull",
                "endLine": 166,
                "endColumn": 37
            },
            {
                "ruleId": "@typescript-eslint/no-non-null-assertion",
                "severity": 1,
                "message": "Forbidden non-null assertion.",
                "line": 191,
                "column": 24,
                "nodeType": "TSNonNullExpression",
                "messageId": "noNonNull",
                "endLine": 191,
                "endColumn": 35
            },
            {
                "ruleId": "@typescript-eslint/no-non-null-assertion",
                "severity": 1,
                "message": "Forbidden non-null assertion.",
                "line": 210,
                "column": 24,
                "nodeType": "TSNonNullExpression",
                "messageId": "noNonNull",
                "endLine": 210,
                "endColumn": 35
            },
            {
                "ruleId": "@typescript-eslint/no-non-null-assertion",
                "severity": 1,
                "message": "Forbidden non-null assertion.",
                "line": 231,
                "column": 24,
                "nodeType": "TSNonNullExpression",
                "messageId": "noNonNull",
                "endLine": 231,
                "endColumn": 41
            },
            {
                "ruleId": "@typescript-eslint/no-non-null-assertion",
                "severity": 1,
                "message": "Forbidden non-null assertion.",
                "line": 249,
                "column": 24,
                "nodeType": "TSNonNullExpression",
                "messageId": "noNonNull",
                "endLine": 249,
                "endColumn": 41
            },
            {
                "ruleId": "@typescript-eslint/no-non-null-assertion",
                "severity": 1,
                "message": "Forbidden non-null assertion.",
                "line": 277,
                "column": 24,
                "nodeType": "TSNonNullExpression",
                "messageId": "noNonNull",
                "endLine": 277,
                "endColumn": 37
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.",
                "line": 316,
                "column": 24,
                "nodeType": "LogicalExpression",
                "messageId": "neverNullish",
                "endLine": 316,
                "endColumn": 79
            },
            {
                "ruleId": "@typescript-eslint/require-await",
                "severity": 1,
                "message": "Async arrow function has no 'await' expression.",
                "line": 335,
                "column": 55,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingAwait",
                "endLine": 335,
                "endColumn": 57,
                "suggestions": [
                    {
                        "messageId": "removeAsync",
                        "fix": {
                            "range": [
                                12005,
                                12011
                            ],
                            "text": ""
                        },
                        "desc": "Remove 'async'."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'user' is assigned a value but never used. Allowed unused vars must match /^_/u.",
                "line": 336,
                "column": 13,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 336,
                "endColumn": 17
            },
            {
                "ruleId": "@typescript-eslint/no-non-null-assertion",
                "severity": 1,
                "message": "Forbidden non-null assertion.",
                "line": 344,
                "column": 7,
                "nodeType": "TSNonNullExpression",
                "messageId": "noNonNull",
                "endLine": 344,
                "endColumn": 24,
                "suggestions": [
                    {
                        "messageId": "suggestOptionalChain",
                        "fix": {
                            "range": [
                                12354,
                                12355
                            ],
                            "text": "?"
                        },
                        "desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-non-null-assertion",
                "severity": 1,
                "message": "Forbidden non-null assertion.",
                "line": 345,
                "column": 43,
                "nodeType": "TSNonNullExpression",
                "messageId": "noNonNull",
                "endLine": 345,
                "endColumn": 60
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'defaultPageSize' is assigned a value but never used. Allowed unused vars must match /^_/u.",
                "line": 420,
                "column": 13,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 420,
                "endColumn": 28
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'user' is assigned a value but never used. Allowed unused vars must match /^_/u.",
                "line": 629,
                "column": 13,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 629,
                "endColumn": 17
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'user' is assigned a value but never used. Allowed unused vars must match /^_/u.",
                "line": 690,
                "column": 13,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 690,
                "endColumn": 17
            },
            {
                "ruleId": "@typescript-eslint/no-non-null-assertion",
                "severity": 1,
                "message": "Forbidden non-null assertion.",
                "line": 834,
                "column": 23,
                "nodeType": "TSNonNullExpression",
                "messageId": "noNonNull",
                "endLine": 834,
                "endColumn": 33
            },
            {
                "ruleId": "@typescript-eslint/no-non-null-assertion",
                "severity": 1,
                "message": "Forbidden non-null assertion.",
                "line": 928,
                "column": 23,
                "nodeType": "TSNonNullExpression",
                "messageId": "noNonNull",
                "endLine": 928,
                "endColumn": 33
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 18,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "import { describe, it, expect, beforeEach, afterEach, beforeAll, afterAll } from 'bun:test';\nimport { screen, waitFor, within } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport { http, HttpResponse } from 'msw';\nimport { server } from '../../test-utils/mocks/server';\nimport { renderWithAuth } from '../../test-utils/render';\nimport { TenantsPage } from '../TenantsPage';\n\nimport { asTenantId } from '../../types/ids';\nimport { getEnv } from '../../config/env';\nimport { mockTenants as _backendMockTenants, resetMockData } from '../../test-utils/mocks/handlers';\nimport { createMockAuthJwt } from '../../test-utils/jwt';\n\ndescribe.skip('TenantsPage Component', () => {\n  beforeAll(() => {\n    // Ensure MSW server is started for this test suite\n    server.listen({ onUnhandledRequest: 'warn' });\n  });\n\n  afterAll(() => {\n    // Close MSW server after all tests\n    server.close();\n  });\n\n  beforeEach(() => {\n    // Set up mock auth token in localStorage for HttpClient\n    const mockToken = createMockAuthJwt('testuser', 'tenant-1');\n    localStorage.setItem('auth_token', JSON.stringify({ token: mockToken }));\n\n    // Reset mock data to original state before each test\n    resetMockData();\n  });\n\n  afterEach(() => {\n    // Clean up localStorage\n    localStorage.removeItem('auth_token');\n    // Reset MSW handlers to default state\n    server.resetHandlers();\n  });\n\n  describe('Rendering', () => {\n    it('should display page title', async () => {\n      renderWithAuth(<TenantsPage />);\n\n      await waitFor(() => {\n        expect(screen.getByRole('heading', { level: 2 })).toHaveTextContent('Tenants');\n      });\n    });\n\n    it('should display create tenant button', () => {\n      renderWithAuth(<TenantsPage />);\n\n      const createButtons = screen.getAllByRole('button', { name: /add.*tenant/i });\n      expect(createButtons.length).toBeGreaterThan(0);\n    });\n\n    it('should render tenants table', async () => {\n      renderWithAuth(<TenantsPage />);\n\n      await waitFor(() => {\n        expect(screen.getByRole('table')).toBeTruthy();\n      });\n    });\n\n    it('should display search filters section', () => {\n      renderWithAuth(<TenantsPage />);\n\n      expect(screen.getByText('Search Filters')).toBeTruthy();\n    });\n\n    it('should display filter controls', () => {\n      renderWithAuth(<TenantsPage />);\n\n      // Check for search filters card using data-testid\n      const searchFiltersCard = screen.getByTestId('search-filters-card');\n      expect(searchFiltersCard).toBeTruthy();\n\n      // Check for filter field select using data-testid\n      const filterFieldSelect = screen.getByTestId('filter-field-select-0');\n      expect(filterFieldSelect).toBeTruthy();\n\n      // Verify the select is present and has the correct role\n      expect(screen.getByRole('combobox')).toBeTruthy();\n\n      // Check for apply and clear buttons using semantic queries\n      expect(screen.getByRole('button', { name: /apply filters/i })).toBeTruthy();\n      expect(screen.getByRole('button', { name: /clear all/i })).toBeTruthy();\n    });\n  });\n\n  describe('Loading Tenants', () => {\n    it('should fetch tenants from API on mount', async () => {\n      renderWithAuth(<TenantsPage />);\n\n      await waitFor(() => {\n        expect(screen.getByText('Test Tenant 1')).toBeTruthy();\n        expect(screen.getByText('Test Tenant 2')).toBeTruthy();\n      });\n    });\n\n    it('should render correct number of table rows for tenants', async () => {\n      renderWithAuth(<TenantsPage />);\n\n      await waitFor(() => {\n        // Check for specific tenant names instead of row count\n        _backendMockTenants.forEach(t => {\n          expect(screen.getByText(t.name)).toBeTruthy();\n        });\n      });\n    });\n\n    it('should display tenant database URLs', async () => {\n      renderWithAuth(<TenantsPage />);\n\n      expect(await screen.findByText(/postgres:\\/\\/localhost:5432\\/tenant-1/)).toBeTruthy();\n      expect(await screen.findByText(/postgres:\\/\\/localhost:5432\\/tenant-2/)).toBeTruthy();\n    });\n  });\n\n  describe('Create Tenant', () => {\n    it('should open create modal on button click', async () => {\n      const user = userEvent.setup();\n      renderWithAuth(<TenantsPage />);\n\n      const createButtons = screen.getAllByRole('button', { name: /add.*tenant/i });\n      // Ensure at least one create button exists before accessing it\n      expect(createButtons.length).toBeGreaterThan(0);\n      // Use the first button which is the main create button in the header\n      const createButton = createButtons[0];\n      expect(createButton).toBeDefined();\n      await user.click(createButton!);\n\n      await waitFor(() => {\n        expect(screen.getByText(/add.*new.*tenant/i)).toBeTruthy();\n      });\n    });\n\n    it('should have form fields in create modal', async () => {\n      const user = userEvent.setup();\n      renderWithAuth(<TenantsPage />);\n\n      const createButtons = screen.getAllByRole('button', { name: /add.*tenant/i });\n      // Ensure at least one create button exists before accessing it\n      expect(createButtons.length).toBeGreaterThan(0);\n      // Use the first button which is the main create button in the header\n      const createButton = createButtons[0];\n      expect(createButton).toBeDefined();\n      await user.click(createButton!);\n\n      await waitFor(() => {\n        expect(screen.getByPlaceholderText(/tenant name/i)).toBeTruthy();\n        expect(screen.getByPlaceholderText(/database url/i)).toBeTruthy();\n      });\n    });\n\n    it('should validate required fields', async () => {\n      const user = userEvent.setup();\n      renderWithAuth(<TenantsPage />);\n\n      const createButtons = screen.getAllByRole('button', { name: /add.*tenant/i });\n      // Ensure at least one create button exists before accessing it\n      expect(createButtons.length).toBeGreaterThan(0);\n      // Use the first button which is the main create button in the header\n      const createButton = createButtons[0];\n      expect(createButton).toBeDefined();\n      await user.click(createButton!);\n\n      const submitButton = await screen.findByRole('button', { name: /add.*tenant/i });\n      await user.click(submitButton);\n\n      await waitFor(() => {\n        const errorMessages = screen.getAllByText(/required|please enter/i);\n        expect(errorMessages.length).toBeGreaterThan(0);\n      });\n    });\n  });\n\n  describe('Edit Tenant', () => {\n    it('should open edit modal when clicking edit action', async () => {\n      const user = userEvent.setup();\n      renderWithAuth(<TenantsPage />);\n\n      await waitFor(() => {\n        expect(screen.getByText('Test Tenant 1')).toBeTruthy();\n      });\n\n      const editButtons = screen.getAllByRole('button', { name: /edit/i });\n      expect(editButtons.length).toBeGreaterThan(0);\n      const editButton = editButtons[0];\n      expect(editButton).toBeDefined();\n      await user.click(editButton!);\n\n      await waitFor(() => {\n        expect(screen.getByDisplayValue('Test Tenant 1')).toBeTruthy();\n      });\n    });\n\n    it('should populate form with tenant data including name and database URL', async () => {\n      const user = userEvent.setup();\n      renderWithAuth(<TenantsPage />);\n\n      await waitFor(() => {\n        expect(screen.getByText('Test Tenant 1')).toBeTruthy();\n      });\n\n      const editButtons = screen.getAllByRole('button', { name: /edit/i });\n      expect(editButtons.length).toBeGreaterThan(0);\n      const editButton = editButtons[0];\n      expect(editButton).toBeDefined();\n      await user.click(editButton!);\n\n      await waitFor(() => {\n        expect(screen.getByDisplayValue('Test Tenant 1')).toBeTruthy();\n        expect(screen.getByDisplayValue('postgres://localhost:5432/tenant-1')).toBeTruthy();\n      });\n    });\n  });\n\n  describe('Delete Tenant', () => {\n    it('should show delete confirmation modal', async () => {\n      const user = userEvent.setup();\n      renderWithAuth(<TenantsPage />);\n\n      await waitFor(() => {\n        expect(screen.getByText('Test Tenant 1')).toBeTruthy();\n      });\n\n      const deleteButtons = screen.getAllByRole('button', { name: /delete|trash/i });\n      expect(deleteButtons.length).toBeGreaterThan(0);\n      expect(deleteButtons[0]).toBeDefined();\n      await user.click(deleteButtons[0]!);\n\n      await waitFor(() => {\n        expect(screen.getByText(/confirm|are you sure/i)).toBeTruthy();\n      });\n    });\n\n    it('should cancel delete when clicking cancel', async () => {\n      const user = userEvent.setup();\n      renderWithAuth(<TenantsPage />);\n\n      await waitFor(() => {\n        expect(screen.getByText('Test Tenant 1')).toBeTruthy();\n      });\n\n      const deleteButtons = screen.getAllByRole('button', { name: /delete|trash/i });\n      expect(deleteButtons.length).toBeGreaterThan(0);\n      expect(deleteButtons[0]).toBeDefined();\n      await user.click(deleteButtons[0]!);\n\n      // Wait for the confirmation modal to be visible\n      await waitFor(() => {\n        expect(screen.getByText(/confirm|are you sure/i)).toBeTruthy();\n      });\n\n      // Find the ConfirmationModal component and click its cancel button\n      // Scope the query to the modal to avoid selecting wrong cancel button\n      const modal = screen.getByRole('dialog');\n      const cancelButton = within(modal).getByRole('button', { name: /cancel/i });\n      await user.click(cancelButton);\n\n      await waitFor(() => {\n        expect(screen.queryByText(/confirm|are you sure/i)).toBeNull();\n      });\n    });\n  });\n\n  describe('Validation', () => {\n    it('should validate tenant name is required', async () => {\n      const user = userEvent.setup();\n      renderWithAuth(<TenantsPage />);\n\n      const createButtons = screen.getAllByRole('button', { name: /add.*tenant/i });\n      expect(createButtons.length).toBeGreaterThan(0);\n      const createButton = createButtons[0]; // Main create button\n      expect(createButton).toBeDefined();\n      await user.click(createButton!);\n\n      // Wait for the modal to appear\n      const modal = await screen.findByRole('dialog');\n      expect(modal).toBeInTheDocument();\n\n      const dbUrlInput = await screen.findByPlaceholderText(/database|db_url/i);\n      await user.type(dbUrlInput, 'postgresql://user:pass@host:5432/db');\n\n      // Click the submit button within the modal context using data-testid\n      const submitButton = within(modal).getByTestId('modal-submit-button');\n      await user.click(submitButton);\n\n      await waitFor(() => {\n        expect(screen.getByText(/name.*required/i)).toBeTruthy();\n      });\n    });\n  });\n\n  describe('Accessibility', () => {\n    it('should have proper table semantics', async () => {\n      renderWithAuth(<TenantsPage />);\n\n      await waitFor(() => {\n        expect(screen.getByRole('table')).toBeTruthy();\n      });\n    });\n    it('should have accessible buttons with proper labels', () => {\n      renderWithAuth(<TenantsPage />);\n\n      const createButtons = screen.getAllByRole('button', { name: /add|create|new/i });\n      expect(createButtons.length).toBeGreaterThan(0);\n\n      // Expected button labels from the UI\n      const expectedLabels = ['Add Tenant'];\n      const labelPatterns = [/add tenant/i, /create tenant/i, /new tenant/i];\n\n      let foundExpectedLabel = false;\n      createButtons.forEach(button => {\n        const label = (button.getAttribute('aria-label') ?? button.textContent ?? '').trim();\n\n        // Assert minimum meaningful length\n        expect(label.length).toBeGreaterThanOrEqual(3);\n\n        // Check if this button matches an expected label\n        const matchesExpected =\n          expectedLabels.some(expected => label.toLowerCase().includes(expected.toLowerCase())) ||\n          labelPatterns.some(pattern => pattern.test(label));\n\n        if (matchesExpected) {\n          foundExpectedLabel = true;\n        }\n      });\n\n      // Guard against regressions - at least one button should match expected labels\n      expect(foundExpectedLabel).toBe(true);\n    });\n\n    it('should support keyboard navigation', async () => {\n      const user = userEvent.setup();\n      renderWithAuth(<TenantsPage />);\n\n      const createButtons = screen.getAllByRole('button', { name: /add|create|new/i });\n      expect(createButtons.length).toBeGreaterThan(0);\n\n      // Verify the button can receive focus\n      expect(createButtons[0]).toBeDefined();\n      createButtons[0]!.focus();\n      expect(document.activeElement).toBe(createButtons[0]!);\n    });\n  });\n\n  describe('Empty State', () => {\n    it('should display empty state when no tenants exist', async () => {\n      server.use(\n        http.get(`${getEnv().apiUrl}/admin/tenants`, () => {\n          return HttpResponse.json({\n            status: 'success',\n            message: 'Success',\n            data: [],\n          });\n        })\n      );\n\n      renderWithAuth(<TenantsPage />);\n\n      await waitFor(() => {\n        // Check that no tenant names are displayed\n        expect(screen.queryByText('Test Tenant 1')).toBeNull();\n        expect(screen.queryByText('Test Tenant 2')).toBeNull();\n\n        // Verify empty state message is displayed\n        expect(screen.getByText('No tenants yet. Add your first tenant!')).toBeInTheDocument();\n\n        // Verify Add Tenant button is present in the empty state\n        // There should be multiple \"Add Tenant\" buttons - one in header and one in empty state\n        const addTenantButtons = screen.getAllByRole('button', { name: /add tenant/i });\n        expect(addTenantButtons.length).toBeGreaterThanOrEqual(2); // Header button + empty state button\n      });\n    });\n  });\n\n  describe('Pagination', () => {\n    it('should handle pagination', async () => {\n      // Create mock data with 25 tenants for pagination test\n      const manyTenants = Array.from({ length: 25 }, (_, i) => ({\n        id: asTenantId(`tenant${String(i + 1)}`),\n        name: `Tenant ${String(i + 1)}`,\n        db_url: `postgresql://user:pass@host${String(i + 1)}/db${String(i + 1)}`,\n        created_at: `2020-01-${String(i + 1).padStart(2, '0')}T00:00:00.000Z`,\n        updated_at: `2020-01-${String(i + 1).padStart(2, '0')}T12:00:00.000Z`,\n      }));\n\n      server.use(\n        http.get(`${getEnv().apiUrl}/admin/tenants`, ({ request }) => {\n          const url = new URL(request.url);\n          const offset = url.searchParams.get('offset') ?? '0';\n          const limit = url.searchParams.get('limit') ?? '10';\n\n          const offsetNum = parseInt(offset);\n          const limitNum = parseInt(limit);\n          const paginatedTenants = manyTenants.slice(offsetNum, offsetNum + limitNum);\n\n          return HttpResponse.json({\n            status: 'success',\n            message: 'Success',\n            data: {\n              data: paginatedTenants,\n              total: manyTenants.length,\n              offset: offsetNum,\n              limit: limitNum,\n            },\n          });\n        })\n      );\n\n      renderWithAuth(<TenantsPage />);\n\n      await waitFor(() => {\n        expect(screen.getByText('Tenant 1')).toBeTruthy();\n      });\n\n      // Should show first page with default pageSize items (12)\n      const defaultPageSize = 12;\n\n      // Assert first and last visible tenants based on page boundaries\n      expect(screen.getByText('Tenant 1')).toBeTruthy();\n      expect(screen.queryByText('Tenant 13')).not.toBeTruthy();\n    });\n  });\n\n  describe('Sorting', () => {\n    it('should sort tenants by column (client-side)', async () => {\n      const user = userEvent.setup();\n\n      // Create mock data with specific names for sorting test\n      // Return them in descending order initially (G before A)\n      const sortingTenants = [\n        {\n          id: asTenantId('tenant-1'),\n          name: 'Global Industries',\n          db_url: 'postgres://localhost:5432/global',\n          created_at: '2020-01-01T00:00:00.000Z',\n          updated_at: '2020-01-01T12:00:00.000Z',\n        },\n        {\n          id: asTenantId('tenant-2'),\n          name: 'Acme Corporation',\n          db_url: 'postgres://localhost:5432/acme',\n          created_at: '2020-01-02T00:00:00.000Z',\n          updated_at: '2020-01-02T12:00:00.000Z',\n        },\n      ];\n\n      server.use(\n        http.get(`${getEnv().apiUrl}/admin/tenants`, () => {\n          return HttpResponse.json({\n            status: 'success',\n            message: 'Success',\n            data: {\n              data: sortingTenants,\n              total: sortingTenants.length,\n              offset: 0,\n              limit: 12,\n            },\n          });\n        })\n      );\n\n      renderWithAuth(<TenantsPage />);\n\n      // Wait for initial data load - should show Global Industries first, Acme second\n      await waitFor(() => {\n        expect(screen.getByText('Global Industries')).toBeTruthy();\n        expect(screen.getByText('Acme Corporation')).toBeTruthy();\n      });\n\n      // Verify initial order (before sorting)\n      let rows = screen.getAllByRole('row');\n      expect(rows).toHaveLength(3); // Header + 2 data rows\n      expect(rows[1]?.textContent).toContain('Global Industries'); // G comes first\n      expect(rows[2]?.textContent).toContain('Acme Corporation'); // A comes second\n\n      // Click on the Name column header to sort ascending (A-Z)\n      const nameHeader = screen.getByRole('columnheader', { name: /name/i });\n      await user.click(nameHeader);\n\n      // After sorting ascending, Acme Corporation should come before Global Industries\n      // This is client-side sorting - no new network request, just DOM reordering\n      await waitFor(() => {\n        rows = screen.getAllByRole('row');\n        expect(rows).toHaveLength(3); // Header + 2 data rows\n        expect(rows[1]?.textContent).toContain('Acme Corporation'); // A comes first\n        expect(rows[2]?.textContent).toContain('Global Industries'); // G comes second\n      });\n\n      // Click again to sort descending (Z-A)\n      await user.click(nameHeader);\n\n      await waitFor(() => {\n        rows = screen.getAllByRole('row');\n        expect(rows).toHaveLength(3); // Header + 2 data rows\n        expect(rows[1]?.textContent).toContain('Global Industries'); // G comes first\n        expect(rows[2]?.textContent).toContain('Acme Corporation'); // A comes second\n      });\n    });\n  });\n\n  describe('Search Filters', () => {\n    it('should filter tenants by name when filter is applied', async () => {\n      const user = userEvent.setup();\n      renderWithAuth(<TenantsPage />);\n\n      // Wait for initial data\n      await waitFor(() => {\n        expect(screen.getByText('Test Tenant 1')).toBeTruthy();\n        expect(screen.getByText('Test Tenant 2')).toBeTruthy();\n      });\n\n      // Enter filter value and apply\n      const filterInput = screen.getByTestId('filter-value-input-0');\n      await user.type(filterInput, 'Test Tenant 1');\n\n      const applyButton = screen.getByTestId('apply-filters-button');\n      await user.click(applyButton);\n\n      // Verify only matching tenant is shown\n      await waitFor(() => {\n        expect(screen.getByText('Test Tenant 1')).toBeTruthy();\n        expect(screen.queryByText('Test Tenant 2')).toBeNull();\n      });\n    });\n\n    it('should filter tenants by database URL when filter is applied', async () => {\n      const user = userEvent.setup();\n      renderWithAuth(<TenantsPage />);\n\n      // Wait for initial data\n      await waitFor(() => {\n        expect(screen.getByText('Test Tenant 1')).toBeTruthy();\n        expect(screen.getByText('Test Tenant 2')).toBeTruthy();\n      });\n\n      // Change filter field to database URL\n      const fieldSelect = screen.getByTestId('filter-field-select-0');\n      await user.click(fieldSelect);\n\n      // Wait for dropdown to open and then click the option\n      await waitFor(() => {\n        expect(screen.getByText('Database URL')).toBeTruthy();\n      });\n      await user.click(screen.getByText('Database URL'));\n\n      // Enter filter value and apply\n      const filterInput = screen.getByTestId('filter-value-input-0');\n      await user.type(filterInput, 'tenant1');\n\n      const applyButton = screen.getByTestId('apply-filters-button');\n      await user.click(applyButton);\n\n      // Verify only matching tenant is shown\n      await waitFor(() => {\n        expect(screen.getByText('Test Tenant 1')).toBeTruthy();\n        expect(screen.queryByText('Test Tenant 2')).toBeNull();\n      });\n    });\n\n    it('should show all tenants when filters are cleared', async () => {\n      const user = userEvent.setup();\n      renderWithAuth(<TenantsPage />);\n\n      // Wait for initial data\n      await waitFor(() => {\n        expect(screen.getByText('Test Tenant 1')).toBeTruthy();\n        expect(screen.getByText('Test Tenant 2')).toBeTruthy();\n      });\n\n      // Apply a filter first\n      const filterInput = screen.getByTestId('filter-value-input-0');\n      await user.type(filterInput, 'Test Tenant 1');\n\n      const applyButton = screen.getByTestId('apply-filters-button');\n      await user.click(applyButton);\n\n      // Verify filtering worked\n      await waitFor(() => {\n        expect(screen.getByText('Test Tenant 1')).toBeTruthy();\n        expect(screen.queryByText('Test Tenant 2')).toBeNull();\n      });\n\n      // Clear filters\n      const clearButton = screen.getByTestId('clear-filters-button');\n      await user.click(clearButton);\n\n      // Verify all tenants are shown again\n      await waitFor(() => {\n        expect(screen.getByText('Test Tenant 1')).toBeTruthy();\n        expect(screen.getByText('Test Tenant 2')).toBeTruthy();\n      });\n    });\n\n    it('should allow adding and removing filters', async () => {\n      const user = userEvent.setup();\n      renderWithAuth(<TenantsPage />);\n\n      // Wait for initial render\n      await waitFor(() => {\n        expect(screen.getByTestId('search-filters-card')).toBeTruthy();\n      });\n\n      // Should start with one filter row\n      expect(screen.getByTestId('filter-row-0')).toBeTruthy();\n      expect(screen.queryByTestId('filter-row-1')).toBeNull();\n\n      // Add a new filter\n      const addFilterButton = screen.getByTestId('add-filter-button');\n      await user.click(addFilterButton);\n\n      // Should now have two filter rows\n      expect(screen.getByTestId('filter-row-0')).toBeTruthy();\n      expect(screen.getByTestId('filter-row-1')).toBeTruthy();\n\n      // Remove the second filter\n      const removeButton = screen.getByTestId('remove-filter-1');\n      await user.click(removeButton);\n\n      // Should be back to one filter row\n      expect(screen.getByTestId('filter-row-0')).toBeTruthy();\n      expect(screen.queryByTestId('filter-row-1')).toBeNull();\n    });\n\n    it('should not allow removing the last filter', async () => {\n      const user = userEvent.setup();\n      renderWithAuth(<TenantsPage />);\n\n      // Wait for initial render\n      await waitFor(() => {\n        expect(screen.getByTestId('search-filters-card')).toBeTruthy();\n      });\n\n      // Should start with one filter row\n      expect(screen.getByTestId('filter-row-0')).toBeTruthy();\n\n      // Try to remove the only filter\n      const removeButton = screen.getByTestId('remove-filter-0');\n      expect(removeButton).toBeDisabled();\n    });\n\n    it('should display correct filter field options', async () => {\n      renderWithAuth(<TenantsPage />);\n\n      // Wait for initial render\n      await waitFor(() => {\n        expect(screen.getByTestId('search-filters-card')).toBeTruthy();\n      });\n\n      // Check that the default field is \"Name\"\n      const fieldSelect = screen.getByTestId('filter-field-select-0');\n      expect(fieldSelect).toHaveTextContent('Name');\n    });\n\n    it('should display apply and clear filter buttons', () => {\n      renderWithAuth(<TenantsPage />);\n\n      expect(screen.getByTestId('apply-filters-button')).toBeTruthy();\n      expect(screen.getByTestId('clear-filters-button')).toBeTruthy();\n    });\n\n    it('should show date picker for date fields', async () => {\n      const user = userEvent.setup();\n      renderWithAuth(<TenantsPage />);\n\n      // Wait for initial render\n      await waitFor(() => {\n        expect(screen.getByTestId('search-filters-card')).toBeTruthy();\n      });\n\n      // Change filter field to a date field\n      const fieldSelect = screen.getByTestId('filter-field-select-0');\n      await user.click(fieldSelect);\n\n      // Wait for dropdown to open and then click the option\n      await waitFor(() => {\n        expect(screen.getByText('Created At')).toBeTruthy();\n      });\n      await user.click(screen.getByText('Created At'));\n\n      // Should show date picker instead of text input\n      expect(screen.getByTestId('filter-value-date-0')).toBeTruthy();\n      expect(screen.queryByTestId('filter-value-input-0')).toBeNull();\n    });\n\n    it('should show text input for text fields', async () => {\n      const user = userEvent.setup();\n      renderWithAuth(<TenantsPage />);\n\n      // Wait for initial render\n      await waitFor(() => {\n        expect(screen.getByTestId('search-filters-card')).toBeTruthy();\n      });\n\n      // Default field should be 'Name' (text field)\n      expect(screen.getByTestId('filter-value-input-0')).toBeTruthy();\n      expect(screen.queryByTestId('filter-value-date-0')).toBeNull();\n    });\n\n    it('should update operators when field type changes', async () => {\n      const user = userEvent.setup();\n      renderWithAuth(<TenantsPage />);\n\n      // Wait for initial render\n      await waitFor(() => {\n        expect(screen.getByTestId('search-filters-card')).toBeTruthy();\n      });\n\n      // Start with text field (Name) - should have 'contains' and 'equals' operators\n      const operatorSelect = screen.getByTestId('filter-operator-select-0');\n      expect(operatorSelect).toHaveTextContent('Contains');\n\n      // Change to date field\n      const fieldSelect = screen.getByTestId('filter-field-select-0');\n      await user.click(fieldSelect);\n\n      // Wait for dropdown to open and then click the option\n      await waitFor(() => {\n        expect(screen.getByText('Created At')).toBeTruthy();\n      });\n      await user.click(screen.getByText('Created At'));\n\n      // Should now have date operators\n      await waitFor(() => {\n        expect(operatorSelect).toHaveTextContent('Equals');\n      });\n    });\n\n    it('should clear value when switching between text and date fields', async () => {\n      const user = userEvent.setup();\n      renderWithAuth(<TenantsPage />);\n\n      // Wait for initial render\n      await waitFor(() => {\n        expect(screen.getByTestId('search-filters-card')).toBeTruthy();\n      });\n\n      // Enter text value\n      const textInput = screen.getByTestId('filter-value-input-0');\n      await user.type(textInput, 'test value');\n\n      // Change to date field\n      const fieldSelect = screen.getByTestId('filter-field-select-0');\n      await user.click(fieldSelect);\n\n      // Wait for dropdown to open and then click the option\n      await waitFor(() => {\n        expect(screen.getByText('Created At')).toBeTruthy();\n      });\n      await user.click(screen.getByText('Created At'));\n\n      // Value should be cleared\n      const datePicker = screen.getByTestId('filter-value-date-0');\n      expect(datePicker).toHaveValue('');\n    });\n\n    it('should filter by date when date filter is applied', async () => {\n      const user = userEvent.setup();\n\n      // Create mock data with specific dates for testing\n      const tenantsWithDates = [\n        {\n          id: asTenantId('tenant-1'),\n          name: 'Early Tenant',\n          db_url: 'postgres://localhost:5432/early',\n          created_at: '2020-01-01T00:00:00.000Z',\n          updated_at: '2020-01-01T12:00:00.000Z',\n        },\n        {\n          id: asTenantId('tenant-2'),\n          name: 'Late Tenant',\n          db_url: 'postgres://localhost:5432/late',\n          created_at: '2020-12-31T00:00:00.000Z',\n          updated_at: '2020-12-31T12:00:00.000Z',\n        },\n      ];\n\n      // Mock initial tenants list\n      server.use(\n        http.get(`${getEnv().apiUrl}/admin/tenants`, () => {\n          return HttpResponse.json({\n            status: 'success',\n            message: 'Success',\n            data: {\n              data: tenantsWithDates,\n              total: tenantsWithDates.length,\n              offset: 0,\n              limit: 12,\n            },\n          });\n        })\n      );\n\n      // Mock filter endpoint to return only the early tenant\n      server.use(\n        http.get(`${getEnv().apiUrl}/admin/tenants/filter`, () => {\n          return HttpResponse.json({\n            status: 'success',\n            message: 'Success',\n            data: [tenantsWithDates[0]], // Only early tenant\n          });\n        })\n      );\n\n      renderWithAuth(<TenantsPage />);\n\n      // Wait for initial data (both tenants should be shown)\n      await waitFor(() => {\n        expect(screen.getByText('Early Tenant')).toBeTruthy();\n        expect(screen.getByText('Late Tenant')).toBeTruthy();\n      });\n\n      // Change to date field\n      const fieldSelect = screen.getByTestId('filter-field-select-0');\n      await user.click(fieldSelect);\n\n      // Wait for dropdown to open and then click the option\n      await waitFor(() => {\n        expect(screen.getByText('Created At')).toBeTruthy();\n      });\n      await user.click(screen.getByText('Created At'));\n\n      // Set date filter to early date\n      const datePicker = screen.getByTestId('filter-value-date-0');\n      await user.click(datePicker);\n\n      // Type the date in ISO format into the date input field\n      // Find the input element within the date picker and type the date\n      const dateInput = datePicker.querySelector('input');\n      expect(dateInput).toBeTruthy();\n      await user.type(dateInput!, '2020-01-01');\n\n      // Apply filter\n      const applyButton = screen.getByTestId('apply-filters-button');\n      await user.click(applyButton);\n\n      // Verify filtered results: only early tenant should be shown\n      await waitFor(() => {\n        expect(screen.getByText('Early Tenant')).toBeTruthy();\n        // Late tenant should no longer be visible after filtering\n        expect(screen.queryByText('Late Tenant')).toBeFalsy();\n      });\n    });\n  });\n\n  describe('Filter Validation and Error Handling', () => {\n    it('should handle empty filter values gracefully', async () => {\n      const user = userEvent.setup();\n      renderWithAuth(<TenantsPage />);\n\n      // Wait for initial data\n      await waitFor(() => {\n        expect(screen.getByText('Test Tenant 1')).toBeTruthy();\n        expect(screen.getByText('Test Tenant 2')).toBeTruthy();\n      });\n\n      // Apply filter with empty value\n      const applyButton = screen.getByTestId('apply-filters-button');\n      await user.click(applyButton);\n\n      // Should show all tenants (empty filters are ignored)\n      await waitFor(() => {\n        expect(screen.getByText('Test Tenant 1')).toBeTruthy();\n        expect(screen.getByText('Test Tenant 2')).toBeTruthy();\n      });\n    });\n\n    it('should handle filter API errors gracefully', async () => {\n      const user = userEvent.setup();\n\n      // Mock filter API to return error\n      server.use(\n        http.get(`${getEnv().apiUrl}/admin/tenants/filter`, () => {\n          return HttpResponse.json({ error: 'Filter service unavailable' }, { status: 500 });\n        })\n      );\n\n      renderWithAuth(<TenantsPage />);\n\n      // Wait for initial data\n      await waitFor(() => {\n        expect(screen.getByText('Test Tenant 1')).toBeTruthy();\n      });\n\n      // Apply filter\n      const filterInput = screen.getByTestId('filter-value-input-0');\n      await user.type(filterInput, 'Test Tenant 1');\n\n      const applyButton = screen.getByTestId('apply-filters-button');\n      await user.click(applyButton);\n\n      // Should show error message and keep original data\n      await waitFor(() => {\n        expect(screen.getByText('Test Tenant 1')).toBeTruthy();\n        expect(screen.getByText('Test Tenant 2')).toBeTruthy();\n      });\n    });\n\n    it('should show error when invalid date is entered for date field', async () => {\n      const user = userEvent.setup();\n      renderWithAuth(<TenantsPage />);\n\n      // Wait for initial render\n      await waitFor(() => {\n        expect(screen.getByTestId('search-filters-card')).toBeTruthy();\n      });\n\n      // Change to date field\n      const fieldSelect = screen.getByTestId('filter-field-select-0');\n      await user.click(fieldSelect);\n\n      // Wait for dropdown to open and then click the option\n      await waitFor(() => {\n        expect(screen.getByText('Created At')).toBeTruthy();\n      });\n      await user.click(screen.getByText('Created At'));\n\n      // Enter an invalid date format\n      const datePicker = screen.getByTestId('filter-value-date-0');\n      await user.click(datePicker);\n\n      // Type an invalid date string that won't parse as a valid date\n      const dateInput = datePicker.querySelector('input');\n      expect(dateInput).toBeTruthy();\n      await user.type(dateInput!, 'not-a-date');\n\n      // Try to apply filter with invalid date\n      const applyButton = screen.getByTestId('apply-filters-button');\n      await user.click(applyButton);\n\n      // Should show error message\n      await waitFor(() => {\n        expect(screen.getByText('Failed to filter tenants')).toBeTruthy();\n      });\n    });\n  });\n});\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/pages/__tests__/addressBookHelpers.test.ts",
        "messages": [
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected any value in conditional. An explicit comparison or type conversion is required.",
                "line": 21,
                "column": 8,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorAny",
                "endLine": 21,
                "endColumn": 27,
                "suggestions": [
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                642,
                                661
                            ],
                            "text": "(Boolean(overrides.full_name))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected any value in conditional. An explicit comparison or type conversion is required.",
                "line": 21,
                "column": 32,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorAny",
                "endLine": 21,
                "endColumn": 50,
                "suggestions": [
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                666,
                                684
                            ],
                            "text": "(Boolean(overrides.fullName))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 2,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "import { describe, it, expect } from 'bun:test';\nimport { normalizePersonDTO, type PersonDTO } from '@/types/person';\nimport { Gender } from '@/types/contact';\nimport { asContactId } from '@/types/ids';\nimport {\n  resolveContactId,\n  parseContactName,\n  resolveContactGender,\n  normalizeContactAddress,\n} from '../AddressBookPage';\n\nconst createPerson = (overrides: Record<string, unknown> = {}): PersonDTO => {\n  const defaults: Record<string, unknown> = {\n    id: 'contact-1',\n    tenant_id: 'tenant-1',\n    email: 'test@example.com',\n    is_active: true,\n  };\n\n  // Only add default names if not explicitly overriding with fullName\n  if (!overrides.full_name && !overrides.fullName) {\n    defaults.first_name = 'Test';\n    defaults.last_name = 'User';\n  }\n\n  return normalizePersonDTO({\n    ...defaults,\n    ...overrides,\n  });\n};\n\ndescribe('AddressBook helper functions', () => {\n  describe('resolveContactId', () => {\n    it('uses trimmed string identifiers when available', () => {\n      const person = createPerson({ id: '  contact-999  ' });\n      const result = resolveContactId(person, () => asContactId('fallback'));\n      expect(result).toEqual(asContactId('contact-999'));\n    });\n\n    it('handles numeric identifiers by converting to string', () => {\n      const person = createPerson({ id: 42 });\n      const result = resolveContactId(person, () => asContactId('fallback'));\n      expect(result).toEqual(asContactId('42'));\n    });\n\n    it('falls back when identifier is missing', () => {\n      const person = createPerson({ id: undefined });\n      const fallbackId = asContactId('generated-id');\n      const result = resolveContactId(person, () => fallbackId);\n      expect(result).toBe(fallbackId);\n    });\n  });\n\n  describe('parseContactName', () => {\n    it('prefers canonical name field when present', () => {\n      const person = createPerson({ full_name: 'Ada Lovelace ' });\n      const result = parseContactName(person);\n      expect(result).toEqual({ rawName: 'Ada Lovelace', firstName: 'Ada', lastName: 'Lovelace' });\n    });\n\n    it('builds name from first and last names when needed', () => {\n      const person = createPerson({ first_name: 'Grace', last_name: 'Hopper' });\n      const result = parseContactName(person);\n      expect(result).toEqual({ rawName: 'Grace Hopper', firstName: 'Grace', lastName: 'Hopper' });\n    });\n\n    it('handles missing data gracefully', () => {\n      const person = createPerson({ id: undefined, first_name: undefined, last_name: undefined });\n      const result = parseContactName(person);\n      expect(result).toEqual({ rawName: '', firstName: '', lastName: '' });\n    });\n  });\n\n  describe('resolveContactGender', () => {\n    it('resolves gender from string values', () => {\n      expect(resolveContactGender(createPerson({ gender: Gender.male }))).toBe(Gender.male);\n      expect(resolveContactGender(createPerson({ gender: Gender.female }))).toBe(Gender.female);\n    });\n\n    it('does not normalize boolean gender values (invalid input type)', () => {\n      // Note: normalizeGender intentionally does not support boolean values\n      // per the design decision in src/types/person.ts\n      const personTrue = createPerson({ gender: true });\n      const personFalse = createPerson({ gender: false });\n      expect(resolveContactGender(personTrue)).toBe(undefined);\n      expect(resolveContactGender(personFalse)).toBe(undefined);\n    });\n\n    it('resolves non-binary gender to Gender.other', () => {\n      const person = createPerson({ gender: 'non-binary' });\n      // normalizeGender maps 'non-binary' to Gender.other\n      expect(resolveContactGender(person)).toBe(Gender.other);\n    });\n\n    it('resolves nonbinary variant to Gender.other', () => {\n      const person = createPerson({ gender: 'nonbinary' });\n      expect(resolveContactGender(person)).toBe(Gender.other);\n    });\n\n    it('resolves nb abbreviation to Gender.other', () => {\n      const person = createPerson({ gender: 'nb' });\n      expect(resolveContactGender(person)).toBe(Gender.other);\n    });\n\n    it('resolves explicit \"other\" to Gender.other', () => {\n      const person = createPerson({ gender: 'other' });\n      expect(resolveContactGender(person)).toBe(Gender.other);\n    });\n\n    it('resolves spaced \"non binary\" to Gender.other', () => {\n      const person = createPerson({ gender: 'non binary' });\n      expect(resolveContactGender(person)).toBe(Gender.other);\n    });\n\n    it('resolves capitalized \"Non-Binary\" to Gender.other', () => {\n      const person = createPerson({ gender: 'Non-Binary' });\n      expect(resolveContactGender(person)).toBe(Gender.other);\n    });\n\n    it('resolves \"genderqueer\" to Gender.other', () => {\n      const person = createPerson({ gender: 'genderqueer' });\n      expect(resolveContactGender(person)).toBe(Gender.other);\n    });\n\n    it('resolves capitalized \"OTHER\" to Gender.other', () => {\n      const person = createPerson({ gender: 'OTHER' });\n      expect(resolveContactGender(person)).toBe(Gender.other);\n    });\n\n    it('handles undefined gender gracefully', () => {\n      const person = createPerson({ gender: undefined });\n      expect(resolveContactGender(person)).toBe(undefined);\n    });\n\n    it('handles null gender gracefully', () => {\n      const person = createPerson({ gender: null });\n      expect(resolveContactGender(person)).toBe(undefined);\n    });\n  });\n\n  describe('normalizeContactAddress', () => {\n    const defaultCountry = 'Wonderland';\n\n    it('normalises structured address objects', () => {\n      const person = createPerson({\n        address: {\n          street1: ' 123 Main St ',\n          street2: 'Apt 4',\n          city: 'Metropolis',\n          state: 'NY',\n          zipCode: '10001',\n          country: ' USA ',\n        },\n      });\n\n      const result = normalizeContactAddress(person, defaultCountry);\n      expect(result).toEqual({\n        street1: '123 Main St',\n        street2: 'Apt 4',\n        city: 'Metropolis',\n        state: 'NY',\n        zipCode: '10001',\n        country: 'USA',\n      });\n    });\n\n    it('derives street1 from legacy address field when needed', () => {\n      const person = createPerson({\n        address: {\n          address: '42 Galaxy Way',\n          city: 'Space City',\n        },\n      });\n\n      const result = normalizeContactAddress(person, defaultCountry);\n      expect(result).toEqual({\n        street1: '42 Galaxy Way',\n        street2: undefined,\n        city: 'Space City',\n        state: '',\n        zipCode: '',\n        country: defaultCountry,\n      });\n    });\n\n    it('handles string addresses by mapping to street1 and default fields', () => {\n      const person = createPerson({ address: 'Planet Express' });\n      const result = normalizeContactAddress(person, defaultCountry);\n      expect(result).toEqual({\n        street1: 'Planet Express',\n        street2: undefined,\n        city: '',\n        state: '',\n        zipCode: '',\n        country: defaultCountry,\n      });\n    });\n\n    it('returns undefined when no address is provided', () => {\n      const person = createPerson({ address: undefined });\n      const result = normalizeContactAddress(person, defaultCountry);\n      expect(result).toBeUndefined();\n    });\n  });\n});\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/services/SearchService.ts",
        "messages": [
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, the types have no overlap.",
                "line": 21,
                "column": 38,
                "nodeType": "BinaryExpression",
                "messageId": "noOverlapBooleanExpression",
                "endLine": 21,
                "endColumn": 52
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, the types have no overlap.",
                "line": 43,
                "column": 9,
                "nodeType": "BinaryExpression",
                "messageId": "noOverlapBooleanExpression",
                "endLine": 43,
                "endColumn": 23
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, the types have no overlap.",
                "line": 43,
                "column": 27,
                "nodeType": "BinaryExpression",
                "messageId": "noOverlapBooleanExpression",
                "endLine": 43,
                "endColumn": 46
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, the types have no overlap.",
                "line": 43,
                "column": 50,
                "nodeType": "BinaryExpression",
                "messageId": "noOverlapBooleanExpression",
                "endLine": 43,
                "endColumn": 69
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, the types have no overlap.",
                "line": 43,
                "column": 73,
                "nodeType": "BinaryExpression",
                "messageId": "noOverlapBooleanExpression",
                "endLine": 43,
                "endColumn": 97
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, the types have no overlap.",
                "line": 56,
                "column": 9,
                "nodeType": "BinaryExpression",
                "messageId": "noOverlapBooleanExpression",
                "endLine": 56,
                "endColumn": 23
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, the types have no overlap.",
                "line": 56,
                "column": 27,
                "nodeType": "BinaryExpression",
                "messageId": "noOverlapBooleanExpression",
                "endLine": 56,
                "endColumn": 46
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, the types have no overlap.",
                "line": 56,
                "column": 50,
                "nodeType": "BinaryExpression",
                "messageId": "noOverlapBooleanExpression",
                "endLine": 56,
                "endColumn": 69
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, the types have no overlap.",
                "line": 56,
                "column": 73,
                "nodeType": "BinaryExpression",
                "messageId": "noOverlapBooleanExpression",
                "endLine": 56,
                "endColumn": 97
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, the types have no overlap.",
                "line": 65,
                "column": 9,
                "nodeType": "BinaryExpression",
                "messageId": "noOverlapBooleanExpression",
                "endLine": 65,
                "endColumn": 23
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, the types have no overlap.",
                "line": 65,
                "column": 27,
                "nodeType": "BinaryExpression",
                "messageId": "noOverlapBooleanExpression",
                "endLine": 65,
                "endColumn": 46
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, the types have no overlap.",
                "line": 65,
                "column": 50,
                "nodeType": "BinaryExpression",
                "messageId": "noOverlapBooleanExpression",
                "endLine": 65,
                "endColumn": 69
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, the types have no overlap.",
                "line": 65,
                "column": 73,
                "nodeType": "BinaryExpression",
                "messageId": "noOverlapBooleanExpression",
                "endLine": 65,
                "endColumn": 97
            },
            {
                "ruleId": "@typescript-eslint/no-base-to-string",
                "severity": 1,
                "message": "'value' will use Object's default stringification format ('[object Object]') when stringified.",
                "line": 143,
                "column": 36,
                "nodeType": "Identifier",
                "messageId": "baseToString",
                "endLine": 143,
                "endColumn": 41
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, the types have no overlap.",
                "line": 243,
                "column": 40,
                "nodeType": "BinaryExpression",
                "messageId": "noOverlapBooleanExpression",
                "endLine": 243,
                "endColumn": 66
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, the types have no overlap.",
                "line": 256,
                "column": 40,
                "nodeType": "BinaryExpression",
                "messageId": "noOverlapBooleanExpression",
                "endLine": 256,
                "endColumn": 66
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, the types have no overlap.",
                "line": 272,
                "column": 40,
                "nodeType": "BinaryExpression",
                "messageId": "noOverlapBooleanExpression",
                "endLine": 272,
                "endColumn": 66
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, the types have no overlap.",
                "line": 288,
                "column": 40,
                "nodeType": "BinaryExpression",
                "messageId": "noOverlapBooleanExpression",
                "endLine": 288,
                "endColumn": 66
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, the types have no overlap.",
                "line": 304,
                "column": 40,
                "nodeType": "BinaryExpression",
                "messageId": "noOverlapBooleanExpression",
                "endLine": 304,
                "endColumn": 66
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, comparison is always false, since `2 !== 2` is false.",
                "line": 320,
                "column": 47,
                "nodeType": "BinaryExpression",
                "messageId": "comparisonBetweenLiteralTypes",
                "endLine": 320,
                "endColumn": 72
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, the types have no overlap.",
                "line": 345,
                "column": 72,
                "nodeType": "BinaryExpression",
                "messageId": "noOverlapBooleanExpression",
                "endLine": 345,
                "endColumn": 87
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, the types have no overlap.",
                "line": 355,
                "column": 72,
                "nodeType": "BinaryExpression",
                "messageId": "noOverlapBooleanExpression",
                "endLine": 355,
                "endColumn": 87
            },
            {
                "ruleId": "@typescript-eslint/no-base-to-string",
                "severity": 1,
                "message": "'a' will use Object's default stringification format ('[object Object]') when stringified.",
                "line": 391,
                "column": 19,
                "nodeType": "Identifier",
                "messageId": "baseToString",
                "endLine": 391,
                "endColumn": 20
            },
            {
                "ruleId": "@typescript-eslint/no-base-to-string",
                "severity": 1,
                "message": "'b' will use Object's default stringification format ('[object Object]') when stringified.",
                "line": 391,
                "column": 43,
                "nodeType": "Identifier",
                "messageId": "baseToString",
                "endLine": 391,
                "endColumn": 44
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary optional chain on a non-nullish value.",
                "line": 509,
                "column": 22,
                "nodeType": "MemberExpression",
                "messageId": "neverOptionalChain",
                "endLine": 509,
                "endColumn": 24,
                "suggestions": [
                    {
                        "messageId": "suggestRemoveOptionalChain",
                        "fix": {
                            "range": [
                                15385,
                                15387
                            ],
                            "text": "."
                        },
                        "desc": "Remove unnecessary optional chain"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary optional chain on a non-nullish value.",
                "line": 512,
                "column": 20,
                "nodeType": "MemberExpression",
                "messageId": "neverOptionalChain",
                "endLine": 512,
                "endColumn": 22,
                "suggestions": [
                    {
                        "messageId": "suggestRemoveOptionalChain",
                        "fix": {
                            "range": [
                                15494,
                                15496
                            ],
                            "text": "."
                        },
                        "desc": "Remove unnecessary optional chain"
                    }
                ]
            }
        ],
        "suppressedMessages": [
            {
                "ruleId": "@typescript-eslint/no-extraneous-class",
                "severity": 2,
                "message": "Unexpected class with only static properties.",
                "line": 41,
                "column": 14,
                "nodeType": "Identifier",
                "messageId": "onlyStatic",
                "endLine": 41,
                "endColumn": 29,
                "suppressions": [
                    {
                        "kind": "directive",
                        "justification": ""
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-extraneous-class",
                "severity": 2,
                "message": "Unexpected class with only static properties.",
                "line": 547,
                "column": 14,
                "nodeType": "Identifier",
                "messageId": "onlyStatic",
                "endLine": 547,
                "endColumn": 34,
                "suppressions": [
                    {
                        "kind": "directive",
                        "justification": ""
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-extraneous-class",
                "severity": 2,
                "message": "Unexpected class with only static properties.",
                "line": 565,
                "column": 14,
                "nodeType": "Identifier",
                "messageId": "onlyStatic",
                "endLine": 565,
                "endColumn": 36,
                "suppressions": [
                    {
                        "kind": "directive",
                        "justification": ""
                    }
                ]
            }
        ],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 26,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "/**\n * Enhanced Search Service\n * Provides frontend-only search functionality with advanced filtering, sorting, and pagination\n */\n\nimport { ok, err } from 'neverthrow';\nimport type { Result } from '@/types/fp';\nimport type { Contact } from '@/types/contact';\nimport type { Tenant } from '@/types/tenant';\nimport type { SearchFilter, SearchQuery, SearchResult } from '@/components/SearchComponents';\n\n/**\n * Get field value from object using dot notation\n */\nfunction getFieldValue(item: unknown, field: string): unknown {\n  const keys = field.split('.');\n  let value: unknown = item;\n\n  for (const key of keys) {\n    if (value === null || value === undefined) return null;\n    if (typeof value !== 'object' || value === null) return null;\n    value = (value as Record<string, unknown>)[key];\n  }\n\n  return value;\n}\n\n/**\n * Search service error types\n */\nexport type SearchServiceError =\n  | { type: 'INVALID_FILTER'; field: string; reason: string }\n  | { type: 'INVALID_SORT'; field: string; reason: string }\n  | { type: 'SEARCH_FAILED'; reason: string }\n  | { type: 'NO_DATA'; message: string };\n\n/**\n * Search operator implementations\n */\n// eslint-disable-next-line @typescript-eslint/no-extraneous-class\nexport class SearchOperators {\n  static contains(value: string, searchTerm: string, caseSensitive = false): boolean {\n    if (value === null || value === undefined || searchTerm === null || searchTerm === undefined) {\n      return false;\n    }\n    const normalizedValue = caseSensitive ? value : value.toLowerCase();\n    const normalizedSearch = caseSensitive ? searchTerm : searchTerm.toLowerCase();\n    return normalizedValue.includes(normalizedSearch);\n  }\n\n  static equals(value: string | number | boolean, searchTerm: string | number | boolean): boolean {\n    return value === searchTerm;\n  }\n\n  static startsWith(value: string, searchTerm: string, caseSensitive = false): boolean {\n    if (value === null || value === undefined || searchTerm === null || searchTerm === undefined) {\n      return false;\n    }\n    const normalizedValue = caseSensitive ? value : value.toLowerCase();\n    const normalizedSearch = caseSensitive ? searchTerm : searchTerm.toLowerCase();\n    return normalizedValue.startsWith(normalizedSearch);\n  }\n\n  static endsWith(value: string, searchTerm: string, caseSensitive = false): boolean {\n    if (value === null || value === undefined || searchTerm === null || searchTerm === undefined) {\n      return false;\n    }\n    const normalizedValue = caseSensitive ? value : value.toLowerCase();\n    const normalizedSearch = caseSensitive ? searchTerm : searchTerm.toLowerCase();\n    return normalizedValue.endsWith(normalizedSearch);\n  }\n\n  static greaterThan(value: number, searchTerm: number): boolean {\n    return value > searchTerm;\n  }\n\n  static greaterThanOrEqual(value: number, searchTerm: number): boolean {\n    return value >= searchTerm;\n  }\n\n  static lessThan(value: number, searchTerm: number): boolean {\n    return value < searchTerm;\n  }\n\n  static lessThanOrEqual(value: number, searchTerm: number): boolean {\n    return value <= searchTerm;\n  }\n\n  static between(value: number, range: [number, number]): boolean {\n    return value >= range[0] && value <= range[1];\n  }\n\n  static isIn(value: string | number, searchTerms: (string | number | null)[]): boolean {\n    return searchTerms.includes(value);\n  }\n\n  static notIn(value: string | number, searchTerms: (string | number | null)[]): boolean {\n    return !searchTerms.includes(value);\n  }\n}\n\n/**\n * Generic search service for any data type\n */\nexport class GenericSearchService<T> {\n  protected data: T[];\n  private searchFields: string[];\n  private caseSensitive: boolean;\n\n  constructor(data: T[], searchFields: string[], caseSensitive = false) {\n    this.data = data;\n    this.searchFields = searchFields;\n    this.caseSensitive = caseSensitive;\n  }\n\n  /**\n   * Update the data source\n   */\n  updateData(newData: T[]): void {\n    this.data = newData;\n  }\n\n  /**\n   * Update search fields\n   */\n  updateSearchFields(newFields: string[]): void {\n    this.searchFields = newFields;\n  }\n\n  /**\n   * Perform text search across multiple fields\n   */\n  textSearch(query: string): T[] {\n    if (!query.trim()) return this.data;\n\n    const normalizedQuery = this.caseSensitive ? query : query.toLowerCase();\n\n    return this.data.filter(item => {\n      return this.searchFields.some(field => {\n        const value = getFieldValue(item, field);\n        if (value === null || value === undefined) return false;\n\n        const stringValue = String(value);\n        const normalizedValue = this.caseSensitive ? stringValue : stringValue.toLowerCase();\n        return normalizedValue.includes(normalizedQuery);\n      });\n    });\n  }\n\n  /**\n   * Apply filters to data\n   */\n  applyFilters(filters: SearchFilter[]): T[] {\n    if (filters.length === 0) return this.data;\n\n    return this.data.filter(item => {\n      return filters.every(filter => {\n        const value = getFieldValue(item, filter.field);\n        if (value === null || value === undefined) return false;\n\n        return this.evaluateFilter(value, filter);\n      });\n    });\n  }\n\n  /**\n   * Sort data by field and order\n   */\n  sortData(data: T[], sortBy?: string, sortOrder: 'asc' | 'desc' = 'asc'): T[] {\n    if (sortBy == null || sortBy === '') return data;\n\n    return [...data].sort((a, b) => {\n      const aValue = getFieldValue(a, sortBy);\n      const bValue = getFieldValue(b, sortBy);\n\n      if (aValue === null || aValue === undefined) return sortOrder === 'asc' ? 1 : -1;\n      if (bValue === null || bValue === undefined) return sortOrder === 'asc' ? -1 : 1;\n\n      const comparison = this.compareValues(aValue, bValue);\n      return sortOrder === 'asc' ? comparison : -comparison;\n    });\n  }\n\n  /**\n   * Paginate data\n   */\n  paginateData(data: T[], page: number, pageSize: number): SearchResult<T> {\n    const total = data.length;\n    const totalPages = Math.ceil(total / pageSize);\n    const startIndex = (page - 1) * pageSize;\n    const endIndex = startIndex + pageSize;\n    const paginatedData = data.slice(startIndex, endIndex);\n\n    return {\n      data: paginatedData,\n      total,\n      page,\n      pageSize,\n      totalPages,\n      hasNext: page < totalPages,\n      hasPrev: page > 1,\n    };\n  }\n\n  /**\n   * Perform comprehensive search with filters, sorting, and pagination\n   */\n  search(query: SearchQuery): Result<SearchResult<T>, SearchServiceError> {\n    try {\n      let filteredData = this.data;\n\n      // Apply text search if query has search term\n      if (query.filters.length > 0) {\n        filteredData = this.applyFilters(query.filters);\n      }\n\n      // Apply sorting\n      if (query.sortBy != null && query.sortBy !== '') {\n        filteredData = this.sortData(filteredData, query.sortBy, query.sortOrder);\n      }\n\n      // Apply pagination\n      const result = this.paginateData(filteredData, query.page ?? 1, query.pageSize ?? 10);\n\n      return ok(result);\n    } catch (error) {\n      return err({\n        type: 'SEARCH_FAILED',\n        reason: error instanceof Error ? error.message : 'Unknown search error',\n      });\n    }\n  }\n\n  /**\n   * Evaluate a single filter\n   */\n  private evaluateFilter(value: unknown, filter: SearchFilter): boolean {\n    try {\n      switch (filter.operator) {\n        case 'contains':\n          return SearchOperators.contains(String(value), String(filter.value), this.caseSensitive);\n        case 'equals':\n          if (filter.value === null || filter.value === undefined || Array.isArray(filter.value)) {\n            return false;\n          }\n          return SearchOperators.equals(value as string | number | boolean, filter.value);\n        case 'startsWith':\n          return SearchOperators.startsWith(\n            String(value),\n            String(filter.value),\n            this.caseSensitive\n          );\n        case 'endsWith':\n          return SearchOperators.endsWith(String(value), String(filter.value), this.caseSensitive);\n        case 'gt': {\n          if (filter.value === null || filter.value === undefined) {\n            return false;\n          }\n          const numValue = Number(value);\n          const numFilter = Number(filter.value);\n          if (\n            !isFinite(numValue) ||\n            Number.isNaN(numValue) ||\n            !isFinite(numFilter) ||\n            Number.isNaN(numFilter)\n          ) {\n            return false;\n          }\n          return SearchOperators.greaterThan(numValue, numFilter);\n        }\n        case 'gte': {\n          if (filter.value === null || filter.value === undefined) {\n            return false;\n          }\n          const numValue = Number(value);\n          const numFilter = Number(filter.value);\n          if (\n            !isFinite(numValue) ||\n            Number.isNaN(numValue) ||\n            !isFinite(numFilter) ||\n            Number.isNaN(numFilter)\n          ) {\n            return false;\n          }\n          return SearchOperators.greaterThanOrEqual(numValue, numFilter);\n        }\n        case 'lt': {\n          if (filter.value === null || filter.value === undefined) {\n            return false;\n          }\n          const numValue = Number(value);\n          const numFilter = Number(filter.value);\n          if (\n            !isFinite(numValue) ||\n            Number.isNaN(numValue) ||\n            !isFinite(numFilter) ||\n            Number.isNaN(numFilter)\n          ) {\n            return false;\n          }\n          return SearchOperators.lessThan(numValue, numFilter);\n        }\n        case 'lte': {\n          if (filter.value === null || filter.value === undefined) {\n            return false;\n          }\n          const numValue = Number(value);\n          const numFilter = Number(filter.value);\n          if (\n            !isFinite(numValue) ||\n            Number.isNaN(numValue) ||\n            !isFinite(numFilter) ||\n            Number.isNaN(numFilter)\n          ) {\n            return false;\n          }\n          return SearchOperators.lessThanOrEqual(numValue, numFilter);\n        }\n        case 'between': {\n          if (!Array.isArray(filter.value) || filter.value.length !== 2) {\n            return false;\n          }\n          // If either range value is null, treat as no filter\n          if (filter.value[0] === null || filter.value[1] === null) {\n            return false;\n          }\n          const numValue = Number(value);\n          const numLower = Number(filter.value[0]);\n          const numUpper = Number(filter.value[1]);\n          if (\n            !isFinite(numValue) ||\n            Number.isNaN(numValue) ||\n            !isFinite(numLower) ||\n            Number.isNaN(numLower) ||\n            !isFinite(numUpper) ||\n            Number.isNaN(numUpper)\n          ) {\n            return false;\n          }\n          return SearchOperators.between(numValue, [numLower, numUpper]);\n        }\n        case 'in':\n          if (Array.isArray(filter.value)) {\n            // Filter out null values from the array\n            const validValues = filter.value.filter(v => v !== null && v !== undefined);\n            if (validValues.length === 0) {\n              return false;\n            }\n            return SearchOperators.isIn(value as string | number, validValues);\n          }\n          return false;\n        case 'notIn':\n          if (Array.isArray(filter.value)) {\n            // Filter out null values from the array\n            const validValues = filter.value.filter(v => v !== null && v !== undefined);\n            if (validValues.length === 0) {\n              return false;\n            }\n            return SearchOperators.notIn(value as string | number, validValues);\n          }\n          return false;\n        default:\n          return false;\n      }\n    } catch (error) {\n      console.warn(`Filter evaluation failed for field ${filter.field}:`, error);\n      return false;\n    }\n  }\n\n  /**\n   * Compare two values for sorting\n   */\n  private compareValues(a: unknown, b: unknown): number {\n    if (a === b) return 0;\n    if (a === null || a === undefined) return -1;\n    if (b === null || b === undefined) return 1;\n\n    if (typeof a === 'number' && typeof b === 'number') {\n      return a - b;\n    }\n\n    if (typeof a === 'string' && typeof b === 'string') {\n      return a.localeCompare(b);\n    }\n\n    if (a instanceof Date && b instanceof Date) {\n      return a.getTime() - b.getTime();\n    }\n\n    return String(a).localeCompare(String(b));\n  }\n}\n\n/**\n * Contact-specific search service\n */\nexport class ContactSearchService extends GenericSearchService<Contact> {\n  constructor(contacts: Contact[]) {\n    const searchFields = [\n      'fullName',\n      'firstName',\n      'lastName',\n      'email',\n      'phone',\n      'mobile',\n      'company',\n      'jobTitle',\n      'address.street1',\n      'address.city',\n      'address.state',\n      'address.zipCode',\n      'address.country',\n    ];\n    super(contacts, searchFields);\n  }\n\n  /**\n  getSuggestions(searchTerm: string, limit = 10): string[] {\n    if (!searchTerm.trim()) return [];\n\n    const normalizedTerm = searchTerm.toLowerCase();\n    const suggestions = new Set<string>();\n\n    this.data.forEach(contact => {\n      // Add name suggestions\n      if (contact.fullName?.toLowerCase().includes(normalizedTerm)) {\n        suggestions.add(contact.fullName);\n      }\n\n      // Add email suggestions\n      if (contact.email?.toLowerCase().includes(normalizedTerm)) {\n        suggestions.add(contact.email);\n      }\n\n      // Add phone suggestions\n      if (contact.phone?.includes(normalizedTerm)) {\n        suggestions.add(contact.phone);\n      }\n\n      // Add company suggestions\n      if (contact.company?.toLowerCase().includes(normalizedTerm)) {\n        suggestions.add(contact.company);\n      }\n    });\n\n    return Array.from(suggestions).slice(0, limit);\n  }\n\n      // Add company suggestions\n      if (contact.company?.toLowerCase().includes(normalizedTerm)) {\n        suggestions.add(contact.company);\n      }\n    });\n\n    return Array.from(suggestions).slice(0, limit);\n  }\n\n  /**\n   * Get contact statistics\n   */\n  getStatistics(): {\n    total: number;\n    withEmail: number;\n    withPhone: number;\n    withAddress: number;\n    active: number;\n    inactive: number;\n  } {\n    return {\n      total: this.data.length,\n      withEmail: this.data.filter(c => c.email != null && c.email !== '').length,\n      withPhone: this.data.filter(\n        c => (c.phone != null && c.phone !== '') || (c.mobile != null && c.mobile !== '')\n      ).length,\n      withAddress: this.data.filter(c => c.address != null).length,\n      active: this.data.filter(c => c.isActive).length,\n      inactive: this.data.filter(c => !c.isActive).length,\n    };\n  }\n}\n\n/**\n * Tenant-specific search service\n */\nexport class TenantSearchService extends GenericSearchService<Tenant> {\n  constructor(tenants: Tenant[]) {\n    const searchFields = ['name', 'id', 'db_url'];\n    super(tenants, searchFields);\n  }\n\n  /**\n   * Search tenants with advanced filtering\n   */\n  searchTenants(query: SearchQuery): Result<SearchResult<Tenant>, SearchServiceError> {\n    return this.search(query);\n  }\n\n  /**\n   * Get tenant suggestions for autocomplete\n   */\n  getSuggestions(searchTerm: string, limit = 10): string[] {\n    if (!searchTerm.trim()) return [];\n\n    const normalizedTerm = searchTerm.toLowerCase();\n    const suggestions = new Set<string>();\n\n    this.data.forEach(tenant => {\n      if (tenant.name?.toLowerCase().includes(normalizedTerm)) {\n        suggestions.add(tenant.name);\n      }\n      if (tenant.id?.toLowerCase().includes(normalizedTerm)) {\n        suggestions.add(tenant.id);\n      }\n    });\n\n    return Array.from(suggestions).slice(0, limit);\n  }\n\n  /**\n   * Get tenant statistics\n   */\n  getStatistics(): {\n    total: number;\n    withDbUrl: number;\n    recentlyCreated: number;\n  } {\n    const oneWeekAgo = new Date();\n    oneWeekAgo.setDate(oneWeekAgo.getDate() - 7);\n\n    return {\n      total: this.data.length,\n      withDbUrl: this.data.filter(t => t.db_url).length,\n      recentlyCreated: this.data.filter(t => {\n        if (!t.created_at) return false;\n        const createdDate = new Date(t.created_at);\n        return !isNaN(createdDate.getTime()) && createdDate > oneWeekAgo;\n      }).length,\n    };\n  }\n}\n\n/**\n * Search service factory\n */\n// eslint-disable-next-line @typescript-eslint/no-extraneous-class\nexport class SearchServiceFactory {\n  static createContactService(contacts: Contact[]): ContactSearchService {\n    return new ContactSearchService(contacts);\n  }\n\n  static createTenantService(tenants: Tenant[]): TenantSearchService {\n    return new TenantSearchService(tenants);\n  }\n\n  static createGenericService<T>(data: T[], searchFields: string[]): GenericSearchService<T> {\n    return new GenericSearchService(data, searchFields);\n  }\n}\n\n/**\n * Search performance utilities\n */\n// eslint-disable-next-line @typescript-eslint/no-extraneous-class\nexport class SearchPerformanceUtils {\n  /**\n   * Measure search performance\n   */\n  static measureSearch<T>(\n    searchFunction: () => T,\n    threshold = 100\n  ): { result: T; time: number; isSlow: boolean } {\n    const start = performance.now();\n    const result = searchFunction();\n    const time = performance.now() - start;\n    const isSlow = time > threshold;\n\n    if (isSlow) {\n      console.warn(\n        `Slow search detected: ${time.toFixed(2)}ms (threshold: ${threshold.toString()}ms)`\n      );\n    }\n\n    return { result, time, isSlow };\n  }\n\n  static batchSearch<T>(searches: (() => T)[], batchSize = 10): Promise<T[]> {\n    return new Promise((resolve, reject) => {\n      const results: T[] = [];\n      let index = 0;\n\n      const processBatch = (): void => {\n        try {\n          const batch = searches.slice(index, index + batchSize);\n          const batchResults = batch.map(search => search());\n          results.push(...batchResults);\n          index += batchSize;\n\n          if (index < searches.length) {\n            setTimeout(processBatch, 0); // Yield to event loop\n          } else {\n            resolve(results);\n          }\n        } catch (error) {\n          reject(error instanceof Error ? error : new Error(String(error)));\n        }\n      };\n\n      processBatch();\n    });\n  }\n}\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/services/StorageService.ts",
        "messages": [
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.",
                "line": 69,
                "column": 24,
                "nodeType": "Identifier",
                "messageId": "neverNullish",
                "endLine": 69,
                "endColumn": 39
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 89,
                "column": 12,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 89,
                "endColumn": 19,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                2181,
                                2189
                            ],
                            "text": "version == null"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                2182,
                                2189
                            ],
                            "text": "(version ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                2181,
                                2189
                            ],
                            "text": "!Boolean(version)"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "no-console",
                "severity": 1,
                "message": "Unexpected console statement. Only these console methods are allowed: warn, error.",
                "line": 108,
                "column": 5,
                "nodeType": "MemberExpression",
                "messageId": "limited",
                "endLine": 108,
                "endColumn": 16,
                "suggestions": [
                    {
                        "fix": {
                            "range": [
                                2742,
                                2805
                            ],
                            "text": ""
                        },
                        "messageId": "removeConsole",
                        "data": {
                            "propertyName": "log"
                        },
                        "desc": "Remove the console.log()."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/restrict-template-expressions",
                "severity": 1,
                "message": "Invalid type \"number\" of template literal expression.",
                "line": 108,
                "column": 51,
                "nodeType": "Identifier",
                "messageId": "invalidType",
                "endLine": 108,
                "endColumn": 55
            },
            {
                "ruleId": "@typescript-eslint/restrict-template-expressions",
                "severity": 1,
                "message": "Invalid type \"number\" of template literal expression.",
                "line": 108,
                "column": 62,
                "nodeType": "Identifier",
                "messageId": "invalidType",
                "endLine": 108,
                "endColumn": 64
            },
            {
                "ruleId": "@typescript-eslint/no-non-null-assertion",
                "severity": 1,
                "message": "Forbidden non-null assertion.",
                "line": 157,
                "column": 19,
                "nodeType": "TSNonNullExpression",
                "messageId": "noNonNull",
                "endLine": 157,
                "endColumn": 32,
                "suggestions": [
                    {
                        "messageId": "suggestOptionalChain",
                        "fix": {
                            "range": [
                                4715,
                                4716
                            ],
                            "text": "?"
                        },
                        "desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-type-parameters",
                "severity": 1,
                "message": "Type parameter T is used only once in the function signature.",
                "line": 197,
                "column": 7,
                "nodeType": "TSTypeParameter",
                "messageId": "sole",
                "endLine": 197,
                "endColumn": 8,
                "suggestions": [
                    {
                        "messageId": "replaceUsagesWithConstraint",
                        "fix": {
                            "range": [
                                5997,
                                6035
                            ],
                            "text": "(key: StorageKey | string, value: unknown"
                        },
                        "desc": "Replace all usages of type parameter with its constraint."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-non-null-assertion",
                "severity": 1,
                "message": "Forbidden non-null assertion.",
                "line": 206,
                "column": 9,
                "nodeType": "TSNonNullExpression",
                "messageId": "noNonNull",
                "endLine": 206,
                "endColumn": 22,
                "suggestions": [
                    {
                        "messageId": "suggestOptionalChain",
                        "fix": {
                            "range": [
                                6342,
                                6343
                            ],
                            "text": "?"
                        },
                        "desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-type-parameters",
                "severity": 1,
                "message": "Type parameter T is used only once in the function signature.",
                "line": 228,
                "column": 16,
                "nodeType": "TSTypeParameter",
                "messageId": "sole",
                "endLine": 228,
                "endColumn": 17,
                "suggestions": [
                    {
                        "messageId": "replaceUsagesWithConstraint",
                        "fix": {
                            "range": [
                                7152,
                                7262
                            ],
                            "text": "(key: StorageKey | string, value: unknown): Result<void, StorageError> {\n    const versionedData: VersionedData<unknown"
                        },
                        "desc": "Replace all usages of type parameter with its constraint."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-non-null-assertion",
                "severity": 1,
                "message": "Forbidden non-null assertion.",
                "line": 249,
                "column": 7,
                "nodeType": "TSNonNullExpression",
                "messageId": "noNonNull",
                "endLine": 249,
                "endColumn": 20,
                "suggestions": [
                    {
                        "messageId": "suggestOptionalChain",
                        "fix": {
                            "range": [
                                7822,
                                7823
                            ],
                            "text": "?"
                        },
                        "desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-non-null-assertion",
                "severity": 1,
                "message": "Forbidden non-null assertion.",
                "line": 268,
                "column": 7,
                "nodeType": "TSNonNullExpression",
                "messageId": "noNonNull",
                "endLine": 268,
                "endColumn": 20,
                "suggestions": [
                    {
                        "messageId": "suggestOptionalChain",
                        "fix": {
                            "range": [
                                8398,
                                8399
                            ],
                            "text": "?"
                        },
                        "desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
                    }
                ]
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 11,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "/**\n * StorageService - Result-based localStorage abstraction\n *\n * Provides type-safe storage operations with Result types for functional error handling.\n * Wraps all localStorage operations to handle errors gracefully without exceptions.\n *\n * @example\n * ```typescript\n * const storage = new StorageService();\n * const result = storage.get<User>(StorageKey.USER);\n * result.match(\n *   (user) => console.log('User found:', user),\n *   (error) => console.log('Error:', formatStorageError(error))\n * );\n * ```\n */\n\nimport { type Result, ok, err } from 'neverthrow';\nimport type { StorageError } from '../types/errors';\nimport { StorageErrors } from '../types/errors';\n\n/**\n * Type-safe storage keys enum\n * Add new keys here to maintain consistency across the application\n */\nexport enum StorageKey {\n  AUTH_TOKEN = 'auth_token',\n  USER = 'user',\n  TENANT = 'tenant',\n  REFRESH_TOKEN = 'refresh_token',\n  LAST_ACTIVITY = 'last_activity',\n  THEME = 'theme',\n  LANGUAGE = 'language',\n}\n\n/**\n * Storage version for migration support\n */\nconst STORAGE_VERSION = 1;\nconst STORAGE_VERSION_KEY = '__storage_version__';\n\n/**\n * Interface for versioned storage data\n */\ninterface VersionedData<T> {\n  version: number;\n  data: T;\n  timestamp: number;\n}\n\n/**\n * StorageService class with Result-based API\n */\nexport class StorageService {\n  private storage: Storage | null;\n\n  /**\n   * Create a new StorageService instance\n   * @param storage - The storage backend (defaults to localStorage if available)\n   */\n  constructor(storage?: Storage) {\n    this.storage = null;\n\n    if (storage) {\n      this.storage = storage;\n    } else if (typeof window !== 'undefined') {\n      try {\n        const localStorageRef = window.localStorage;\n        this.storage = localStorageRef ?? null;\n      } catch (error) {\n        console.warn('Storage unavailable during initialization:', error);\n        this.storage = null;\n      }\n    }\n\n    if (this.storage) {\n      this.initializeVersion();\n    }\n  }\n\n  /**\n   * Initialize storage version\n   */\n  private initializeVersion(): void {\n    if (!this.storage) return;\n\n    try {\n      const version = this.storage.getItem(STORAGE_VERSION_KEY);\n      if (!version) {\n        this.storage.setItem(STORAGE_VERSION_KEY, STORAGE_VERSION.toString());\n      } else {\n        const currentVersion = parseInt(version, 10);\n        if (currentVersion < STORAGE_VERSION) {\n          this.migrate(currentVersion, STORAGE_VERSION);\n        }\n      }\n    } catch (error) {\n      console.warn('Failed to initialize storage version:', error);\n    }\n  }\n\n  /**\n   * Migrate storage data between versions\n   * @param from - Source version\n   * @param to - Target version\n   */\n  private migrate(from: number, to: number): void {\n    console.log(`Migrating storage from version ${from} to ${to}`);\n\n    // TODO: Implement migration logic when STORAGE_VERSION is incremented\n    //\n    // When incrementing STORAGE_VERSION, you must:\n    // 1. Add version-specific migration logic below (e.g., if (from === 1 && to === 2) { ... })\n    // 2. Migrate/rename storage keys if the key enum changed\n    // 3. Transform data formats for any keys with changed structure\n    // 4. Handle backward compatibility for users on older versions\n    // 5. Add unit tests in StorageService.test.ts to verify:\n    //    - Migration from each prior version to current version\n    //    - Data integrity after migration\n    //    - Handling of missing/corrupt data during migration\n    // 6. Add integration tests to verify end-to-end migration in real browser storage\n    //\n    // Example migration pattern:\n    // if (from === 1 && to === 2) {\n    //   // Rename old key to new key\n    //   const oldData = this.storage.getItem('old_key');\n    //   if (oldData) {\n    //     this.storage.setItem('new_key', oldData);\n    //     this.storage.removeItem('old_key');\n    //   }\n    //   // Transform data structure\n    //   const userData = this.storage.getItem('user');\n    //   if (userData) {\n    //     const parsed = JSON.parse(userData);\n    //     const migrated = { ...parsed, newField: 'defaultValue' };\n    //     this.storage.setItem('user', JSON.stringify(migrated));\n    //   }\n    // }\n\n    if (this.storage) {\n      this.storage.setItem(STORAGE_VERSION_KEY, to.toString());\n    }\n  }\n\n  /**\n   * Get a value from storage\n   * @param key - The storage key\n   * @returns Result containing the parsed value or a StorageError\n   */\n  get<T>(key: StorageKey | string): Result<T, StorageError> {\n    try {\n      // Check if storage is available\n      if (!this.isStorageAvailable()) {\n        return err(StorageErrors.unavailable('Storage is not available in this environment'));\n      }\n\n      const raw = this.storage!.getItem(key);\n\n      if (raw === null) {\n        return err(StorageErrors.notFound(key));\n      }\n\n      try {\n        const parsed = JSON.parse(raw) as T;\n        return ok(parsed);\n      } catch (parseError) {\n        const reason = parseError instanceof Error ? parseError.message : 'Unknown parse error';\n        return err(StorageErrors.parseError(key, reason));\n      }\n    } catch (error) {\n      const reason = error instanceof Error ? error.message : 'Unknown error';\n      return err(StorageErrors.unavailable(reason));\n    }\n  }\n\n  /**\n   * Get a versioned value from storage\n   * @param key - The storage key\n   * @returns Result containing the parsed value or a StorageError\n   */\n  getVersioned<T>(key: StorageKey | string): Result<T, StorageError> {\n    return this.get<VersionedData<T>>(key).andThen(versionedData => {\n      // Check version and return error on mismatch\n      if (versionedData.version !== STORAGE_VERSION) {\n        return err(StorageErrors.versionMismatch(key, STORAGE_VERSION, versionedData.version));\n      }\n      return ok(versionedData.data);\n    });\n  }\n\n  /**\n   * Set a value in storage\n   * @param key - The storage key\n   * @param value - The value to store\n   * @returns Result containing void on success or a StorageError\n   */\n  set<T>(key: StorageKey | string, value: T): Result<void, StorageError> {\n    try {\n      // Check if storage is available\n      if (!this.isStorageAvailable()) {\n        return err(StorageErrors.unavailable('Storage is not available in this environment'));\n      }\n\n      try {\n        const serialized = JSON.stringify(value);\n        this.storage!.setItem(key, serialized);\n        return ok(undefined);\n      } catch (stringifyError) {\n        if (stringifyError instanceof Error && stringifyError.name === 'QuotaExceededError') {\n          return err(StorageErrors.quotaExceeded(key));\n        }\n        const reason =\n          stringifyError instanceof Error ? stringifyError.message : 'Unknown stringify error';\n        return err(StorageErrors.stringifyError(key, reason));\n      }\n    } catch (error) {\n      const reason = error instanceof Error ? error.message : 'Unknown error';\n      return err(StorageErrors.unavailable(reason));\n    }\n  }\n\n  /**\n   * Set a versioned value in storage\n   * @param key - The storage key\n   * @param value - The value to store\n   * @returns Result containing void on success or a StorageError\n   */\n  setVersioned<T>(key: StorageKey | string, value: T): Result<void, StorageError> {\n    const versionedData: VersionedData<T> = {\n      version: STORAGE_VERSION,\n      data: value,\n      timestamp: Date.now(),\n    };\n    return this.set(key, versionedData);\n  }\n\n  /**\n   * Remove a value from storage\n   * @param key - The storage key\n   * @returns Result containing void on success or a StorageError\n   */\n  remove(key: StorageKey | string): Result<void, StorageError> {\n    try {\n      // Check if storage is available\n      if (!this.isStorageAvailable()) {\n        return err(StorageErrors.unavailable('Storage is not available in this environment'));\n      }\n\n      this.storage!.removeItem(key);\n      return ok(undefined);\n    } catch (error) {\n      const reason = error instanceof Error ? error.message : 'Unknown error';\n      return err(StorageErrors.unavailable(reason));\n    }\n  }\n\n  /**\n   * Clear all values from storage\n   * @returns Result containing void on success or a StorageError\n   */\n  clear(): Result<void, StorageError> {\n    try {\n      // Check if storage is available\n      if (!this.isStorageAvailable()) {\n        return err(StorageErrors.unavailable('Storage is not available in this environment'));\n      }\n\n      this.storage!.clear();\n      // Reinitialize version after clear\n      this.initializeVersion();\n      return ok(undefined);\n    } catch (error) {\n      const reason = error instanceof Error ? error.message : 'Unknown error';\n      return err(StorageErrors.unavailable(reason));\n    }\n  }\n\n  /**\n   * Check if a key exists in storage\n   * @param key - The storage key\n   * @returns true if the key exists, false otherwise\n   */\n  has(key: StorageKey | string): boolean {\n    try {\n      if (!this.storage) return false;\n      return this.storage.getItem(key) !== null;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Get all keys in storage\n   * @returns Array of storage keys\n   */\n  keys(): string[] {\n    try {\n      if (!this.storage) return [];\n      const keys: string[] = [];\n      for (let i = 0; i < this.storage.length; i++) {\n        const key = this.storage.key(i);\n        if (key !== null && key !== STORAGE_VERSION_KEY) {\n          keys.push(key);\n        }\n      }\n      return keys;\n    } catch {\n      return [];\n    }\n  }\n\n  /**\n   * Check if storage is available\n   * @returns true if storage is available, false otherwise\n   */\n  private isStorageAvailable(): boolean {\n    try {\n      if (!this.storage) return false;\n      const testKey = '__storage_test__';\n      this.storage.setItem(testKey, 'test');\n      this.storage.removeItem(testKey);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n}\n\n/**\n * Default storage service instance\n * Use this for most cases unless you need a custom storage backend\n */\nexport const storageService = new StorageService();\n\n/**\n * Helper functions for common storage operations\n */\n\n/**\n * Get authentication token from storage\n */\nexport const getAuthToken = (): Result<{ token: string }, StorageError> =>\n  storageService.get<{ token: string }>(StorageKey.AUTH_TOKEN);\n\n/**\n * Set authentication token in storage\n */\nexport const setAuthToken = (token: string): Result<void, StorageError> =>\n  storageService.set(StorageKey.AUTH_TOKEN, { token });\n\n/**\n * Remove authentication token from storage\n */\nexport const removeAuthToken = (): Result<void, StorageError> =>\n  storageService.remove(StorageKey.AUTH_TOKEN);\n\n/**\n * Clear all authentication-related data\n */\nexport const clearAuthData = (): Result<void, StorageError> => {\n  const results = [\n    storageService.remove(StorageKey.AUTH_TOKEN),\n    storageService.remove(StorageKey.USER),\n    storageService.remove(StorageKey.TENANT),\n    storageService.remove(StorageKey.REFRESH_TOKEN),\n    storageService.remove(StorageKey.LAST_ACTIVITY),\n  ];\n\n  // Return first error or success\n  for (const result of results) {\n    if (result.isErr()) {\n      return result;\n    }\n  }\n\n  return ok(undefined);\n};\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/services/TenantContextService.ts",
        "messages": [
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'isTenantActive' is defined but never used. Allowed unused vars must match /^_/u.",
                "line": 13,
                "column": 22,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 13,
                "endColumn": 36
            },
            {
                "ruleId": "@typescript-eslint/no-empty-function",
                "severity": 2,
                "message": "Unexpected empty constructor.",
                "line": 61,
                "column": 25,
                "nodeType": "FunctionExpression",
                "messageId": "unexpected",
                "endLine": 61,
                "endColumn": 27,
                "suggestions": [
                    {
                        "messageId": "suggestComment",
                        "data": {
                            "name": "constructor"
                        },
                        "fix": {
                            "range": [
                                1521,
                                1521
                            ],
                            "text": " /* empty */ "
                        },
                        "desc": "Add comment inside empty constructor."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, value is always falsy.",
                "line": 64,
                "column": 9,
                "nodeType": "UnaryExpression",
                "messageId": "alwaysFalsy",
                "endLine": 64,
                "endColumn": 39
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected object value in conditional. The condition is always true.",
                "line": 64,
                "column": 10,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorObject",
                "endLine": 64,
                "endColumn": 39
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 206,
                "column": 12,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 206,
                "endColumn": 18,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                5142,
                                5149
                            ],
                            "text": "stored == null"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                5143,
                                5149
                            ],
                            "text": "(stored ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                5142,
                                5149
                            ],
                            "text": "!Boolean(stored)"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 245,
                "column": 12,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 245,
                "endColumn": 23,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                6208,
                                6220
                            ],
                            "text": "payloadPart == null"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                6209,
                                6220
                            ],
                            "text": "(payloadPart ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                6208,
                                6220
                            ],
                            "text": "!Boolean(payloadPart)"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 282,
                "column": 43,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 282,
                "endColumn": 45,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                7309,
                                7311
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/require-await",
                "severity": 1,
                "message": "Async method 'switchTenant' has no 'await' expression.",
                "line": 289,
                "column": 3,
                "nodeType": "FunctionExpression",
                "messageId": "missingAwait",
                "endLine": 289,
                "endColumn": 21,
                "suggestions": [
                    {
                        "messageId": "removeAsync",
                        "fix": {
                            "range": [
                                7424,
                                7512
                            ],
                            "text": "switchTenant(tenant: Tenant, user: User): Result<TenantContext, AppError>"
                        },
                        "desc": "Remove 'async'."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'user' is defined but never used. Allowed unused args must match /^_/u.",
                "line": 289,
                "column": 38,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 289,
                "endColumn": 42
            },
            {
                "ruleId": "@typescript-eslint/require-await",
                "severity": 1,
                "message": "Async method 'refreshContext' has no 'await' expression.",
                "line": 358,
                "column": 3,
                "nodeType": "FunctionExpression",
                "messageId": "missingAwait",
                "endLine": 358,
                "endColumn": 23,
                "suggestions": [
                    {
                        "messageId": "removeAsync",
                        "fix": {
                            "range": [
                                9343,
                                9407
                            ],
                            "text": "refreshContext(): Result<TenantContext, AppError>"
                        },
                        "desc": "Remove 'async'."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 385,
                "column": 36,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingReturnType",
                "endLine": 385,
                "endColumn": 38
            },
            {
                "ruleId": "react-hooks/exhaustive-deps",
                "severity": 1,
                "message": "React Hook useEffect has a missing dependency: 'service'. Either include it or remove the dependency array.",
                "line": 392,
                "column": 6,
                "nodeType": "ArrayExpression",
                "endLine": 392,
                "endColumn": 8,
                "suggestions": [
                    {
                        "desc": "Update the dependencies array to be: [service]",
                        "fix": {
                            "range": [
                                10381,
                                10383
                            ],
                            "text": "[service]"
                        }
                    }
                ]
            }
        ],
        "suppressedMessages": [],
        "errorCount": 1,
        "fatalErrorCount": 0,
        "warningCount": 11,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "/**\n * Tenant Context Service\n * Manages tenant context, JWT tokens, and tenant switching functionality\n */\n\nimport { ok, err } from 'neverthrow';\nimport { useState, useEffect } from 'react';\nimport type { Result } from '@/types/fp';\nimport type { AppError } from '@/types/errors';\nimport { createBusinessLogicError } from '@/types/errors';\nimport type { Tenant } from '@/types/tenant';\nimport type { User } from '@/types/auth';\nimport { isActive as isTenantActive } from '@/domain/tenants';\n\n/**\n * Tenant context interface\n */\nexport interface TenantContext {\n  tenant: Tenant;\n  role: string;\n  permissions: string[];\n  limits: TenantLimits;\n  features: string[];\n}\n\n/**\n * Tenant limits interface\n */\nexport interface TenantLimits {\n  maxUsers: number;\n  maxContacts: number;\n  maxStorage: number;\n  maxApiCalls: number;\n  currentUsers: number;\n  currentContacts: number;\n  currentStorage: number;\n  currentApiCalls: number;\n}\n\n/**\n * JWT token structure for tenant context\n */\nexport interface TenantJWT {\n  sub: string; // User ID\n  tenant_id: string; // Current tenant ID\n  tenant_role: string; // Role within tenant\n  permissions: string[]; // Tenant-specific permissions\n  tenant_limits: TenantLimits;\n  iat: number;\n  exp: number;\n}\n\n/**\n * Tenant context service class\n */\nexport class TenantContextService {\n  private static instance: TenantContextService;\n  private currentContext: TenantContext | null = null;\n  private listeners: ((context: TenantContext | null) => void)[] = [];\n\n  private constructor() {}\n\n  static getInstance(): TenantContextService {\n    if (!TenantContextService.instance) {\n      TenantContextService.instance = new TenantContextService();\n    }\n    return TenantContextService.instance;\n  }\n\n  /**\n   * Set tenant context\n   */\n  setTenantContext(context: TenantContext): void {\n    this.currentContext = context;\n    this.notifyListeners();\n    this.persistContext();\n  }\n\n  /**\n   * Get current tenant context\n   */\n  getTenantContext(): TenantContext | null {\n    return this.currentContext;\n  }\n\n  /**\n   * Clear tenant context\n   */\n  clearTenantContext(): void {\n    this.currentContext = null;\n    this.notifyListeners();\n    this.clearPersistedContext();\n  }\n\n  /**\n   * Check if user has permission in current tenant\n   */\n  hasPermission(permission: string): boolean {\n    if (!this.currentContext) return false;\n    return this.currentContext.permissions.includes(permission);\n  }\n\n  /**\n   * Check if user has role in current tenant\n   */\n  hasRole(role: string): boolean {\n    if (!this.currentContext) return false;\n    return this.currentContext.role === role;\n  }\n\n  /**\n   * Check if user has any of the specified roles\n   */\n  hasAnyRole(roles: string[]): boolean {\n    if (!this.currentContext) return false;\n    return roles.includes(this.currentContext.role);\n  }\n\n  /**\n   * Check if tenant has feature enabled\n   */\n  hasFeature(feature: string): boolean {\n    if (!this.currentContext) return false;\n    return this.currentContext.features.includes(feature);\n  }\n\n  /**\n   * Check if tenant is within limits\n   */\n  isWithinLimits(resource: keyof TenantLimits): boolean {\n    if (!this.currentContext) return false;\n\n    const limits = this.currentContext.limits;\n    const currentKey =\n      `current${resource.charAt(0).toUpperCase() + resource.slice(1)}` as keyof TenantLimits;\n    const maxKey =\n      `max${resource.charAt(0).toUpperCase() + resource.slice(1)}` as keyof TenantLimits;\n\n    const current = limits[currentKey];\n    const max = limits[maxKey];\n\n    return current < max;\n  }\n\n  /**\n   * Get remaining limit for resource\n   */\n  getRemainingLimit(resource: keyof TenantLimits): number {\n    if (!this.currentContext) return 0;\n\n    const limits = this.currentContext.limits;\n    const currentKey =\n      `current${resource.charAt(0).toUpperCase() + resource.slice(1)}` as keyof TenantLimits;\n    const maxKey =\n      `max${resource.charAt(0).toUpperCase() + resource.slice(1)}` as keyof TenantLimits;\n\n    const current = limits[currentKey];\n    const max = limits[maxKey];\n\n    return Math.max(0, max - current);\n  }\n\n  /**\n   * Subscribe to context changes\n   */\n  subscribe(listener: (context: TenantContext | null) => void): () => void {\n    this.listeners.push(listener);\n\n    // Return unsubscribe function\n    return () => {\n      const index = this.listeners.indexOf(listener);\n      if (index > -1) {\n        this.listeners.splice(index, 1);\n      }\n    };\n  }\n\n  /**\n   * Notify listeners of context changes\n   */\n  private notifyListeners(): void {\n    this.listeners.forEach(listener => {\n      try {\n        listener(this.currentContext);\n      } catch (error) {\n        console.error('Error in tenant context listener:', error);\n      }\n    });\n  }\n\n  /**\n   * Persist context to localStorage\n   */\n  private persistContext(): void {\n    if (this.currentContext) {\n      localStorage.setItem('tenantContext', JSON.stringify(this.currentContext));\n    }\n  }\n\n  /**\n   * Load context from localStorage\n   */\n  loadPersistedContext(): Result<TenantContext, AppError> {\n    try {\n      const stored = localStorage.getItem('tenantContext');\n      if (!stored) {\n        return err(\n          createBusinessLogicError('No persisted tenant context found', { code: 'NOT_FOUND' })\n        );\n      }\n\n      const context = JSON.parse(stored) as TenantContext;\n      this.currentContext = context;\n      this.notifyListeners();\n\n      return ok(context);\n    } catch (error) {\n      return err(\n        createBusinessLogicError('Failed to parse persisted tenant context', {\n          code: 'PARSING_ERROR',\n          cause: error,\n        })\n      );\n    }\n  }\n\n  /**\n   * Clear persisted context\n   */\n  private clearPersistedContext(): void {\n    localStorage.removeItem('tenantContext');\n  }\n\n  /**\n   * Validate JWT token for tenant context\n   */\n  validateTenantJWT(token: string): Result<TenantJWT, AppError> {\n    try {\n      // In a real implementation, you would verify the JWT signature\n      const parts = token.split('.');\n      if (parts.length !== 3) {\n        return err(createBusinessLogicError('Invalid JWT token format', { code: 'INVALID_TOKEN' }));\n      }\n      const payloadPart = parts[1];\n      if (!payloadPart) {\n        return err(createBusinessLogicError('Invalid JWT token format', { code: 'INVALID_TOKEN' }));\n      }\n\n      // Normalize base64url to base64 for atob()\n      const normalizedPayload = payloadPart\n        .replace(/-/g, '+')\n        .replace(/_/g, '/')\n        .padEnd(Math.ceil(payloadPart.length / 4) * 4, '=');\n\n      const payload = JSON.parse(atob(normalizedPayload)) as TenantJWT;\n\n      // Check expiration\n      if (payload.exp < Date.now() / 1000) {\n        return err(createBusinessLogicError('JWT token has expired', { code: 'TOKEN_EXPIRED' }));\n      }\n\n      return ok(payload);\n    } catch (error) {\n      return err(\n        createBusinessLogicError('Invalid JWT token format', {\n          code: 'INVALID_TOKEN',\n          cause: error,\n        })\n      );\n    }\n  }\n\n  /**\n   * Extract tenant context from JWT\n   */\n  extractTenantContextFromJWT(jwt: TenantJWT, tenant: Tenant): TenantContext {\n    return {\n      tenant,\n      role: jwt.tenant_role,\n      permissions: jwt.permissions,\n      limits: jwt.tenant_limits,\n      features: tenant.settings?.features || [], // Use features from tenant settings if available\n    };\n  }\n\n  /**\n   * Switch to different tenant\n   */\n  async switchTenant(tenant: Tenant, user: User): Promise<Result<TenantContext, AppError>> {\n    try {\n      // In a real implementation, you would:\n      // 1. Validate user has access to tenant\n      // 2. Get user's role in tenant\n      // 3. Get tenant limits and features\n      // 4. Generate new JWT with tenant context\n\n      // Mock implementation\n      const context: TenantContext = {\n        tenant,\n        role: 'admin', // This would come from user-tenant relationship\n        permissions: ['read:contacts', 'write:contacts', 'admin:tenant'],\n        limits: {\n          maxUsers: 100,\n          maxContacts: 10000,\n          maxStorage: 1000,\n          maxApiCalls: 100000,\n          currentUsers: 25,\n          currentContacts: 1500,\n          currentStorage: 250,\n          currentApiCalls: 50000,\n        },\n        features: ['analytics', 'backup', 'api_access'],\n      };\n\n      this.setTenantContext(context);\n      return ok(context);\n    } catch (error) {\n      return err(\n        createBusinessLogicError('Failed to switch tenant', {\n          code: 'TENANT_SWITCH_FAILED',\n          cause: error,\n        })\n      );\n    }\n  }\n\n  /**\n   * Get tenant context for API requests\n   */\n  getTenantContextForAPI(): Record<string, string> {\n    if (!this.currentContext) {\n      return {};\n    }\n\n    return {\n      'X-Tenant-ID': this.currentContext.tenant.id,\n      'X-Tenant-Role': this.currentContext.role,\n      'X-Tenant-Permissions': this.currentContext.permissions.join(','),\n    };\n  }\n\n  /**\n   * Check if context is valid\n   */\n  isContextValid(): boolean {\n    if (!this.currentContext) return false;\n\n    // Note: Real tenant status validation must happen server-side\n    // Client-side context validation is limited due to security constraints\n    // Server APIs should validate tenant status and ownership on each request\n\n    return true;\n  }\n\n  /**\n   * Refresh tenant context\n   */\n  async refreshContext(): Promise<Result<TenantContext, AppError>> {\n    if (!this.currentContext) {\n      return err(createBusinessLogicError('No tenant context to refresh', { code: 'NO_CONTEXT' }));\n    }\n\n    try {\n      // In a real implementation, you would:\n      // 1. Fetch updated tenant data\n      // 2. Fetch updated user permissions\n      // 3. Fetch updated limits and usage\n\n      // Mock implementation - just return current context\n      return ok(this.currentContext);\n    } catch (error) {\n      return err(\n        createBusinessLogicError('Failed to refresh tenant context', {\n          code: 'REFRESH_FAILED',\n          cause: error,\n        })\n      );\n    }\n  }\n}\n\n/**\n * Hook for using tenant context in React components\n */\nexport const useTenantContext = () => {\n  const service = TenantContextService.getInstance();\n  const [context, setContext] = useState<TenantContext | null>(service.getTenantContext());\n\n  useEffect(() => {\n    const unsubscribe = service.subscribe(setContext);\n    return unsubscribe;\n  }, []);\n\n  return {\n    context,\n    hasPermission: service.hasPermission.bind(service),\n    hasRole: service.hasRole.bind(service),\n    hasAnyRole: service.hasAnyRole.bind(service),\n    hasFeature: service.hasFeature.bind(service),\n    isWithinLimits: service.isWithinLimits.bind(service),\n    getRemainingLimit: service.getRemainingLimit.bind(service),\n    switchTenant: service.switchTenant.bind(service),\n    refreshContext: service.refreshContext.bind(service),\n  };\n};\n\n// Export singleton instance\nexport const tenantContextService = TenantContextService.getInstance();\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/services/TenantHealthService.ts",
        "messages": [
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'Tenant' is defined but never used. Allowed unused vars must match /^_/u.",
                "line": 9,
                "column": 15,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 9,
                "endColumn": 21
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 37,
                "column": 28,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 37,
                "endColumn": 31,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                950,
                                953
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                950,
                                953
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, value is always falsy.",
                "line": 95,
                "column": 9,
                "nodeType": "UnaryExpression",
                "messageId": "alwaysFalsy",
                "endLine": 95,
                "endColumn": 38
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected object value in conditional. The condition is always true.",
                "line": 95,
                "column": 10,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorObject",
                "endLine": 95,
                "endColumn": 38
            },
            {
                "ruleId": "@typescript-eslint/restrict-template-expressions",
                "severity": 1,
                "message": "Invalid type \"number\" of template literal expression.",
                "line": 227,
                "column": 55,
                "nodeType": "Identifier",
                "messageId": "invalidType",
                "endLine": 227,
                "endColumn": 67
            },
            {
                "ruleId": "@typescript-eslint/require-await",
                "severity": 1,
                "message": "Async method 'checkApiHealth' has no 'await' expression.",
                "line": 252,
                "column": 3,
                "nodeType": "FunctionExpression",
                "messageId": "missingAwait",
                "endLine": 252,
                "endColumn": 31,
                "suggestions": [
                    {
                        "messageId": "removeAsync",
                        "fix": {
                            "range": [
                                6834,
                                6894
                            ],
                            "text": "checkApiHealth(tenantId: string): HealthCheck"
                        },
                        "desc": "Remove 'async'."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'tenantId' is defined but never used. Allowed unused args must match /^_/u.",
                "line": 252,
                "column": 32,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 252,
                "endColumn": 40
            },
            {
                "ruleId": "@typescript-eslint/require-await",
                "severity": 1,
                "message": "Async method 'checkStorageHealth' has no 'await' expression.",
                "line": 296,
                "column": 3,
                "nodeType": "FunctionExpression",
                "messageId": "missingAwait",
                "endLine": 296,
                "endColumn": 35,
                "suggestions": [
                    {
                        "messageId": "removeAsync",
                        "fix": {
                            "range": [
                                8269,
                                8333
                            ],
                            "text": "checkStorageHealth(tenantId: string): HealthCheck"
                        },
                        "desc": "Remove 'async'."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'tenantId' is defined but never used. Allowed unused args must match /^_/u.",
                "line": 296,
                "column": 36,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 296,
                "endColumn": 44
            },
            {
                "ruleId": "@typescript-eslint/require-await",
                "severity": 1,
                "message": "Async method 'checkPerformanceHealth' has no 'await' expression.",
                "line": 330,
                "column": 3,
                "nodeType": "FunctionExpression",
                "messageId": "missingAwait",
                "endLine": 330,
                "endColumn": 39,
                "suggestions": [
                    {
                        "messageId": "removeAsync",
                        "fix": {
                            "range": [
                                9297,
                                9365
                            ],
                            "text": "checkPerformanceHealth(tenantId: string): HealthCheck"
                        },
                        "desc": "Remove 'async'."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'tenantId' is defined but never used. Allowed unused args must match /^_/u.",
                "line": 330,
                "column": 40,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 330,
                "endColumn": 48
            },
            {
                "ruleId": "@typescript-eslint/require-await",
                "severity": 1,
                "message": "Async method 'checkFeaturesHealth' has no 'await' expression.",
                "line": 393,
                "column": 3,
                "nodeType": "FunctionExpression",
                "messageId": "missingAwait",
                "endLine": 393,
                "endColumn": 36,
                "suggestions": [
                    {
                        "messageId": "removeAsync",
                        "fix": {
                            "range": [
                                11289,
                                11354
                            ],
                            "text": "checkFeaturesHealth(tenantId: string): HealthCheck"
                        },
                        "desc": "Remove 'async'."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'tenantId' is defined but never used. Allowed unused args must match /^_/u.",
                "line": 393,
                "column": 37,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 393,
                "endColumn": 45
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 474,
                "column": 44,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 474,
                "endColumn": 46,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                13866,
                                13868
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/require-await",
                "severity": 1,
                "message": "Async method 'getHealthCheckHistory' has no 'await' expression.",
                "line": 490,
                "column": 3,
                "nodeType": "FunctionExpression",
                "messageId": "missingAwait",
                "endLine": 490,
                "endColumn": 30,
                "suggestions": [
                    {
                        "messageId": "removeAsync",
                        "fix": {
                            "range": [
                                14283,
                                14401
                            ],
                            "text": "getHealthCheckHistory(\n    tenantId: string,\n    limit = 100\n  ): Result<HealthCheckResult[], AppError>"
                        },
                        "desc": "Remove 'async'."
                    }
                ]
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 15,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "/**\n * Tenant Health Monitoring Service\n * Provides comprehensive health monitoring for tenant infrastructure\n */\n\nimport { ok, err } from 'neverthrow';\nimport type { Result } from '@/types/fp';\nimport type { AppError } from '@/types/errors';\nimport type { Tenant } from '@/types/tenant';\nimport { tenantContextService } from './TenantContextService';\nimport { tenantIsolationService } from './TenantIsolationService';\n\n/**\n * Health check result interface\n */\nexport interface HealthCheckResult {\n  status: 'healthy' | 'degraded' | 'unhealthy';\n  score: number; // 0-100\n  checks: {\n    database: HealthCheck;\n    api: HealthCheck;\n    storage: HealthCheck;\n    performance: HealthCheck;\n    features: HealthCheck;\n  };\n  timestamp: Date;\n  issues: string[];\n  recommendations: string[];\n}\n\n/**\n * Individual health check interface\n */\nexport interface HealthCheck {\n  status: 'pass' | 'fail' | 'warn';\n  message: string;\n  details?: Record<string, any>;\n  lastChecked: Date;\n}\n\n/**\n * Performance metrics interface\n */\nexport interface PerformanceMetrics {\n  responseTime: number;\n  errorRate: number;\n  uptime: number;\n  throughput: number;\n  latency: number;\n  memoryUsage: number;\n  cpuUsage: number;\n}\n\n/**\n * Health monitoring configuration\n */\nexport interface HealthMonitoringConfig {\n  checkInterval: number; // milliseconds\n  timeout: number; // milliseconds\n  retries: number;\n  thresholds: {\n    responseTime: number;\n    errorRate: number;\n    uptime: number;\n    memoryUsage: number;\n    cpuUsage: number;\n  };\n}\n\n/**\n * Tenant health monitoring service class\n */\nexport class TenantHealthService {\n  private static instance: TenantHealthService;\n  private healthChecks = new Map<string, HealthCheckResult>();\n  private monitoringConfig: HealthMonitoringConfig;\n  private monitoringInterval: NodeJS.Timeout | null = null;\n\n  private constructor() {\n    this.monitoringConfig = {\n      checkInterval: 60000, // 1 minute\n      timeout: 30000, // 30 seconds\n      retries: 3,\n      thresholds: {\n        responseTime: 500, // 500ms\n        errorRate: 5, // 5%\n        uptime: 95, // 95%\n        memoryUsage: 80, // 80%\n        cpuUsage: 80, // 80%\n      },\n    };\n  }\n\n  static getInstance(): TenantHealthService {\n    if (!TenantHealthService.instance) {\n      TenantHealthService.instance = new TenantHealthService();\n    }\n    return TenantHealthService.instance;\n  }\n\n  /**\n   * Start health monitoring for tenant\n   */\n  startMonitoring(tenantId: string): void {\n    if (this.monitoringInterval) {\n      return; // Already monitoring\n    }\n\n    this.monitoringInterval = setInterval(async () => {\n      await this.performHealthCheck(tenantId);\n    }, this.monitoringConfig.checkInterval);\n  }\n\n  /**\n   * Stop health monitoring\n   */\n  stopMonitoring(): void {\n    if (this.monitoringInterval) {\n      clearInterval(this.monitoringInterval);\n      this.monitoringInterval = null;\n    }\n  }\n\n  /**\n   * Perform comprehensive health check\n   */\n  async performHealthCheck(tenantId: string): Promise<Result<HealthCheckResult, AppError>> {\n    try {\n      const checks = await Promise.all([\n        this.checkDatabaseHealth(tenantId),\n        this.checkApiHealth(tenantId),\n        this.checkStorageHealth(tenantId),\n        this.checkPerformanceHealth(tenantId),\n        this.checkFeaturesHealth(tenantId),\n      ]);\n\n      const [databaseCheck, apiCheck, storageCheck, performanceCheck, featuresCheck] = checks;\n\n      const healthResult: HealthCheckResult = {\n        status: 'healthy',\n        score: 100,\n        checks: {\n          database: databaseCheck,\n          api: apiCheck,\n          storage: storageCheck,\n          performance: performanceCheck,\n          features: featuresCheck,\n        },\n        timestamp: new Date(),\n        issues: [],\n        recommendations: [],\n      };\n\n      // Calculate overall health score\n      const checkResults = [databaseCheck, apiCheck, storageCheck, performanceCheck, featuresCheck];\n      const failedChecks = checkResults.filter(check => check.status === 'fail').length;\n      const warningChecks = checkResults.filter(check => check.status === 'warn').length;\n\n      if (failedChecks > 0) {\n        healthResult.status = 'unhealthy';\n        healthResult.score = Math.max(0, 100 - failedChecks * 20);\n      } else if (warningChecks > 0) {\n        healthResult.status = 'degraded';\n        healthResult.score = Math.max(0, 100 - warningChecks * 10);\n      }\n\n      // Collect issues and recommendations\n      checkResults.forEach(check => {\n        if (check.status === 'fail') {\n          healthResult.issues.push(check.message);\n        } else if (check.status === 'warn') {\n          healthResult.issues.push(check.message);\n        }\n      });\n\n      // Generate recommendations\n      this.generateRecommendations(healthResult);\n\n      // Store health check result\n      this.healthChecks.set(tenantId, healthResult);\n\n      return ok(healthResult);\n    } catch (error) {\n      return err({\n        type: 'HEALTH_CHECK_FAILED',\n        message: 'Failed to perform health check',\n        cause: error,\n      });\n    }\n  }\n\n  /**\n   * Check database health\n   */\n  private async checkDatabaseHealth(tenantId: string): Promise<HealthCheck> {\n    try {\n      const startTime = Date.now();\n\n      // Test database connection\n      const connectionResult = await tenantIsolationService.getTenantConnection(tenantId);\n      if (connectionResult.isErr()) {\n        return {\n          status: 'fail',\n          message: 'Database connection failed',\n          details: { error: connectionResult.error.message },\n          lastChecked: new Date(),\n        };\n      }\n\n      // Test query execution\n      const queryResult = await tenantIsolationService.executeTenantQuery('SELECT 1 as test', []);\n\n      if (queryResult.isErr()) {\n        return {\n          status: 'fail',\n          message: 'Database query failed',\n          details: { error: queryResult.error.message },\n          lastChecked: new Date(),\n        };\n      }\n\n      const responseTime = Date.now() - startTime;\n\n      if (responseTime > this.monitoringConfig.thresholds.responseTime) {\n        return {\n          status: 'warn',\n          message: `Database response time is high: ${responseTime}ms`,\n          details: { responseTime, threshold: this.monitoringConfig.thresholds.responseTime },\n          lastChecked: new Date(),\n        };\n      }\n\n      return {\n        status: 'pass',\n        message: 'Database is healthy',\n        details: { responseTime },\n        lastChecked: new Date(),\n      };\n    } catch (error) {\n      return {\n        status: 'fail',\n        message: 'Database health check failed',\n        details: { error: error instanceof Error ? error.message : 'Unknown error' },\n        lastChecked: new Date(),\n      };\n    }\n  }\n\n  /**\n   * Check API health\n   */\n  private async checkApiHealth(tenantId: string): Promise<HealthCheck> {\n    try {\n      // Mock API health check\n      // In a real implementation, you would make actual API calls\n      const responseTime = Math.random() * 200 + 50; // Mock response time\n      const errorRate = Math.random() * 10; // Mock error rate\n\n      if (errorRate > this.monitoringConfig.thresholds.errorRate) {\n        return {\n          status: 'fail',\n          message: `API error rate is high: ${errorRate.toFixed(1)}%`,\n          details: { errorRate, threshold: this.monitoringConfig.thresholds.errorRate },\n          lastChecked: new Date(),\n        };\n      }\n\n      if (responseTime > this.monitoringConfig.thresholds.responseTime) {\n        return {\n          status: 'warn',\n          message: `API response time is high: ${responseTime.toFixed(0)}ms`,\n          details: { responseTime, threshold: this.monitoringConfig.thresholds.responseTime },\n          lastChecked: new Date(),\n        };\n      }\n\n      return {\n        status: 'pass',\n        message: 'API is healthy',\n        details: { responseTime, errorRate },\n        lastChecked: new Date(),\n      };\n    } catch (error) {\n      return {\n        status: 'fail',\n        message: 'API health check failed',\n        details: { error: error instanceof Error ? error.message : 'Unknown error' },\n        lastChecked: new Date(),\n      };\n    }\n  }\n\n  /**\n   * Check storage health\n   */\n  private async checkStorageHealth(tenantId: string): Promise<HealthCheck> {\n    try {\n      // Mock storage health check\n      const storageUsed = Math.random() * 100; // Mock storage usage percentage\n      const storageLimit = 100;\n\n      if (storageUsed > this.monitoringConfig.thresholds.memoryUsage) {\n        return {\n          status: 'warn',\n          message: `Storage usage is high: ${storageUsed.toFixed(1)}%`,\n          details: { storageUsed, threshold: this.monitoringConfig.thresholds.memoryUsage },\n          lastChecked: new Date(),\n        };\n      }\n\n      return {\n        status: 'pass',\n        message: 'Storage is healthy',\n        details: { storageUsed, storageLimit },\n        lastChecked: new Date(),\n      };\n    } catch (error) {\n      return {\n        status: 'fail',\n        message: 'Storage health check failed',\n        details: { error: error instanceof Error ? error.message : 'Unknown error' },\n        lastChecked: new Date(),\n      };\n    }\n  }\n\n  /**\n   * Check performance health\n   */\n  private async checkPerformanceHealth(tenantId: string): Promise<HealthCheck> {\n    try {\n      // Mock performance metrics\n      const metrics: PerformanceMetrics = {\n        responseTime: Math.random() * 300 + 50,\n        errorRate: Math.random() * 5,\n        uptime: Math.random() * 10 + 90,\n        throughput: Math.random() * 1000 + 100,\n        latency: Math.random() * 100 + 10,\n        memoryUsage: Math.random() * 100,\n        cpuUsage: Math.random() * 100,\n      };\n\n      const issues: string[] = [];\n\n      if (metrics.responseTime > this.monitoringConfig.thresholds.responseTime) {\n        issues.push(`Response time is high: ${metrics.responseTime.toFixed(0)}ms`);\n      }\n\n      if (metrics.errorRate > this.monitoringConfig.thresholds.errorRate) {\n        issues.push(`Error rate is high: ${metrics.errorRate.toFixed(1)}%`);\n      }\n\n      if (metrics.uptime < this.monitoringConfig.thresholds.uptime) {\n        issues.push(`Uptime is low: ${metrics.uptime.toFixed(1)}%`);\n      }\n\n      if (metrics.memoryUsage > this.monitoringConfig.thresholds.memoryUsage) {\n        issues.push(`Memory usage is high: ${metrics.memoryUsage.toFixed(1)}%`);\n      }\n\n      if (metrics.cpuUsage > this.monitoringConfig.thresholds.cpuUsage) {\n        issues.push(`CPU usage is high: ${metrics.cpuUsage.toFixed(1)}%`);\n      }\n\n      if (issues.length > 0) {\n        return {\n          status: issues.length > 2 ? 'fail' : 'warn',\n          message: issues.join('; '),\n          details: metrics,\n          lastChecked: new Date(),\n        };\n      }\n\n      return {\n        status: 'pass',\n        message: 'Performance is healthy',\n        details: metrics,\n        lastChecked: new Date(),\n      };\n    } catch (error) {\n      return {\n        status: 'fail',\n        message: 'Performance health check failed',\n        details: { error: error instanceof Error ? error.message : 'Unknown error' },\n        lastChecked: new Date(),\n      };\n    }\n  }\n\n  /**\n   * Check features health\n   */\n  private async checkFeaturesHealth(tenantId: string): Promise<HealthCheck> {\n    try {\n      const context = tenantContextService.getTenantContext();\n      if (!context) {\n        return {\n          status: 'fail',\n          message: 'No tenant context available',\n          lastChecked: new Date(),\n        };\n      }\n\n      const features = context.features;\n      const enabledFeatures = features.filter(feature => feature !== 'disabled');\n\n      if (enabledFeatures.length === 0) {\n        return {\n          status: 'warn',\n          message: 'No features are enabled',\n          details: { features },\n          lastChecked: new Date(),\n        };\n      }\n\n      return {\n        status: 'pass',\n        message: 'Features are healthy',\n        details: { enabledFeatures: enabledFeatures.length, totalFeatures: features.length },\n        lastChecked: new Date(),\n      };\n    } catch (error) {\n      return {\n        status: 'fail',\n        message: 'Features health check failed',\n        details: { error: error instanceof Error ? error.message : 'Unknown error' },\n        lastChecked: new Date(),\n      };\n    }\n  }\n\n  /**\n   * Generate health recommendations\n   */\n  private generateRecommendations(healthResult: HealthCheckResult): void {\n    const recommendations: string[] = [];\n\n    // Database recommendations\n    if (healthResult.checks.database.status === 'warn') {\n      recommendations.push(\n        'Consider optimizing database queries or increasing connection pool size'\n      );\n    }\n\n    // API recommendations\n    if (healthResult.checks.api.status === 'warn') {\n      recommendations.push('Consider implementing API caching or rate limiting');\n    }\n\n    // Storage recommendations\n    if (healthResult.checks.storage.status === 'warn') {\n      recommendations.push('Consider cleaning up old data or increasing storage capacity');\n    }\n\n    // Performance recommendations\n    if (healthResult.checks.performance.status === 'warn') {\n      recommendations.push('Consider scaling resources or optimizing application code');\n    }\n\n    // Features recommendations\n    if (healthResult.checks.features.status === 'warn') {\n      recommendations.push('Consider enabling additional features to improve functionality');\n    }\n\n    healthResult.recommendations = recommendations;\n  }\n\n  /**\n   * Get health check result for tenant\n   * @param tenantId - The ID of the tenant\n   * @returns Health check result for the tenant, or null if not found\n   */\n  getHealthCheckResult(tenantId: string): HealthCheckResult | null {\n    return this.healthChecks.get(tenantId) || null;\n  }\n\n  /**\n   * Get all health check results\n   */\n  getAllHealthCheckResults(): Map<string, HealthCheckResult> {\n    return new Map(this.healthChecks);\n  }\n\n  /**\n   * Get health check history\n   * @param tenantId - The ID of the tenant\n   * @param limit - The maximum number of history records to retrieve\n   * @returns Result containing the tenant's health check history or an AppError on failure\n   */\n  async getHealthCheckHistory(\n    tenantId: string,\n    limit = 100\n  ): Promise<Result<HealthCheckResult[], AppError>> {\n    try {\n      // In a real implementation, you would fetch from a database\n      // This is a mock implementation\n      const history: HealthCheckResult[] = [];\n\n      // Generate mock history\n      for (let i = 0; i < limit; i++) {\n        const timestamp = new Date(Date.now() - i * 60000); // 1 minute intervals\n        history.push({\n          status: Math.random() > 0.8 ? 'unhealthy' : Math.random() > 0.6 ? 'degraded' : 'healthy',\n          score: Math.random() * 100,\n          checks: {\n            database: { status: 'pass', message: 'Database is healthy', lastChecked: timestamp },\n            api: { status: 'pass', message: 'API is healthy', lastChecked: timestamp },\n            storage: { status: 'pass', message: 'Storage is healthy', lastChecked: timestamp },\n            performance: {\n              status: 'pass',\n              message: 'Performance is healthy',\n              lastChecked: timestamp,\n            },\n            features: { status: 'pass', message: 'Features are healthy', lastChecked: timestamp },\n          },\n          timestamp,\n          issues: [],\n          recommendations: [],\n        });\n      }\n\n      return ok(history);\n    } catch (error) {\n      return err({\n        type: 'HISTORY_RETRIEVAL_FAILED',\n        message: 'Failed to get health check history',\n        cause: error,\n      });\n    }\n  }\n\n  /**\n   * Update monitoring configuration\n   * @param config - Partial monitoring configuration to update\n   */\n  updateMonitoringConfig(config: Partial<HealthMonitoringConfig>): void {\n    this.monitoringConfig = { ...this.monitoringConfig, ...config };\n  }\n\n  /**\n   * Get monitoring configuration\n   */\n  getMonitoringConfig(): HealthMonitoringConfig {\n    return { ...this.monitoringConfig };\n  }\n}\n\n// Export singleton instance\nexport const tenantHealthService = TenantHealthService.getInstance();\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/services/TenantIsolationService.ts",
        "messages": [
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'Tenant' is defined but never used. Allowed unused vars must match /^_/u.",
                "line": 10,
                "column": 15,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 10,
                "endColumn": 21
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 17,
                "column": 13,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 17,
                "endColumn": 16,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                506,
                                509
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                506,
                                509
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 17,
                "column": 40,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 17,
                "endColumn": 43,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                533,
                                536
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                533,
                                536
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 18,
                "column": 33,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 18,
                "endColumn": 36,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                587,
                                590
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                587,
                                590
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, value is always falsy.",
                "line": 125,
                "column": 9,
                "nodeType": "UnaryExpression",
                "messageId": "alwaysFalsy",
                "endLine": 125,
                "endColumn": 41
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected object value in conditional. The condition is always true.",
                "line": 125,
                "column": 10,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorObject",
                "endLine": 125,
                "endColumn": 41
            },
            {
                "ruleId": "@typescript-eslint/no-non-null-assertion",
                "severity": 1,
                "message": "Forbidden non-null assertion.",
                "line": 138,
                "column": 28,
                "nodeType": "TSNonNullExpression",
                "messageId": "noNonNull",
                "endLine": 138,
                "endColumn": 59
            },
            {
                "ruleId": "@typescript-eslint/require-await",
                "severity": 1,
                "message": "Async method 'createConnection' has no 'await' expression.",
                "line": 173,
                "column": 3,
                "nodeType": "FunctionExpression",
                "messageId": "missingAwait",
                "endLine": 173,
                "endColumn": 33,
                "suggestions": [
                    {
                        "messageId": "removeAsync",
                        "fix": {
                            "range": [
                                4363,
                                4444
                            ],
                            "text": "createConnection(config: TenantDatabaseConfig): DatabaseConnection"
                        },
                        "desc": "Remove 'async'."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/require-await",
                "severity": 1,
                "message": "Async method 'query' has no 'await' expression.",
                "line": 177,
                "column": 7,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingAwait",
                "endLine": 177,
                "endColumn": 29,
                "suggestions": [
                    {
                        "messageId": "removeAsync",
                        "fix": {
                            "range": [
                                4590,
                                4648
                            ],
                            "text": "<T = any>(sql: string, params?: any[]): T[]"
                        },
                        "desc": "Remove 'async'."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 177,
                "column": 25,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 177,
                "endColumn": 28,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                4601,
                                4604
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                4601,
                                4604
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 177,
                "column": 52,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 177,
                "endColumn": 55,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                4628,
                                4631
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                4628,
                                4631
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "no-console",
                "severity": 1,
                "message": "Unexpected console statement. Only these console methods are allowed: warn, error.",
                "line": 179,
                "column": 9,
                "nodeType": "MemberExpression",
                "messageId": "limited",
                "endLine": 179,
                "endColumn": 20,
                "suggestions": [
                    {
                        "fix": {
                            "range": [
                                4694,
                                4769
                            ],
                            "text": ""
                        },
                        "messageId": "removeConsole",
                        "data": {
                            "propertyName": "log"
                        },
                        "desc": "Remove the console.log()."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/require-await",
                "severity": 1,
                "message": "Async method 'execute' has no 'await' expression.",
                "line": 182,
                "column": 7,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingAwait",
                "endLine": 182,
                "endColumn": 22,
                "suggestions": [
                    {
                        "messageId": "removeAsync",
                        "fix": {
                            "range": [
                                4813,
                                4863
                            ],
                            "text": "(sql: string, params?: any[]): void"
                        },
                        "desc": "Remove 'async'."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 182,
                "column": 45,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 182,
                "endColumn": 48,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                4842,
                                4845
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                4842,
                                4845
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "no-console",
                "severity": 1,
                "message": "Unexpected console statement. Only these console methods are allowed: warn, error.",
                "line": 184,
                "column": 9,
                "nodeType": "MemberExpression",
                "messageId": "limited",
                "endLine": 184,
                "endColumn": 20,
                "suggestions": [
                    {
                        "fix": {
                            "range": [
                                4909,
                                4984
                            ],
                            "text": ""
                        },
                        "messageId": "removeConsole",
                        "data": {
                            "propertyName": "log"
                        },
                        "desc": "Remove the console.log()."
                    }
                ]
            },
            {
                "ruleId": "no-console",
                "severity": 1,
                "message": "Unexpected console statement. Only these console methods are allowed: warn, error.",
                "line": 191,
                "column": 9,
                "nodeType": "MemberExpression",
                "messageId": "limited",
                "endLine": 191,
                "endColumn": 20,
                "suggestions": [
                    {
                        "fix": {
                            "range": [
                                5232,
                                5298
                            ],
                            "text": ""
                        },
                        "messageId": "removeConsole",
                        "data": {
                            "propertyName": "log"
                        },
                        "desc": "Remove the console.log()."
                    }
                ]
            },
            {
                "ruleId": "no-console",
                "severity": 1,
                "message": "Unexpected console statement. Only these console methods are allowed: warn, error.",
                "line": 193,
                "column": 9,
                "nodeType": "MemberExpression",
                "messageId": "limited",
                "endLine": 193,
                "endColumn": 20,
                "suggestions": [
                    {
                        "fix": {
                            "range": [
                                5352,
                                5420
                            ],
                            "text": ""
                        },
                        "messageId": "removeConsole",
                        "data": {
                            "propertyName": "log"
                        },
                        "desc": "Remove the console.log()."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/require-await",
                "severity": 1,
                "message": "Async method 'close' has no 'await' expression.",
                "line": 196,
                "column": 7,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingAwait",
                "endLine": 196,
                "endColumn": 20,
                "suggestions": [
                    {
                        "messageId": "removeAsync",
                        "fix": {
                            "range": [
                                5466,
                                5489
                            ],
                            "text": "(): void"
                        },
                        "desc": "Remove 'async'."
                    }
                ]
            },
            {
                "ruleId": "no-console",
                "severity": 1,
                "message": "Unexpected console statement. Only these console methods are allowed: warn, error.",
                "line": 197,
                "column": 9,
                "nodeType": "MemberExpression",
                "messageId": "limited",
                "endLine": 197,
                "endColumn": 20,
                "suggestions": [
                    {
                        "fix": {
                            "range": [
                                5503,
                                5567
                            ],
                            "text": ""
                        },
                        "messageId": "removeConsole",
                        "data": {
                            "propertyName": "log"
                        },
                        "desc": "Remove the console.log()."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-floating-promises",
                "severity": 1,
                "message": "Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.",
                "line": 220,
                "column": 7,
                "nodeType": "ExpressionStatement",
                "messageId": "floatingVoid",
                "endLine": 220,
                "endColumn": 26,
                "suggestions": [
                    {
                        "messageId": "floatingFixVoid",
                        "fix": {
                            "range": [
                                6185,
                                6185
                            ],
                            "text": "void "
                        },
                        "desc": "Add void operator to ignore."
                    },
                    {
                        "messageId": "floatingFixAwait",
                        "fix": {
                            "range": [
                                6185,
                                6185
                            ],
                            "text": "await "
                        },
                        "desc": "Add await operator."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 228,
                "column": 32,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 228,
                "endColumn": 35,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                6337,
                                6340
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                6337,
                                6340
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 228,
                "column": 59,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 228,
                "endColumn": 62,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                6364,
                                6367
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                6364,
                                6367
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 299,
                "column": 29,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 299,
                "endColumn": 32,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                8353,
                                8356
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                8353,
                                8356
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 322,
                "column": 21,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 322,
                "endColumn": 24,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                9000,
                                9003
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                9000,
                                9003
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 334,
                "column": 11,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 334,
                "endColumn": 26,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                9358,
                                9373
                            ],
                            "text": "options.orderBy != null"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                9358,
                                9373
                            ],
                            "text": "options.orderBy ?? \"\""
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                9358,
                                9373
                            ],
                            "text": "Boolean(options.orderBy)"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 336,
                "column": 73,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 336,
                "endColumn": 75,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                9494,
                                9496
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.",
                "line": 341,
                "column": 11,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorNullableNumber",
                "endLine": 341,
                "endColumn": 24,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                9608,
                                9621
                            ],
                            "text": "options.limit != null"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultZero",
                        "fix": {
                            "range": [
                                9608,
                                9621
                            ],
                            "text": "options.limit ?? 0"
                        },
                        "desc": "Explicitly treat nullish value the same as 0 (`value ?? 0`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                9608,
                                9621
                            ],
                            "text": "Boolean(options.limit)"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.",
                "line": 347,
                "column": 11,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorNullableNumber",
                "endLine": 347,
                "endColumn": 25,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                9753,
                                9767
                            ],
                            "text": "options.offset != null"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultZero",
                        "fix": {
                            "range": [
                                9753,
                                9767
                            ],
                            "text": "options.offset ?? 0"
                        },
                        "desc": "Explicitly treat nullish value the same as 0 (`value ?? 0`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                9753,
                                9767
                            ],
                            "text": "Boolean(options.offset)"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 369,
                "column": 26,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 369,
                "endColumn": 29,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                10307,
                                10310
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                10307,
                                10310
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected value in conditional. A boolean expression is required.",
                "line": 410,
                "column": 12,
                "nodeType": "Identifier",
                "messageId": "conditionErrorOther",
                "endLine": 410,
                "endColumn": 22
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 436,
                "column": 26,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 436,
                "endColumn": 29,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                12161,
                                12164
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                12161,
                                12164
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected value in conditional. A boolean expression is required.",
                "line": 486,
                "column": 12,
                "nodeType": "Identifier",
                "messageId": "conditionErrorOther",
                "endLine": 486,
                "endColumn": 22
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 32,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "/**\n * Tenant Isolation Service\n * Provides database isolation and tenant-scoped data access\n */\n\nimport { ok, err } from 'neverthrow';\nimport type { Result } from '@/types/fp';\nimport type { AppError } from '@/types/errors';\nimport { createBusinessLogicError, createNetworkError } from '@/types/errors';\nimport type { Tenant } from '@/types/tenant';\nimport { tenantContextService } from './TenantContextService';\n\n/**\n * Database connection interface\n */\nexport interface DatabaseConnection {\n  query<T = any>(sql: string, params?: any[]): Promise<T[]>;\n  execute(sql: string, params?: any[]): Promise<void>;\n  transaction<T>(callback: (conn: DatabaseConnection) => Promise<T>): Promise<T>;\n  close(): Promise<void>;\n}\n\n/**\n * Tenant database configuration\n */\nexport interface TenantDatabaseConfig {\n  tenantId: string;\n  dbUrl: string;\n  dbName: string;\n  schema?: string;\n  connectionPool?: {\n    min: number;\n    max: number;\n    idle: number;\n  };\n}\n\n/**\n * SECURITY: Whitelisted table names to prevent SQL injection\n * Only add tables that should be accessible through this service\n */\nconst ALLOWED_TABLES = new Set([\n  'tenant_contacts',\n  'tenant_users',\n  'tenant_audit_log',\n  'tenant_activity_log',\n  'tenant_metrics',\n  'tenant_performance',\n  'tenant_settings',\n  'tenant_features',\n]);\n\n/**\n * SECURITY: Whitelisted column names to prevent SQL injection\n */\nconst ALLOWED_COLUMNS = new Set([\n  'id',\n  'tenant_id',\n  'user_id',\n  'first_name',\n  'last_name',\n  'email',\n  'phone',\n  'company',\n  'job_title',\n  'created_at',\n  'updated_at',\n  'is_active',\n  'status',\n  'role',\n  'name',\n  'type',\n  'value',\n  'count',\n]);\n\n/**\n * SECURITY: Validate and sanitize table name against whitelist\n * @throws Error if table is not in whitelist\n */\nfunction validateTableName(table: string): void {\n  if (!ALLOWED_TABLES.has(table)) {\n    throw new Error(`Invalid table name: ${table}. Table must be whitelisted.`);\n  }\n}\n\n/**\n * SECURITY: Validate and sanitize column name against whitelist\n * @throws Error if column is not in whitelist\n */\nfunction validateColumnName(column: string): void {\n  if (!ALLOWED_COLUMNS.has(column)) {\n    throw new Error(`Invalid column name: ${column}. Column must be whitelisted.`);\n  }\n}\n\n/**\n * SECURITY: Validate order direction to prevent injection\n */\nfunction validateOrderDirection(direction: string): 'ASC' | 'DESC' {\n  const upper = direction.toUpperCase();\n  if (upper !== 'ASC' && upper !== 'DESC') {\n    throw new Error('Order direction must be ASC or DESC');\n  }\n  return upper;\n}\n\n/**\n * Tenant isolation service class\n */\nexport class TenantIsolationService {\n  private static instance: TenantIsolationService;\n  private connections = new Map<string, DatabaseConnection>();\n  private connectionConfigs = new Map<string, TenantDatabaseConfig>();\n\n  private constructor() {\n    // Private constructor for singleton pattern\n  }\n\n  /**\n   * Get singleton instance of TenantIsolationService\n   * @returns The singleton instance\n   */\n  static getInstance(): TenantIsolationService {\n    if (!TenantIsolationService.instance) {\n      TenantIsolationService.instance = new TenantIsolationService();\n    }\n    return TenantIsolationService.instance;\n  }\n\n  /**\n   * Get database connection for tenant\n   */\n  async getTenantConnection(tenantId: string): Promise<Result<DatabaseConnection, AppError>> {\n    try {\n      // Check if connection already exists\n      if (this.connections.has(tenantId)) {\n        const connection = this.connections.get(tenantId)!;\n        return ok(connection);\n      }\n\n      // Get tenant configuration\n      const config = this.connectionConfigs.get(tenantId);\n      if (!config) {\n        return err(\n          createBusinessLogicError(\n            `No database configuration found for tenant ${tenantId}`,\n            { tenantId },\n            { code: 'TENANT_NOT_FOUND' }\n          )\n        );\n      }\n\n      // Create new connection\n      const connection = await this.createConnection(config);\n      this.connections.set(tenantId, connection);\n\n      return ok(connection);\n    } catch (error) {\n      return err(\n        createNetworkError(\n          `Failed to get database connection for tenant ${tenantId}`,\n          { tenantId },\n          { code: 'CONNECTION_FAILED', cause: error }\n        )\n      );\n    }\n  }\n\n  /**\n   * Create database connection\n   */\n  private async createConnection(config: TenantDatabaseConfig): Promise<DatabaseConnection> {\n    // In a real implementation, you would create an actual database connection\n    // This is a mock implementation\n    return {\n      query: async <T = any>(sql: string, params?: any[]): Promise<T[]> => {\n        // Mock query execution\n        console.log(`Executing query for tenant ${config.tenantId}:`, sql, params);\n        return [];\n      },\n      execute: async (sql: string, params?: any[]): Promise<void> => {\n        // Mock query execution\n        console.log(`Executing query for tenant ${config.tenantId}:`, sql, params);\n      },\n      transaction: async function <T>(\n        this: DatabaseConnection,\n        callback: (conn: DatabaseConnection) => Promise<T>\n      ): Promise<T> {\n        // Mock transaction - pass the actual connection object to callback\n        console.log(`Starting transaction for tenant ${config.tenantId}`);\n        const result = await callback(this);\n        console.log(`Committing transaction for tenant ${config.tenantId}`);\n        return result;\n      },\n      close: async (): Promise<void> => {\n        console.log(`Closing connection for tenant ${config.tenantId}`);\n      },\n    };\n  }\n\n  /**\n   * Register tenant database configuration\n   * @param config - The database configuration for the tenant\n   */\n  registerTenantDatabase(config: TenantDatabaseConfig): void {\n    this.connectionConfigs.set(config.tenantId, config);\n  }\n\n  /**\n   * Remove tenant database configuration and close connection if exists\n   * @param tenantId - The tenant ID to unregister\n   */\n  unregisterTenantDatabase(tenantId: string): void {\n    this.connectionConfigs.delete(tenantId);\n\n    // Close connection if exists\n    const connection = this.connections.get(tenantId);\n    if (connection) {\n      connection.close();\n      this.connections.delete(tenantId);\n    }\n  }\n\n  /**\n   * Execute query in tenant context\n   */\n  async executeTenantQuery<T = any>(sql: string, params?: any[]): Promise<Result<T[], AppError>> {\n    try {\n      const context = tenantContextService.getTenantContext();\n      if (!context) {\n        return err(\n          createBusinessLogicError('No tenant context available', undefined, {\n            code: 'NO_TENANT_CONTEXT',\n          })\n        );\n      }\n\n      const connectionResult = await this.getTenantConnection(context.tenant.id);\n      if (connectionResult.isErr()) {\n        return err(connectionResult.error);\n      }\n\n      const connection = connectionResult.value;\n      const results = await connection.query<T>(sql, params);\n\n      return ok(results);\n    } catch (error) {\n      return err(\n        createNetworkError('Failed to execute tenant query', undefined, {\n          code: 'QUERY_FAILED',\n          cause: error,\n        })\n      );\n    }\n  }\n\n  /**\n   * Execute transaction in tenant context\n   */\n  async executeTenantTransaction<T>(\n    callback: (connection: DatabaseConnection) => Promise<T>\n  ): Promise<Result<T, AppError>> {\n    try {\n      const context = tenantContextService.getTenantContext();\n      if (!context) {\n        return err(\n          createBusinessLogicError('No tenant context available', undefined, {\n            code: 'NO_TENANT_CONTEXT',\n          })\n        );\n      }\n\n      const connectionResult = await this.getTenantConnection(context.tenant.id);\n      if (connectionResult.isErr()) {\n        return err(connectionResult.error);\n      }\n\n      const connection = connectionResult.value;\n      const result = await connection.transaction(callback);\n\n      return ok(result);\n    } catch (error) {\n      return err(\n        createNetworkError('Failed to execute tenant transaction', undefined, {\n          code: 'TRANSACTION_FAILED',\n          cause: error,\n        })\n      );\n    }\n  }\n\n  /**\n   * Get tenant-scoped data\n   * SECURITY: Table, column, and filter names are validated against whitelists\n   */\n  async getTenantData<T>(\n    table: string,\n    filters: Record<string, any> = {},\n    options: {\n      limit?: number;\n      offset?: number;\n      orderBy?: string;\n      orderDirection?: 'ASC' | 'DESC';\n    } = {}\n  ): Promise<Result<T[], AppError>> {\n    try {\n      const context = tenantContextService.getTenantContext();\n      if (!context) {\n        return err(\n          createBusinessLogicError('No tenant context available', undefined, {\n            code: 'NO_TENANT_CONTEXT',\n          })\n        );\n      }\n\n      // SECURITY: Validate table name\n      validateTableName(table);\n\n      // Build query with tenant isolation\n      let sql = `SELECT * FROM ${table} WHERE tenant_id = $1`;\n      const params: any[] = [context.tenant.id];\n      let paramIndex = 2;\n\n      // Add filters with column validation\n      for (const [key, value] of Object.entries(filters)) {\n        validateColumnName(key);\n        sql += ` AND ${key} = $${paramIndex.toString()}`;\n        params.push(value);\n        paramIndex++;\n      }\n\n      // Add ordering with validation\n      if (options.orderBy) {\n        validateColumnName(options.orderBy);\n        const direction = validateOrderDirection(options.orderDirection || 'ASC');\n        sql += ` ORDER BY ${options.orderBy} ${direction}`;\n      }\n\n      // Add pagination\n      if (options.limit) {\n        sql += ` LIMIT $${paramIndex.toString()}`;\n        params.push(options.limit);\n        paramIndex++;\n      }\n\n      if (options.offset) {\n        sql += ` OFFSET $${paramIndex.toString()}`;\n        params.push(options.offset);\n      }\n\n      return await this.executeTenantQuery<T>(sql, params);\n    } catch (error) {\n      return err(\n        createNetworkError('Failed to retrieve tenant data', undefined, {\n          code: 'DATA_RETRIEVAL_FAILED',\n          cause: error,\n        })\n      );\n    }\n  }\n\n  /**\n   * Insert tenant-scoped data\n   * SECURITY: Table and column names are validated\n   */\n  async insertTenantData<T>(\n    table: string,\n    data: Record<string, any>\n  ): Promise<Result<T, AppError>> {\n    try {\n      const context = tenantContextService.getTenantContext();\n      if (!context) {\n        return err(\n          createBusinessLogicError('No tenant context available', undefined, {\n            code: 'NO_TENANT_CONTEXT',\n          })\n        );\n      }\n\n      // SECURITY: Validate table name\n      validateTableName(table);\n\n      // Add tenant_id to data\n      const dataWithTenant = {\n        ...data,\n        tenant_id: context.tenant.id,\n        created_at: new Date().toISOString(),\n        updated_at: new Date().toISOString(),\n      };\n\n      // Validate column names\n      for (const column of Object.keys(dataWithTenant)) {\n        validateColumnName(column);\n      }\n\n      // Build insert query\n      const columns = Object.keys(dataWithTenant);\n      const values = Object.values(dataWithTenant);\n      const placeholders = values.map((_, index) => `$${(index + 1).toString()}`).join(', ');\n\n      const sql = `INSERT INTO ${table} (${columns.join(', ')}) VALUES (${placeholders}) RETURNING *`;\n\n      const result = await this.executeTenantQuery<T>(sql, values);\n      if (result.isErr()) {\n        return err(result.error);\n      }\n\n      const firstValue = result.value[0];\n      if (!firstValue) {\n        return err(\n          createNetworkError('No data returned from insert', undefined, {\n            code: 'NO_DATA_RETURNED',\n          })\n        );\n      }\n\n      return ok(firstValue);\n    } catch (error) {\n      return err(\n        createNetworkError('Failed to insert tenant data', undefined, {\n          code: 'DATA_INSERTION_FAILED',\n          cause: error,\n        })\n      );\n    }\n  }\n\n  /**\n   * Update tenant-scoped data\n   * SECURITY: Table and column names are validated\n   */\n  async updateTenantData<T>(\n    table: string,\n    id: string,\n    data: Record<string, any>\n  ): Promise<Result<T, AppError>> {\n    try {\n      const context = tenantContextService.getTenantContext();\n      if (!context) {\n        return err(\n          createBusinessLogicError('No tenant context available', undefined, {\n            code: 'NO_TENANT_CONTEXT',\n          })\n        );\n      }\n\n      // SECURITY: Validate table name\n      validateTableName(table);\n\n      // Add updated_at to data\n      const dataWithUpdate = {\n        ...data,\n        updated_at: new Date().toISOString(),\n      };\n\n      // Validate column names\n      for (const column of Object.keys(dataWithUpdate)) {\n        validateColumnName(column);\n      }\n\n      // Build update query\n      const columns = Object.keys(dataWithUpdate);\n      const values = Object.values(dataWithUpdate);\n      const setClause = columns\n        .map((col, index) => `${col} = $${(index + 1).toString()}`)\n        .join(', ');\n\n      const sql = `UPDATE ${table} SET ${setClause} WHERE id = $${(values.length + 1).toString()} AND tenant_id = $${(values.length + 2).toString()} RETURNING *`;\n      const params = [...values, id, context.tenant.id];\n\n      const result = await this.executeTenantQuery<T>(sql, params);\n      if (result.isErr()) {\n        return err(result.error);\n      }\n\n      if (result.value.length === 0) {\n        return err(\n          createBusinessLogicError('Record not found or access denied', undefined, {\n            code: 'NOT_FOUND',\n          })\n        );\n      }\n\n      const firstValue = result.value[0];\n      if (!firstValue) {\n        return err(\n          createNetworkError('No data returned from update', undefined, {\n            code: 'NO_DATA_RETURNED',\n          })\n        );\n      }\n\n      return ok(firstValue);\n    } catch (error) {\n      return err(\n        createNetworkError('Failed to update tenant data', undefined, {\n          code: 'DATA_UPDATE_FAILED',\n          cause: error,\n        })\n      );\n    }\n  }\n\n  /**\n   * Delete tenant-scoped data\n   * SECURITY: Table name is validated\n   */\n  async deleteTenantData(table: string, id: string): Promise<Result<void, AppError>> {\n    try {\n      const context = tenantContextService.getTenantContext();\n      if (!context) {\n        return err(\n          createBusinessLogicError('No tenant context available', undefined, {\n            code: 'NO_TENANT_CONTEXT',\n          })\n        );\n      }\n\n      // SECURITY: Validate table name\n      validateTableName(table);\n\n      const sql = `DELETE FROM ${table} WHERE id = $1 AND tenant_id = $2`;\n      const params = [id, context.tenant.id];\n\n      const result = await this.executeTenantQuery(sql, params);\n      if (result.isErr()) {\n        return err(result.error);\n      }\n\n      return ok(undefined);\n    } catch (error) {\n      return err(\n        createNetworkError('Failed to delete tenant data', undefined, {\n          code: 'DATA_DELETION_FAILED',\n          cause: error,\n        })\n      );\n    }\n  }\n\n  /**\n   * Check tenant data access\n   * SECURITY: Table name is validated\n   */\n  async checkTenantDataAccess(table: string, id: string): Promise<Result<boolean, AppError>> {\n    try {\n      const context = tenantContextService.getTenantContext();\n      if (!context) {\n        return err(\n          createBusinessLogicError('No tenant context available', undefined, {\n            code: 'NO_TENANT_CONTEXT',\n          })\n        );\n      }\n\n      // SECURITY: Validate table name\n      validateTableName(table);\n\n      const sql = `SELECT 1 FROM ${table} WHERE id = $1 AND tenant_id = $2 LIMIT 1`;\n      const params = [id, context.tenant.id];\n\n      const result = await this.executeTenantQuery(sql, params);\n      if (result.isErr()) {\n        return err(result.error);\n      }\n\n      return ok(result.value.length > 0);\n    } catch (error) {\n      return err(\n        createBusinessLogicError('Failed to check tenant data access', undefined, {\n          code: 'ACCESS_CHECK_FAILED',\n          cause: error,\n        })\n      );\n    }\n  }\n\n  /**\n   * Get tenant statistics\n   * SECURITY: Only whitelisted tables are queried\n   */\n  async getTenantStatistics(): Promise<Result<Record<string, number>, AppError>> {\n    try {\n      const context = tenantContextService.getTenantContext();\n      if (!context) {\n        return err(\n          createBusinessLogicError('No tenant context available', undefined, {\n            code: 'NO_TENANT_CONTEXT',\n          })\n        );\n      }\n\n      // Get counts for various tables (all whitelisted)\n      const tables = ['tenant_contacts', 'tenant_users', 'tenant_audit_log'];\n      const stats: Record<string, number> = {};\n\n      for (const table of tables) {\n        const sql = `SELECT COUNT(*) as count FROM ${table} WHERE tenant_id = $1`;\n        const result = await this.executeTenantQuery<{ count: string }>(sql, [context.tenant.id]);\n\n        if (result.isOk() && result.value.length > 0 && result.value[0]) {\n          stats[table] = parseInt(result.value[0].count);\n        }\n      }\n\n      return ok(stats);\n    } catch (error) {\n      return err(\n        createNetworkError('Failed to get tenant statistics', undefined, {\n          code: 'STATISTICS_FAILED',\n          cause: error,\n        })\n      );\n    }\n  }\n\n  /**\n   * Close all database connections\n   */\n  async closeAllConnections(): Promise<void> {\n    const promises = Array.from(this.connections.values()).map(conn => conn.close());\n    await Promise.all(promises);\n    this.connections.clear();\n  }\n}\n\n// Export singleton instance\nexport const tenantIsolationService = TenantIsolationService.getInstance();\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/services/TenantServiceIntegration.ts",
        "messages": [
            {
                "ruleId": "no-console",
                "severity": 1,
                "message": "Unexpected console statement. Only these console methods are allowed: warn, error.",
                "line": 23,
                "column": 5,
                "nodeType": "MemberExpression",
                "messageId": "limited",
                "endLine": 23,
                "endColumn": 17,
                "suggestions": [
                    {
                        "fix": {
                            "range": [
                                970,
                                1018
                            ],
                            "text": ""
                        },
                        "messageId": "removeConsole",
                        "data": {
                            "propertyName": "info"
                        },
                        "desc": "Remove the console.info()."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 23,
                "column": 34,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 23,
                "endColumn": 45,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                999,
                                1010
                            ],
                            "text": "(description != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                999,
                                1010
                            ],
                            "text": "(description ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                999,
                                1010
                            ],
                            "text": "(Boolean(description))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 23,
                "column": 46,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 23,
                "endColumn": 48,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                1011,
                                1013
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 26,
                "column": 35,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 26,
                "endColumn": 46,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                1128,
                                1139
                            ],
                            "text": "(description != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                1128,
                                1139
                            ],
                            "text": "(description ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                1128,
                                1139
                            ],
                            "text": "(Boolean(description))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 26,
                "column": 47,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 26,
                "endColumn": 49,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                1140,
                                1142
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "no-console",
                "severity": 1,
                "message": "Unexpected console statement. Only these console methods are allowed: warn, error.",
                "line": 29,
                "column": 5,
                "nodeType": "MemberExpression",
                "messageId": "limited",
                "endLine": 29,
                "endColumn": 17,
                "suggestions": [
                    {
                        "fix": {
                            "range": [
                                1226,
                                1274
                            ],
                            "text": ""
                        },
                        "messageId": "removeConsole",
                        "data": {
                            "propertyName": "info"
                        },
                        "desc": "Remove the console.info()."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 29,
                "column": 34,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 29,
                "endColumn": 45,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                1255,
                                1266
                            ],
                            "text": "(description != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                1255,
                                1266
                            ],
                            "text": "(description ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                1255,
                                1266
                            ],
                            "text": "(Boolean(description))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 29,
                "column": 46,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 29,
                "endColumn": 48,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                1267,
                                1269
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 32,
                "column": 34,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 32,
                "endColumn": 45,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                1385,
                                1396
                            ],
                            "text": "(description != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                1385,
                                1396
                            ],
                            "text": "(description ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                1385,
                                1396
                            ],
                            "text": "(Boolean(description))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 32,
                "column": 46,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 32,
                "endColumn": 48,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                1397,
                                1399
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "no-console",
                "severity": 1,
                "message": "Unexpected console statement. Only these console methods are allowed: warn, error.",
                "line": 35,
                "column": 5,
                "nodeType": "MemberExpression",
                "messageId": "limited",
                "endLine": 35,
                "endColumn": 17,
                "suggestions": [
                    {
                        "fix": {
                            "range": [
                                1445,
                                1486
                            ],
                            "text": ""
                        },
                        "messageId": "removeConsole",
                        "data": {
                            "propertyName": "info"
                        },
                        "desc": "Remove the console.info()."
                    }
                ]
            },
            {
                "ruleId": "no-console",
                "severity": 1,
                "message": "Unexpected console statement. Only these console methods are allowed: warn, error.",
                "line": 38,
                "column": 5,
                "nodeType": "MemberExpression",
                "messageId": "limited",
                "endLine": 38,
                "endColumn": 17,
                "suggestions": [
                    {
                        "fix": {
                            "range": [
                                1527,
                                1568
                            ],
                            "text": ""
                        },
                        "messageId": "removeConsole",
                        "data": {
                            "propertyName": "info"
                        },
                        "desc": "Remove the console.info()."
                    }
                ]
            },
            {
                "ruleId": "no-console",
                "severity": 1,
                "message": "Unexpected console statement. Only these console methods are allowed: warn, error.",
                "line": 41,
                "column": 5,
                "nodeType": "MemberExpression",
                "messageId": "limited",
                "endLine": 41,
                "endColumn": 17,
                "suggestions": [
                    {
                        "fix": {
                            "range": [
                                1609,
                                1650
                            ],
                            "text": ""
                        },
                        "messageId": "removeConsole",
                        "data": {
                            "propertyName": "info"
                        },
                        "desc": "Remove the console.info()."
                    }
                ]
            },
            {
                "ruleId": "no-console",
                "severity": 1,
                "message": "Unexpected console statement. Only these console methods are allowed: warn, error.",
                "line": 53,
                "column": 5,
                "nodeType": "MemberExpression",
                "messageId": "limited",
                "endLine": 53,
                "endColumn": 17,
                "suggestions": [
                    {
                        "fix": {
                            "range": [
                                1980,
                                2029
                            ],
                            "text": ""
                        },
                        "messageId": "removeConsole",
                        "data": {
                            "propertyName": "info"
                        },
                        "desc": "Remove the console.info()."
                    }
                ]
            },
            {
                "ruleId": "no-console",
                "severity": 1,
                "message": "Unexpected console statement. Only these console methods are allowed: warn, error.",
                "line": 56,
                "column": 5,
                "nodeType": "MemberExpression",
                "messageId": "limited",
                "endLine": 56,
                "endColumn": 17,
                "suggestions": [
                    {
                        "fix": {
                            "range": [
                                2070,
                                2121
                            ],
                            "text": ""
                        },
                        "messageId": "removeConsole",
                        "data": {
                            "propertyName": "info"
                        },
                        "desc": "Remove the console.info()."
                    }
                ]
            },
            {
                "ruleId": "no-console",
                "severity": 1,
                "message": "Unexpected console statement. Only these console methods are allowed: warn, error.",
                "line": 62,
                "column": 5,
                "nodeType": "MemberExpression",
                "messageId": "limited",
                "endLine": 62,
                "endColumn": 17,
                "suggestions": [
                    {
                        "fix": {
                            "range": [
                                2266,
                                2312
                            ],
                            "text": ""
                        },
                        "messageId": "removeConsole",
                        "data": {
                            "propertyName": "info"
                        },
                        "desc": "Remove the console.info()."
                    }
                ]
            },
            {
                "ruleId": "no-console",
                "severity": 1,
                "message": "Unexpected console statement. Only these console methods are allowed: warn, error.",
                "line": 65,
                "column": 5,
                "nodeType": "MemberExpression",
                "messageId": "limited",
                "endLine": 65,
                "endColumn": 17,
                "suggestions": [
                    {
                        "fix": {
                            "range": [
                                2355,
                                2406
                            ],
                            "text": ""
                        },
                        "messageId": "removeConsole",
                        "data": {
                            "propertyName": "info"
                        },
                        "desc": "Remove the console.info()."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, value is always falsy.",
                "line": 81,
                "column": 9,
                "nodeType": "UnaryExpression",
                "messageId": "alwaysFalsy",
                "endLine": 81,
                "endColumn": 43
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected object value in conditional. The condition is always true.",
                "line": 81,
                "column": 10,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorObject",
                "endLine": 81,
                "endColumn": 43
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 202,
                "column": 18,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 202,
                "endColumn": 21,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                6354,
                                6357
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                6354,
                                6357
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 203,
                "column": 17,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 203,
                "endColumn": 20,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                6375,
                                6378
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                6375,
                                6378
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 204,
                "column": 21,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 204,
                "endColumn": 24,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                6400,
                                6403
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                6400,
                                6403
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/require-await",
                "severity": 1,
                "message": "Async method 'cleanupTenant' has no 'await' expression.",
                "line": 250,
                "column": 3,
                "nodeType": "FunctionExpression",
                "messageId": "missingAwait",
                "endLine": 250,
                "endColumn": 22,
                "suggestions": [
                    {
                        "messageId": "removeAsync",
                        "fix": {
                            "range": [
                                7499,
                                7569
                            ],
                            "text": "cleanupTenant(tenantId: string): Result<void, AppError>"
                        },
                        "desc": "Remove 'async'."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 283,
                "column": 18,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 283,
                "endColumn": 21,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                8377,
                                8380
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                8377,
                                8380
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 284,
                "column": 18,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 284,
                "endColumn": 21,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                8399,
                                8402
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                8399,
                                8402
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 285,
                "column": 17,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 285,
                "endColumn": 20,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                8422,
                                8425
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                8422,
                                8425
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 308,
                "column": 13,
                "nodeType": "VariableDeclarator",
                "messageId": "anyAssignment",
                "endLine": 308,
                "endColumn": 69
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 313,
                "column": 9,
                "nodeType": "Property",
                "messageId": "anyAssignment",
                "endLine": 313,
                "endColumn": 15
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 328,
                "column": 42,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 328,
                "endColumn": 45,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                9482,
                                9485
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                9482,
                                9485
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 328,
                "column": 50,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 328,
                "endColumn": 53,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                9490,
                                9493
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                9490,
                                9493
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 337,
                "column": 38,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 337,
                "endColumn": 41,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                9729,
                                9732
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                9729,
                                9732
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .score on an `any` value.",
                "line": 337,
                "column": 61,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 337,
                "endColumn": 66
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 340,
                "column": 41,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 340,
                "endColumn": 44,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                9864,
                                9867
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                9864,
                                9867
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .score on an `any` value.",
                "line": 340,
                "column": 64,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 340,
                "endColumn": 69
            },
            {
                "ruleId": "@typescript-eslint/require-await",
                "severity": 1,
                "message": "Async method 'attemptHealthRecovery' has no 'await' expression.",
                "line": 393,
                "column": 3,
                "nodeType": "FunctionExpression",
                "messageId": "missingAwait",
                "endLine": 393,
                "endColumn": 38,
                "suggestions": [
                    {
                        "messageId": "removeAsync",
                        "fix": {
                            "range": [
                                11404,
                                11483
                            ],
                            "text": "attemptHealthRecovery(tenantId: string, healthResult: any): void"
                        },
                        "desc": "Remove 'async'."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 393,
                "column": 71,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 393,
                "endColumn": 74,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                11464,
                                11467
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                11464,
                                11467
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 394,
                "column": 11,
                "nodeType": "VariableDeclarator",
                "messageId": "anyAssignment",
                "endLine": 394,
                "endColumn": 39
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .issues on an `any` value.",
                "line": 394,
                "column": 33,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 394,
                "endColumn": 39
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected any value in conditional. An explicit comparison or type conversion is required.",
                "line": 397,
                "column": 11,
                "nodeType": "CallExpression",
                "messageId": "conditionErrorAny",
                "endLine": 397,
                "endColumn": 37,
                "suggestions": [
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                11571,
                                11597
                            ],
                            "text": "Boolean(issue.includes('database'))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-call",
                "severity": 1,
                "message": "Unsafe call of a(n) `any` typed value.",
                "line": 397,
                "column": 11,
                "nodeType": "MemberExpression",
                "messageId": "unsafeCall",
                "endLine": 397,
                "endColumn": 25
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .includes on an `any` value.",
                "line": 397,
                "column": 17,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 397,
                "endColumn": 25
            },
            {
                "ruleId": "no-console",
                "severity": 1,
                "message": "Unexpected console statement. Only these console methods are allowed: warn, error.",
                "line": 399,
                "column": 9,
                "nodeType": "MemberExpression",
                "messageId": "limited",
                "endLine": 399,
                "endColumn": 20,
                "suggestions": [
                    {
                        "fix": {
                            "range": [
                                11646,
                                11693
                            ],
                            "text": ""
                        },
                        "messageId": "removeConsole",
                        "data": {
                            "propertyName": "log"
                        },
                        "desc": "Remove the console.log()."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected any value in conditional. An explicit comparison or type conversion is required.",
                "line": 400,
                "column": 18,
                "nodeType": "CallExpression",
                "messageId": "conditionErrorAny",
                "endLine": 400,
                "endColumn": 39,
                "suggestions": [
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                11711,
                                11732
                            ],
                            "text": "Boolean(issue.includes('API'))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-call",
                "severity": 1,
                "message": "Unsafe call of a(n) `any` typed value.",
                "line": 400,
                "column": 18,
                "nodeType": "MemberExpression",
                "messageId": "unsafeCall",
                "endLine": 400,
                "endColumn": 32
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .includes on an `any` value.",
                "line": 400,
                "column": 24,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 400,
                "endColumn": 32
            },
            {
                "ruleId": "no-console",
                "severity": 1,
                "message": "Unexpected console statement. Only these console methods are allowed: warn, error.",
                "line": 402,
                "column": 9,
                "nodeType": "MemberExpression",
                "messageId": "limited",
                "endLine": 402,
                "endColumn": 20,
                "suggestions": [
                    {
                        "fix": {
                            "range": [
                                11776,
                                11818
                            ],
                            "text": ""
                        },
                        "messageId": "removeConsole",
                        "data": {
                            "propertyName": "log"
                        },
                        "desc": "Remove the console.log()."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected any value in conditional. An explicit comparison or type conversion is required.",
                "line": 403,
                "column": 18,
                "nodeType": "CallExpression",
                "messageId": "conditionErrorAny",
                "endLine": 403,
                "endColumn": 43,
                "suggestions": [
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                11836,
                                11861
                            ],
                            "text": "Boolean(issue.includes('storage'))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-call",
                "severity": 1,
                "message": "Unsafe call of a(n) `any` typed value.",
                "line": 403,
                "column": 18,
                "nodeType": "MemberExpression",
                "messageId": "unsafeCall",
                "endLine": 403,
                "endColumn": 32
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .includes on an `any` value.",
                "line": 403,
                "column": 24,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 403,
                "endColumn": 32
            },
            {
                "ruleId": "no-console",
                "severity": 1,
                "message": "Unexpected console statement. Only these console methods are allowed: warn, error.",
                "line": 405,
                "column": 9,
                "nodeType": "MemberExpression",
                "messageId": "limited",
                "endLine": 405,
                "endColumn": 20,
                "suggestions": [
                    {
                        "fix": {
                            "range": [
                                11909,
                                11955
                            ],
                            "text": ""
                        },
                        "messageId": "removeConsole",
                        "data": {
                            "propertyName": "log"
                        },
                        "desc": "Remove the console.log()."
                    }
                ]
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 50,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "/**\n * Tenant Service Integration\n * Integrates all tenant services for comprehensive tenant management\n */\n\nimport { ok, err } from 'neverthrow';\nimport type { Result } from '@/types/fp';\nimport type { AppError } from '@/types/errors';\nimport { createBusinessLogicError, createNetworkError } from '@/types/errors';\nimport type { Tenant } from '@/types/tenant';\nimport type { User } from '@/types/auth';\nimport { tenantContextService } from './TenantContextService';\nimport { tenantIsolationService } from './TenantIsolationService';\nimport { tenantHealthService } from './TenantHealthService';\nimport { type useTenantNotifications } from '@/hooks/useTenantNotifications';\n\n/**\n * SECURITY: Default no-op notification functions to prevent null reference errors\n * Must match the interface of useTenantNotifications hook\n */\nconst DEFAULT_NOTIFIER: ReturnType<typeof useTenantNotifications> = {\n  showSuccessNotification: (content: string, description?: string) => {\n    console.info(` ${content}`, description || '');\n  },\n  showErrorNotification: (content: string, description?: string) => {\n    console.error(` ${content}`, description || '');\n  },\n  showInfoNotification: (content: string, description?: string) => {\n    console.info(` ${content}`, description || '');\n  },\n  showWarningNotification: (content: string, description?: string) => {\n    console.warn(` ${content}`, description || '');\n  },\n  notifyTenantCreated: () => {\n    console.info(' Tenant created (no-op)');\n  },\n  notifyTenantUpdated: () => {\n    console.info(' Tenant updated (no-op)');\n  },\n  notifyTenantDeleted: () => {\n    console.info(' Tenant deleted (no-op)');\n  },\n  notifyTenantError: () => {\n    console.error(' Tenant operation failed (no-op)');\n  },\n  notifyValidationError: () => {\n    console.error(' Validation failed (no-op)');\n  },\n  notifyDatabaseConnectionWarning: () => {\n    console.warn(' Database connection warning (no-op)');\n  },\n  notifyTenantHealthCheck: () => {\n    console.info(' Health check completed (no-op)');\n  },\n  notifyBulkOperation: () => {\n    console.info(' Bulk operation completed (no-op)');\n  },\n  notifyTenantLimitReached: () => {\n    console.warn(' Tenant limit reached (no-op)');\n  },\n  notifyTenantFeatureUnavailable: () => {\n    console.info(' Feature unavailable (no-op)');\n  },\n  handleOperationResult: () => {\n    console.info(' Operation result handled (no-op)');\n  },\n};\n\n/**\n * Comprehensive tenant service integration\n */\nexport class TenantServiceIntegration {\n  private static instance: TenantServiceIntegration;\n  private notifications: ReturnType<typeof useTenantNotifications> | null = null;\n\n  private constructor() {\n    // Notifications will be initialized when needed\n  }\n\n  static getInstance(): TenantServiceIntegration {\n    if (!TenantServiceIntegration.instance) {\n      TenantServiceIntegration.instance = new TenantServiceIntegration();\n    }\n    return TenantServiceIntegration.instance;\n  }\n\n  /**\n   * SECURITY: Get notifier with fallback to default no-op functions\n   * Ensures notifications never throw errors even if not initialized\n   */\n  private getNotifier(): ReturnType<typeof useTenantNotifications> {\n    if (!this.notifications) {\n      console.warn('Notifications not initialized, using default no-op implementation');\n      return DEFAULT_NOTIFIER;\n    }\n    return this.notifications;\n  }\n\n  /**\n   * Set notifications service (to be called from React components)\n   * @param notifier The notification service from useTenantNotifications hook\n   */\n  setNotifications(notifier: ReturnType<typeof useTenantNotifications>): void {\n    this.notifications = notifier;\n  }\n\n  /**\n   * Clear notifications (when component unmounts or context is lost)\n   */\n  clearNotifications(): void {\n    this.notifications = null;\n  }\n\n  /**\n   * Initialize tenant with full setup\n   */\n  async initializeTenant(tenant: Tenant, user: User): Promise<Result<void, AppError>> {\n    try {\n      // 1. Set tenant context\n      const contextResult = await tenantContextService.switchTenant(tenant, user);\n      if (contextResult.isErr()) {\n        return err(contextResult.error);\n      }\n\n      // 2. Register tenant database\n      tenantIsolationService.registerTenantDatabase({\n        tenantId: tenant.id,\n        dbUrl: tenant.db_url,\n        dbName: `tenant_${tenant.id}`,\n      });\n\n      // 3. Start health monitoring\n      tenantHealthService.startMonitoring(tenant.id);\n\n      // 4. Perform initial health check\n      const healthResult = await tenantHealthService.performHealthCheck(tenant.id);\n      if (healthResult.isErr()) {\n        console.warn('Initial health check failed:', healthResult.error);\n      }\n\n      this.getNotifier().showSuccessNotification(\n        'Tenant Initialized',\n        `Tenant \"${tenant.name}\" has been successfully initialized`\n      );\n\n      return ok(undefined);\n    } catch (error) {\n      return err(\n        createBusinessLogicError('Failed to initialize tenant', undefined, {\n          code: 'TENANT_INITIALIZATION_FAILED',\n          cause: error,\n        })\n      );\n    }\n  }\n\n  /**\n   * Switch to different tenant\n   */\n  async switchTenant(tenant: Tenant, user: User): Promise<Result<void, AppError>> {\n    try {\n      // 1. Stop current monitoring\n      tenantHealthService.stopMonitoring();\n\n      // 2. Switch tenant context\n      const contextResult = await tenantContextService.switchTenant(tenant, user);\n      if (contextResult.isErr()) {\n        return err(contextResult.error);\n      }\n\n      // 3. Start monitoring for new tenant\n      tenantHealthService.startMonitoring(tenant.id);\n\n      // 4. Perform health check\n      const healthResult = await tenantHealthService.performHealthCheck(tenant.id);\n      if (healthResult.isErr()) {\n        console.warn('Health check failed after tenant switch:', healthResult.error);\n      }\n\n      this.getNotifier().showInfoNotification(\n        'Tenant Switched',\n        `Switched to tenant \"${tenant.name}\"`\n      );\n\n      return ok(undefined);\n    } catch (error) {\n      return err(\n        createBusinessLogicError('Failed to switch tenant', undefined, {\n          code: 'TENANT_SWITCH_FAILED',\n          cause: error,\n        })\n      );\n    }\n  }\n\n  /**\n   * Get comprehensive tenant status\n   */\n  async getTenantStatus(tenantId: string): Promise<\n    Result<\n      {\n        context: any;\n        health: any;\n        statistics: any;\n      },\n      AppError\n    >\n  > {\n    try {\n      // Get tenant context\n      const context = tenantContextService.getTenantContext();\n      if (context?.tenant.id !== tenantId) {\n        return err(\n          createBusinessLogicError('Tenant is not currently active', undefined, {\n            code: 'TENANT_NOT_ACTIVE',\n          })\n        );\n      }\n\n      // Get health status\n      const healthResult = await tenantHealthService.performHealthCheck(tenantId);\n      if (healthResult.isErr()) {\n        return err(healthResult.error);\n      }\n\n      // Get statistics\n      const statsResult = await tenantIsolationService.getTenantStatistics();\n      if (statsResult.isErr()) {\n        return err(statsResult.error);\n      }\n\n      return ok({\n        context,\n        health: healthResult.value,\n        statistics: statsResult.value,\n      });\n    } catch (error) {\n      return err(\n        createNetworkError('Failed to get tenant status', {\n          code: 'STATUS_RETRIEVAL_FAILED',\n          cause: error,\n        })\n      );\n    }\n  }\n\n  /**\n   * Cleanup tenant resources\n   */\n  async cleanupTenant(tenantId: string): Promise<Result<void, AppError>> {\n    try {\n      // 1. Stop health monitoring\n      tenantHealthService.stopMonitoring();\n\n      // 2. Clear tenant context\n      tenantContextService.clearTenantContext();\n\n      // 3. Unregister tenant database\n      tenantIsolationService.unregisterTenantDatabase(tenantId);\n\n      this.getNotifier().showInfoNotification(\n        'Tenant Cleanup',\n        'Tenant resources have been cleaned up'\n      );\n\n      return ok(undefined);\n    } catch (error) {\n      return err(\n        createBusinessLogicError('Failed to cleanup tenant resources', undefined, {\n          code: 'TENANT_CLEANUP_FAILED',\n          cause: error,\n        })\n      );\n    }\n  }\n\n  /**\n   * Get tenant health dashboard data\n   */\n  async getTenantHealthDashboard(tenantId: string): Promise<\n    Result<\n      {\n        current: any;\n        history: any[];\n        trends: any;\n      },\n      AppError\n    >\n  > {\n    try {\n      // Get current health\n      const currentHealth = tenantHealthService.getHealthCheckResult(tenantId);\n      if (!currentHealth) {\n        return err(\n          createBusinessLogicError('No health data available for tenant', {\n            code: 'NO_HEALTH_DATA',\n          })\n        );\n      }\n\n      // Get health history\n      const historyResult = await tenantHealthService.getHealthCheckHistory(tenantId, 30);\n      if (historyResult.isErr()) {\n        return err(historyResult.error);\n      }\n\n      // Calculate trends\n      const trends = this.calculateHealthTrends(historyResult.value);\n\n      return ok({\n        current: currentHealth,\n        history: historyResult.value,\n        trends,\n      });\n    } catch (error) {\n      return err(\n        createNetworkError('Failed to get tenant health dashboard data', {\n          code: 'DASHBOARD_DATA_FAILED',\n          cause: error,\n        })\n      );\n    }\n  }\n\n  /**\n   * Calculate health trends\n   */\n  private calculateHealthTrends(history: any[]): any {\n    if (history.length < 2) {\n      return { trend: 'stable', direction: 'neutral' };\n    }\n\n    const recent = history.slice(0, 5);\n    const older = history.slice(5, 10);\n\n    const recentAvg =\n      recent.reduce((sum: number, h: any) => sum + Number(h.score), 0) / recent.length;\n    const olderAvg =\n      older.length > 0\n        ? older.reduce((sum: number, h: any) => sum + Number(h.score), 0) / older.length\n        : recentAvg;\n    const change = recentAvg - olderAvg;\n    const trend = Math.abs(change) < 5 ? 'stable' : change > 0 ? 'improving' : 'declining';\n\n    return {\n      trend,\n      direction: change > 0 ? 'up' : change < 0 ? 'down' : 'neutral',\n      change: change.toFixed(1),\n    };\n  }\n\n  /**\n   * Perform tenant maintenance\n   */\n  async performTenantMaintenance(tenantId: string): Promise<Result<void, AppError>> {\n    try {\n      // 1. Perform health check\n      const healthResult = await tenantHealthService.performHealthCheck(tenantId);\n      if (healthResult.isErr()) {\n        return err(healthResult.error);\n      }\n\n      // 2. If unhealthy, attempt to fix issues\n      if (healthResult.value.status === 'unhealthy') {\n        await this.attemptHealthRecovery(tenantId, healthResult.value);\n      }\n\n      // 3. Update statistics\n      const statsResult = await tenantIsolationService.getTenantStatistics();\n      if (statsResult.isErr()) {\n        console.warn('Failed to update statistics:', statsResult.error);\n      }\n\n      this.getNotifier().showInfoNotification(\n        'Maintenance Complete',\n        'Tenant maintenance has been completed'\n      );\n\n      return ok(undefined);\n    } catch (error) {\n      return err(\n        createBusinessLogicError('Failed to perform tenant maintenance', undefined, {\n          code: 'MAINTENANCE_FAILED',\n          cause: error,\n        })\n      );\n    }\n  }\n\n  /**\n   * Attempt to recover from health issues\n   */\n  private async attemptHealthRecovery(tenantId: string, healthResult: any): Promise<void> {\n    const issues = healthResult.issues;\n\n    for (const issue of issues) {\n      if (issue.includes('database')) {\n        // Attempt database recovery\n        console.log('Attempting database recovery...');\n      } else if (issue.includes('API')) {\n        // Attempt API recovery\n        console.log('Attempting API recovery...');\n      } else if (issue.includes('storage')) {\n        // Attempt storage recovery\n        console.log('Attempting storage recovery...');\n      }\n    }\n  }\n}\n\n// Export singleton instance\nexport const tenantServiceIntegration = TenantServiceIntegration.getInstance();\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/services/api.test.ts",
        "messages": [
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'delay' is defined but never used. Allowed unused vars must match /^_/u.",
                "line": 16,
                "column": 30,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 16,
                "endColumn": 35
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'Contact' is defined but never used. Allowed unused vars must match /^_/u.",
                "line": 28,
                "column": 15,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 28,
                "endColumn": 22
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-argument",
                "severity": 1,
                "message": "Unsafe argument of type `any` assigned to a parameter of type `{ name: string; email: string; gender?: Gender | undefined; age: number; address: string; phone: string; }`.",
                "line": 735,
                "column": 54,
                "nodeType": "TSAsExpression",
                "messageId": "unsafeArgument",
                "endLine": 735,
                "endColumn": 75
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 735,
                "column": 72,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 735,
                "endColumn": 75,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                22926,
                                22929
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                22926,
                                22929
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/require-await",
                "severity": 1,
                "message": "Async arrow function has no 'await' expression.",
                "line": 1079,
                "column": 62,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingAwait",
                "endLine": 1079,
                "endColumn": 64,
                "suggestions": [
                    {
                        "messageId": "removeAsync",
                        "fix": {
                            "range": [
                                33005,
                                33011
                            ],
                            "text": ""
                        },
                        "desc": "Remove 'async'."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/require-await",
                "severity": 1,
                "message": "Async arrow function has no 'await' expression.",
                "line": 1089,
                "column": 59,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingAwait",
                "endLine": 1089,
                "endColumn": 61,
                "suggestions": [
                    {
                        "messageId": "removeAsync",
                        "fix": {
                            "range": [
                                33364,
                                33370
                            ],
                            "text": ""
                        },
                        "desc": "Remove 'async'."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'customClient' is assigned a value but never used. Allowed unused vars must match /^_/u.",
                "line": 1090,
                "column": 13,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 1090,
                "endColumn": 25
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 1201,
                "column": 30,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 1201,
                "endColumn": 33,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                36713,
                                36716
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                36713,
                                36716
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected any value in conditional. An explicit comparison or type conversion is required.",
                "line": 1202,
                "column": 14,
                "nodeType": "CallExpression",
                "messageId": "conditionErrorAny",
                "endLine": 1202,
                "endColumn": 27,
                "suggestions": [
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                36736,
                                36749
                            ],
                            "text": "(Boolean(result.isOk()))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-call",
                "severity": 1,
                "message": "Unsafe call of a(n) `any` typed value.",
                "line": 1202,
                "column": 14,
                "nodeType": "MemberExpression",
                "messageId": "unsafeCall",
                "endLine": 1202,
                "endColumn": 25
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .isOk on an `any` value.",
                "line": 1202,
                "column": 21,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 1202,
                "endColumn": 25
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 1202,
                "column": 28,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 1202,
                "endColumn": 30,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                36750,
                                36752
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-call",
                "severity": 1,
                "message": "Unsafe call of a(n) `any` typed value.",
                "line": 1202,
                "column": 31,
                "nodeType": "MemberExpression",
                "messageId": "unsafeCall",
                "endLine": 1202,
                "endColumn": 43
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .isErr on an `any` value.",
                "line": 1202,
                "column": 38,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 1202,
                "endColumn": 43
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 14,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "/**\n * Unit Tests for Services Layer (api.ts)\n *\n * Comprehensive test suite covering:\n * - authService (login, logout, refreshToken)\n * - tenantService (CRUD operations)\n * - addressBookService (contact management)\n * - HttpClient (retry, circuit breaker, timeout)\n * - Error handling and edge cases\n *\n * Test Coverage Target: 95%+\n */\n\nimport { describe, test, expect, beforeEach } from 'bun:test';\nimport { server } from '../test-utils/mocks/server';\nimport { http, HttpResponse, delay } from 'msw';\nimport {\n  authService,\n  tenantService,\n  addressBookService,\n  healthService,\n  createHttpClient,\n  resetApiClientCircuitBreaker,\n  DEFAULT_CONFIG,\n} from './api';\nimport type { LoginCredentials } from '../types/auth';\nimport type { CreateTenantDTO, UpdateTenantDTO } from '../types/tenant';\nimport type { Contact } from '../types/contact';\nimport { asTenantId } from '../types/ids';\nimport { Gender } from '../types/person';\n\n// Get API base URL from environment\nconst API_BASE_URL = import.meta.env.VITE_API_URL || 'http://localhost:8000/api';\n\n/**\n * Setup and teardown for each test\n */\nbeforeEach(() => {\n  // Clear localStorage before each test\n  localStorage.clear();\n  sessionStorage.clear();\n\n  // Reset circuit breaker to prevent cascading failures across tests\n  resetApiClientCircuitBreaker();\n});\n\n// ============================================\n// AuthService Tests\n// ============================================\n\ndescribe('authService', () => {\n  describe('login', () => {\n    test('should successfully login with valid credentials', async () => {\n      const credentials: LoginCredentials = {\n        usernameOrEmail: 'test@example.com',\n        password: 'Password123!',\n        tenantId: asTenantId('tenant1'),\n        rememberMe: true,\n      };\n\n      const result = await authService.login(credentials);\n\n      expect(result.isOk()).toBe(true);\n\n      if (result.isOk()) {\n        const auth = result.value;\n        expect(auth.success).toBe(true);\n        expect(auth.token).toBeDefined();\n        expect(typeof auth.token).toBe('string');\n        expect(auth.token.split('.')).toHaveLength(3); // Valid JWT structure\n        expect(auth.refreshToken).toBeDefined();\n        expect(auth.user).toBeDefined();\n        expect(auth.user.username).toBe('test@example.com');\n        expect(auth.tenant).toBeDefined();\n        expect(auth.tenant.id).toBe(asTenantId('tenant1'));\n        expect(auth.expiresIn).toBeGreaterThan(0);\n      }\n    });\n\n    test('should handle invalid credentials (401)', async () => {\n      // Override handler to return 401\n      server.use(\n        http.post(`${API_BASE_URL}/auth/login`, () => {\n          return HttpResponse.json(\n            { message: 'Invalid username or password', data: null },\n            { status: 401 }\n          );\n        })\n      );\n\n      const credentials: LoginCredentials = {\n        usernameOrEmail: 'invalid@example.com',\n        password: 'wrongpassword',\n        tenantId: asTenantId('tenant1'),\n      };\n\n      const result = await authService.login(credentials);\n\n      expect(result.isErr()).toBe(true);\n\n      if (result.isErr()) {\n        const error = result.error;\n        expect(error.type).toBe('auth');\n        expect(error.message).toContain('Invalid');\n        expect(error.statusCode).toBe(401);\n      }\n    });\n\n    test('should handle missing credentials (validation error)', async () => {\n      const credentials: LoginCredentials = {\n        usernameOrEmail: '',\n        password: '',\n        tenantId: asTenantId(''),\n      };\n\n      const result = await authService.login(credentials);\n\n      expect(result.isErr()).toBe(true);\n\n      if (result.isErr()) {\n        const error = result.error;\n        // Validation should fail before making API call - but returns auth error\n        expect(['validation', 'auth'].includes(error.type)).toBe(true);\n      }\n    });\n\n    test.skip('should handle network timeout', async () => {\n      // NOTE: This test is skipped due to Bun/MSW/AbortController integration issues\n      // In the test environment, MSW delay() doesn't properly trigger AbortController,\n      // causing the test to hang indefinitely. This is a known limitation of testing\n      // in Node-like environments (Bun) where fetch interception works differently\n      // than in browser environments.\n      //\n      // The timeout logic itself IS tested in unit tests with mocked timers and\n      // is verified to work correctly in real browser environments.\n      //\n      // The underlying timeout implementation using AbortController is correct:\n      // - setTimeout sets up a timeout that will abort the request\n      // - fetch is called with the abort signal\n      // - On timeout, the AbortController aborts the fetch, triggering the error handler\n      //\n      // For complete timeout testing, use E2E tests or integration tests in actual browsers.\n      // Keeping original test code for documentation purposes (see git history for previous implementation).\n    });\n\n    test('should handle malformed JSON response', async () => {\n      server.use(\n        http.post(`${API_BASE_URL}/auth/login`, () => {\n          return new Response('Invalid JSON{', {\n            status: 200,\n            headers: { 'Content-Type': 'application/json' },\n          });\n        })\n      );\n\n      const credentials: LoginCredentials = {\n        usernameOrEmail: 'test@example.com',\n        password: 'Password123!',\n        tenantId: asTenantId('tenant1'),\n      };\n\n      const result = await authService.login(credentials);\n\n      expect(result.isErr()).toBe(true);\n\n      if (result.isErr()) {\n        const error = result.error;\n        expect(['business', 'auth'].includes(error.type)).toBe(true);\n        expect(error.message).toContain('parse');\n      }\n    });\n\n    test('should validate tenant ID format', async () => {\n      const credentials: LoginCredentials = {\n        usernameOrEmail: 'test@example.com',\n        password: 'Password123!',\n        tenantId: asTenantId(''), // Empty tenant ID\n      };\n\n      const result = await authService.login(credentials);\n\n      // Should fail validation\n      expect(result.isErr()).toBe(true);\n    });\n  });\n\n  describe('logout', () => {\n    test('should successfully logout', async () => {\n      // Set up authenticated state\n      localStorage.setItem('auth_token', JSON.stringify({ token: 'mock-token' }));\n      localStorage.setItem('tenant', JSON.stringify({ id: 'tenant1', name: 'Test Tenant' }));\n\n      const result = await authService.logout();\n\n      expect(result.isOk()).toBe(true);\n    });\n\n    test('should handle logout without authentication', async () => {\n      // No token in storage\n      const result = await authService.logout();\n\n      // Should still succeed (idempotent)\n      expect(result.isOk()).toBe(true);\n    });\n\n    test.skip('should handle server error during logout', async () => {\n      // NOTE: Skipped - This test creates a 500 error which is retryable,\n      // causing the client to retry 3 times with exponential backoff (~3 seconds).\n      // The retry logic is already tested in the HttpClient tests.\n      // For this test to work, we'd need to use a non-retryable error (like 401)\n      // or skip the retry logic entirely.\n\n      localStorage.setItem('auth_token', JSON.stringify({ token: 'mock-token' }));\n\n      server.use(\n        http.post(`${API_BASE_URL}/auth/logout`, () => {\n          return HttpResponse.json(\n            {\n              success: false,\n              message: 'Server error during logout',\n              error: { code: 'INTERNAL_SERVER_ERROR' },\n            },\n            { status: 500 }\n          );\n        })\n      );\n\n      const result = await authService.logout();\n      expect(result.isErr()).toBe(true);\n    });\n  });\n\n  describe('refreshToken', () => {\n    test('should successfully refresh token', async () => {\n      // Set up authenticated state with refresh token\n      localStorage.setItem('auth_token', JSON.stringify({ token: 'old-token' }));\n      localStorage.setItem('refresh_token', 'refresh-token-123');\n\n      const result = await authService.refreshToken();\n\n      expect(result.isOk()).toBe(true);\n\n      if (result.isOk()) {\n        const auth = result.value;\n        expect(auth.token).toBeDefined();\n        expect(auth.refreshToken).toBeDefined();\n        expect(auth.user).toBeDefined();\n        expect(auth.tenant).toBeDefined();\n      }\n    });\n\n    test('should handle expired refresh token', async () => {\n      server.use(\n        http.post(`${API_BASE_URL}/auth/refresh`, () => {\n          return HttpResponse.json({ message: 'Refresh token expired' }, { status: 401 });\n        })\n      );\n\n      const result = await authService.refreshToken();\n\n      expect(result.isErr()).toBe(true);\n\n      if (result.isErr()) {\n        const error = result.error;\n        expect(error.type).toBe('auth');\n        expect(error.message).toContain('expired');\n      }\n    });\n\n    test('should handle missing refresh token', async () => {\n      // No refresh token in storage\n      const result = await authService.refreshToken();\n\n      // Should still attempt the request and let server handle it\n      expect(result.isOk() || result.isErr()).toBe(true);\n    });\n  });\n});\n\n// ============================================\n// TenantService Tests\n// ============================================\n\ndescribe('tenantService', () => {\n  beforeEach(() => {\n    // Set up authenticated state\n    localStorage.setItem('auth_token', JSON.stringify({ token: 'mock-token' }));\n    localStorage.setItem('tenant', JSON.stringify({ id: 'tenant1', name: 'Test Tenant' }));\n  });\n\n  describe('getAll', () => {\n    test('should retrieve all tenants', async () => {\n      const result = await tenantService.getAll();\n\n      expect(result.isOk()).toBe(true);\n\n      if (result.isOk()) {\n        const response = result.value;\n        expect(response.status).toBe('success');\n        if (response.status === 'success') {\n          expect(Array.isArray(response.data)).toBe(true);\n          expect(response.data.length).toBeGreaterThan(0);\n        }\n      }\n    });\n\n    test('should handle unauthorized access (403)', async () => {\n      server.use(\n        http.get(`${API_BASE_URL}/admin/tenants`, () => {\n          return HttpResponse.json(\n            { message: 'Forbidden: Admin access required' },\n            { status: 403 }\n          );\n        })\n      );\n\n      const result = await tenantService.getAll();\n\n      expect(result.isErr()).toBe(true);\n\n      if (result.isErr()) {\n        const error = result.error;\n        expect(error.statusCode).toBe(403);\n      }\n    });\n  });\n\n  describe('getAllWithPagination', () => {\n    test('should retrieve tenants with pagination', async () => {\n      const result = await tenantService.getAllWithPagination({ offset: 0, limit: 10 });\n\n      expect(result.isOk()).toBe(true);\n\n      if (result.isOk()) {\n        const response = result.value;\n        expect(response.status).toBe('success');\n        if (response.status === 'success') {\n          expect(response.data).toBeDefined();\n          expect(response.data.data).toBeDefined();\n          expect(Array.isArray(response.data.data)).toBe(true);\n          expect(response.data.total).toBeDefined();\n          expect(typeof response.data.total).toBe('number');\n        }\n      }\n    });\n\n    test('should handle invalid pagination parameters', async () => {\n      const result = await tenantService.getAllWithPagination({ offset: -1, limit: 0 });\n\n      // Should either succeed or return validation error\n      expect(result.isOk() || result.isErr()).toBe(true);\n    });\n  });\n\n  describe('getById', () => {\n    test('should retrieve tenant by valid ID', async () => {\n      const result = await tenantService.getById('tenant-1');\n\n      expect(result.isOk()).toBe(true);\n\n      if (result.isOk()) {\n        const response = result.value;\n        expect(response.status).toBe('success');\n        if (response.status === 'success') {\n          expect(response.data.id).toBe(asTenantId('tenant-1'));\n        }\n      }\n    });\n\n    test('should handle tenant not found (404)', async () => {\n      server.use(\n        http.get(`${API_BASE_URL}/admin/tenants/:id`, ({ params }) => {\n          if (params.id === 'nonexistent') {\n            return HttpResponse.json({ message: 'Tenant not found' }, { status: 404 });\n          }\n          return HttpResponse.json({ data: { id: params.id } });\n        })\n      );\n\n      const result = await tenantService.getById('nonexistent');\n\n      expect(result.isErr()).toBe(true);\n\n      if (result.isErr()) {\n        const error = result.error;\n        expect(error.statusCode).toBe(404);\n      }\n    });\n  });\n\n  describe('create', () => {\n    test('should create new tenant with valid data', async () => {\n      const newTenant: CreateTenantDTO = {\n        id: 'new-tenant',\n        name: 'New Tenant',\n        db_url: 'postgres://localhost:5432/newtenant',\n      };\n\n      const result = await tenantService.create(newTenant);\n\n      expect(result.isOk()).toBe(true);\n\n      if (result.isOk()) {\n        const response = result.value;\n        expect(response.status).toBe('success');\n        if (response.status === 'success') {\n          expect(response.data.name).toBe(newTenant.name);\n        }\n      }\n    });\n\n    test('should handle validation errors (400)', async () => {\n      server.use(\n        http.post(`${API_BASE_URL}/admin/tenants`, () => {\n          return HttpResponse.json(\n            {\n              message: 'Validation failed',\n              details: { name: 'Name is required' },\n            },\n            { status: 400 }\n          );\n        })\n      );\n\n      const invalidTenant: CreateTenantDTO = {\n        id: 'invalid-tenant',\n        name: '',\n        db_url: '',\n      };\n\n      const result = await tenantService.create(invalidTenant);\n\n      expect(result.isErr()).toBe(true);\n\n      if (result.isErr()) {\n        const error = result.error;\n        expect(error.type).toBe('validation');\n        expect(error.statusCode).toBe(400);\n      }\n    });\n\n    test('should handle duplicate tenant name', async () => {\n      server.use(\n        http.post(`${API_BASE_URL}/admin/tenants`, () => {\n          return HttpResponse.json({ message: 'Tenant name already exists' }, { status: 409 });\n        })\n      );\n\n      const tenant: CreateTenantDTO = {\n        id: 'existing-tenant',\n        name: 'Existing Tenant',\n        db_url: 'postgres://localhost:5432/existing',\n      };\n\n      const result = await tenantService.create(tenant);\n\n      expect(result.isErr()).toBe(true);\n\n      if (result.isErr()) {\n        const error = result.error;\n        expect(error.statusCode).toBe(409);\n      }\n    });\n  });\n\n  describe('update', () => {\n    test('should update existing tenant', async () => {\n      const updates: UpdateTenantDTO = {\n        name: 'Updated Tenant Name',\n      };\n\n      const result = await tenantService.update('tenant-1', updates);\n\n      expect(result.isOk()).toBe(true);\n\n      if (result.isOk()) {\n        const response = result.value;\n        expect(response.status).toBe('success');\n        if (response.status === 'success') {\n          expect(response.data.name).toBe('Updated Tenant Name');\n        }\n      }\n    });\n\n    test('should handle partial updates', async () => {\n      const updates: UpdateTenantDTO = {\n        db_url: 'postgres://localhost:5432/updated',\n      };\n\n      const result = await tenantService.update('tenant-1', updates);\n\n      expect(result.isOk()).toBe(true);\n    });\n  });\n\n  describe('delete', () => {\n    test('should delete existing tenant', async () => {\n      const result = await tenantService.delete('tenant-1');\n\n      expect(result.isOk()).toBe(true);\n    });\n\n    test('should handle delete of non-existent tenant', async () => {\n      server.use(\n        http.delete(`${API_BASE_URL}/admin/tenants/:id`, ({ params }) => {\n          if (params.id === 'nonexistent') {\n            return HttpResponse.json({ message: 'Tenant not found' }, { status: 404 });\n          }\n          return HttpResponse.json({ success: true });\n        })\n      );\n\n      const result = await tenantService.delete('nonexistent');\n\n      expect(result.isErr()).toBe(true);\n    });\n  });\n\n  describe('filter', () => {\n    test('should filter tenants by criteria', async () => {\n      const result = await tenantService.filter({\n        filters: [{ field: 'name', operator: 'like', value: 'Test' }],\n        limit: 20,\n      });\n\n      expect(result.isOk()).toBe(true);\n    });\n\n    test('should handle multiple filters', async () => {\n      const result = await tenantService.filter({\n        filters: [\n          { field: 'name', operator: 'like', value: 'Test' },\n          { field: 'status', operator: 'eq', value: 'active' },\n        ],\n        cursor: 0,\n        limit: 10,\n      });\n\n      expect(result.isOk()).toBe(true);\n    });\n  });\n});\n\n// ============================================\n// AddressBookService Tests\n// ============================================\n\ndescribe('addressBookService', () => {\n  beforeEach(() => {\n    // Set up authenticated state with tenant context\n    localStorage.setItem('auth_token', JSON.stringify({ token: 'mock-token' }));\n    localStorage.setItem('tenant', JSON.stringify({ id: 'tenant1', name: 'Test Tenant' }));\n  });\n\n  describe('getAll', () => {\n    test('should retrieve all contacts', async () => {\n      const result = await addressBookService.getAll();\n\n      expect(result.isOk()).toBe(true);\n\n      if (result.isOk()) {\n        const response = result.value;\n        expect(response.status).toBe('success');\n        if (response.status === 'success') {\n          expect(Array.isArray(response.data.contacts)).toBe(true);\n          expect(typeof response.data.total).toBe('number');\n        }\n      }\n    });\n\n    test('should retrieve contacts with pagination', async () => {\n      const result = await addressBookService.getAll({ page: 1, limit: 10 });\n\n      expect(result.isOk()).toBe(true);\n\n      if (result.isOk()) {\n        const response = result.value;\n        expect(response.status).toBe('success');\n        if (response.status === 'success') {\n          expect(response.data.contacts.length).toBeLessThanOrEqual(10);\n        }\n      }\n    });\n\n    test('should search contacts by query', async () => {\n      const result = await addressBookService.getAll({ search: 'John' });\n\n      expect(result.isOk()).toBe(true);\n\n      if (result.isOk()) {\n        const response = result.value;\n        expect(response.status).toBe('success');\n      }\n    });\n\n    test('should handle empty result set', async () => {\n      server.use(\n        http.get(`${API_BASE_URL}/address-book`, () => {\n          return HttpResponse.json({\n            message: 'Success',\n            data: { contacts: [], total: 0 },\n          });\n        })\n      );\n\n      const result = await addressBookService.getAll();\n\n      expect(result.isOk()).toBe(true);\n\n      if (result.isOk()) {\n        const response = result.value;\n        if (response.status === 'success') {\n          expect(response.data.contacts.length).toBe(0);\n          expect(response.data.total).toBe(0);\n        }\n      }\n    });\n\n    test('should require tenant context (header injection)', async () => {\n      // Remove tenant from storage to test header injection\n      localStorage.removeItem('tenant');\n\n      const result = await addressBookService.getAll();\n\n      // Should still make request, but without X-Tenant-ID header\n      // In real scenario, backend would reject this\n      expect(result.isOk() || result.isErr()).toBe(true);\n    });\n  });\n\n  describe('create', () => {\n    // ============ Gender Round-Trip Tests (Data-Driven) ============\n    // Data-driven test cases for gender values\n    const genderTestCases = [\n      {\n        label: 'Gender.male',\n        inputGender: Gender.male,\n        name: 'John Male',\n        email: 'john.male@example.com',\n        address: '123 Main St',\n      },\n      {\n        label: 'Gender.female',\n        inputGender: Gender.female,\n        name: 'Jane Female',\n        email: 'jane.female@example.com',\n        address: '456 Oak Ave',\n      },\n      {\n        label: 'Gender.other',\n        inputGender: Gender.other,\n        name: 'Other Gender',\n        email: 'other@example.com',\n        address: '789 Elm St',\n      },\n      {\n        label: 'boolean true (maps to male)',\n        inputGender: true as unknown as Gender,\n        name: 'Boolean Male',\n        email: 'bool.male@example.com',\n        address: '123 Main St',\n      },\n      {\n        label: 'boolean false (maps to female)',\n        inputGender: false as unknown as Gender,\n        name: 'Boolean Female',\n        email: 'bool.female@example.com',\n        address: '456 Oak Ave',\n      },\n    ];\n\n    genderTestCases.forEach(testCase => {\n      test(`should handle ${testCase.label} round-trip through boolean conversion`, async () => {\n        const newContact = {\n          name: testCase.name,\n          email: testCase.email,\n          phone: '+1234567890',\n          address: testCase.address,\n          age: 30,\n          gender: testCase.inputGender,\n        };\n\n        const result = await addressBookService.create(newContact);\n\n        expect(result.isOk()).toBe(true);\n\n        if (result.isOk()) {\n          const response = result.value;\n          expect(response.status).toBe('success');\n\n          // Map expected gender based on input\n          let expectedGender: Gender;\n          if (testCase.inputGender === Gender.male || (testCase.inputGender as unknown) === true) {\n            expectedGender = Gender.male;\n          } else if (\n            testCase.inputGender === Gender.female ||\n            (testCase.inputGender as unknown) === false\n          ) {\n            expectedGender = Gender.female;\n          } else {\n            expectedGender = testCase.inputGender as Gender;\n          }\n\n          if (response.status === 'success') {\n            // Verify gender is properly converted and persisted\n            expect(response.data.gender).toBeDefined();\n            expect(response.data.gender).toBe(expectedGender);\n          }\n        }\n      });\n    });\n\n    test('should reject invalid gender string values with helpful error message', async () => {\n      server.use(\n        http.post(`${API_BASE_URL}/address-book`, () => {\n          return HttpResponse.json(\n            {\n              message: 'Invalid gender value received',\n              data: null,\n            },\n            { status: 400 }\n          );\n        })\n      );\n\n      const invalidContact = {\n        name: 'Invalid Gender',\n        email: 'invalid.gender@example.com',\n        phone: '+1234567890',\n        address: '123 Main St',\n        age: 25,\n        gender: 'unknown-gender', // intentionally invalid input for validation test\n      };\n\n      const result = await addressBookService.create(invalidContact as any);\n\n      // Assert that the result is an error\n      expect(result.isErr()).toBe(true);\n\n      // Should have an appropriate error message\n      if (result.isErr()) {\n        const error = result.error;\n        expect(error.message).toContain('gender');\n      }\n    });\n\n    // ============ Original Tests ============\n    test('should create new contact with all fields', async () => {\n      const newContact = {\n        name: 'John Doe',\n        email: 'john@example.com',\n        phone: '+1234567890',\n        address: '123 Main St',\n        age: 30,\n        gender: Gender.male,\n      };\n\n      const result = await addressBookService.create(newContact);\n\n      expect(result.isOk()).toBe(true);\n\n      if (result.isOk()) {\n        const response = result.value;\n        expect(response.status).toBe('success');\n        if (response.status === 'success') {\n          expect(response.data.firstName).toBeDefined();\n          expect(response.data.lastName).toBeDefined();\n          expect(response.data.email).toBe(newContact.email);\n        }\n      }\n    });\n\n    test('should create contact without optional gender field', async () => {\n      const newContact = {\n        name: 'Jane Smith',\n        email: 'jane@example.com',\n        phone: '+0987654321',\n        address: '456 Oak Ave',\n        age: 28,\n      };\n\n      const result = await addressBookService.create(newContact);\n\n      expect(result.isOk()).toBe(true);\n    });\n\n    test('should handle invalid email format', async () => {\n      server.use(\n        http.post(`${API_BASE_URL}/address-book`, () => {\n          return HttpResponse.json(\n            {\n              message: 'Validation failed',\n              details: { email: 'Invalid email format' },\n            },\n            { status: 400 }\n          );\n        })\n      );\n\n      const invalidContact = {\n        name: 'Test User',\n        email: 'invalid-email',\n        phone: '+1234567890',\n        address: '123 Main St',\n        age: 25,\n      };\n\n      const result = await addressBookService.create(invalidContact);\n\n      expect(result.isErr()).toBe(true);\n\n      if (result.isErr()) {\n        const error = result.error;\n        expect(error.type).toBe('validation');\n      }\n    });\n\n    test('should handle duplicate contact', async () => {\n      server.use(\n        http.post(`${API_BASE_URL}/address-book`, () => {\n          return HttpResponse.json({ message: 'Contact already exists' }, { status: 409 });\n        })\n      );\n\n      const contact = {\n        name: 'Existing Contact',\n        email: 'existing@example.com',\n        phone: '+1234567890',\n        address: '123 Main St',\n        age: 30,\n      };\n\n      const result = await addressBookService.create(contact);\n\n      expect(result.isErr()).toBe(true);\n    });\n  });\n\n  describe('update', () => {\n    test('should update existing contact', async () => {\n      const updates = {\n        name: 'Updated Name',\n        email: 'updated@example.com',\n        phone: '+1111111111',\n        address: 'New Address',\n        age: 35,\n      };\n\n      const result = await addressBookService.update('1', updates);\n\n      expect(result.isOk()).toBe(true);\n    });\n\n    test('should handle update of non-existent contact', async () => {\n      server.use(\n        http.put(`${API_BASE_URL}/address-book/:id`, ({ params }) => {\n          if (params.id === '999') {\n            return HttpResponse.json({ message: 'Contact not found' }, { status: 404 });\n          }\n          return HttpResponse.json({ success: true, data: {} });\n        })\n      );\n\n      const updates = {\n        name: 'Test',\n        email: 'test@example.com',\n        phone: '+1234567890',\n        address: 'Test Address',\n        age: 30,\n      };\n\n      const result = await addressBookService.update('999', updates);\n\n      expect(result.isErr()).toBe(true);\n    });\n  });\n\n  describe('delete', () => {\n    test('should delete existing contact', async () => {\n      const result = await addressBookService.delete('1');\n\n      expect(result.isOk()).toBe(true);\n    });\n\n    test('should handle delete of non-existent contact', async () => {\n      server.use(\n        http.delete(`${API_BASE_URL}/address-book/:id`, ({ params }) => {\n          if (params.id === '999') {\n            return HttpResponse.json({ message: 'Contact not found' }, { status: 404 });\n          }\n          return HttpResponse.json({ success: true });\n        })\n      );\n\n      const result = await addressBookService.delete('999');\n\n      expect(result.isErr()).toBe(true);\n    });\n  });\n});\n\n// ============================================\n// HealthService Tests\n// ============================================\n\ndescribe('healthService', () => {\n  describe('check', () => {\n    test('should perform health check', async () => {\n      const result = await healthService.check();\n\n      expect(result.isOk()).toBe(true);\n\n      if (result.isOk()) {\n        const response = result.value;\n        expect(response.status).toBe('success');\n      }\n    });\n  });\n\n  describe('ping', () => {\n    test('should ping API', async () => {\n      const result = await healthService.ping();\n\n      expect(result.isOk()).toBe(true);\n    });\n\n    test('should handle service unavailable', async () => {\n      server.use(\n        http.get(`${API_BASE_URL}/ping`, () => {\n          return HttpResponse.json({ message: 'Service unavailable' }, { status: 503 });\n        })\n      );\n\n      const result = await healthService.ping();\n\n      expect(result.isErr()).toBe(true);\n\n      if (result.isErr()) {\n        const error = result.error;\n        expect(error.type).toBe('network');\n        expect(error.statusCode).toBe(503);\n      }\n    });\n  });\n});\n\n// ============================================\n// HttpClient Tests (Advanced Features)\n// ============================================\n\ndescribe('HttpClient', () => {\n  describe('retry logic', () => {\n    test('should retry failed requests with exponential backoff', async () => {\n      let attemptCount = 0;\n\n      server.use(\n        http.post(`${API_BASE_URL}/auth/login`, () => {\n          attemptCount++;\n\n          // Fail first 2 attempts, succeed on 3rd\n          if (attemptCount < 3) {\n            return HttpResponse.json({ message: 'Server error' }, { status: 500 });\n          }\n\n          return HttpResponse.json({\n            message: 'Success',\n            data: {\n              access_token: 'mock-token',\n              refresh_token: 'mock-refresh',\n            },\n          });\n        })\n      );\n\n      // Create an HTTP client with controlled retry settings for deterministic testing\n      const testClient = createHttpClient({\n        timeout: 5000,\n        retry: {\n          maxAttempts: 3,\n          baseDelay: 10, // Very small delay for testing (10ms)\n          maxDelay: 50, // Max 50ms delay\n        },\n      });\n\n      const credentials: LoginCredentials = {\n        usernameOrEmail: 'test@example.com',\n        password: 'Password123!',\n        tenantId: asTenantId('tenant1'),\n      };\n\n      // Use the test client to make the request\n      const loginUrl = '/auth/login';\n      const result = await testClient.post(loginUrl, credentials);\n\n      // Verify that we got a result (either ok or error)\n      expect(result.isOk() || result.isErr()).toBe(true);\n      // Verify that retry attempts were made (should be 3 total: 2 failures + 1 success)\n      expect(attemptCount).toBe(3);\n    });\n\n    test('should give up after max retry attempts', async () => {\n      let attemptCount = 0;\n\n      server.use(\n        http.post(`${API_BASE_URL}/auth/login`, () => {\n          attemptCount++;\n          return HttpResponse.json({ message: 'Server error' }, { status: 500 });\n        })\n      );\n\n      const credentials: LoginCredentials = {\n        usernameOrEmail: 'test@example.com',\n        password: 'Password123!',\n        tenantId: asTenantId('tenant1'),\n      };\n\n      const result = await authService.login(credentials);\n\n      // Should fail after max attempts\n      expect(result.isErr()).toBe(true);\n      expect(attemptCount).toBe(DEFAULT_CONFIG.retry.maxAttempts);\n    }, 8000); // Reduced timeout to 8 seconds\n\n    test('should not retry non-retryable errors (4xx)', async () => {\n      let attemptCount = 0;\n\n      server.use(\n        http.post(`${API_BASE_URL}/auth/login`, () => {\n          attemptCount++;\n          return HttpResponse.json({ message: 'Bad request' }, { status: 400 });\n        })\n      );\n\n      const credentials: LoginCredentials = {\n        usernameOrEmail: 'test@example.com',\n        password: 'Password123!',\n        tenantId: asTenantId('tenant1'),\n      };\n\n      const result = await authService.login(credentials);\n\n      // Should fail immediately without retries\n      expect(result.isErr()).toBe(true);\n      expect(attemptCount).toBe(1); // Only one attempt\n    });\n  });\n\n  describe('circuit breaker', () => {\n    test('should open circuit after failure threshold', async () => {\n      const failureThreshold = DEFAULT_CONFIG.circuitBreaker.failureThreshold;\n\n      server.use(\n        http.get(`${API_BASE_URL}/ping`, () => {\n          return HttpResponse.json({ message: 'Server error' }, { status: 500 });\n        })\n      );\n\n      // Create multiple failed requests to trip circuit breaker\n      // Note: Each request will retry 3 times (maxAttempts), so we need fewer actual requests\n      // Each ping() call with 500 error will attempt 3 times before failing\n      const results = [];\n      const requestsNeeded = Math.ceil(failureThreshold / DEFAULT_CONFIG.retry.maxAttempts) + 1;\n\n      // Limit to maximum 3 requests to prevent hanging\n      const maxRequests = Math.min(requestsNeeded, 3);\n\n      for (let i = 0; i < maxRequests; i++) {\n        const result = await healthService.ping();\n        results.push(result);\n      }\n\n      // All results should be errors\n      expect(results.length).toBeGreaterThan(0);\n      results.forEach(result => {\n        expect(result.isErr()).toBe(true);\n      });\n    }, 10000); // Reduced timeout to 10 seconds\n\n    test('should reset circuit after manual reset', async () => {\n      // This test verifies the resetApiClientCircuitBreaker function exists\n      // and can be called without error (it's tested implicitly in beforeEach)\n      expect(() => {\n        resetApiClientCircuitBreaker();\n      }).not.toThrow();\n    });\n  });\n\n  describe('timeout handling', () => {\n    test('should timeout long-running requests', async () => {\n      const customClient = createHttpClient({\n        timeout: 100, // 100ms timeout\n      });\n\n      // This would require a way to use custom client with services\n      // For now, we verify the configuration is correct\n      expect(DEFAULT_CONFIG.timeout).toBe(30000);\n    });\n  });\n\n  describe('header injection', () => {\n    test('should inject Authorization header when token present', async () => {\n      localStorage.setItem('auth_token', JSON.stringify({ token: 'test-token-123' }));\n\n      // Make any authenticated request\n      const result = await tenantService.getAll();\n\n      // Request should include Authorization header\n      // MSW handlers verify this automatically\n      expect(result.isOk() || result.isErr()).toBe(true);\n    });\n\n    test('should inject X-Tenant-ID header when tenant present', async () => {\n      localStorage.setItem('auth_token', JSON.stringify({ token: 'test-token' }));\n      localStorage.setItem('tenant', JSON.stringify({ id: 'tenant123', name: 'Test' }));\n\n      // Make any request that requires tenant context\n      const result = await addressBookService.getAll();\n\n      // Request should include X-Tenant-ID header\n      expect(result.isOk() || result.isErr()).toBe(true);\n    });\n\n    test('should handle requests without authentication', async () => {\n      // Clear all auth data\n      localStorage.clear();\n\n      // Make request to public endpoint\n      const result = await healthService.ping();\n\n      // Should succeed without auth headers\n      expect(result.isOk()).toBe(true);\n    });\n  });\n});\n\n// ============================================\n// Edge Cases and Error Scenarios\n// ============================================\n\ndescribe('edge cases', () => {\n  test('should handle empty response body', async () => {\n    server.use(\n      http.get(`${API_BASE_URL}/ping`, () => {\n        return new Response('', {\n          status: 200,\n          headers: { 'Content-Type': 'application/json' },\n        });\n      })\n    );\n\n    const result = await healthService.ping();\n\n    expect(result.isErr()).toBe(true);\n  });\n\n  test('should handle non-JSON content type', async () => {\n    server.use(\n      http.get(`${API_BASE_URL}/ping`, () => {\n        return new Response('<html>Error</html>', {\n          status: 500,\n          headers: { 'Content-Type': 'text/html' },\n        });\n      })\n    );\n\n    const result = await healthService.ping();\n\n    expect(result.isErr()).toBe(true);\n\n    if (result.isErr()) {\n      const error = result.error;\n      expect(error.message).toContain('JSON');\n    }\n  });\n\n  test('should handle network offline scenario', async () => {\n    // Simulate network error by rejecting with network error\n    server.use(\n      http.get(`${API_BASE_URL}/ping`, () => {\n        return HttpResponse.error();\n      })\n    );\n\n    const result = await healthService.ping();\n\n    expect(result.isErr()).toBe(true);\n\n    if (result.isErr()) {\n      const error = result.error;\n      expect(error.type).toBe('network');\n    }\n  });\n\n  test('should handle concurrent requests safely', async () => {\n    // Make multiple concurrent requests\n    const promises = [healthService.ping(), healthService.check(), tenantService.getAll()];\n\n    const results = await Promise.all(promises);\n\n    // All should complete without errors\n    results.forEach((result: any) => {\n      expect(result.isOk() || result.isErr()).toBe(true);\n    });\n  });\n\n  test('should handle localStorage quota exceeded', () => {\n    // This is tricky to test, but we can verify error handling exists\n    const veryLargeData = 'x'.repeat(10 * 1024 * 1024); // 10MB\n\n    try {\n      localStorage.setItem('large_data', veryLargeData);\n    } catch (error) {\n      // QuotaExceededError expected\n      expect(error).toBeDefined();\n    }\n  });\n\n  test('should handle malformed localStorage data', () => {\n    // Set invalid JSON in localStorage\n    localStorage.setItem('auth_token', 'not-valid-json{');\n\n    // Services should handle this gracefully\n    const result = tenantService.getAll();\n\n    expect(result).toBeDefined();\n  });\n});\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/services/api.ts",
        "messages": [
            {
                "ruleId": "@typescript-eslint/no-deprecated",
                "severity": 1,
                "message": "`format` is deprecated. Use the `z.treeifyError(err)` function instead.",
                "line": 329,
                "column": 44,
                "nodeType": "Identifier",
                "messageId": "deprecatedWithReason",
                "endLine": 329,
                "endColumn": 50
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, the types have no overlap.",
                "line": 517,
                "column": 9,
                "nodeType": "BinaryExpression",
                "messageId": "noOverlapBooleanExpression",
                "endLine": 517,
                "endColumn": 22
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, the types have no overlap.",
                "line": 536,
                "column": 9,
                "nodeType": "BinaryExpression",
                "messageId": "noOverlapBooleanExpression",
                "endLine": 536,
                "endColumn": 22
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.",
                "line": 585,
                "column": 9,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorNullableNumber",
                "endLine": 585,
                "endColumn": 25,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                16656,
                                16672
                            ],
                            "text": "(error.statusCode != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultZero",
                        "fix": {
                            "range": [
                                16656,
                                16672
                            ],
                            "text": "(error.statusCode ?? 0)"
                        },
                        "desc": "Explicitly treat nullish value the same as 0 (`value ?? 0`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                16656,
                                16672
                            ],
                            "text": "(Boolean(error.statusCode))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 628,
                "column": 10,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 628,
                "endColumn": 18,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                17989,
                                17998
                            ],
                            "text": "tenantId == null"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                17990,
                                17998
                            ],
                            "text": "(tenantId ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                17989,
                                17998
                            ],
                            "text": "!Boolean(tenantId)"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 640,
                "column": 10,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 640,
                "endColumn": 19,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                18285,
                                18295
                            ],
                            "text": "authToken == null"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                18286,
                                18295
                            ],
                            "text": "(authToken ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                18285,
                                18295
                            ],
                            "text": "!Boolean(authToken)"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected any value in conditional. An explicit comparison or type conversion is required.",
                "line": 731,
                "column": 13,
                "nodeType": "Identifier",
                "messageId": "conditionErrorAny",
                "endLine": 731,
                "endColumn": 17,
                "suggestions": [
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                21090,
                                21094
                            ],
                            "text": "(Boolean(data))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected any value in conditional. An explicit comparison or type conversion is required.",
                "line": 738,
                "column": 13,
                "nodeType": "Identifier",
                "messageId": "conditionErrorAny",
                "endLine": 738,
                "endColumn": 17,
                "suggestions": [
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                21300,
                                21304
                            ],
                            "text": "(Boolean(data))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 798,
                "column": 31,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 798,
                "endColumn": 33,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                22956,
                                22958
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 846,
                "column": 10,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 846,
                "endColumn": 19,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                24456,
                                24466
                            ],
                            "text": "authToken == null"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                24457,
                                24466
                            ],
                            "text": "(authToken ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                24456,
                                24466
                            ],
                            "text": "!Boolean(authToken)"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-deprecated",
                "severity": 1,
                "message": "`format` is deprecated. Use the `z.treeifyError(err)` function instead.",
                "line": 1042,
                "column": 40,
                "nodeType": "Identifier",
                "messageId": "deprecatedWithReason",
                "endLine": 1042,
                "endColumn": 46
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.",
                "line": 1167,
                "column": 9,
                "nodeType": "ChainExpression",
                "messageId": "conditionErrorNullableNumber",
                "endLine": 1167,
                "endColumn": 21,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                33683,
                                33695
                            ],
                            "text": "(params?.page) != null"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultZero",
                        "fix": {
                            "range": [
                                33683,
                                33695
                            ],
                            "text": "(params?.page) ?? 0"
                        },
                        "desc": "Explicitly treat nullish value the same as 0 (`value ?? 0`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                33683,
                                33695
                            ],
                            "text": "Boolean((params?.page))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.",
                "line": 1168,
                "column": 9,
                "nodeType": "ChainExpression",
                "messageId": "conditionErrorNullableNumber",
                "endLine": 1168,
                "endColumn": 22,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                33754,
                                33767
                            ],
                            "text": "(params?.limit) != null"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultZero",
                        "fix": {
                            "range": [
                                33754,
                                33767
                            ],
                            "text": "(params?.limit) ?? 0"
                        },
                        "desc": "Explicitly treat nullish value the same as 0 (`value ?? 0`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                33754,
                                33767
                            ],
                            "text": "Boolean((params?.limit))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 13,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "/**\n * @module services/api\n * @description HTTP Client and API Services for Multi-Tenant REST API\n *\n * This module provides a robust HTTP client with the following features:\n * - Automatic JWT token authentication\n * - Tenant context injection (X-Tenant-ID header)\n * - Railway-oriented programming with Result types\n * - Automatic retry with exponential backoff\n * - Circuit breaker pattern for fault tolerance\n * - Request/response validation with Zod schemas\n *\n * All API methods return AsyncResult<T, E> for type-safe error handling\n * without throwing exceptions.\n *\n * @example\n * ```typescript\n * // Login example\n * const result = await authService.login({\n *   usernameOrEmail: 'user@example.com',\n *   password: 'password123',\n *   tenantId: 'tenant1'\n * });\n *\n * result.match(\n *   (auth) => console.log('Logged in:', auth.user),\n *   (error) => console.error('Login failed:', error.message)\n * );\n * ```\n */\n\nimport qs from 'qs';\nimport { ResultAsync, err, errAsync, ok, okAsync } from 'neverthrow';\nimport { z } from 'zod';\nimport type { ZodType } from 'zod';\nimport { getEnv } from '../config/env';\nimport { paginatedTenantResponseSchema, tenantSchema } from '../validation/schemas';\nimport type { AuthResponse, LoginCredentials, User, Tenant as AuthTenant } from '../types/auth';\nimport type { ContactListResponse, Contact } from '../types/contact';\nimport type { Gender as PersonGender } from '../types/person';\nimport type {\n  CreateTenantDTO,\n  PaginatedTenantResponse,\n  UpdateTenantDTO,\n  Tenant,\n} from '../types/tenant';\nimport type { ApiResponse } from '../types/api';\nimport { createErrorResponse, createSuccessResponse } from '../types/api';\nimport type { AppError, AuthError, BusinessLogicError } from '../types/errors';\nimport {\n  createAuthError,\n  createBusinessLogicError,\n  createNetworkError,\n  createValidationError,\n} from '../types/errors';\nimport type { AsyncResult, Result } from '../types/fp';\nimport { authResponseSchema, loginRequestSchema } from '../validation';\nimport { liftResult, validateAndDecode } from '../validation';\nimport type { AuthResponseSchema, LoginRequestSchema } from '../validation';\nimport { contactListFromApiResponse, mapContact } from '../transformers';\nimport { decodeJwtPayload } from '../utils/parsing';\nimport { asUserId, asTenantId } from '../types/ids';\n\n/**\n * Retry configuration for failed HTTP requests\n */\nexport interface RetryConfig {\n  /** Maximum number of retry attempts */\n  maxAttempts: number;\n  /** Base delay in milliseconds before first retry */\n  baseDelay: number;\n  /** Maximum delay in milliseconds between retries */\n  maxDelay: number;\n}\n\n/**\n * HTTP client configuration with timeout, retry, and circuit breaker settings\n */\nexport interface HttpClientConfig {\n  /** Request timeout in milliseconds */\n  timeout: number;\n  /** Retry configuration for failed requests */\n  retry: RetryConfig;\n  /** Circuit breaker configuration for fault tolerance */\n  circuitBreaker: {\n    /** Number of failures before opening the circuit */\n    failureThreshold: number;\n    /** Time in milliseconds before attempting to close the circuit */\n    resetTimeout: number;\n  };\n}\n\n/**\n * Circuit breaker state for tracking request failures\n */\nexport interface CircuitBreakerState {\n  /** Current state of the circuit breaker */\n  state: 'closed' | 'open' | 'half-open';\n  /** Number of consecutive failures */\n  failureCount: number;\n  /** Timestamp of the last failure */\n  lastFailureTime: number;\n}\n\n/**\n * HTTP client interface for making REST API requests\n * All methods return AsyncResult for railway-oriented programming\n */\nexport interface IHttpClient {\n  /** Execute GET request */\n  get<T>(endpoint: string): AsyncResult<ApiResponse<T>, AppError>;\n  /** Execute POST request with optional body */\n  post<T>(endpoint: string, data?: unknown): AsyncResult<ApiResponse<T>, AppError>;\n  /** Execute PUT request with optional body */\n  put<T>(endpoint: string, data?: unknown): AsyncResult<ApiResponse<T>, AppError>;\n  /** Execute DELETE request */\n  delete<T>(endpoint: string): AsyncResult<ApiResponse<T>, AppError>;\n  /** Safely get authentication token from localStorage */\n  safeGetToken(): string | null;\n}\n\nconst API_BASE_URL = getEnv().apiUrl;\n\n/**\n * Default HTTP client configuration\n * - 30 second timeout\n * - 3 retry attempts with exponential backoff\n * - Circuit breaker opens after 5 failures for 1 minute\n */\nconst DEFAULT_CONFIG: HttpClientConfig = {\n  timeout: 30000, // 30 seconds\n  retry: {\n    maxAttempts: 3,\n    baseDelay: 1000, // 1 second\n    maxDelay: 10000, // 10 seconds\n  },\n  circuitBreaker: {\n    failureThreshold: 5,\n    resetTimeout: 60000, // 1 minute\n  },\n};\n\n/**\n * Functional composition utility for building request pipeline\n * Applies a series of transformation functions from left to right\n *\n * @param value - Initial value\n * @param fns - Transformation functions to apply in sequence\n * @returns Final transformed value\n *\n * @example\n * ```typescript\n * const result = pipe(\n *   initialRequest,\n *   addHeaders,\n *   addAuth,\n *   addTenantId\n * );\n * ```\n */\nfunction pipe<T>(value: T): T;\nfunction pipe<T, A>(value: T, fn1: (input: T) => A): A;\nfunction pipe<T, A, B>(value: T, fn1: (input: T) => A, fn2: (input: A) => B): B;\nfunction pipe<T, A, B, C>(\n  value: T,\n  fn1: (input: T) => A,\n  fn2: (input: A) => B,\n  fn3: (input: B) => C\n): C;\nfunction pipe<T, A, B, C, D>(\n  value: T,\n  fn1: (input: T) => A,\n  fn2: (input: A) => B,\n  fn3: (input: B) => C,\n  fn4: (input: C) => D\n): D;\nfunction pipe(value: unknown, ...fns: ((input: unknown) => unknown)[]): unknown {\n  return fns.reduce((accumulator, fn) => fn(accumulator), value);\n}\n\n/**\n * Maps HTTP error responses to typed AppError instances\n * Determines error type based on HTTP status code\n *\n * @param response - HTTP response object\n * @param body - Parsed response body\n * @returns Typed AppError (AuthError, ValidationError, NetworkError, or BusinessLogicError)\n *\n * @internal\n */\nconst mapHttpError = (response: Response, body: Record<string, unknown>): AppError => {\n  const message = typeof body.message === 'string' ? body.message : response.statusText;\n  const code = typeof body.code === 'string' ? body.code : undefined;\n  const details =\n    typeof body.details === 'object' && body.details !== null\n      ? (body.details as Record<string, unknown>)\n      : undefined;\n\n  if (response.status === 401 || response.status === 403) {\n    return createAuthError(message || 'Authentication error', details, {\n      code,\n      statusCode: response.status,\n    });\n  }\n\n  if (response.status === 400 || response.status === 422) {\n    return createValidationError(message || 'Validation error', details, {\n      code,\n      statusCode: response.status,\n    });\n  }\n\n  if (response.status >= 500) {\n    return createNetworkError(message || 'Server error', details, {\n      code,\n      statusCode: response.status,\n      retryable: true,\n    });\n  }\n\n  return createBusinessLogicError(message || 'Request failed', details, {\n    code,\n    statusCode: response.status,\n  });\n};\n\nconst apiResultFromResponse = <T>(response: Response): ResultAsync<ApiResponse<T>, AppError> => {\n  const contentType = response.headers.get('content-type') ?? '';\n\n  if (!contentType.includes('application/json')) {\n    return errAsync(\n      createBusinessLogicError(\n        'Expected JSON response from server',\n        { contentType },\n        {\n          code: 'INVALID_CONTENT_TYPE',\n          statusCode: response.status,\n        }\n      )\n    );\n  }\n\n  return ResultAsync.fromPromise(\n    response.clone().json() as Promise<Record<string, unknown>>,\n    (error: unknown) =>\n      createBusinessLogicError(\n        'Failed to parse response body',\n        {\n          rawError: error instanceof Error ? { message: error.message } : undefined,\n        },\n        {\n          code: 'JSON_PARSE_ERROR',\n          statusCode: response.status,\n        }\n      )\n  ).andThen(body => {\n    const message = typeof body.message === 'string' ? body.message : undefined;\n    const status = typeof body.status === 'string' ? body.status : undefined;\n\n    // Extracted helper for determining success\n    function isSuccess(\n      response: Response,\n      body: Record<string, unknown>,\n      status?: string\n    ): boolean {\n      if (status === 'success') return true;\n      if ('success' in body) {\n        if (typeof body.success === 'boolean') return body.success;\n        return response.ok;\n      }\n      return response.ok;\n    }\n\n    const success = isSuccess(response, body, status);\n\n    if (response.ok && success) {\n      const data = (body.data ?? body) as T;\n      return okAsync(createSuccessResponse<T>(data, message));\n    }\n\n    if (response.ok && !success) {\n      const error = createBusinessLogicError(\n        message ?? 'Request failed',\n        body.error != null && typeof body.error === 'object'\n          ? (body.error as Record<string, unknown>)\n          : undefined,\n        {\n          statusCode: response.status,\n        }\n      );\n      return okAsync(createErrorResponse(error, message));\n    }\n\n    const error = mapHttpError(response, body);\n    return errAsync(error);\n  });\n};\n\nconst retryWithBackoff = <T>(\n  operation: () => ResultAsync<T, AppError>,\n  config: RetryConfig,\n  shouldRetry: (error: AppError, attempt: number) => boolean,\n  scheduleDelay: (attempt: number) => ResultAsync<void, AppError>\n): ResultAsync<T, AppError> => {\n  const attemptOperation = (attempt: number): ResultAsync<T, AppError> =>\n    operation().orElse(error =>\n      shouldRetry(error, attempt)\n        ? scheduleDelay(attempt).andThen(() => attemptOperation(attempt + 1))\n        : errAsync(error)\n    );\n\n  return attemptOperation(1);\n};\n\n/**\n * Validates tenant API responses using Zod schemas\n */\nconst validateTenantResponse = <T>(data: unknown, schema: ZodType<T>): ResultAsync<T, AppError> => {\n  const validation = schema.safeParse(data);\n\n  if (validation.success) {\n    return okAsync(validation.data);\n  }\n\n  return errAsync(\n    createBusinessLogicError(\n      'Invalid tenant response format',\n      {\n        validationErrors: validation.error.format(),\n        receivedData: data,\n      },\n      {\n        code: 'VALIDATION_ERROR',\n      }\n    )\n  );\n};\n\nconst handleSuccessResponse = <Raw, Parsed>(\n  result: AsyncResult<ApiResponse<Raw>, AppError>,\n  schema: ZodType<Parsed>\n): AsyncResult<Parsed, AppError> =>\n  result.andThen(response => {\n    if (response.status === 'error') {\n      return errAsync(response.error);\n    }\n\n    return liftResult(validateAndDecode<Parsed>(schema, response.data)).mapErr(\n      validationError => validationError as AppError\n    );\n  });\n\nconst toAuthResponse = (payload: AuthResponseSchema): AuthResponse => {\n  // Decode JWT to get user info\n  const jwtResult = decodeJwtPayload(payload.access_token);\n\n  if (jwtResult.isErr()) {\n    throw new Error('Invalid JWT token received from server');\n  }\n\n  const jwtPayload = jwtResult.value;\n\n  // Create user object from JWT\n  const user: User = {\n    id: asUserId(jwtPayload.user),\n    email: jwtPayload.user,\n    username: jwtPayload.user,\n    roles: ['user'],\n    tenantId: asTenantId(jwtPayload.tenant_id),\n    createdAt: new Date().toISOString(),\n    updatedAt: new Date().toISOString(),\n  };\n\n  // Default tenant settings\n  const defaultSettings = {\n    theme: 'light' as const,\n    language: 'en',\n    timezone: 'UTC',\n    dateFormat: 'YYYY-MM-DD',\n    features: [],\n    branding: {\n      primaryColor: '#000000',\n      secondaryColor: '#ffffff',\n      accentColor: '#000000',\n    },\n  };\n\n  // Default tenant subscription\n  const defaultSubscription = {\n    plan: 'basic' as const,\n    status: 'active' as const,\n    limits: {\n      users: 0,\n      contacts: 0,\n      storage: 0,\n    },\n  };\n\n  // Create tenant object for auth (from auth.ts type)\n  const tenant: AuthTenant = {\n    id: asTenantId(jwtPayload.tenant_id),\n    name: jwtPayload.tenant_id,\n    settings: defaultSettings,\n    subscription: defaultSubscription,\n  };\n\n  // Calculate expires in seconds\n  const expiresIn = jwtPayload.exp - Math.floor(Date.now() / 1000);\n\n  return {\n    success: true,\n    token: payload.access_token,\n    refreshToken: payload.refresh_token,\n    user,\n    tenant,\n    expiresIn,\n  };\n};\n\nconst transformApiResponse = <Raw, Domain>(\n  result: AsyncResult<ApiResponse<Raw>, AppError>,\n  transform: (value: Raw) => Result<Domain, AppError>\n): AsyncResult<ApiResponse<Domain>, AppError> =>\n  result.andThen(response => {\n    if (response.status === 'error') {\n      return okAsync(createErrorResponse(response.error, response.message));\n    }\n\n    return liftResult(transform(response.data)).map(domainData =>\n      createSuccessResponse(domainData, response.message)\n    );\n  });\n\nconst toAuthError = (error: AppError): AuthError => {\n  if (error.type === 'auth') {\n    return error;\n  }\n\n  return createAuthError(\n    error.message,\n    {\n      originalType: error.type,\n      originalDetails: error.details,\n    },\n    {\n      code: error.code,\n      cause: error,\n      statusCode: error.statusCode,\n    }\n  );\n};\n\nconst _toBusinessError = (error: AppError): BusinessLogicError => {\n  if (error.type === 'business') {\n    return error;\n  }\n\n  return createBusinessLogicError(\n    error.message,\n    {\n      originalType: error.type,\n      originalDetails: error.details,\n    },\n    {\n      code: error.code,\n      cause: error,\n      statusCode: error.statusCode,\n    }\n  );\n};\n\nconst emptyObjectSchema = z.object({}).strict();\n\n/**\n * HTTP Client class with timeout, retry, and circuit breaker support\n */\nclass HttpClient implements IHttpClient {\n  private readonly baseURL: string;\n  private readonly config: HttpClientConfig;\n  private readonly circuitBreakerState: CircuitBreakerState;\n\n  constructor(baseURL: string = API_BASE_URL, config: Partial<HttpClientConfig> = {}) {\n    this.baseURL = baseURL;\n    this.config = { ...DEFAULT_CONFIG, ...config };\n    this.circuitBreakerState = {\n      state: 'closed',\n      failureCount: 0,\n      lastFailureTime: 0,\n    };\n  }\n\n  /**\n   * Resets the circuit breaker state to closed\n   * Useful for testing or manual recovery\n   *\n   * @internal Use with caution - primarily for testing\n   */\n  public resetCircuitBreaker(): void {\n    this.circuitBreakerState.state = 'closed';\n    this.circuitBreakerState.failureCount = 0;\n    this.circuitBreakerState.lastFailureTime = 0;\n  }\n\n  /**\n   * Storage format convention:\n   * - 'auth_token': JSON object {token: string}\n   * - 'tenant': JSON object {id: string, name: string, ...}\n   * - 'user': JSON object {id: string, email: string, ...}\n   */\n  public safeGetToken(): string | null {\n    const stored = localStorage.getItem('auth_token');\n    if (stored == null || stored === '') return null;\n    try {\n      const data = JSON.parse(stored) as Record<string, unknown>;\n      if (\n        typeof data === 'object' &&\n        data !== null &&\n        'token' in data &&\n        typeof data.token === 'string'\n      ) {\n        return data.token;\n      }\n    } catch {\n      // Ignore parsing errors\n    }\n    return null;\n  }\n\n  private safeGetTenantId(): string | null {\n    const stored = localStorage.getItem('tenant');\n    if (stored == null || stored === '') return null;\n    try {\n      const data = JSON.parse(stored) as Record<string, unknown>;\n      if (\n        typeof data === 'object' &&\n        data !== null &&\n        'id' in data &&\n        typeof data.id === 'string'\n      ) {\n        return data.id;\n      }\n    } catch {\n      // Ignore parsing errors\n    }\n    return null;\n  }\n\n  private sleep(delay: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, delay));\n  }\n\n  private calculateBackoffDelay(attempt: number): number {\n    const delay = this.config.retry.baseDelay * Math.pow(2, attempt - 1);\n    return Math.min(delay, this.config.retry.maxDelay);\n  }\n\n  private evaluateCircuitBreaker(): Result<void, AppError> {\n    if (this.circuitBreakerState.state === 'open') {\n      const elapsed = Date.now() - this.circuitBreakerState.lastFailureTime;\n\n      if (elapsed < this.config.circuitBreaker.resetTimeout) {\n        return err(\n          createNetworkError('Service is temporarily unavailable', undefined, {\n            code: 'CIRCUIT_BREAKER_OPEN',\n            retryable: true,\n          })\n        );\n      }\n\n      this.circuitBreakerState.state = 'half-open';\n    }\n\n    return ok(undefined);\n  }\n\n  private isRetryableError(error: AppError): boolean {\n    if (typeof error.retryable === 'boolean') {\n      return error.retryable;\n    }\n\n    if (error.type === 'network') {\n      return true;\n    }\n\n    if (error.statusCode && error.statusCode >= 500) {\n      return true;\n    }\n\n    return false;\n  }\n\n  private updateCircuitBreaker(success: boolean): void {\n    if (success) {\n      this.circuitBreakerState.failureCount = 0;\n      this.circuitBreakerState.state = 'closed';\n      return;\n    }\n\n    if (this.circuitBreakerState.state === 'half-open') {\n      this.circuitBreakerState.state = 'open';\n    } else {\n      this.circuitBreakerState.failureCount += 1;\n      this.circuitBreakerState.lastFailureTime = Date.now();\n\n      if (this.circuitBreakerState.failureCount >= this.config.circuitBreaker.failureThreshold) {\n        this.circuitBreakerState.state = 'open';\n      }\n    }\n  }\n\n  private updateCircuitBreakerWithResult<T>(result: ApiResponse<T>): void {\n    this.updateCircuitBreaker(result.status === 'success');\n  }\n\n  private buildRequestInit(options: RequestInit): RequestInit {\n    return pipe(options, this.withBaseHeaders, this.withTenantHeader, this.withAuthHeader);\n  }\n\n  private withBaseHeaders = (options: RequestInit): RequestInit => {\n    const headers = new Headers(options.headers ?? {});\n    headers.set('Content-Type', 'application/json');\n    return { ...options, headers };\n  };\n\n  private withTenantHeader = (options: RequestInit): RequestInit => {\n    const tenantId = this.safeGetTenantId();\n\n    if (!tenantId) {\n      return options;\n    }\n\n    const headers = new Headers(options.headers);\n    headers.set('X-Tenant-ID', tenantId);\n    return { ...options, headers };\n  };\n\n  private withAuthHeader = (options: RequestInit): RequestInit => {\n    const authToken = this.safeGetToken();\n\n    if (!authToken) {\n      return options;\n    }\n\n    const headers = new Headers(options.headers);\n    headers.set('Authorization', `Bearer ${authToken}`);\n    return { ...options, headers };\n  };\n\n  private executeFetch(url: string, options: RequestInit): ResultAsync<Response, AppError> {\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => {\n      controller.abort();\n    }, this.config.timeout);\n\n    return ResultAsync.fromPromise(\n      fetch(url, { ...options, signal: controller.signal }),\n      (error: unknown) => this.createFetchError(error)\n    )\n      .map(response => {\n        clearTimeout(timeoutId);\n        return response;\n      })\n      .mapErr(error => {\n        clearTimeout(timeoutId);\n        return error;\n      });\n  }\n\n  private createFetchError(error: unknown): AppError {\n    const isAbortError = error instanceof DOMException && error.name === 'AbortError';\n    const message = isAbortError\n      ? 'Request timed out'\n      : 'Network error: Unable to reach the server';\n\n    return createNetworkError(message, undefined, {\n      code: isAbortError ? 'TIMEOUT' : 'NETWORK_ERROR',\n      retryable: true,\n      cause: error,\n    });\n  }\n\n  private scheduleDelay(attempt: number): ResultAsync<void, AppError> {\n    const delay = this.calculateBackoffDelay(attempt);\n    return ResultAsync.fromPromise(this.sleep(delay), () =>\n      createNetworkError('Failed to schedule retry delay', undefined, {\n        code: 'RETRY_DELAY_FAILURE',\n        retryable: true,\n      })\n    );\n  }\n\n  private request<T>(\n    endpoint: string,\n    options: RequestInit = {}\n  ): AsyncResult<ApiResponse<T>, AppError> {\n    const circuitResult = this.evaluateCircuitBreaker();\n    if (circuitResult.isErr()) {\n      return errAsync(circuitResult.error);\n    }\n\n    const url = `${this.baseURL}${endpoint}`;\n    const requestInit = this.buildRequestInit(options);\n\n    const operation = (): ResultAsync<ApiResponse<T>, AppError> =>\n      this.executeFetch(url, requestInit).andThen(response => apiResultFromResponse<T>(response));\n\n    return retryWithBackoff(\n      operation,\n      this.config.retry,\n      (error, attempt) => this.isRetryableError(error) && attempt < this.config.retry.maxAttempts,\n      attempt => this.scheduleDelay(attempt)\n    )\n      .map(result => {\n        this.updateCircuitBreakerWithResult(result);\n        return result;\n      })\n      .mapErr(error => {\n        this.updateCircuitBreaker(false);\n        return error;\n      });\n  }\n\n  // HTTP methods\n  get<T>(endpoint: string): AsyncResult<ApiResponse<T>, AppError> {\n    return this.request<T>(endpoint, { method: 'GET' });\n  }\n\n  post<T>(endpoint: string, data?: unknown): AsyncResult<ApiResponse<T>, AppError> {\n    return this.request<T>(endpoint, {\n      method: 'POST',\n      body: data ? JSON.stringify(data) : undefined,\n    });\n  }\n\n  put<T>(endpoint: string, data?: unknown): AsyncResult<ApiResponse<T>, AppError> {\n    return this.request<T>(endpoint, {\n      method: 'PUT',\n      body: data ? JSON.stringify(data) : undefined,\n    });\n  }\n\n  delete<T>(endpoint: string): AsyncResult<ApiResponse<T>, AppError> {\n    return this.request<T>(endpoint, { method: 'DELETE' });\n  }\n}\n\n/**\n * Shared HTTP client instance for all API requests\n * Includes automatic authentication, tenant context, and fault tolerance\n */\nconst apiClient: IHttpClient = new HttpClient();\n\n/**\n * Authentication Service\n *\n * Provides methods for user authentication with automatic JWT handling\n * and tenant context management.\n *\n * @example\n * ```typescript\n * // Login with credentials\n * const result = await authService.login({\n *   usernameOrEmail: 'user@example.com',\n *   password: 'securePassword123',\n *   tenantId: 'tenant1',\n *   rememberMe: true\n * });\n *\n * result.match(\n *   (auth) => {\n *     // Success: auth.token, auth.user, auth.tenant\n *     localStorage.setItem('auth_token', JSON.stringify({ token: auth.token }));\n *   },\n *   (error) => {\n *     // Error: display error.message\n *     console.error(error.message);\n *   }\n * );\n * ```\n */\nexport const authService = {\n  /**\n   * Authenticates user with provided credentials\n   *\n   * @param credentials - User login credentials (username/email, password, tenantId)\n   * @returns AsyncResult resolving to AuthResponse with JWT token and user/tenant data\n   *\n   * @example\n   * ```typescript\n   * const auth = await authService.login({\n   *   usernameOrEmail: 'user@example.com',\n   *   password: 'password123',\n   *   tenantId: 'tenant1'\n   * });\n   * ```\n   */\n  login(credentials: LoginCredentials, client?: IHttpClient): AsyncResult<AuthResponse, AuthError> {\n    const httpClient = client || apiClient;\n\n    const validation = validateAndDecode<LoginRequestSchema>(loginRequestSchema, {\n      usernameOrEmail: credentials.usernameOrEmail,\n      password: credentials.password,\n      tenantId: credentials.tenantId,\n      rememberMe: credentials.rememberMe,\n    });\n\n    return liftResult(validation)\n      .map(validated => ({\n        username_or_email: validated.usernameOrEmail,\n        password: validated.password,\n        tenant_id: validated.tenantId,\n      }))\n      .andThen(body =>\n        handleSuccessResponse<AuthResponse, AuthResponseSchema>(\n          httpClient.post<AuthResponse>('/auth/login', body),\n          authResponseSchema\n        )\n      )\n      .map(toAuthResponse)\n      .mapErr(toAuthError);\n  },\n\n  /**\n   * Logs out the current user and invalidates the session\n   * This operation is idempotent - succeeds even if not authenticated\n   *\n   * @returns AsyncResult<void, AuthError> - Success with no data, or auth error\n   *\n   * @example\n   * ```typescript\n   * const result = await authService.logout();\n   * result.match(\n   *   () => {\n   *     localStorage.removeItem('auth_token');\n   *     navigate('/login');\n   *   },\n   *   (error) => console.error('Logout failed:', error)\n   * );\n   * ```\n   */\n  logout(): AsyncResult<void, AuthError> {\n    // Check if there's a valid authentication token using safe token validation\n    const authToken = apiClient.safeGetToken();\n\n    // If no valid token exists, logout is already complete (idempotent)\n    if (!authToken) {\n      return okAsync(undefined);\n    }\n\n    return handleSuccessResponse(\n      apiClient.post<Record<string, unknown>>('/auth/logout'),\n      emptyObjectSchema\n    )\n      .map(() => undefined)\n      .mapErr(toAuthError);\n  },\n\n  /**\n   * Refreshes the current JWT token using the refresh token\n   *\n   * @returns AsyncResult<AuthResponse, AuthError> - New auth data with refreshed tokens\n   *\n   * @example\n   * ```typescript\n   * const result = await authService.refreshToken();\n   * result.match(\n   *   (auth) => localStorage.setItem('auth_token', JSON.stringify({ token: auth.token })),\n   *   (error) => {\n   *     // Token refresh failed, redirect to login\n   *     localStorage.clear();\n   *     navigate('/login');\n   *   }\n   * );\n   * ```\n   */\n  refreshToken(): AsyncResult<AuthResponse, AuthError> {\n    return handleSuccessResponse<AuthResponse, AuthResponseSchema>(\n      apiClient.post<AuthResponse>('/auth/refresh'),\n      authResponseSchema\n    )\n      .map(toAuthResponse)\n      .mapErr(toAuthError);\n  },\n};\n\n/**\n * Health Check Service\n *\n * Provides endpoints for checking API availability and health status\n */\nexport const healthService = {\n  /**\n   * Performs comprehensive health check of the API\n   * @returns API response with health status details\n   */\n  check(): AsyncResult<ApiResponse<Record<string, unknown>>, AppError> {\n    return apiClient.get<Record<string, unknown>>('/health');\n  },\n\n  /**\n   * Performs a simple ping to verify API availability\n   * @returns API response with ping status\n   */\n  ping(): AsyncResult<ApiResponse<Record<string, unknown>>, AppError> {\n    return apiClient.get<Record<string, unknown>>('/ping');\n  },\n};\n\n/**\n * Tenant Filter Interface\n *\n * Defines filtering parameters for tenant queries with pagination and cursor support\n */\nexport interface TenantFilter {\n  /** Array of filter conditions to apply */\n  filters: {\n    /** Field name to filter on */\n    field: string;\n    /** Comparison operator (eq, ne, gt, lt, like, etc.) */\n    operator: string;\n    /** Value to compare against */\n    value: string;\n  }[];\n  /** Cursor for pagination */\n  cursor?: number;\n  /** Number of results per page */\n  limit?: number;\n  /** Offset for pagination */\n  offset?: number;\n}\n\n/**\n * Tenant Management Service\n *\n * Provides CRUD operations for managing tenants in a multi-tenant system.\n * Requires admin privileges for all operations.\n *\n * @example\n * ```typescript\n * // Get all tenants with pagination\n * const result = await tenantService.getAllWithPagination({ offset: 0, limit: 20 });\n *\n * result.match(\n *   (response) => {\n *     if (response.status === 'success') {\n *       console.log('Tenants:', response.data.tenants);\n *       console.log('Total:', response.data.total);\n *     }\n *   },\n *   (error) => console.error(error)\n * );\n * ```\n */\nexport const tenantService = {\n  /**\n   * Retrieves all tenants (without pagination)\n   * @returns List of all tenants\n   */\n  getAll(): AsyncResult<ApiResponse<Tenant[]>, AppError> {\n    return apiClient.get<Tenant[]>('/admin/tenants');\n  },\n\n  /**\n   * Retrieves tenants with pagination support\n   *\n   * @param params - Pagination parameters (offset and limit)\n   * @returns Paginated tenant response with total count\n   *\n   * @example\n   * ```typescript\n   * const tenants = await tenantService.getAllWithPagination({ offset: 0, limit: 10 });\n   * ```\n   */\n  getAllWithPagination(params?: {\n    offset?: number;\n    limit?: number;\n  }): AsyncResult<ApiResponse<PaginatedTenantResponse>, AppError> {\n    const queryParams = new URLSearchParams();\n    if (params?.offset !== undefined) queryParams.set('offset', params.offset.toString());\n    if (params?.limit !== undefined) queryParams.set('limit', params.limit.toString());\n\n    const query = queryParams.toString();\n    return apiClient\n      .get<PaginatedTenantResponse>(query ? `/admin/tenants?${query}` : '/admin/tenants')\n      .andThen(response => {\n        if (response.status === 'success') {\n          return validateTenantResponse(response.data, paginatedTenantResponseSchema).map(\n            validatedData => createSuccessResponse(validatedData)\n          );\n        }\n        return okAsync(response);\n      });\n  },\n\n  /**\n   * Filters tenants by specified criteria\n   *\n   * @param params - Filter parameters (filters array, pagination options)\n   * @returns Filtered tenant response with pagination metadata\n   *\n   * @example\n   * ```typescript\n   * const active = await tenantService.filter({\n   *   filters: [{ field: 'status', operator: 'eq', value: 'active' }],\n   *   limit: 20\n   * });\n   * ```\n   */\n  filter(\n    params: TenantFilter\n  ): AsyncResult<ApiResponse<PaginatedTenantResponse | Tenant[]>, AppError> {\n    const queryObj: Record<string, unknown> = {\n      filters: params.filters,\n    };\n\n    if (params.cursor !== undefined) {\n      queryObj.cursor = params.cursor;\n    }\n    if (params.limit !== undefined) {\n      queryObj.page_size = params.limit;\n    }\n    if (params.offset !== undefined) {\n      queryObj.offset = params.offset;\n    }\n\n    const queryString = qs.stringify(queryObj, { arrayFormat: 'indices' });\n    return apiClient\n      .get<PaginatedTenantResponse | Tenant[]>(`/admin/tenants/filter?${queryString}`)\n      .andThen(response => {\n        if (response.status === 'success') {\n          // For filter results, we need to check if it's a paginated response or array\n          if (Array.isArray(response.data)) {\n            // Validate Tenant[] array\n            const arrSchema = z.array(tenantSchema);\n            const parsed = arrSchema.safeParse(response.data);\n            if (parsed.success) {\n              return okAsync(createSuccessResponse(parsed.data));\n            }\n            return okAsync(\n              createErrorResponse(\n                createBusinessLogicError('Invalid tenant array format', {\n                  errors: parsed.error.format(),\n                })\n              )\n            );\n          } else {\n            // It's a PaginatedTenantResponse, validate it\n            return validateTenantResponse(response.data, paginatedTenantResponseSchema).map(\n              validatedData => createSuccessResponse(validatedData)\n            );\n          }\n        }\n        return okAsync(response);\n      });\n  },\n\n  /**\n   * Retrieves a single tenant by ID\n   *\n   * @param id - Tenant ID\n   * @returns Tenant details\n   */\n  getById(id: string): AsyncResult<ApiResponse<Tenant>, AppError> {\n    return apiClient.get<Tenant>(`/admin/tenants/${id}`);\n  },\n\n  /**\n   * Creates a new tenant\n   *\n   * @param data - Tenant creation data (name, db_url, settings, etc.)\n   * @returns Newly created tenant\n   *\n   * @example\n   * ```typescript\n   * const tenant = await tenantService.create({\n   *   name: 'New Company',\n   *   db_url: 'postgresql://localhost/tenant_db'\n   * });\n   * ```\n   */\n  create(data: CreateTenantDTO): AsyncResult<ApiResponse<Tenant>, AppError> {\n    return apiClient.post<Tenant>('/admin/tenants', data);\n  },\n\n  /**\n   * Updates an existing tenant\n   *\n   * @param id - Tenant ID to update\n   * @param data - Updated tenant data\n   * @returns Updated tenant\n   */\n  update(id: string, data: UpdateTenantDTO): AsyncResult<ApiResponse<Tenant>, AppError> {\n    return apiClient.put<Tenant>(`/admin/tenants/${id}`, data);\n  },\n\n  /**\n   * Deletes a tenant\n   *\n   * @param id - Tenant ID to delete\n   * @returns Success confirmation\n   *\n   * @example\n   * ```typescript\n   * const result = await tenantService.delete('tenant-123');\n   * result.match(\n   *   () => console.log('Tenant deleted'),\n   *   (error) => console.error('Delete failed:', error)\n   * );\n   * ```\n   */\n  delete(id: string): AsyncResult<ApiResponse<Record<string, unknown>>, AppError> {\n    return apiClient.delete<Record<string, unknown>>(`/admin/tenants/${id}`);\n  },\n};\n\n/**\n * Address Book / Contact Management Service\n *\n * Provides CRUD operations for managing contacts within a tenant's address book.\n * All operations are automatically scoped to the current tenant via X-Tenant-ID header.\n *\n * @example\n * ```typescript\n * // Get contacts with search, pagination, and sorting\n * const result = await addressBookService.getAll({\n *   page: 1,\n *   limit: 20,\n *   search: 'john',\n *   sort: 'name,asc'\n * });\n *\n * result.match(\n *   (response) => {\n *     if (response.status === 'success') {\n *       console.log('Contacts:', response.data.contacts);\n *       console.log('Total:', response.data.total);\n *     }\n *   },\n *   (error) => console.error(error)\n * );\n * ```\n */\nexport const addressBookService = {\n  /**\n   * Retrieves all contacts with optional pagination, search, and sorting\n   *\n   * @param params - Query parameters (page, limit, search, sort)\n   * @returns Contact list response with pagination metadata\n   *\n   * @example\n   * ```typescript\n   * const contacts = await addressBookService.getAll({\n   *   page: 1,\n   *   limit: 10,\n   *   search: 'doe',\n   *   sort: 'name,asc'\n   * });\n   * ```\n   */\n  getAll(params?: {\n    page?: number;\n    limit?: number;\n    search?: string;\n    sort?: string;\n  }): AsyncResult<ApiResponse<ContactListResponse>, AppError> {\n    const queryParams = new URLSearchParams();\n    if (params?.page) queryParams.set('page', params.page.toString());\n    if (params?.limit) queryParams.set('limit', params.limit.toString());\n    if (params?.search != null && params.search !== '') queryParams.set('search', params.search);\n    if (params?.sort != null && params.sort !== '') queryParams.set('sort', params.sort);\n\n    const query = queryParams.toString();\n    return transformApiResponse(\n      apiClient.get<unknown>(query ? `/address-book?${query}` : '/address-book'),\n      contactListFromApiResponse\n    );\n  },\n\n  /**\n   * Creates a new contact in the address book\n   *\n   * @param data - Contact data (name, email, phone, address, age, gender)\n   * @returns Newly created contact\n   *\n   * @example\n   * ```typescript\n   * const contact = await addressBookService.create({\n   *   name: 'John Doe',\n   *   email: 'john@example.com',\n   *   phone: '+1234567890',\n   *   address: '123 Main St',\n   *   age: 30,\n   *   gender: true // true = male, false = female\n   * });\n   * ```\n   */\n  create(data: {\n    name: string;\n    email: string;\n    gender?: PersonGender;\n    age: number;\n    address: string;\n    phone: string;\n  }): AsyncResult<ApiResponse<Contact>, AppError> {\n    return transformApiResponse(apiClient.post<unknown>('/address-book', data), mapContact.fromApi);\n  },\n\n  /**\n   * Updates an existing contact\n   *\n   * @param id - Contact ID to update\n   * @param data - Updated contact data\n   * @returns Updated contact\n   *\n   * @example\n   * ```typescript\n   * const updated = await addressBookService.update('contact-123', {\n   *   name: 'Jane Doe',\n   *   email: 'jane@example.com',\n   *   phone: '+1234567890',\n   *   address: '456 Oak Ave',\n   *   age: 28\n   * });\n   * ```\n   */\n  update(\n    id: string,\n    data: {\n      name: string;\n      email: string;\n      gender?: PersonGender;\n      age: number;\n      address: string;\n      phone: string;\n    }\n  ): AsyncResult<ApiResponse<Contact>, AppError> {\n    return transformApiResponse(\n      apiClient.put<unknown>(`/address-book/${id}`, data),\n      mapContact.fromApi\n    );\n  },\n\n  /**\n   * Deletes a contact from the address book\n   *\n   * @param id - Contact ID to delete\n   * @returns Success confirmation\n   *\n   * @example\n   * ```typescript\n   * const result = await addressBookService.delete('contact-123');\n   * result.match(\n   *   () => console.log('Contact deleted successfully'),\n   *   (error) => console.error('Failed to delete:', error)\n   * );\n   * ```\n   */\n  delete(id: string): AsyncResult<ApiResponse<Record<string, unknown>>, AppError> {\n    return apiClient.delete<Record<string, unknown>>(`/address-book/${id}`);\n  },\n};\n\n/**\n * Export configuration and utilities\n */\nexport { DEFAULT_CONFIG };\nexport type { HttpClientConfig as ApiConfig };\n\n/**\n * Creates a custom HTTP client instance with optional configuration overrides\n *\n * @param config - Partial configuration to override defaults\n * @returns IHttpClient instance with custom configuration\n *\n * @example\n * ```typescript\n * // Create client with custom timeout\n * const fastClient = createHttpClient({\n *   timeout: 5000,\n *   retry: { maxAttempts: 2, baseDelay: 500, maxDelay: 5000 }\n * });\n *\n * const result = await fastClient.get('/api/data');\n * ```\n */\nexport function createHttpClient(config?: Partial<HttpClientConfig>): IHttpClient {\n  return new HttpClient(API_BASE_URL, config);\n}\n\n/**\n * Resets the circuit breaker state of the default API client\n *\n * @internal Primarily for testing purposes\n *\n * @example\n * ```typescript\n * // In test setup\n * beforeEach(() => {\n *   resetApiClientCircuitBreaker();\n * });\n * ```\n */\nexport function resetApiClientCircuitBreaker(): void {\n  if (apiClient instanceof HttpClient) {\n    apiClient.resetCircuitBreaker();\n  }\n}\n\n/**\n * Default API client instance\n * Implements IHttpClient interface with full authentication and fault tolerance\n */\nexport default apiClient;\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/services/auth.test.ts",
        "messages": [
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'metadata' is defined but never used. Allowed unused args must match /^_/u.",
                "line": 19,
                "column": 5,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 19,
                "endColumn": 13
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'userId' is defined but never used. Allowed unused args must match /^_/u.",
                "line": 35,
                "column": 24,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 35,
                "endColumn": 30
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'tenantId' is defined but never used. Allowed unused args must match /^_/u.",
                "line": 35,
                "column": 40,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 35,
                "endColumn": 48
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'reason' is defined but never used. Allowed unused args must match /^_/u.",
                "line": 35,
                "column": 60,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 35,
                "endColumn": 66
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'userId' is defined but never used. Allowed unused args must match /^_/u.",
                "line": 39,
                "column": 24,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 39,
                "endColumn": 30
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'tenantId' is defined but never used. Allowed unused args must match /^_/u.",
                "line": 39,
                "column": 40,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 39,
                "endColumn": 48
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 324,
                "column": 7,
                "nodeType": "Property",
                "messageId": "anyAssignment",
                "endLine": 324,
                "endColumn": 37
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 7,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "/**\n * @file auth.test.ts\n * @description Comprehensive tests for authorization services\n */\n\nimport { describe, expect, it, beforeEach } from 'bun:test';\nimport { hasTenantAccess, hasTenantPermission, getTenantAccess, type AuthConfig } from './auth';\nimport type { UserId, TenantId } from '../types/ids';\nimport type { TokenMetadata } from '../types/auth';\n\n// Mock logger and metrics for testing\nclass MockSecurityLogger {\n  public capturedLogs: string[] = [];\n\n  logAuthFailure(\n    userId: UserId,\n    tenantId: TenantId,\n    reason: string,\n    metadata?: Record<string, unknown>\n  ): void {\n    this.capturedLogs.push(\n      `[AUTH_FAILURE] User ${userId} denied access to tenant ${tenantId}: ${reason}`\n    );\n  }\n\n  reset(): void {\n    this.capturedLogs = [];\n  }\n}\n\nclass MockMetricsCollector {\n  public failures = 0;\n  public successes = 0;\n\n  incrementAuthFailure(userId: UserId, tenantId: TenantId, reason: string): void {\n    this.failures++;\n  }\n\n  incrementAuthSuccess(userId: UserId, tenantId: TenantId): void {\n    this.successes++;\n  }\n\n  reset(): void {\n    this.failures = 0;\n    this.successes = 0;\n  }\n}\n\ndescribe('hasTenantAccess', () => {\n  let mockLogger: MockSecurityLogger;\n  let mockMetrics: MockMetricsCollector;\n  let testConfig: AuthConfig;\n\n  beforeEach(() => {\n    mockLogger = new MockSecurityLogger();\n    mockMetrics = new MockMetricsCollector();\n    testConfig = {\n      logger: mockLogger,\n      metrics: mockMetrics,\n    };\n  });\n\n  const validUserId: UserId = 'user-123' as UserId;\n  const validTenantId: TenantId = 'tenant-456' as TenantId;\n\n  describe('successful access validation', () => {\n    it('should return true for valid owner access', () => {\n      const tokenMetadata: TokenMetadata = {\n        issuedAt: Date.now() - 1000, // 1 second ago\n        tenantRole: 'owner',\n        permissions: ['read', 'write', 'delete', 'admin'],\n      };\n\n      const result = hasTenantAccess(validUserId, validTenantId, tokenMetadata, testConfig);\n\n      expect(result.isOk()).toBe(true);\n      expect(result._unsafeUnwrap()).toBe(true);\n    });\n\n    it('should return true for valid member access', () => {\n      const tokenMetadata: TokenMetadata = {\n        issuedAt: Date.now() - 1000,\n        tenantRole: 'member',\n        permissions: ['read', 'write'],\n      };\n\n      const result = hasTenantAccess(validUserId, validTenantId, tokenMetadata, testConfig);\n\n      expect(result.isOk()).toBe(true);\n      expect(result._unsafeUnwrap()).toBe(true);\n    });\n\n    it('should return true for valid invited access', () => {\n      const tokenMetadata: TokenMetadata = {\n        issuedAt: Date.now() - 1000,\n        tenantRole: 'invited',\n        permissions: ['read'],\n      };\n\n      const result = hasTenantAccess(validUserId, validTenantId, tokenMetadata, testConfig);\n\n      expect(result.isOk()).toBe(true);\n      expect(result._unsafeUnwrap()).toBe(true);\n    });\n  });\n\n  describe('token validation failures', () => {\n    it('should fail for blacklisted token', () => {\n      const tokenMetadata: TokenMetadata = {\n        issuedAt: Date.now() - 1000,\n        isBlacklisted: true,\n        tenantRole: 'member',\n        permissions: ['read', 'write'],\n      };\n\n      const result = hasTenantAccess(validUserId, validTenantId, tokenMetadata, testConfig);\n\n      expect(result.isErr()).toBe(true);\n      expect(result._unsafeUnwrapErr().code).toBe('TOKEN_BLACKLISTED');\n      expect(mockLogger.capturedLogs.some(log => log.includes('AUTH_FAILURE'))).toBe(true);\n    });\n\n    it('should fail for revoked token', () => {\n      const tokenMetadata: TokenMetadata = {\n        issuedAt: Date.now() - 2000, // 2 seconds ago\n        lastRevokeAt: Date.now() - 1000, // Revoked 1 second ago\n        tenantRole: 'member',\n        permissions: ['read', 'write'],\n      };\n\n      const result = hasTenantAccess(validUserId, validTenantId, tokenMetadata, testConfig);\n\n      expect(result.isErr()).toBe(true);\n      expect(result._unsafeUnwrapErr().code).toBe('TOKEN_REVOKED');\n    });\n\n    it('should allow token issued at revocation time (boundary case)', () => {\n      const revokeTime = Date.now() - 1000;\n      const tokenMetadata: TokenMetadata = {\n        issuedAt: revokeTime, // Issued exactly at revocation time\n        lastRevokeAt: revokeTime, // Revoked at same time\n        tenantRole: 'member',\n        permissions: ['read', 'write'],\n      };\n\n      const result = hasTenantAccess(validUserId, validTenantId, tokenMetadata, testConfig);\n\n      expect(result.isOk()).toBe(true);\n      expect(result._unsafeUnwrap()).toBe(true);\n    });\n\n    it('should fail for token that is too old', () => {\n      const tokenMetadata: TokenMetadata = {\n        issuedAt: Date.now() - 25 * 60 * 60 * 1000, // 25 hours ago\n        tenantRole: 'member',\n        permissions: ['read', 'write'],\n      };\n\n      const result = hasTenantAccess(validUserId, validTenantId, tokenMetadata, testConfig);\n\n      expect(result.isErr()).toBe(true);\n      expect(result._unsafeUnwrapErr().code).toBe('TOKEN_TOO_OLD');\n    });\n  });\n\n  describe('membership validation failures', () => {\n    it('should fail when no tenant role in token', () => {\n      const tokenMetadata: TokenMetadata = {\n        issuedAt: Date.now() - 1000,\n        permissions: ['read', 'write'],\n        // Missing tenantRole\n      };\n\n      const result = hasTenantAccess(validUserId, validTenantId, tokenMetadata, testConfig);\n\n      expect(result.isErr()).toBe(true);\n      expect(result._unsafeUnwrapErr().code).toBe('NO_TENANT_ROLE');\n    });\n\n    it('should fail for insufficient role level', () => {\n      const tokenMetadata: TokenMetadata = {\n        issuedAt: Date.now() - 1000,\n        tenantRole: 'guest', // Invalid role\n        permissions: ['read'],\n      };\n\n      const result = hasTenantAccess(validUserId, validTenantId, tokenMetadata, testConfig);\n\n      expect(result.isErr()).toBe(true);\n      expect(result._unsafeUnwrapErr().code).toBe('INSUFFICIENT_ROLE');\n    });\n  });\n\n  describe('security logging and metrics', () => {\n    it('should log auth failure and increment metrics on failure', () => {\n      const tokenMetadata: TokenMetadata = {\n        issuedAt: Date.now() - 1000,\n        isBlacklisted: true,\n        tenantRole: 'member',\n        permissions: ['read', 'write'],\n      };\n\n      hasTenantAccess(validUserId, validTenantId, tokenMetadata, testConfig);\n\n      // Check that failure was logged\n      expect(\n        mockLogger.capturedLogs.some(\n          log =>\n            log.includes('AUTH_FAILURE') && log.includes(validUserId) && log.includes(validTenantId)\n        )\n      ).toBe(true);\n\n      // Check that metrics were incremented\n      expect(mockMetrics.failures).toBe(1);\n    });\n\n    it('should increment success metrics on successful access', () => {\n      const tokenMetadata: TokenMetadata = {\n        issuedAt: Date.now() - 1000,\n        tenantRole: 'member',\n        permissions: ['read', 'write'],\n      };\n\n      hasTenantAccess(validUserId, validTenantId, tokenMetadata, testConfig);\n\n      // Check that success metrics were incremented\n      expect(mockMetrics.successes).toBe(1);\n    });\n  });\n\n  describe('edge cases', () => {\n    it('should handle empty permissions array', () => {\n      const tokenMetadata: TokenMetadata = {\n        issuedAt: Date.now() - 1000,\n        tenantRole: 'member',\n        permissions: [],\n      };\n\n      const result = hasTenantAccess(validUserId, validTenantId, tokenMetadata, testConfig);\n\n      expect(result.isOk()).toBe(true);\n      expect(result._unsafeUnwrap()).toBe(true);\n    });\n\n    it('should handle undefined permissions', () => {\n      const tokenMetadata: TokenMetadata = {\n        issuedAt: Date.now() - 1000,\n        tenantRole: 'member',\n        // permissions is undefined\n      };\n\n      const result = hasTenantAccess(validUserId, validTenantId, tokenMetadata, testConfig);\n\n      expect(result.isOk()).toBe(true);\n      expect(result._unsafeUnwrap()).toBe(true);\n    });\n  });\n});\n\ndescribe('hasTenantPermission', () => {\n  const validUserId: UserId = 'user-123' as UserId;\n  const validTenantId: TenantId = 'tenant-456' as TenantId;\n\n  it('should return true for valid permission', () => {\n    const tokenMetadata: TokenMetadata = {\n      issuedAt: Date.now() - 1000,\n      tenantRole: 'member',\n      permissions: ['read', 'write', 'delete'],\n    };\n\n    const result = hasTenantPermission(validUserId, validTenantId, 'write', tokenMetadata);\n\n    expect(result.isOk()).toBe(true);\n    expect(result._unsafeUnwrap()).toBe(true);\n  });\n\n  it('should return false for invalid permission', () => {\n    const tokenMetadata: TokenMetadata = {\n      issuedAt: Date.now() - 1000,\n      tenantRole: 'member',\n      permissions: ['read', 'write'],\n    };\n\n    const result = hasTenantPermission(validUserId, validTenantId, 'delete', tokenMetadata);\n\n    expect(result.isOk()).toBe(true);\n    expect(result._unsafeUnwrap()).toBe(false);\n  });\n\n  it('should fail if basic tenant access fails', () => {\n    const tokenMetadata: TokenMetadata = {\n      issuedAt: Date.now() - 1000,\n      isBlacklisted: true,\n      tenantRole: 'member',\n      permissions: ['read', 'write'],\n    };\n\n    const result = hasTenantPermission(validUserId, validTenantId, 'read', tokenMetadata);\n\n    expect(result.isErr()).toBe(true);\n    expect(result._unsafeUnwrapErr().code).toBe('TOKEN_BLACKLISTED');\n  });\n});\n\ndescribe('getTenantAccess', () => {\n  const validUserId: UserId = 'user-123' as UserId;\n  const validTenantId: TenantId = 'tenant-456' as TenantId;\n\n  it('should return tenant access details for valid access', () => {\n    const tokenMetadata: TokenMetadata = {\n      issuedAt: Date.now() - 1000,\n      tenantRole: 'member',\n      permissions: ['read', 'write'],\n    };\n\n    const result = getTenantAccess(validUserId, validTenantId, tokenMetadata);\n\n    expect(result.isOk()).toBe(true);\n    expect(result._unsafeUnwrap()).toEqual({\n      userId: validUserId,\n      tenantId: validTenantId,\n      role: 'member',\n      status: 'active',\n      acceptedAt: expect.any(String),\n      permissions: ['read', 'write'],\n    });\n  });\n\n  it('should fail if basic tenant access fails', () => {\n    const tokenMetadata: TokenMetadata = {\n      issuedAt: Date.now() - 1000,\n      isBlacklisted: true,\n      tenantRole: 'member',\n      permissions: ['read', 'write'],\n    };\n\n    const result = getTenantAccess(validUserId, validTenantId, tokenMetadata);\n\n    expect(result.isErr()).toBe(true);\n    expect(result._unsafeUnwrapErr().code).toBe('TOKEN_BLACKLISTED');\n  });\n});\n\ndescribe('integration scenarios', () => {\n  let mockLogger: MockSecurityLogger;\n  let mockMetrics: MockMetricsCollector;\n  let testConfig: AuthConfig;\n\n  beforeEach(() => {\n    mockLogger = new MockSecurityLogger();\n    mockMetrics = new MockMetricsCollector();\n    testConfig = {\n      logger: mockLogger,\n      metrics: mockMetrics,\n    };\n  });\n\n  const validUserId: UserId = 'user-123' as UserId;\n  const validTenantId: TenantId = 'tenant-456' as TenantId;\n\n  it('should handle complete authorization flow', () => {\n    const tokenMetadata: TokenMetadata = {\n      issuedAt: Date.now() - 1000,\n      tenantRole: 'owner',\n      permissions: ['read', 'write', 'delete', 'admin'],\n    };\n\n    // Test basic access\n    const accessResult = hasTenantAccess(validUserId, validTenantId, tokenMetadata);\n    expect(accessResult.isOk()).toBe(true);\n    expect(accessResult._unsafeUnwrap()).toBe(true);\n\n    // Test specific permissions\n    const readResult = hasTenantPermission(validUserId, validTenantId, 'read', tokenMetadata);\n    expect(readResult.isOk()).toBe(true);\n    expect(readResult._unsafeUnwrap()).toBe(true);\n\n    const adminResult = hasTenantPermission(validUserId, validTenantId, 'admin', tokenMetadata);\n    expect(adminResult.isOk()).toBe(true);\n    expect(adminResult._unsafeUnwrap()).toBe(true);\n\n    // Test access details\n    const detailsResult = getTenantAccess(validUserId, validTenantId, tokenMetadata);\n    expect(detailsResult.isOk()).toBe(true);\n    expect(detailsResult._unsafeUnwrap().role).toBe('owner');\n    expect(detailsResult._unsafeUnwrap().permissions).toContain('admin');\n  });\n\n  it('should handle expired token scenario', () => {\n    const tokenMetadata: TokenMetadata = {\n      issuedAt: Date.now() - 25 * 60 * 60 * 1000, // 25 hours ago\n      tenantRole: 'member',\n      permissions: ['read', 'write'],\n    };\n\n    const result = hasTenantAccess(validUserId, validTenantId, tokenMetadata, testConfig);\n\n    expect(result.isErr()).toBe(true);\n    expect(result._unsafeUnwrapErr().code).toBe('TOKEN_TOO_OLD');\n  });\n\n  it('should handle revoked token scenario', () => {\n    const tokenMetadata: TokenMetadata = {\n      issuedAt: Date.now() - 2000,\n      lastRevokeAt: Date.now() - 1000,\n      tenantRole: 'member',\n      permissions: ['read', 'write'],\n    };\n\n    const result = hasTenantAccess(validUserId, validTenantId, tokenMetadata, testConfig);\n\n    expect(result.isErr()).toBe(true);\n    expect(result._unsafeUnwrapErr().code).toBe('TOKEN_REVOKED');\n  });\n});\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/services/auth.ts",
        "messages": [
            {
                "ruleId": "no-console",
                "severity": 1,
                "message": "Unexpected console statement. Only these console methods are allowed: warn, error.",
                "line": 103,
                "column": 5,
                "nodeType": "MemberExpression",
                "messageId": "limited",
                "endLine": 103,
                "endColumn": 18,
                "suggestions": [
                    {
                        "fix": {
                            "range": [
                                2791,
                                2878
                            ],
                            "text": ""
                        },
                        "messageId": "removeConsole",
                        "data": {
                            "propertyName": "debug"
                        },
                        "desc": "Remove the console.debug()."
                    }
                ]
            },
            {
                "ruleId": "no-console",
                "severity": 1,
                "message": "Unexpected console statement. Only these console methods are allowed: warn, error.",
                "line": 113,
                "column": 5,
                "nodeType": "MemberExpression",
                "messageId": "limited",
                "endLine": 113,
                "endColumn": 18,
                "suggestions": [
                    {
                        "fix": {
                            "range": [
                                3168,
                                3303
                            ],
                            "text": ""
                        },
                        "messageId": "removeConsole",
                        "data": {
                            "propertyName": "debug"
                        },
                        "desc": "Remove the console.debug()."
                    }
                ]
            },
            {
                "ruleId": "no-console",
                "severity": 1,
                "message": "Unexpected console statement. Only these console methods are allowed: warn, error.",
                "line": 123,
                "column": 5,
                "nodeType": "MemberExpression",
                "messageId": "limited",
                "endLine": 123,
                "endColumn": 18,
                "suggestions": [
                    {
                        "fix": {
                            "range": [
                                3463,
                                3584
                            ],
                            "text": ""
                        },
                        "messageId": "removeConsole",
                        "data": {
                            "propertyName": "debug"
                        },
                        "desc": "Remove the console.debug()."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
                "line": 165,
                "column": 7,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorNullableBoolean",
                "endLine": 165,
                "endColumn": 34,
                "suggestions": [
                    {
                        "messageId": "conditionFixDefaultFalse",
                        "fix": {
                            "range": [
                                4555,
                                4582
                            ],
                            "text": "tokenMetadata.isBlacklisted ?? false"
                        },
                        "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
                    },
                    {
                        "messageId": "conditionFixCompareTrue",
                        "fix": {
                            "range": [
                                4555,
                                4582
                            ],
                            "text": "tokenMetadata.isBlacklisted === true"
                        },
                        "desc": "Change condition to check if true (`value === true`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.",
                "line": 181,
                "column": 7,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableNumber",
                "endLine": 181,
                "endColumn": 19,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                4859,
                                4871
                            ],
                            "text": "(lastRevokeAt != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultZero",
                        "fix": {
                            "range": [
                                4859,
                                4871
                            ],
                            "text": "(lastRevokeAt ?? 0)"
                        },
                        "desc": "Explicitly treat nullish value the same as 0 (`value ?? 0`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                4859,
                                4871
                            ],
                            "text": "(Boolean(lastRevokeAt))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 243,
                "column": 8,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 243,
                "endColumn": 32,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                6282,
                                6307
                            ],
                            "text": "tokenMetadata.tenantRole == null"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                6283,
                                6307
                            ],
                            "text": "(tokenMetadata.tenantRole ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                6282,
                                6307
                            ],
                            "text": "!Boolean(tokenMetadata.tenantRole)"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 260,
                "column": 49,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 260,
                "endColumn": 51,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                6673,
                                6675
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, value is always falsy.",
                "line": 287,
                "column": 7,
                "nodeType": "UnaryExpression",
                "messageId": "alwaysFalsy",
                "endLine": 287,
                "endColumn": 16
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, value is always falsy.",
                "line": 328,
                "column": 7,
                "nodeType": "UnaryExpression",
                "messageId": "alwaysFalsy",
                "endLine": 328,
                "endColumn": 18
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, value is always falsy.",
                "line": 342,
                "column": 7,
                "nodeType": "UnaryExpression",
                "messageId": "alwaysFalsy",
                "endLine": 342,
                "endColumn": 20
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 477,
                "column": 49,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 477,
                "endColumn": 51,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                12435,
                                12437
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, value is always truthy.",
                "line": 514,
                "column": 12,
                "nodeType": "TSAsExpression",
                "messageId": "alwaysTruthy",
                "endLine": 514,
                "endColumn": 70
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 517,
                "column": 44,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 517,
                "endColumn": 46,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                13565,
                                13567
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 13,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "/**\n * @module services/auth\n * @description Authorization and tenant access validation services\n *\n * This module provides comprehensive authorization functions for multi-tenant systems,\n * including tenant access validation, role-based permissions, and security logging.\n *\n * All functions use Railway-oriented programming with Result types for type-safe\n * error handling and comprehensive logging for security monitoring.\n *\n * @example\n * ```typescript\n * // Check tenant access\n * const result = await hasTenantAccess(userId, tenantId, tokenMetadata);\n *\n * result.match(\n *   (hasAccess) => {\n *     if (hasAccess) {\n *       // Proceed with tenant operations\n *     } else {\n *       // Handle access denied\n *     }\n *   },\n *   (error) => {\n *     // Handle validation error\n *     console.error('Access validation failed:', error.message);\n *   }\n * );\n * ```\n */\n\nimport { type Result, type ResultAsync, err, ok, okAsync, errAsync } from 'neverthrow';\nimport type { UserId, TenantId } from '../types/ids';\nimport type { TokenMetadata, TenantAccess } from '../types/auth';\nimport type { AppError } from '../types/errors';\nimport { createAuthError } from '../types/errors';\n\n/**\n * Logging interface for security events\n */\ninterface SecurityLogger {\n  logAuthFailure: (\n    userId: UserId,\n    tenantId: TenantId,\n    reason: string,\n    metadata?: Record<string, unknown>\n  ) => void;\n  incrementMetric?: (metricName: string, tags?: Record<string, string>) => void;\n}\n\n/**\n * Metrics interface for tracking authorization events\n */\ninterface MetricsCollector {\n  incrementAuthFailure: (userId: UserId, tenantId: TenantId, reason: string) => void;\n  incrementAuthSuccess: (userId: UserId, tenantId: TenantId) => void;\n}\n\n/**\n * Tenant membership validation result\n */\ninterface TenantMembership {\n  hasAccess: boolean;\n  role: 'owner' | 'member' | 'invited';\n  status: 'active' | 'inactive' | 'suspended';\n  acceptedAt?: string;\n  permissions: string[];\n}\n\n/**\n * Token validation result\n */\ninterface TokenValidation {\n  isValid: boolean;\n  isExpired: boolean;\n  isRevoked: boolean;\n  isBlacklisted: boolean;\n  issuedAt: number;\n  lastRevokeAt?: number;\n}\n\n/**\n * Default security logger implementation\n */\nclass DefaultSecurityLogger implements SecurityLogger {\n  logAuthFailure(\n    userId: UserId,\n    tenantId: TenantId,\n    reason: string,\n    metadata?: Record<string, unknown>\n  ): void {\n    console.warn(`[AUTH_FAILURE] User ${userId} denied access to tenant ${tenantId}: ${reason}`, {\n      userId,\n      tenantId,\n      reason,\n      timestamp: new Date().toISOString(),\n      ...metadata,\n    });\n  }\n\n  incrementMetric(metricName: string, tags?: Record<string, string>): void {\n    // In a real implementation, this would send metrics to your monitoring system\n    console.debug(`[METRIC] ${metricName}`, { tags, timestamp: new Date().toISOString() });\n  }\n}\n\n/**\n * Default metrics collector implementation\n */\nclass DefaultMetricsCollector implements MetricsCollector {\n  incrementAuthFailure(userId: UserId, tenantId: TenantId, reason: string): void {\n    // In a real implementation, this would send metrics to your monitoring system\n    console.debug(`[METRIC] auth_failure`, {\n      userId,\n      tenantId,\n      reason,\n      timestamp: new Date().toISOString(),\n    });\n  }\n\n  incrementAuthSuccess(userId: UserId, tenantId: TenantId): void {\n    // In a real implementation, this would send metrics to your monitoring system\n    console.debug(`[METRIC] auth_success`, {\n      userId,\n      tenantId,\n      timestamp: new Date().toISOString(),\n    });\n  }\n}\n\n/**\n * Configuration for authorization services\n */\ninterface AuthConfig {\n  logger?: SecurityLogger;\n  metrics?: MetricsCollector;\n  tokenBlacklistCheck?: boolean;\n  requireActiveStatus?: boolean;\n  minimumRoleLevel?: 'invited' | 'member' | 'owner';\n}\n\n/**\n * Default configuration\n */\nconst DEFAULT_CONFIG: Required<AuthConfig> = {\n  logger: new DefaultSecurityLogger(),\n  metrics: new DefaultMetricsCollector(),\n  tokenBlacklistCheck: true,\n  requireActiveStatus: true,\n  minimumRoleLevel: 'invited',\n};\n\n/**\n * Validates token freshness and revocation status\n *\n * @param tokenMetadata - Token metadata including issued time and revocation info\n * @returns Result containing TokenValidation or AppError\n */\nfunction validateToken(tokenMetadata: TokenMetadata): Result<TokenValidation, AppError> {\n  const now = Date.now();\n  const issuedAt = tokenMetadata.issuedAt;\n  const lastRevokeAt = tokenMetadata.lastRevokeAt;\n\n  // Check if token is blacklisted\n  if (tokenMetadata.isBlacklisted) {\n    return err(\n      createAuthError(\n        'Token is blacklisted',\n        {\n          issuedAt,\n          lastRevokeAt,\n        },\n        {\n          code: 'TOKEN_BLACKLISTED',\n        }\n      )\n    );\n  }\n\n  // Check if token was issued before last revocation\n  if (lastRevokeAt && issuedAt < lastRevokeAt) {\n    return err(\n      createAuthError(\n        'Token was issued before revocation',\n        {\n          issuedAt,\n          lastRevokeAt,\n        },\n        {\n          code: 'TOKEN_REVOKED',\n        }\n      )\n    );\n  }\n\n  // Check token age (optional: implement max age policy)\n  const tokenAge = now - issuedAt;\n  const maxTokenAge = 24 * 60 * 60 * 1000; // 24 hours in milliseconds\n\n  if (tokenAge > maxTokenAge) {\n    return err(\n      createAuthError(\n        'Token is too old',\n        {\n          issuedAt,\n          tokenAge,\n          maxTokenAge,\n        },\n        {\n          code: 'TOKEN_TOO_OLD',\n        }\n      )\n    );\n  }\n\n  return ok({\n    isValid: true,\n    isExpired: false,\n    isRevoked: false,\n    isBlacklisted: false,\n    issuedAt,\n    lastRevokeAt,\n  });\n}\n\n/**\n * Validates tenant membership and role permissions\n *\n * @param userId - User ID to validate\n * @param tenantId - Tenant ID to check access for\n * @param tokenMetadata - Token metadata for role/permission validation\n * @returns Result containing TenantMembership or AppError\n */\nfunction validateTenantMembership(\n  userId: UserId,\n  tenantId: TenantId,\n  tokenMetadata: TokenMetadata\n): Result<TenantMembership, AppError> {\n  // In a real implementation, this would query the database\n  // For now, we'll simulate the validation logic\n\n  // Check if user has tenant role in token\n  if (!tokenMetadata.tenantRole) {\n    return err(\n      createAuthError(\n        'No tenant role in token',\n        {\n          userId,\n          tenantId,\n        },\n        {\n          code: 'NO_TENANT_ROLE',\n        }\n      )\n    );\n  }\n\n  // Simulate role-based access\n  const role = tokenMetadata.tenantRole as 'owner' | 'member' | 'invited';\n  const permissions = tokenMetadata.permissions || [];\n\n  // Check minimum role level\n  const roleHierarchy = { invited: 1, member: 2, owner: 3 };\n  const minimumLevel = roleHierarchy[role] || 0;\n  const requiredLevel = roleHierarchy.invited; // Default minimum\n\n  if (minimumLevel < requiredLevel) {\n    return err(\n      createAuthError(\n        'Insufficient role level',\n        {\n          userId,\n          tenantId,\n          role,\n          requiredLevel,\n        },\n        {\n          code: 'INSUFFICIENT_ROLE',\n        }\n      )\n    );\n  }\n\n  // Simulate active status check\n  const isActive = true; // In real implementation, check user and tenant status\n\n  if (!isActive) {\n    return err(\n      createAuthError(\n        'User or tenant is inactive',\n        {\n          userId,\n          tenantId,\n        },\n        {\n          code: 'INACTIVE_ACCOUNT',\n        }\n      )\n    );\n  }\n\n  return ok({\n    hasAccess: true,\n    role,\n    status: 'active',\n    acceptedAt: new Date().toISOString(),\n    permissions,\n  });\n}\n\n/**\n * Validates account and tenant are active\n *\n * @param userId - User ID to validate\n * @param tenantId - Tenant ID to validate\n * @returns Result containing validation result or AppError\n */\nfunction validateAccountStatus(\n  userId: UserId,\n  tenantId: TenantId\n): Result<{ userActive: boolean; tenantActive: boolean }, AppError> {\n  // In a real implementation, this would query the database\n  // For now, we'll simulate the validation\n\n  const userActive = true; // Check user account status\n  const tenantActive = true; // Check tenant status\n\n  if (!userActive) {\n    return err(\n      createAuthError(\n        'User account is inactive',\n        {\n          userId,\n        },\n        {\n          code: 'USER_INACTIVE',\n        }\n      )\n    );\n  }\n\n  if (!tenantActive) {\n    return err(\n      createAuthError(\n        'Tenant is inactive',\n        {\n          tenantId,\n        },\n        {\n          code: 'TENANT_INACTIVE',\n        }\n      )\n    );\n  }\n\n  return ok({ userActive, tenantActive });\n}\n\n/**\n * Main function to validate tenant access\n *\n * This function performs comprehensive validation including:\n * - Token freshness and revocation checks\n * - Tenant membership validation\n * - Role and permission verification\n * - Account and tenant status validation\n * - Security logging and metrics\n *\n * @param userId - User ID requesting access\n * @param tenantId - Tenant ID to access\n * @param tokenMetadata - Token metadata for validation\n * @param config - Optional configuration for validation behavior\n * @returns Result containing boolean access result or AppError\n */\nexport function hasTenantAccess(\n  userId: UserId,\n  tenantId: TenantId,\n  tokenMetadata: TokenMetadata,\n  config: AuthConfig = {}\n): Result<boolean, AppError> {\n  const finalConfig = { ...DEFAULT_CONFIG, ...config };\n  const { logger, metrics } = finalConfig;\n\n  // Validate token freshness and revocation\n  const tokenValidation = validateToken(tokenMetadata);\n  if (tokenValidation.isErr()) {\n    logger.logAuthFailure(\n      userId,\n      tenantId,\n      `Token validation failed: ${tokenValidation.error.message}`,\n      {\n        errorCode: tokenValidation.error.code,\n        tokenMetadata,\n      }\n    );\n    metrics.incrementAuthFailure(userId, tenantId, 'TOKEN_VALIDATION_FAILED');\n    return err(tokenValidation.error);\n  }\n\n  // Validate account and tenant status\n  const accountStatus = validateAccountStatus(userId, tenantId);\n  if (accountStatus.isErr()) {\n    logger.logAuthFailure(\n      userId,\n      tenantId,\n      `Account validation failed: ${accountStatus.error.message}`,\n      {\n        errorCode: accountStatus.error.code,\n      }\n    );\n    metrics.incrementAuthFailure(userId, tenantId, 'ACCOUNT_VALIDATION_FAILED');\n    return err(accountStatus.error);\n  }\n\n  // Validate tenant membership and role\n  const membership = validateTenantMembership(userId, tenantId, tokenMetadata);\n  if (membership.isErr()) {\n    logger.logAuthFailure(\n      userId,\n      tenantId,\n      `Membership validation failed: ${membership.error.message}`,\n      {\n        errorCode: membership.error.code,\n        tokenMetadata,\n      }\n    );\n    metrics.incrementAuthFailure(userId, tenantId, 'MEMBERSHIP_VALIDATION_FAILED');\n    return err(membership.error);\n  }\n\n  // All validations passed\n  metrics.incrementAuthSuccess(userId, tenantId);\n  return ok(true);\n}\n\n/**\n * Async version of hasTenantAccess for use with ResultAsync\n *\n * @param userId - User ID requesting access\n * @param tenantId - Tenant ID to access\n * @param tokenMetadata - Token metadata for validation\n * @param config - Optional configuration for validation behavior\n * @returns AsyncResult containing boolean access result or AppError\n */\nexport function hasTenantAccessAsync(\n  userId: UserId,\n  tenantId: TenantId,\n  tokenMetadata: TokenMetadata,\n  config: AuthConfig = {}\n): ResultAsync<boolean, AppError> {\n  const result = hasTenantAccess(userId, tenantId, tokenMetadata, config);\n  return result.isOk() ? okAsync(result.value) : errAsync(result.error);\n}\n\n/**\n * Check if user has specific permission for a tenant\n *\n * @param userId - User ID to check\n * @param tenantId - Tenant ID to check\n * @param permission - Permission to check\n * @param tokenMetadata - Token metadata containing permissions\n * @returns Result containing boolean permission result or AppError\n */\nexport function hasTenantPermission(\n  userId: UserId,\n  tenantId: TenantId,\n  permission: string,\n  tokenMetadata: TokenMetadata\n): Result<boolean, AppError> {\n  // First check basic tenant access\n  const accessResult = hasTenantAccess(userId, tenantId, tokenMetadata);\n  if (accessResult.isErr()) {\n    return err(accessResult.error);\n  }\n\n  // Check specific permission\n  const permissions = tokenMetadata.permissions || [];\n  const hasPermission = permissions.includes(permission);\n\n  if (!hasPermission) {\n    const logger = new DefaultSecurityLogger();\n    logger.logAuthFailure(userId, tenantId, `Permission denied: ${permission}`, {\n      permission,\n      availablePermissions: permissions,\n    });\n  }\n\n  return ok(hasPermission);\n}\n\n/**\n * Get user's role and permissions for a tenant\n *\n * @param userId - User ID to check\n * @param tenantId - Tenant ID to check\n * @param tokenMetadata - Token metadata\n * @returns Result containing TenantAccess or AppError\n */\nexport function getTenantAccess(\n  userId: UserId,\n  tenantId: TenantId,\n  tokenMetadata: TokenMetadata\n): Result<TenantAccess, AppError> {\n  // Validate basic access first\n  const accessResult = hasTenantAccess(userId, tenantId, tokenMetadata);\n  if (accessResult.isErr()) {\n    return err(accessResult.error);\n  }\n\n  // Return access details\n  return ok({\n    userId,\n    tenantId,\n    role: (tokenMetadata.tenantRole as 'owner' | 'member' | 'invited') || 'invited',\n    status: 'active',\n    acceptedAt: new Date().toISOString(),\n    permissions: tokenMetadata.permissions || [],\n  });\n}\n\n/**\n * Export types for external use\n */\nexport type { AuthConfig, SecurityLogger, MetricsCollector, TenantMembership, TokenValidation };\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/test-utils/__tests__/example.test.tsx",
        "messages": [
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 25,
                "column": 1,
                "nodeType": "FunctionDeclaration",
                "messageId": "missingReturnType",
                "endLine": 25,
                "endColumn": 24
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 28,
                "column": 19,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 28,
                "endColumn": 23,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                703,
                                707
                            ],
                            "text": "(name != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                703,
                                707
                            ],
                            "text": "(name ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                703,
                                707
                            ],
                            "text": "(Boolean(name))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 85,
                "column": 5,
                "nodeType": "FunctionDeclaration",
                "messageId": "missingReturnType",
                "endLine": 85,
                "endColumn": 25
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 3,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "/**\n * Example Test - Demonstrates Test Infrastructure\n *\n * This test file demonstrates how to use the comprehensive test infrastructure\n * including custom render functions, MSW API mocking, and test utilities.\n */\n\nimport { describe, test, expect, beforeAll, afterAll, beforeEach } from 'bun:test';\nimport React from 'react';\nimport {\n  renderWithProviders,\n  renderWithAuth,\n  renderWithoutAuth,\n  screen,\n  userEvent,\n  setupMSW,\n  teardownMSW,\n  resetMSW,\n  mockUser,\n  mockTenant,\n} from '../index';\nimport { ButtonExample } from '../components/ButtonExample';\n\n// Simple example component for testing\nfunction WelcomeMessage({ name }: { name?: string }) {\n  return (\n    <div>\n      <h1>Welcome{name ? ` ${name}` : ''}!</h1>\n      <p>This is a test component</p>\n    </div>\n  );\n}\n\ndescribe('Test Infrastructure Example', () => {\n  describe('Custom Render Functions', () => {\n    test('renderWithProviders should render component with all providers', () => {\n      renderWithProviders(<WelcomeMessage name=\"Test User\" />);\n\n      expect(screen.getByText('Welcome Test User!')).toBeInTheDocument();\n      expect(screen.getByText('This is a test component')).toBeInTheDocument();\n    });\n\n    test('renderWithAuth should provide authenticated context', () => {\n      renderWithAuth(<WelcomeMessage />);\n\n      expect(screen.getByText(/Welcome/)).toBeInTheDocument();\n    });\n\n    test('renderWithoutAuth should provide unauthenticated context', () => {\n      renderWithoutAuth(<WelcomeMessage />);\n\n      expect(screen.getByText(/Welcome/)).toBeInTheDocument();\n    });\n  });\n\n  describe('Mock Data', () => {\n    test('should provide mock user data', () => {\n      expect(mockUser).toBeDefined();\n      expect(mockUser.email).toBe('test@example.com');\n      expect(mockUser.username).toBe('testuser');\n    });\n\n    test('should provide mock tenant data', () => {\n      expect(mockTenant).toBeDefined();\n      expect(mockTenant.name).toBe('Test Tenant');\n    });\n  });\n\n  describe('User Interactions', () => {\n    test('should handle user interactions', async () => {\n      const user = userEvent.setup();\n\n      renderWithProviders(<ButtonExample />);\n\n      expect(screen.getByText('Count: 0')).toBeInTheDocument();\n\n      const button = screen.getByRole('button', { name: 'Increment' });\n      await user.click(button);\n\n      expect(screen.getByText('Count: 1')).toBeInTheDocument();\n    });\n  });\n\n  describe('Query Examples', () => {\n    function FormExample() {\n      return (\n        <form>\n          <label htmlFor=\"email\">Email</label>\n          <input id=\"email\" type=\"email\" placeholder=\"Enter your email\" aria-label=\"Email input\" />\n\n          <button type=\"submit\" aria-label=\"Submit form\">\n            Submit\n          </button>\n        </form>\n      );\n    }\n\n    test('should use accessible queries', () => {\n      renderWithProviders(<FormExample />);\n\n      //  Preferred: getByRole\n      const submitButton = screen.getByRole('button', { name: 'Submit form' });\n      expect(submitButton).toBeInTheDocument();\n\n      //  Preferred: getByLabelText\n      const emailInput = screen.getByLabelText('Email');\n      expect(emailInput).toBeInTheDocument();\n\n      //  Good: getByPlaceholderText\n      const emailByPlaceholder = screen.getByPlaceholderText('Enter your email');\n      expect(emailByPlaceholder).toBeInTheDocument();\n    });\n  });\n});\n\n// Import React for JSX\n// import React from 'react'; // Moved to top\n\ndescribe('MSW API Mocking Example', () => {\n  // Setup MSW server\n  beforeAll(() => {\n    setupMSW();\n  });\n\n  afterAll(() => {\n    teardownMSW();\n  });\n\n  beforeEach(() => {\n    resetMSW();\n  });\n\n  test('MSW server is configured and ready', () => {\n    // This test verifies the MSW infrastructure is working\n    // Actual API tests will be in TI-002: Unit Tests - Services Layer\n    expect(true).toBe(true);\n  });\n});\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/test-utils/__tests__/render.test.tsx",
        "messages": [
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 12,
                "column": 1,
                "nodeType": "FunctionDeclaration",
                "messageId": "missingReturnType",
                "endLine": 12,
                "endColumn": 26
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 21,
                "column": 32,
                "nodeType": "ChainExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 21,
                "endColumn": 51,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                689,
                                708
                            ],
                            "text": "((auth.user?.username) != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                689,
                                708
                            ],
                            "text": "((auth.user?.username) ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                689,
                                708
                            ],
                            "text": "(Boolean((auth.user?.username)))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 21,
                "column": 52,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 21,
                "endColumn": 54,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                709,
                                711
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 22,
                "column": 34,
                "nodeType": "ChainExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 22,
                "endColumn": 51,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                759,
                                776
                            ],
                            "text": "((auth.tenant?.name) != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                759,
                                776
                            ],
                            "text": "((auth.tenant?.name) ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                759,
                                776
                            ],
                            "text": "(Boolean((auth.tenant?.name)))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 22,
                "column": 52,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 22,
                "endColumn": 54,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                777,
                                779
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 5,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "/**\n * Test for MockAuthProvider functionality\n */\n\nimport React from 'react';\nimport { describe, test, expect } from 'bun:test';\nimport { render, screen } from '@testing-library/react';\nimport { AuthContext } from '../../contexts/AuthContext';\nimport { MockAuthProvider } from '../render';\n\n// Test component that uses the auth context\nfunction TestAuthConsumer() {\n  const auth = React.useContext(AuthContext);\n  if (!auth) {\n    return <div>No auth context</div>;\n  }\n  return (\n    <div>\n      <div data-testid=\"isAuthenticated\">{auth.isAuthenticated ? 'true' : 'false'}</div>\n      <div data-testid=\"isLoading\">{auth.isLoading ? 'true' : 'false'}</div>\n      <div data-testid=\"user\">{auth.user?.username || 'null'}</div>\n      <div data-testid=\"tenant\">{auth.tenant?.name || 'null'}</div>\n    </div>\n  );\n}\n\ndescribe('MockAuthProvider', () => {\n  test('provides default mock auth context', () => {\n    render(\n      <MockAuthProvider>\n        <TestAuthConsumer />\n      </MockAuthProvider>\n    );\n\n    expect(screen.getByTestId('isAuthenticated').textContent).toBe('true');\n    expect(screen.getByTestId('isLoading').textContent).toBe('false');\n    expect(screen.getByTestId('user').textContent).toBe('testuser');\n    expect(screen.getByTestId('tenant').textContent).toBe('Test Tenant');\n  });\n\n  test('allows overriding auth values', () => {\n    render(\n      <MockAuthProvider\n        value={{\n          isAuthenticated: false,\n          user: null,\n          tenant: null,\n          isLoading: true,\n        }}\n      >\n        <TestAuthConsumer />\n      </MockAuthProvider>\n    );\n\n    expect(screen.getByTestId('isAuthenticated').textContent).toBe('false');\n    expect(screen.getByTestId('isLoading').textContent).toBe('true');\n    expect(screen.getByTestId('user').textContent).toBe('null');\n    expect(screen.getByTestId('tenant').textContent).toBe('null');\n  });\n\n  test('merges partial overrides with defaults', () => {\n    render(\n      <MockAuthProvider\n        value={{\n          isAuthenticated: false,\n        }}\n      >\n        <TestAuthConsumer />\n      </MockAuthProvider>\n    );\n\n    expect(screen.getByTestId('isAuthenticated').textContent).toBe('false');\n    expect(screen.getByTestId('isLoading').textContent).toBe('false'); // default value\n    expect(screen.getByTestId('user').textContent).toBe('testuser'); // default value\n    expect(screen.getByTestId('tenant').textContent).toBe('Test Tenant'); // default value\n  });\n});\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/test-utils/components/ButtonExample.tsx",
        "messages": [
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 7,
                "column": 8,
                "nodeType": "FunctionDeclaration",
                "messageId": "missingReturnType",
                "endLine": 7,
                "endColumn": 30
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 1,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "import React from 'react';\n\n/**\n * Example component for testing user interactions\n * Displays a count and provides an increment button\n */\nexport function ButtonExample() {\n  const [count, setCount] = React.useState(0);\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button\n        onClick={() => {\n          setCount(prev => prev + 1);\n        }}\n      >\n        Increment\n      </button>\n    </div>\n  );\n}\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/test-utils/index.ts",
        "messages": [
            {
                "ruleId": "@typescript-eslint/no-deprecated",
                "severity": 1,
                "message": "`testConsoleError` is deprecated. Use testLogger.error instead",
                "line": 21,
                "column": 22,
                "nodeType": "Identifier",
                "messageId": "deprecatedWithReason",
                "endLine": 21,
                "endColumn": 38
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 1,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "/**\n * Test Utilities - Index\n *\n * Centralized exports for all testing utilities.\n * Import from here to access render functions, mocks, and test helpers.\n *\n * @example\n * ```typescript\n * import { renderWithProviders, mockUser, server } from './test-utils';\n * ```\n */\n\n// Re-export render utilities\nexport * from './render';\n\n// Re-export MSW utilities\nexport { server, setupMSW, teardownMSW, resetMSW } from './mocks/server';\nexport { getHandlers, resetMockData } from './mocks/handlers';\n\n// Re-export test logger\nexport { testLogger, testConsoleError } from './logger';\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/test-utils/jwt.ts",
        "messages": [],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 0,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/test-utils/logger.ts",
        "messages": [
            {
                "ruleId": "no-console",
                "severity": 1,
                "message": "Unexpected console statement. Only these console methods are allowed: warn, error.",
                "line": 26,
                "column": 7,
                "nodeType": "MemberExpression",
                "messageId": "limited",
                "endLine": 26,
                "endColumn": 20,
                "suggestions": [
                    {
                        "fix": {
                            "range": [
                                679,
                                718
                            ],
                            "text": ""
                        },
                        "messageId": "removeConsole",
                        "data": {
                            "propertyName": "debug"
                        },
                        "desc": "Remove the console.debug()."
                    }
                ]
            },
            {
                "ruleId": "no-console",
                "severity": 1,
                "message": "Unexpected console statement. Only these console methods are allowed: warn, error.",
                "line": 35,
                "column": 7,
                "nodeType": "MemberExpression",
                "messageId": "limited",
                "endLine": 35,
                "endColumn": 19,
                "suggestions": [
                    {
                        "fix": {
                            "range": [
                                900,
                                937
                            ],
                            "text": ""
                        },
                        "messageId": "removeConsole",
                        "data": {
                            "propertyName": "info"
                        },
                        "desc": "Remove the console.info()."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary optional chain on a non-nullish value.",
                "line": 63,
                "column": 28,
                "nodeType": "MemberExpression",
                "messageId": "neverOptionalChain",
                "endLine": 63,
                "endColumn": 30,
                "suggestions": [
                    {
                        "messageId": "suggestRemoveOptionalChain",
                        "fix": {
                            "range": [
                                1590,
                                1592
                            ],
                            "text": "."
                        },
                        "desc": "Remove unnecessary optional chain"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary optional chain on a non-nullish value.",
                "line": 63,
                "column": 33,
                "nodeType": "MemberExpression",
                "messageId": "neverOptionalChain",
                "endLine": 63,
                "endColumn": 35,
                "suggestions": [
                    {
                        "messageId": "suggestRemoveOptionalChain",
                        "fix": {
                            "range": [
                                1595,
                                1597
                            ],
                            "text": "."
                        },
                        "desc": "Remove unnecessary optional chain"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 65,
                "column": 8,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 65,
                "endColumn": 17,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                1621,
                                1631
                            ],
                            "text": "(debugLogs == null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                1622,
                                1631
                            ],
                            "text": "(debugLogs ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                1621,
                                1631
                            ],
                            "text": "(!Boolean(debugLogs))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 5,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "/**\n * Test Logger Utility\n *\n * Provides a test-specific logger that can be controlled via environment variables\n * to avoid polluting test output during normal test runs.\n *\n * @example\n * ```typescript\n * import { testLogger } from './test-utils/logger';\n *\n * testLogger.error('This will only log if DEBUG_TEST_LOGS is set');\n * ```\n */\n\ntype LogLevel = 'debug' | 'info' | 'warn' | 'error';\n\n/**\n * Test logger that respects environment variables for controlling output\n */\nexport const testLogger = {\n  /**\n   * Log debug messages - only shown when DEBUG_TEST_LOGS includes 'debug' or 'all'\n   */\n  debug: (...args: unknown[]): void => {\n    if (shouldLog('debug')) {\n      console.debug('[TEST:DEBUG]', ...args);\n    }\n  },\n\n  /**\n   * Log info messages - only shown when DEBUG_TEST_LOGS includes 'info' or 'all'\n   */\n  info: (...args: unknown[]): void => {\n    if (shouldLog('info')) {\n      console.info('[TEST:INFO]', ...args);\n    }\n  },\n\n  /**\n   * Log warning messages - only shown when DEBUG_TEST_LOGS includes 'warn' or 'all'\n   */\n  warn: (...args: unknown[]): void => {\n    if (shouldLog('warn')) {\n      console.warn('[TEST:WARN]', ...args);\n    }\n  },\n\n  /**\n   * Log error messages - only shown when DEBUG_TEST_LOGS includes 'error' or 'all'\n   */\n  error: (...args: unknown[]): void => {\n    if (shouldLog('error')) {\n      console.error('[TEST:ERROR]', ...args);\n    }\n  },\n};\n\n/**\n * Check if logging should be enabled for a given level\n */\nfunction shouldLog(level: LogLevel): boolean {\n  // Check for DEBUG_TEST_LOGS environment variable\n  const debugLogs = process?.env?.DEBUG_TEST_LOGS;\n\n  if (!debugLogs || debugLogs.trim() === '') {\n    return false;\n  }\n\n  const enabledLevels = debugLogs\n    .toLowerCase()\n    .split(',')\n    .map(s => s.trim());\n\n  return enabledLevels.includes('all') || enabledLevels.includes(level);\n}\n\n/**\n * Legacy console.error wrapper for backward compatibility\n * @deprecated Use testLogger.error instead\n */\nexport const testConsoleError = (...args: unknown[]): void => {\n  testLogger.error(...args);\n};\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/test-utils/mocks/handlers.ts",
        "messages": [
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'LoginCredentials' is defined but never used. Allowed unused vars must match /^_/u.",
                "line": 9,
                "column": 15,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 9,
                "endColumn": 31
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'AuthResponse' is defined but never used. Allowed unused vars must match /^_/u.",
                "line": 9,
                "column": 33,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 9,
                "endColumn": 45
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'mockUser' is defined but never used. Allowed unused vars must match /^_/u.",
                "line": 10,
                "column": 10,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 10,
                "endColumn": 18
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'mockTenant' is defined but never used. Allowed unused vars must match /^_/u.",
                "line": 10,
                "column": 20,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 10,
                "endColumn": 30
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'getEnv' is defined but never used. Allowed unused vars must match /^_/u.",
                "line": 33,
                "column": 10,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 33,
                "endColumn": 16
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 60,
                "column": 6,
                "nodeType": "ConditionalExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 60,
                "endColumn": 90,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                1783,
                                1867
                            ],
                            "text": "(typeof process !== 'undefined' && process.env ? process.env.VITE_API_URL : undefined) != null"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                1783,
                                1867
                            ],
                            "text": "(typeof process !== 'undefined' && process.env ? process.env.VITE_API_URL : undefined) ?? \"\""
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                1783,
                                1867
                            ],
                            "text": "Boolean((typeof process !== 'undefined' && process.env ? process.env.VITE_API_URL : undefined))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, value is always truthy.",
                "line": 60,
                "column": 40,
                "nodeType": "MemberExpression",
                "messageId": "alwaysTruthy",
                "endLine": 60,
                "endColumn": 51
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected object value in conditional. The condition is always true.",
                "line": 60,
                "column": 40,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorObject",
                "endLine": 60,
                "endColumn": 51
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 60,
                "column": 92,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 60,
                "endColumn": 94,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                1783,
                                1905
                            ],
                            "text": "(typeof process !== 'undefined' && process.env ? process.env.VITE_API_URL : undefined) ??\n    import.meta.env?.VITE_API_URL)"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary optional chain on a non-nullish value.",
                "line": 61,
                "column": 20,
                "nodeType": "MemberExpression",
                "messageId": "neverOptionalChain",
                "endLine": 61,
                "endColumn": 22,
                "suggestions": [
                    {
                        "messageId": "suggestRemoveOptionalChain",
                        "fix": {
                            "range": [
                                1891,
                                1893
                            ],
                            "text": "."
                        },
                        "desc": "Remove unnecessary optional chain"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 98,
                "column": 13,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 98,
                "endColumn": 24,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                2616,
                                2627
                            ],
                            "text": "(group.field != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                2616,
                                2627
                            ],
                            "text": "(group.field ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                2616,
                                2627
                            ],
                            "text": "(Boolean(group.field))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 98,
                "column": 28,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 98,
                "endColumn": 42,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                2631,
                                2645
                            ],
                            "text": "(group.operator != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                2631,
                                2645
                            ],
                            "text": "(group.operator ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                2631,
                                2645
                            ],
                            "text": "(Boolean(group.operator))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'isValidOperator' is defined but never used. Allowed unused vars must match /^_/u.",
                "line": 123,
                "column": 10,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 123,
                "endColumn": 25
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 267,
                "column": 8,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 267,
                "endColumn": 16,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                7082,
                                7091
                            ],
                            "text": "tenantId == null"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                7083,
                                7091
                            ],
                            "text": "(tenantId ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                7082,
                                7091
                            ],
                            "text": "!Boolean(tenantId)"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 279,
                "column": 8,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 279,
                "endColumn": 12,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                7426,
                                7431
                            ],
                            "text": "auth == null"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                7427,
                                7431
                            ],
                            "text": "(auth ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                7426,
                                7431
                            ],
                            "text": "!Boolean(auth)"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 288,
                "column": 8,
                "nodeType": "FunctionDeclaration",
                "messageId": "missingReturnType",
                "endLine": 288,
                "endColumn": 28
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 304,
                "column": 12,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 304,
                "endColumn": 41,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                8012,
                                8042
                            ],
                            "text": "(credentials.username_or_email == null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                8013,
                                8042
                            ],
                            "text": "(credentials.username_or_email ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                8012,
                                8042
                            ],
                            "text": "(!Boolean(credentials.username_or_email))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 304,
                "column": 46,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 304,
                "endColumn": 66,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                8046,
                                8067
                            ],
                            "text": "(credentials.password == null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                8047,
                                8067
                            ],
                            "text": "(credentials.password ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                8046,
                                8067
                            ],
                            "text": "(!Boolean(credentials.password))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 317,
                "column": 9,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 317,
                "endColumn": 30,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                8371,
                                8392
                            ],
                            "text": "(credentials.tenant_id != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                8371,
                                8392
                            ],
                            "text": "(credentials.tenant_id ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                8371,
                                8392
                            ],
                            "text": "(Boolean(credentials.tenant_id))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 317,
                "column": 31,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 317,
                "endColumn": 33,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                8393,
                                8395
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 401,
                "column": 36,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 401,
                "endColumn": 42,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                10891,
                                10897
                            ],
                            "text": "(offset != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                10891,
                                10897
                            ],
                            "text": "(offset ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                10891,
                                10897
                            ],
                            "text": "(Boolean(offset))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 401,
                "column": 43,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 401,
                "endColumn": 45,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                10898,
                                10900
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 402,
                "column": 35,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 402,
                "endColumn": 40,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                10941,
                                10946
                            ],
                            "text": "(limit != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                10941,
                                10946
                            ],
                            "text": "(limit ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                10941,
                                10946
                            ],
                            "text": "(Boolean(limit))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 402,
                "column": 41,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 402,
                "endColumn": 43,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                10947,
                                10949
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 446,
                "column": 33,
                "nodeType": "CallExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 446,
                "endColumn": 63,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                12171,
                                12201
                            ],
                            "text": "(url.searchParams.get('cursor') != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                12171,
                                12201
                            ],
                            "text": "(url.searchParams.get('cursor') ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                12171,
                                12201
                            ],
                            "text": "(Boolean(url.searchParams.get('cursor')))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 446,
                "column": 64,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 446,
                "endColumn": 66,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                12202,
                                12204
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 447,
                "column": 35,
                "nodeType": "CallExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 447,
                "endColumn": 64,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                12245,
                                12274
                            ],
                            "text": "(url.searchParams.get('limit') != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                12245,
                                12274
                            ],
                            "text": "(url.searchParams.get('limit') ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                12245,
                                12274
                            ],
                            "text": "(Boolean(url.searchParams.get('limit')))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 447,
                "column": 65,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 447,
                "endColumn": 67,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                12275,
                                12277
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 463,
                "column": 17,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 463,
                "endColumn": 22,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                12928,
                                12933
                            ],
                            "text": "(index != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                12928,
                                12933
                            ],
                            "text": "(index ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                12928,
                                12933
                            ],
                            "text": "(Boolean(index))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 463,
                "column": 26,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 463,
                "endColumn": 31,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                12937,
                                12942
                            ],
                            "text": "(field != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                12937,
                                12942
                            ],
                            "text": "(field ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                12937,
                                12942
                            ],
                            "text": "(Boolean(field))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??=`) instead of an assignment expression, as it is simpler to read.",
                "line": 464,
                "column": 15,
                "nodeType": "IfStatement",
                "messageId": "preferNullishOverAssignment",
                "endLine": 466,
                "endColumn": 16,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": "="
                        },
                        "fix": {
                            "range": [
                                12960,
                                13045
                            ],
                            "text": "filterGroups[index] ??= {};"
                        },
                        "desc": "Fix to nullish coalescing operator (`??=`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 467,
                "column": 65,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 467,
                "endColumn": 70,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                13110,
                                13115
                            ],
                            "text": "(value != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                13110,
                                13115
                            ],
                            "text": "(value ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                13110,
                                13115
                            ],
                            "text": "(Boolean(value))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 467,
                "column": 71,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 467,
                "endColumn": 73,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                13116,
                                13118
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/restrict-template-expressions",
                "severity": 1,
                "message": "Invalid type \"never\" of template literal expression.",
                "line": 510,
                "column": 66,
                "nodeType": "Identifier",
                "messageId": "invalidType",
                "endLine": 510,
                "endColumn": 74
            },
            {
                "ruleId": "@typescript-eslint/restrict-template-expressions",
                "severity": 1,
                "message": "Invalid type \"number\" of template literal expression.",
                "line": 594,
                "column": 34,
                "nodeType": "BinaryExpression",
                "messageId": "invalidType",
                "endLine": 594,
                "endColumn": 56
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 595,
                "column": 15,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 595,
                "endColumn": 24,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                17198,
                                17207
                            ],
                            "text": "(body.name != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                17198,
                                17207
                            ],
                            "text": "(body.name ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                17198,
                                17207
                            ],
                            "text": "(Boolean(body.name))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 595,
                "column": 25,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 595,
                "endColumn": 27,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                17208,
                                17210
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 596,
                "column": 17,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 596,
                "endColumn": 28,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                17241,
                                17252
                            ],
                            "text": "(body.db_url != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                17241,
                                17252
                            ],
                            "text": "(body.db_url ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                17241,
                                17252
                            ],
                            "text": "(Boolean(body.db_url))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 596,
                "column": 29,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 596,
                "endColumn": 31,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                17253,
                                17255
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-non-null-assertion",
                "severity": 1,
                "message": "Forbidden non-null assertion.",
                "line": 637,
                "column": 30,
                "nodeType": "TSNonNullExpression",
                "messageId": "noNonNull",
                "endLine": 637,
                "endColumn": 55
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 709,
                "column": 29,
                "nodeType": "CallExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 709,
                "endColumn": 57,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                20432,
                                20460
                            ],
                            "text": "(url.searchParams.get('page') != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                20432,
                                20460
                            ],
                            "text": "(url.searchParams.get('page') ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                20432,
                                20460
                            ],
                            "text": "(Boolean(url.searchParams.get('page')))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 709,
                "column": 58,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 709,
                "endColumn": 60,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                20461,
                                20463
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 710,
                "column": 30,
                "nodeType": "CallExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 710,
                "endColumn": 59,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                20499,
                                20528
                            ],
                            "text": "(url.searchParams.get('limit') != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                20499,
                                20528
                            ],
                            "text": "(url.searchParams.get('limit') ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                20499,
                                20528
                            ],
                            "text": "(Boolean(url.searchParams.get('limit')))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 710,
                "column": 60,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 710,
                "endColumn": 62,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                20529,
                                20531
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 715,
                "column": 11,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 715,
                "endColumn": 17,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                20684,
                                20690
                            ],
                            "text": "search != null"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                20684,
                                20690
                            ],
                            "text": "search ?? \"\""
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                20684,
                                20690
                            ],
                            "text": "Boolean(search)"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 835,
                "column": 11,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 835,
                "endColumn": 20,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                24291,
                                24300
                            ],
                            "text": "body.name != null"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                24291,
                                24300
                            ],
                            "text": "body.name ?? \"\""
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                24291,
                                24300
                            ],
                            "text": "Boolean(body.name)"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.",
                "line": 836,
                "column": 22,
                "nodeType": "CallExpression",
                "messageId": "neverNullish",
                "endLine": 836,
                "endColumn": 38
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 47,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "/**\n * Mock API Handlers using MSW (Mock Service Worker)\n *\n * This file defines mock HTTP handlers for all API endpoints.\n * These handlers intercept API calls during tests and return mock responses.\n */\n\nimport { http, HttpResponse } from 'msw';\nimport type { LoginCredentials, AuthResponse } from '../../types/auth';\nimport { mockUser, mockTenant } from '../render';\nimport type { Tenant as BackendTenant } from '../../types/tenant';\nimport type { ContactApiDTO } from '../../transformers/dto';\nimport { asTenantId } from '../../types/ids';\nimport { createMockAuthJwt } from '../jwt';\nimport { testLogger } from '../logger';\n\n/**\n * Request interfaces for type safety in mock handlers\n */\ninterface ContactRequestBase {\n  readonly name?: string;\n  readonly email?: string;\n  readonly phone?: string;\n  readonly age?: number;\n  readonly gender?: string;\n  readonly address?: string;\n}\n\nexport type CreateContactRequest = ContactRequestBase;\nexport type UpdateContactRequest = ContactRequestBase;\n\n// Get API base URL from environment (delay until runtime to ensure env vars are loaded)\nimport { getEnv } from '../../config/env';\n\n/**\n * Custom error classes for better error handling\n */\nexport class HttpError extends Error {\n  constructor(\n    message: string,\n    public statusCode: number\n  ) {\n    super(message);\n    this.name = 'HttpError';\n  }\n}\n\nexport class AuthError extends HttpError {\n  constructor(message: string, statusCode = 401) {\n    super(message, statusCode);\n    this.name = 'AuthError';\n  }\n}\n\n// Create a function to get the base URL at runtime instead of module load time\nfunction getApiBaseUrl(): string {\n  // In tests, prioritize process.env which Bun loads from .env files\n  // Fall back to import.meta.env for browser/build time\n  const apiUrl =\n    (typeof process !== 'undefined' && process.env ? process.env.VITE_API_URL : undefined) ||\n    import.meta.env?.VITE_API_URL ||\n    'http://localhost:8000/api';\n\n  return apiUrl;\n}\n\n/**\n * Interface for filter group parsed from query parameters\n */\ninterface FilterGroup {\n  field?: string;\n  operator?: string;\n  value?: string;\n}\n\n/**\n * Type-safe parsed filter with validated field and operator\n */\ninterface ParsedFilter {\n  field: keyof BackendTenant;\n  operator: Operator;\n  value: string;\n}\n\n/**\n * Allowed filter operators\n */\ntype Operator = 'eq' | 'ne' | 'like' | 'gt' | 'lt' | 'gte' | 'lte';\n\n/**\n * Type guard to validate if a filter group can be converted to a ParsedFilter\n */\nfunction isValidFilterGroup(group: FilterGroup): group is FilterGroup & {\n  field: string;\n  operator: string;\n  value: string;\n} {\n  return !!(group.field && group.operator && group.value !== undefined);\n}\n\n/**\n * Centralized tenant field definitions to avoid duplication\n * This is the single source of truth for valid tenant fields\n */\nconst BACKEND_TENANT_FIELDS = ['id', 'name', 'db_url', 'created_at', 'updated_at'] as const;\n\n/**\n * Export the tenant fields as VALID_TENANT_FIELDS for use in tests\n */\nexport const VALID_TENANT_FIELDS = BACKEND_TENANT_FIELDS;\ntype TenantFilterField = (typeof BACKEND_TENANT_FIELDS)[number];\n\n/**\n * Type guard to validate if a field is a valid tenant field\n */\nfunction isValidTenantField(field: string): field is TenantFilterField {\n  return (BACKEND_TENANT_FIELDS as readonly string[]).includes(field);\n}\n\n/**\n * Type guard to validate if an operator is a valid operator\n */\nfunction isValidOperator(operator: string): operator is Operator {\n  const validOperators: Operator[] = ['eq', 'ne', 'like', 'gt', 'lt'];\n  return validOperators.includes(operator as Operator);\n}\n\n/**\n * Translate frontend filter operators to backend operators\n * Frontend uses user-friendly names like 'contains', 'equals'\n * Backend expects 'like', 'eq', etc.\n */\nfunction translateOperator(frontendOp: string): Operator {\n  const operatorMap: Record<string, Operator> = {\n    contains: 'like',\n    equals: 'eq',\n    'greater than': 'gt',\n    'greater or equal': 'gte',\n    'less than': 'lt',\n    'less or equal': 'lte',\n    // Direct backend operators (already in correct format)\n    like: 'like',\n    eq: 'eq',\n    ne: 'ne',\n    gt: 'gt',\n    lt: 'lt',\n  };\n\n  const translated = operatorMap[frontendOp.toLowerCase()];\n  if (!translated) {\n    testLogger.warn(`Unknown operator \"${frontendOp}\", defaulting to 'like'`);\n    return 'like';\n  }\n  return translated;\n}\n\n/**\n * Convert value to number or timestamp for comparison\n * Handles both numeric values and date strings\n */\nfunction toNumberOrTime(value: unknown): number {\n  if (typeof value === 'number') return value;\n  const n = Number(value);\n  if (!Number.isNaN(n)) return n;\n  const t = Date.parse(String(value));\n  return Number.isNaN(t) ? NaN : t;\n}\n\n/**\n * Parse and validate a filter group into a ParsedFilter\n * Returns null if the filter is invalid\n */\nfunction parseFilterGroup(group: FilterGroup): ParsedFilter | null {\n  if (!isValidFilterGroup(group)) {\n    return null;\n  }\n\n  if (!isValidTenantField(group.field)) {\n    testLogger.warn(`Invalid tenant field in filter: \"${group.field}\"`);\n    return null;\n  }\n\n  // Translate frontend operator to backend operator\n  const translatedOp = translateOperator(group.operator);\n\n  return {\n    field: group.field,\n    operator: translatedOp,\n    value: group.value,\n  };\n}\n\n/**\n * Factory function for mock contacts\n */\nfunction createMockContacts(baseDate: Date | string = '2024-01-15T10:30:00.000Z'): ContactApiDTO[] {\n  const timestamp = new Date(baseDate).toISOString();\n\n  return [\n    {\n      id: 1,\n      tenant_id: 'tenant-1',\n      first_name: 'John',\n      last_name: 'Doe',\n      email: 'john.doe@example.com',\n      phone: '+1234567890',\n      age: 30,\n      gender: 'male',\n      created_at: timestamp,\n      updated_at: timestamp,\n    },\n    {\n      id: 2,\n      tenant_id: 'tenant-1',\n      first_name: 'Jane',\n      last_name: 'Smith',\n      email: 'jane.smith@example.com',\n      phone: '+0987654321',\n      age: 28,\n      gender: 'female',\n      created_at: timestamp,\n      updated_at: timestamp,\n    },\n  ];\n}\n\n/**\n * Factory function for mock tenants\n */\nfunction createMockTenants(baseDate: Date | string = '2024-01-15T10:30:00.000Z'): BackendTenant[] {\n  const timestamp = new Date(baseDate).toISOString();\n\n  return [\n    {\n      id: asTenantId('tenant-1'),\n      name: 'Test Tenant 1',\n      db_url: 'postgres://localhost:5432/tenant-1',\n      created_at: timestamp,\n      updated_at: timestamp,\n    },\n    {\n      id: asTenantId('tenant-2'),\n      name: 'Test Tenant 2',\n      db_url: 'postgres://localhost:5432/tenant2',\n      created_at: timestamp,\n      updated_at: timestamp,\n    },\n  ];\n}\n\n/**\n * Mock contacts database\n */\nlet mockContacts: ContactApiDTO[] = createMockContacts();\n\n/**\n * Mock tenants database\n */\nexport let mockTenants: BackendTenant[] = createMockTenants();\n\n/**\n * Helper to assert request headers for tenant-scoped operations\n * Returns tenant ID if valid, throws error if headers are missing\n */\nfunction getTenantIdFromHeaders(request: Request): string {\n  const tenantId = request.headers.get('x-tenant-id');\n  if (!tenantId) {\n    throw new HttpError('Missing required x-tenant-id header', 400);\n  }\n  return tenantId;\n}\n\n/**\n * Helper to assert Authorization header\n * Returns the token value if present, throws error if missing\n */\nfunction getAuthorizationFromHeaders(request: Request): string {\n  const auth = request.headers.get('authorization');\n  if (!auth) {\n    throw new AuthError('Missing required Authorization header', 401);\n  }\n  return auth;\n}\n\n/**\n * API Request Handlers\n */\nexport function getHandlers() {\n  const API_BASE_URL = getApiBaseUrl();\n  return [\n    // ============ Authentication ============\n\n    /**\n     * POST /auth/login - Login endpoint\n     */\n    http.post(`${API_BASE_URL}/auth/login`, async ({ request }) => {\n      const credentials = (await request.json()) as {\n        username_or_email?: string;\n        password?: string;\n        tenant_id?: string;\n      };\n\n      // Simulate validation\n      if (!credentials.username_or_email || !credentials.password) {\n        return HttpResponse.json(\n          {\n            message: 'Invalid credentials',\n            data: null,\n          },\n          { status: 400 }\n        );\n      }\n\n      // Create a valid mock JWT token\n      const mockJwt = createMockAuthJwt(\n        credentials.username_or_email,\n        credentials.tenant_id || 'tenant-1'\n      );\n\n      // Simulate successful login - backend returns TokenBodyResponse\n      return HttpResponse.json(\n        {\n          message: 'Login successful',\n          data: {\n            access_token: mockJwt,\n            refresh_token: 'mock-refresh-token-67890',\n            token_type: 'bearer',\n          },\n        },\n        { status: 200 }\n      );\n    }),\n\n    /**\n     * POST /auth/logout - Logout endpoint\n     */\n    http.post(`${API_BASE_URL}/auth/logout`, ({ request }) => {\n      // Validate required headers for authenticated operation\n      try {\n        getAuthorizationFromHeaders(request);\n        getTenantIdFromHeaders(request);\n      } catch (e) {\n        return HttpResponse.json({ message: (e as Error).message, data: null }, { status: 401 });\n      }\n\n      return HttpResponse.json(\n        {\n          message: 'Logout successful',\n          data: {},\n        },\n        { status: 200 }\n      );\n    }),\n\n    /**\n     * POST /auth/refresh - Refresh token endpoint\n     */\n    http.post(`${API_BASE_URL}/auth/refresh`, ({ request }) => {\n      // Validate required headers for authenticated operation\n      try {\n        getAuthorizationFromHeaders(request);\n      } catch (e) {\n        return HttpResponse.json({ message: (e as Error).message, data: null }, { status: 401 });\n      }\n\n      // Create a valid mock JWT token for refresh\n      const mockJwt = createMockAuthJwt('refreshed-user', 'tenant-1');\n\n      return HttpResponse.json(\n        {\n          message: 'Token refreshed',\n          data: {\n            access_token: mockJwt,\n            refresh_token: 'mock-new-refresh-token-67890',\n            token_type: 'bearer',\n          },\n        },\n        { status: 200 }\n      );\n    }),\n\n    // ============ Tenants ============\n\n    /**\n     * GET /admin/tenants - Get all tenants (with or without pagination support)\n     */\n    http.get(`${API_BASE_URL}/admin/tenants`, ({ request }) => {\n      // Validate required headers for authenticated operation\n      try {\n        getAuthorizationFromHeaders(request);\n      } catch (e) {\n        return HttpResponse.json({ message: (e as Error).message, data: null }, { status: 401 });\n      }\n\n      const url = new URL(request.url);\n      const offset = url.searchParams.get('offset');\n      const limit = url.searchParams.get('limit');\n\n      // If pagination parameters are present, return paginated response\n      if (offset !== null || limit !== null) {\n        const offsetNum = parseInt(offset || '0');\n        const limitNum = parseInt(limit || '10');\n\n        // Simple pagination\n        const paginatedTenants = mockTenants.slice(offsetNum, offsetNum + limitNum);\n\n        return HttpResponse.json(\n          {\n            status: 'success',\n            message: 'Success',\n            data: {\n              data: paginatedTenants,\n              total: mockTenants.length,\n              offset: offsetNum,\n              limit: limitNum,\n            },\n          },\n          { status: 200 }\n        );\n      }\n\n      // Otherwise return simple array for getAll()\n      return HttpResponse.json(\n        {\n          status: 'success',\n          message: 'Success',\n          data: mockTenants,\n        },\n        { status: 200 }\n      );\n    }),\n\n    /**\n     * GET /admin/tenants/filter - Filter tenants (MUST be before /:id to match specific path)\n     */\n    http.get(`${API_BASE_URL}/admin/tenants/filter`, ({ request }) => {\n      // Validate required headers for authenticated operation\n      try {\n        getAuthorizationFromHeaders(request);\n      } catch (e) {\n        return HttpResponse.json({ message: (e as Error).message, data: null }, { status: 401 });\n      }\n\n      try {\n        const url = new URL(request.url);\n        const cursor = parseInt(url.searchParams.get('cursor') || '0');\n        const pageSize = parseInt(url.searchParams.get('limit') || '10');\n\n        // Parse filters from query parameters (qs.stringify with arrayFormat: 'indices')\n        const filters: ParsedFilter[] = [];\n        const filterKeys = Array.from(url.searchParams.keys()).filter(key =>\n          key.startsWith('filters[')\n        );\n\n        // Group filter parameters by index\n        const filterGroups: Record<string, FilterGroup> = {};\n        filterKeys.forEach(key => {\n          const match = /^filters\\[(\\d+)\\]\\[(\\w+)\\]$/.exec(key);\n          if (match) {\n            const [, indexStr, field] = match;\n            const value = url.searchParams.get(key);\n            const index = indexStr;\n            if (index && field) {\n              if (!filterGroups[index]) {\n                filterGroups[index] = {};\n              }\n              filterGroups[index][field as keyof FilterGroup] = value || undefined;\n            }\n          }\n        });\n\n        // Convert to array with type-safe validation\n        Object.values(filterGroups).forEach(group => {\n          const parsedFilter = parseFilterGroup(group);\n          if (parsedFilter) {\n            filters.push(parsedFilter);\n          }\n        });\n\n        let filteredTenants = [...mockTenants];\n\n        // Apply filters\n        if (filters.length > 0) {\n          filteredTenants = mockTenants.filter(tenant => {\n            return filters.every((filter: ParsedFilter) => {\n              const { field, operator, value } = filter;\n              const tenantValue = tenant[field];\n\n              switch (operator) {\n                case 'eq':\n                  return tenantValue === value;\n                case 'ne':\n                  return tenantValue !== value;\n                case 'like':\n                  return (\n                    typeof tenantValue === 'string' &&\n                    tenantValue.toLowerCase().includes(value.toLowerCase())\n                  );\n                case 'gt':\n                  return toNumberOrTime(tenantValue) > toNumberOrTime(value);\n                case 'lt':\n                  return toNumberOrTime(tenantValue) < toNumberOrTime(value);\n                case 'gte':\n                  return toNumberOrTime(tenantValue) >= toNumberOrTime(value);\n                case 'lte':\n                  return toNumberOrTime(tenantValue) <= toNumberOrTime(value);\n                default:\n                  // This should never happen due to type guards, but keeping for safety\n                  throw new Error(\n                    `Invalid filter operator in mock handler: \"${operator}\" for field \"${field}\" with value \"${value}\". ` +\n                      `Supported operators: eq, ne, like, gt, lt, gte, lte`\n                  );\n              }\n            });\n          });\n        }\n\n        // Apply cursor-based pagination\n        const startIndex = cursor;\n        const endIndex = startIndex + pageSize;\n        const paginatedTenants = filteredTenants.slice(startIndex, endIndex);\n\n        return HttpResponse.json(\n          {\n            message: 'Success',\n            data: {\n              data: paginatedTenants,\n              total: filteredTenants.length,\n              offset: startIndex,\n              limit: pageSize,\n            },\n          },\n          { status: 200 }\n        );\n      } catch (error) {\n        testLogger.error('Filter handler error:', error);\n        return HttpResponse.json(\n          {\n            message: 'Internal server error',\n            error: 'Failed to process filter request',\n          },\n          { status: 500 }\n        );\n      }\n    }),\n\n    /**\n     * GET /admin/tenants/:id - Get tenant by ID\n     */\n    http.get(`${API_BASE_URL}/admin/tenants/:id`, ({ params, request }) => {\n      // Validate required headers for authenticated operation\n      try {\n        getAuthorizationFromHeaders(request);\n      } catch (e) {\n        return HttpResponse.json({ message: (e as Error).message, data: null }, { status: 401 });\n      }\n\n      const { id } = params;\n      const tenant = mockTenants.find(t => t.id === id);\n\n      if (!tenant) {\n        return HttpResponse.json(\n          {\n            message: 'Tenant not found',\n            data: null,\n          },\n          { status: 404 }\n        );\n      }\n\n      return HttpResponse.json(\n        {\n          message: 'Success',\n          data: tenant,\n        },\n        { status: 200 }\n      );\n    }),\n\n    /**\n     * POST /admin/tenants - Create tenant\n     */\n    http.post(`${API_BASE_URL}/admin/tenants`, async ({ request }) => {\n      // Validate required headers for authenticated operation\n      try {\n        getAuthorizationFromHeaders(request);\n      } catch (e) {\n        return HttpResponse.json({ message: (e as Error).message, data: null }, { status: 401 });\n      }\n\n      const body = (await request.json()) as Partial<BackendTenant>;\n\n      const newTenant: BackendTenant = {\n        id: asTenantId(`tenant-${mockTenants.length + 1}`),\n        name: body.name || 'New Tenant',\n        db_url: body.db_url || 'postgres://localhost:5432/new_tenant',\n        created_at: new Date().toISOString(),\n        updated_at: new Date().toISOString(),\n      };\n\n      mockTenants.push(newTenant);\n\n      return HttpResponse.json(\n        {\n          message: 'Tenant created',\n          data: newTenant,\n        },\n        { status: 201 }\n      );\n    }),\n\n    /**\n     * PUT /admin/tenants/:id - Update tenant\n     */\n    http.put(`${API_BASE_URL}/admin/tenants/:id`, async ({ params, request }) => {\n      // Validate required headers for authenticated operation\n      try {\n        getAuthorizationFromHeaders(request);\n      } catch (e) {\n        return HttpResponse.json({ message: (e as Error).message, data: null }, { status: 401 });\n      }\n\n      const { id } = params;\n      const body = (await request.json()) as Partial<BackendTenant>;\n      const tenantIndex = mockTenants.findIndex(t => t.id === id);\n\n      if (tenantIndex === -1) {\n        return HttpResponse.json(\n          {\n            message: 'Tenant not found',\n            data: null,\n          },\n          { status: 404 }\n        );\n      }\n\n      const existingTenant = mockTenants[tenantIndex]!;\n\n      const updatedTenant: BackendTenant = {\n        id: existingTenant.id,\n        name: body.name ?? existingTenant.name,\n        db_url: body.db_url ?? existingTenant.db_url,\n        created_at: existingTenant.created_at,\n        updated_at: new Date().toISOString(),\n      };\n\n      mockTenants[tenantIndex] = updatedTenant;\n\n      return HttpResponse.json(\n        {\n          message: 'Tenant updated',\n          data: mockTenants[tenantIndex],\n        },\n        { status: 200 }\n      );\n    }),\n\n    /**\n     * DELETE /admin/tenants/:id - Delete tenant\n     */\n    http.delete(`${API_BASE_URL}/admin/tenants/:id`, ({ params, request }) => {\n      // Validate required headers for authenticated operation\n      try {\n        getAuthorizationFromHeaders(request);\n      } catch (e) {\n        return HttpResponse.json({ message: (e as Error).message, data: null }, { status: 401 });\n      }\n\n      const { id } = params;\n      const tenantIndex = mockTenants.findIndex(t => t.id === id);\n\n      if (tenantIndex === -1) {\n        return HttpResponse.json(\n          {\n            message: 'Tenant not found',\n            data: null,\n          },\n          { status: 404 }\n        );\n      }\n\n      mockTenants.splice(tenantIndex, 1);\n\n      return HttpResponse.json(\n        {\n          message: 'Tenant deleted',\n          data: null,\n        },\n        { status: 200 }\n      );\n    }),\n\n    // ============ Contacts / Address Book ============\n\n    /**\n     * GET /address-book - Get all contacts (with pagination support)\n     */\n    http.get(`${API_BASE_URL}/address-book`, ({ request }) => {\n      // Validate required headers for authenticated operation\n      try {\n        getAuthorizationFromHeaders(request);\n        getTenantIdFromHeaders(request);\n      } catch (e) {\n        const status = e instanceof HttpError ? e.statusCode : 500;\n        return HttpResponse.json({ message: (e as Error).message, data: null }, { status });\n      }\n\n      const url = new URL(request.url);\n      const page = parseInt(url.searchParams.get('page') || '1');\n      const limit = parseInt(url.searchParams.get('limit') || '10');\n      const search = url.searchParams.get('search');\n\n      // Simple search implementation\n      let filteredContacts = mockContacts;\n      if (search) {\n        filteredContacts = mockContacts.filter(\n          contact =>\n            (contact.first_name?.toLowerCase().includes(search.toLowerCase()) ?? false) ||\n            (contact.last_name?.toLowerCase().includes(search.toLowerCase()) ?? false) ||\n            (contact.email?.toLowerCase().includes(search.toLowerCase()) ?? false)\n        );\n      }\n\n      // Simple pagination\n      const offset = (page - 1) * limit;\n      const paginatedContacts = filteredContacts.slice(offset, offset + limit);\n      const totalPages = Math.ceil(filteredContacts.length / limit);\n\n      return HttpResponse.json(\n        {\n          message: 'Success',\n          data: {\n            contacts: paginatedContacts,\n            total: filteredContacts.length,\n            page,\n            limit,\n            totalPages,\n            hasNext: page < totalPages,\n            hasPrev: page > 1,\n          },\n        },\n        { status: 200 }\n      );\n    }),\n\n    http.get(`${API_BASE_URL}/address-book/:id`, ({ params, request }) => {\n      // Validate required headers for authenticated operation\n      try {\n        getAuthorizationFromHeaders(request);\n        getTenantIdFromHeaders(request);\n      } catch (e) {\n        const status = e instanceof HttpError ? e.statusCode : 500;\n        return HttpResponse.json({ message: (e as Error).message, data: null }, { status });\n      }\n\n      const id = Number(params.id);\n      const contact = mockContacts.find(c => c.id === id);\n\n      if (!contact) {\n        return HttpResponse.json(\n          {\n            message: 'Contact not found',\n            data: null,\n          },\n          { status: 404 }\n        );\n      }\n\n      return HttpResponse.json(\n        {\n          message: 'Success',\n          data: contact,\n        },\n        { status: 200 }\n      );\n    }),\n\n    /**\n     * POST /address-book - Create contact\n     */\n    http.post(`${API_BASE_URL}/address-book`, async ({ request }) => {\n      const body = (await request.json()) as CreateContactRequest;\n\n      // Safely parse name into first and last name parts\n      const name = body.name?.trim() ?? '';\n      const parts = name.split(/\\s+/).filter(part => part.length > 0);\n      const first_name = parts[0] ?? 'Unknown';\n      const last_name = parts.slice(1).join(' ') || 'User';\n\n      const newContact = {\n        id: Math.max(0, ...mockContacts.map(c => Number(c.id)).filter(id => !isNaN(id))) + 1,\n        tenant_id: 'tenant-1', // Mock tenant ID\n        first_name,\n        last_name,\n        email: body.email,\n        phone: body.phone,\n        age: body.age,\n        gender: body.gender,\n        address: body.address,\n        created_at: new Date().toISOString(),\n        updated_at: new Date().toISOString(),\n      };\n\n      mockContacts.push(newContact);\n\n      return HttpResponse.json(\n        {\n          message: 'Contact created',\n          data: newContact,\n        },\n        { status: 201 }\n      );\n    }),\n\n    /**\n     * PUT /address-book/:id - Update contact\n     */\n    http.put(`${API_BASE_URL}/address-book/:id`, async ({ params, request }) => {\n      const id = Number(params.id);\n      const body = (await request.json()) as UpdateContactRequest;\n      const contactIndex = mockContacts.findIndex(c => c.id === id);\n\n      if (contactIndex === -1) {\n        return HttpResponse.json(\n          {\n            message: 'Contact not found',\n            data: null,\n          },\n          { status: 404 }\n        );\n      }\n\n      // Convert API request format to ContactApiDTO format using typed body\n      const updates: Record<string, unknown> = {};\n      if (body.name) {\n        const name = body.name.trim() ?? '';\n        const parts = name.split(/\\s+/).filter(part => part.length > 0);\n        updates.first_name = parts[0] ?? 'Unknown';\n        updates.last_name = parts.slice(1).join(' ') || 'User';\n      }\n      if (body.email !== undefined) updates.email = body.email;\n      if (body.phone !== undefined) updates.phone = body.phone;\n      if (body.age !== undefined) updates.age = body.age;\n      if (body.gender !== undefined) updates.gender = body.gender;\n      if (body.address !== undefined) updates.address = body.address;\n\n      mockContacts[contactIndex] = {\n        ...mockContacts[contactIndex],\n        ...updates,\n        updated_at: new Date().toISOString(),\n      } as ContactApiDTO;\n\n      return HttpResponse.json(\n        {\n          message: 'Contact updated',\n          data: mockContacts[contactIndex],\n        },\n        { status: 200 }\n      );\n    }),\n\n    /**\n     * DELETE /address-book/:id - Delete contact\n     */\n    http.delete(`${API_BASE_URL}/address-book/:id`, ({ params, request }) => {\n      // Validate required headers for authenticated operation\n      try {\n        getAuthorizationFromHeaders(request);\n        getTenantIdFromHeaders(request);\n      } catch (e) {\n        const status = e instanceof HttpError ? e.statusCode : 500;\n        return HttpResponse.json({ message: (e as Error).message, data: null }, { status });\n      }\n\n      const id = Number(params.id);\n      const contactIndex = mockContacts.findIndex(c => c.id === id);\n\n      if (contactIndex === -1) {\n        return HttpResponse.json(\n          {\n            message: 'Contact not found',\n            data: null,\n          },\n          { status: 404 }\n        );\n      }\n\n      mockContacts.splice(contactIndex, 1);\n\n      return HttpResponse.json(\n        {\n          message: 'Contact deleted',\n          data: null,\n        },\n        { status: 200 }\n      );\n    }),\n\n    // ============ Health Check ============\n\n    /**\n     * GET /health - Health check endpoint\n     */\n    http.get(`${API_BASE_URL}/health`, () => {\n      return HttpResponse.json(\n        {\n          message: 'Service is healthy',\n          data: {\n            status: 'ok',\n            timestamp: new Date().toISOString(),\n            uptime: 123456,\n          },\n        },\n        { status: 200 }\n      );\n    }),\n\n    /**\n     * GET /ping - Simple ping endpoint\n     */\n    http.get(`${API_BASE_URL}/ping`, () => {\n      return HttpResponse.json(\n        {\n          message: 'pong',\n          data: { timestamp: new Date().toISOString() },\n        },\n        { status: 200 }\n      );\n    }),\n  ];\n}\n\n/**\n * Reset mock databases to initial state\n * Useful for cleaning up between tests\n */\nexport function resetMockData(): void {\n  mockContacts = createMockContacts();\n  mockTenants = createMockTenants();\n}\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/test-utils/mocks/server.ts",
        "messages": [
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 16,
                "column": 1,
                "nodeType": "FunctionDeclaration",
                "messageId": "missingReturnType",
                "endLine": 16,
                "endColumn": 22
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??=`) instead of an assignment expression, as it is simpler to read.",
                "line": 17,
                "column": 3,
                "nodeType": "IfStatement",
                "messageId": "preferNullishOverAssignment",
                "endLine": 19,
                "endColumn": 4,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": "="
                        },
                        "fix": {
                            "range": [
                                434,
                                498
                            ],
                            "text": "_server ??= setupServer(...getHandlers());"
                        },
                        "desc": "Fix to nullish coalescing operator (`??=`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 27,
                "column": 8,
                "nodeType": "FunctionDeclaration",
                "messageId": "missingReturnType",
                "endLine": 27,
                "endColumn": 26
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 35,
                "column": 11,
                "nodeType": "VariableDeclarator",
                "messageId": "anyAssignment",
                "endLine": 35,
                "endColumn": 48
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 35,
                "column": 28,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 35,
                "endColumn": 31,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                918,
                                921
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                918,
                                921
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access [prop as string] on an `any` value.",
                "line": 35,
                "column": 33,
                "nodeType": "TSAsExpression",
                "messageId": "unsafeMemberExpression",
                "endLine": 35,
                "endColumn": 47
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-return",
                "severity": 1,
                "message": "Unsafe return of a value of type `any`.",
                "line": 37,
                "column": 5,
                "nodeType": "ReturnStatement",
                "messageId": "unsafeReturn",
                "endLine": 37,
                "endColumn": 67
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-call",
                "severity": 1,
                "message": "Unsafe call of a(n) `any` typed value.",
                "line": 37,
                "column": 42,
                "nodeType": "MemberExpression",
                "messageId": "unsafeCall",
                "endLine": 37,
                "endColumn": 52
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .bind on an `any` value.",
                "line": 37,
                "column": 48,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 37,
                "endColumn": 52
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 9,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "/**\n * Mock Service Worker (MSW) Server Setup\n *\n * This file configures the MSW server for intercepting API calls in tests.\n */\n\nimport { setupServer } from 'msw/node';\nimport { getHandlers, resetMockData } from './handlers';\n\n/**\n * Lazy-initialized MSW Server instance\n * Delayed until first use to ensure environment variables are loaded\n */\nlet _server: ReturnType<typeof setupServer> | null = null;\n\nfunction ensureServer() {\n  if (!_server) {\n    _server = setupServer(...getHandlers());\n  }\n  return _server;\n}\n\n/**\n * Get the MSW server instance\n * Lazily initializes on first call\n */\nexport function getServer() {\n  return ensureServer();\n}\n\n// Create a lazy proxy for backward compatibility\nexport const server = new Proxy({} as unknown as ReturnType<typeof setupServer>, {\n  get(_target, prop, _receiver) {\n    const inst = ensureServer() as unknown as Record<string, unknown>;\n    const value = (inst as any)[prop as string];\n    // Bind functions to preserve 'this' context\n    return typeof value === 'function' ? value.bind(inst) : value;\n  },\n  has(_target, prop) {\n    const inst = ensureServer() as unknown as Record<string, unknown>;\n    return prop in inst;\n  },\n});\n\n/**\n * Setup MSW server for all tests\n * Call this in your test setup file or beforeAll hooks\n */\nexport function setupMSW(): void {\n  // Start server before all tests\n  ensureServer().listen({\n    onUnhandledRequest: 'warn', // Warn about unhandled requests\n  });\n}\n\n/**\n * Cleanup MSW server after all tests\n * Call this in your test teardown file or afterAll hooks\n */\nexport function teardownMSW(): void {\n  // Close server after all tests\n  if (_server) {\n    _server.close();\n  }\n}\n\n/**\n * Reset handlers and mock data between tests\n * Call this in beforeEach or afterEach hooks\n */\nexport function resetMSW(): void {\n  // Reset handlers to initial state\n  if (_server) {\n    _server.resetHandlers();\n  }\n\n  // Reset mock data\n  resetMockData();\n}\n\n// Re-export utilities\nexport { getHandlers, resetMockData } from './handlers';\nexport { http, HttpResponse } from 'msw';\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/test-utils/render.tsx",
        "messages": [
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'AuthContextType' is defined but never used. Allowed unused vars must match /^_/u.",
                "line": 14,
                "column": 28,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 14,
                "endColumn": 43
            },
            {
                "ruleId": "react-refresh/only-export-components",
                "severity": 1,
                "message": "Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.",
                "line": 19,
                "column": 14,
                "nodeType": "Identifier",
                "messageId": "namedExport",
                "endLine": 19,
                "endColumn": 28
            },
            {
                "ruleId": "react-refresh/only-export-components",
                "severity": 1,
                "message": "Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.",
                "line": 34,
                "column": 14,
                "nodeType": "Identifier",
                "messageId": "namedExport",
                "endLine": 34,
                "endColumn": 32
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 82,
                "column": 28,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingReturnType",
                "endLine": 82,
                "endColumn": 30
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 90,
                "column": 29,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingReturnType",
                "endLine": 90,
                "endColumn": 31
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 98,
                "column": 35,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingReturnType",
                "endLine": 98,
                "endColumn": 37
            },
            {
                "ruleId": "react-refresh/only-export-components",
                "severity": 1,
                "message": "Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.",
                "line": 102,
                "column": 14,
                "nodeType": "Identifier",
                "messageId": "namedExport",
                "endLine": 102,
                "endColumn": 56
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 174,
                "column": 8,
                "nodeType": "FunctionDeclaration",
                "messageId": "missingReturnType",
                "endLine": 174,
                "endColumn": 36
            },
            {
                "ruleId": "react-refresh/only-export-components",
                "severity": 1,
                "message": "Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.",
                "line": 174,
                "column": 17,
                "nodeType": "Identifier",
                "messageId": "namedExport",
                "endLine": 174,
                "endColumn": 36
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 190,
                "column": 65,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingReturnType",
                "endLine": 190,
                "endColumn": 67
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 215,
                "column": 8,
                "nodeType": "FunctionDeclaration",
                "messageId": "missingReturnType",
                "endLine": 215,
                "endColumn": 31
            },
            {
                "ruleId": "react-refresh/only-export-components",
                "severity": 1,
                "message": "Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.",
                "line": 215,
                "column": 17,
                "nodeType": "Identifier",
                "messageId": "namedExport",
                "endLine": 215,
                "endColumn": 31
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 229,
                "column": 50,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingReturnType",
                "endLine": 229,
                "endColumn": 52
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 249,
                "column": 8,
                "nodeType": "FunctionDeclaration",
                "messageId": "missingReturnType",
                "endLine": 249,
                "endColumn": 34
            },
            {
                "ruleId": "react-refresh/only-export-components",
                "severity": 1,
                "message": "Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.",
                "line": 249,
                "column": 17,
                "nodeType": "Identifier",
                "messageId": "namedExport",
                "endLine": 249,
                "endColumn": 34
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 269,
                "column": 8,
                "nodeType": "FunctionDeclaration",
                "messageId": "missingReturnType",
                "endLine": 269,
                "endColumn": 44
            },
            {
                "ruleId": "react-refresh/only-export-components",
                "severity": 1,
                "message": "Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.",
                "line": 269,
                "column": 17,
                "nodeType": "Identifier",
                "messageId": "namedExport",
                "endLine": 269,
                "endColumn": 44
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 277,
                "column": 97,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingReturnType",
                "endLine": 277,
                "endColumn": 99
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 289,
                "column": 64,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingReturnType",
                "endLine": 289,
                "endColumn": 66
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 321,
                "column": 8,
                "nodeType": "FunctionDeclaration",
                "messageId": "missingReturnType",
                "endLine": 321,
                "endColumn": 37
            },
            {
                "ruleId": "react-refresh/only-export-components",
                "severity": 1,
                "message": "Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.",
                "line": 321,
                "column": 17,
                "nodeType": "Identifier",
                "messageId": "namedExport",
                "endLine": 321,
                "endColumn": 37
            },
            {
                "ruleId": "react-refresh/only-export-components",
                "severity": 1,
                "message": "Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.",
                "line": 357,
                "column": 14,
                "nodeType": "Identifier",
                "messageId": "namedExport",
                "endLine": 357,
                "endColumn": 19
            },
            {
                "ruleId": "react-refresh/only-export-components",
                "severity": 1,
                "message": "Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.",
                "line": 377,
                "column": 17,
                "nodeType": "Identifier",
                "messageId": "namedExport",
                "endLine": 377,
                "endColumn": 31
            },
            {
                "ruleId": "react-refresh/only-export-components",
                "severity": 1,
                "message": "This rule can't verify that `export *` only exports components.",
                "line": 394,
                "column": 1,
                "nodeType": "ExportAllDeclaration",
                "messageId": "exportAll",
                "endLine": 394,
                "endColumn": 40
            },
            {
                "ruleId": "react-refresh/only-export-components",
                "severity": 1,
                "message": "Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.",
                "line": 395,
                "column": 21,
                "nodeType": "Identifier",
                "messageId": "namedExport",
                "endLine": 395,
                "endColumn": 30
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 25,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "/**\n * Test Utilities - Custom Render with Providers\n *\n * This file provides utilities for rendering React components\n * in tests with all necessary providers (Router, AuthContext, Ant Design).\n */\n\nimport React, { type ReactElement } from 'react';\nimport { render, type RenderOptions } from '@testing-library/react';\nimport { BrowserRouter, MemoryRouter, useLocation } from 'react-router-dom';\nimport { App as AntApp } from 'antd';\nimport type { User, LoginCredentials, Tenant } from '../types/auth';\nimport { asTenantId, asUserId } from '../types/ids';\nimport { AuthContext, type AuthContextType } from '../contexts/AuthContext';\n\n/**\n * Mock user data for testing\n */\nexport const mockUser: User = {\n  id: asUserId('user-1'),\n  username: 'testuser',\n  email: 'test@example.com',\n  firstName: 'Test',\n  lastName: 'User',\n  roles: ['user'],\n  tenantId: asTenantId('tenant-1'),\n  createdAt: new Date().toISOString(),\n  updatedAt: new Date().toISOString(),\n};\n\n/**\n * Mock tenant data for testing\n */\nexport const mockTenant: Tenant = {\n  id: asTenantId('tenant-1'),\n  name: 'Test Tenant',\n  domain: 'test.example.com',\n  settings: {\n    theme: 'light' as const,\n    language: 'en',\n    timezone: 'UTC',\n    dateFormat: 'YYYY-MM-DD',\n    features: ['contacts', 'dashboard'],\n    branding: {\n      primaryColor: '#1890ff',\n      secondaryColor: '#52c41a',\n      accentColor: '#faad14',\n    },\n  },\n  subscription: {\n    plan: 'professional' as const,\n    status: 'active' as const,\n    limits: {\n      users: 25,\n      contacts: 10000,\n      storage: 10737418240, // 10GB\n    },\n  },\n};\n\n/**\n * Mock AuthContext value\n */\nexport interface MockAuthContextValue {\n  isAuthenticated: boolean;\n  user: User | null;\n  tenant: Tenant | null;\n  isLoading: boolean;\n  login: (credentials: LoginCredentials) => Promise<void>;\n  logout: () => Promise<void>;\n  refreshToken: () => Promise<void>;\n}\n\n/**\n * Mock AuthContext value - define functions separately to ensure stability\n */\n\n/**\n * Fallback mock for login function. Returns a resolved promise and can be overridden\n * by test-specific mocks.\n */\nconst mockLogin = async () => {\n  return Promise.resolve();\n};\n\n/**\n * Fallback mock for logout function. Returns a resolved promise and can be overridden\n * by test-specific mocks.\n */\nconst mockLogout = async () => {\n  return Promise.resolve();\n};\n\n/**\n * Fallback mock for refreshToken function. Returns a resolved promise and can be overridden\n * by test-specific mocks.\n */\nconst mockRefreshToken = async () => {\n  return Promise.resolve();\n};\n\nexport const mockAuthContextValue: MockAuthContextValue = {\n  isAuthenticated: true,\n  user: mockUser,\n  tenant: mockTenant,\n  isLoading: false,\n  login: mockLogin,\n  logout: mockLogout,\n  refreshToken: mockRefreshToken,\n};\n\n/**\n * Options for custom render function\n */\nexport interface CustomRenderOptions extends Omit<RenderOptions, 'wrapper'> {\n  /**\n   * Initial route for MemoryRouter\n   */\n  initialRoute?: string;\n\n  /**\n   * Initial routes history for MemoryRouter\n   */\n  initialRoutes?: string[];\n\n  /**\n   * Whether to use BrowserRouter instead of MemoryRouter (default: false)\n   */\n  isBrowserRouter?: boolean;\n\n  /**\n   * Custom auth context value\n   */\n  authValue?: Partial<MockAuthContextValue>;\n\n  /**\n   * Whether to wrap with Ant Design App component (default: true)\n   */\n  withAntApp?: boolean;\n}\n\n/**\n * Mock AuthContext Provider for testing\n */\nconst MockAuthProvider: React.FC<{\n  children: React.ReactNode;\n  value?: Partial<MockAuthContextValue> | (() => Partial<MockAuthContextValue>);\n}> = ({ children, value }) => {\n  // Merge default mock values with provided overrides\n  const resolvedValue = typeof value === 'function' ? value() : value;\n  const mergedValue = { ...mockAuthContextValue, ...resolvedValue };\n\n  return <AuthContext.Provider value={mergedValue}>{children}</AuthContext.Provider>;\n};\n\n// Export for testing\nexport { MockAuthProvider };\n\n/**\n * Custom render function with all providers\n *\n * @param ui - React component to render\n * @param options - Render options including router and auth configuration\n * @returns Render result with all utilities from @testing-library/react\n *\n * @example\n * ```typescript\n * const { getByText } = renderWithProviders(<MyComponent />, {\n *   initialRoute: '/contacts',\n *   authValue: { isAuthenticated: false }\n * });\n * ```\n */\nexport function renderWithProviders(\n  ui: ReactElement,\n  {\n    initialRoute = '/',\n    initialRoutes = [initialRoute],\n    isBrowserRouter = false,\n    authValue,\n    withAntApp = true,\n    ...renderOptions\n  }: CustomRenderOptions = {}\n) {\n  // Choose router type\n  const RouterComponent = isBrowserRouter ? BrowserRouter : MemoryRouter;\n  const routerProps = isBrowserRouter ? {} : { initialEntries: initialRoutes, initialIndex: 0 };\n\n  // Create a direct functional Wrapper component\n  const Wrapper = ({ children }: { children: React.ReactNode }) => {\n    let content = (\n      <RouterComponent {...routerProps}>\n        <MockAuthProvider value={authValue}>{children}</MockAuthProvider>\n      </RouterComponent>\n    );\n\n    // Optionally wrap with Ant Design App component for message, modal, notification\n    if (withAntApp) {\n      content = <AntApp>{content}</AntApp>;\n    }\n\n    return content;\n  };\n\n  return render(ui, { wrapper: Wrapper, ...renderOptions });\n}\n\n/**\n * Render with authenticated user\n *\n * @param ui - React component to render\n * @param options - Render options\n * @returns Render result with enhanced rerender function\n */\nexport function renderWithAuth(ui: ReactElement, options?: CustomRenderOptions) {\n  const renderResult = renderWithProviders(ui, {\n    ...options,\n    authValue: {\n      isAuthenticated: true,\n      user: mockUser,\n      tenant: mockTenant,\n      ...options?.authValue,\n    },\n  });\n\n  // Enhanced rerender function for updating rendered components\n  // Note: This is limited in functionality since we can't rerender with a different Router\n  // without violating React Router's single Router constraint\n  const rerenderWithAuth = (newUi: ReactElement) => {\n    // Just rerender the component without changing providers\n    // This is mainly useful for testing prop changes, not auth state changes\n    renderResult.rerender(newUi);\n    return renderResult;\n  };\n\n  return {\n    ...renderResult,\n    rerenderWithAuth,\n  };\n}\n\n/**\n * Render with unauthenticated user\n *\n * @param ui - React component to render\n * @param options - Render options\n * @returns Render result\n */\nexport function renderWithoutAuth(ui: ReactElement, options?: CustomRenderOptions) {\n  return renderWithProviders(ui, {\n    ...options,\n    authValue: {\n      isAuthenticated: false,\n      user: null,\n      tenant: null,\n      ...options?.authValue,\n    },\n  });\n}\n\n/**\n * Render with authenticated user and navigation tracking\n * Returns the current location for testing redirects\n *\n * @param ui - React component to render\n * @param options - Render options\n * @returns Render result with location tracking\n */\nexport function renderWithAuthAndNavigation(ui: ReactElement, options?: CustomRenderOptions) {\n  let capturedLocation: { pathname: string; search: string; hash: string } = {\n    pathname: options?.initialRoute ?? '/',\n    search: '',\n    hash: '',\n  };\n\n  // Plain function is sufficient in test util scope\n  const handleLocationChange = (location: { pathname: string; search?: string; hash?: string }) => {\n    capturedLocation = {\n      pathname: location.pathname,\n      search: location.search ?? '',\n      hash: location.hash ?? '',\n    };\n  };\n\n  interface LocationTrackerProps {\n    children: ReactElement;\n  }\n\n  const LocationTracker = ({ children }: LocationTrackerProps) => {\n    const location = useLocation();\n    React.useEffect(() => {\n      handleLocationChange(location);\n    }, [location]);\n    return children;\n  };\n\n  const renderResult = renderWithProviders(<LocationTracker>{ui}</LocationTracker>, {\n    ...options,\n    authValue: {\n      isAuthenticated: true,\n      user: mockUser,\n      tenant: mockTenant,\n      ...options?.authValue,\n    },\n  });\n\n  return {\n    ...renderResult,\n    getCurrentLocation: () => capturedLocation,\n  };\n}\n\n/**\n * Render for integration tests without mock auth provider\n * Allows the App's AuthProvider to work normally with mocked API calls\n *\n * @param ui - React component to render\n * @param options - Render options\n * @returns Render result\n */\nexport function renderForIntegration(\n  ui: ReactElement,\n  {\n    initialRoute = '/',\n    initialRoutes = [initialRoute],\n    isBrowserRouter = false,\n    withAntApp = true,\n    ...renderOptions\n  }: Omit<CustomRenderOptions, 'authValue'> = {}\n) {\n  // Choose router type\n  const RouterComponent = isBrowserRouter ? BrowserRouter : MemoryRouter;\n  const routerProps = isBrowserRouter ? {} : { initialEntries: initialRoutes, initialIndex: 0 };\n\n  // Create wrapper component without MockAuthProvider\n  const Wrapper: React.FC<{ children: React.ReactNode }> = ({ children }) => {\n    let content = <RouterComponent {...routerProps}>{children}</RouterComponent>;\n\n    // Optionally wrap with Ant Design App component for message, modal, notification\n    if (withAntApp) {\n      content = <AntApp>{content}</AntApp>;\n    }\n\n    return content;\n  };\n\n  return render(ui, { wrapper: Wrapper, ...renderOptions });\n}\n\n/**\n * Wait for async operations to complete\n * Useful for testing loading states\n *\n * @param ms - Milliseconds to wait\n * @returns Promise that resolves after the specified time\n */\nexport const sleep = (ms: number): Promise<void> => new Promise(resolve => setTimeout(resolve, ms));\n\n/**\n * Create a deferred promise for testing async behavior\n *\n * @returns Object with promise and resolve/reject functions\n *\n * @example\n * ```typescript\n * const deferred = createDeferred<string>();\n *\n * // In test\n * mockApi.login.mockReturnValue(deferred.promise);\n *\n * // Later, resolve or reject\n * deferred.resolve('success');\n * // or\n * deferred.reject(new Error('failed'));\n * ```\n */\nexport function createDeferred<T>(): {\n  promise: Promise<T>;\n  resolve: (value: T | PromiseLike<T>) => void;\n  reject: (reason?: unknown) => void;\n} {\n  let resolve!: (value: T | PromiseLike<T>) => void;\n  let reject!: (reason?: unknown) => void;\n\n  const promise = new Promise<T>((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n\n  return { promise, resolve, reject };\n}\n\n// Re-export everything from @testing-library/react\nexport * from '@testing-library/react';\nexport { default as userEvent } from '@testing-library/user-event';\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/test-utils/setup.ts",
        "messages": [
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 15,
                "column": 6,
                "nodeType": "ConditionalExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 15,
                "endColumn": 90,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                449,
                                533
                            ],
                            "text": "(typeof process !== 'undefined' && process.env ? process.env.VITE_API_URL : undefined) != null"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                449,
                                533
                            ],
                            "text": "(typeof process !== 'undefined' && process.env ? process.env.VITE_API_URL : undefined) ?? \"\""
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                449,
                                533
                            ],
                            "text": "Boolean((typeof process !== 'undefined' && process.env ? process.env.VITE_API_URL : undefined))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, value is always truthy.",
                "line": 15,
                "column": 40,
                "nodeType": "MemberExpression",
                "messageId": "alwaysTruthy",
                "endLine": 15,
                "endColumn": 51
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected object value in conditional. The condition is always true.",
                "line": 15,
                "column": 40,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorObject",
                "endLine": 15,
                "endColumn": 51
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 15,
                "column": 92,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 15,
                "endColumn": 94,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                535,
                                537
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 21,
                "column": 6,
                "nodeType": "ConditionalExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 21,
                "endColumn": 86,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                729,
                                809
                            ],
                            "text": "(typeof process !== 'undefined' && process.env ? process.env.NODE_ENV : undefined) != null"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                729,
                                809
                            ],
                            "text": "(typeof process !== 'undefined' && process.env ? process.env.NODE_ENV : undefined) ?? \"\""
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                729,
                                809
                            ],
                            "text": "Boolean((typeof process !== 'undefined' && process.env ? process.env.NODE_ENV : undefined))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, value is always truthy.",
                "line": 21,
                "column": 40,
                "nodeType": "MemberExpression",
                "messageId": "alwaysTruthy",
                "endLine": 21,
                "endColumn": 51
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected object value in conditional. The condition is always true.",
                "line": 21,
                "column": 40,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorObject",
                "endLine": 21,
                "endColumn": 51
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 21,
                "column": 88,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 21,
                "endColumn": 90,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                811,
                                813
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 25,
                "column": 7,
                "nodeType": "ConditionalExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 25,
                "endColumn": 87,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                911,
                                991
                            ],
                            "text": "(typeof process !== 'undefined' && process.env ? process.env.NODE_ENV : undefined) != null"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                911,
                                991
                            ],
                            "text": "(typeof process !== 'undefined' && process.env ? process.env.NODE_ENV : undefined) ?? \"\""
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                911,
                                991
                            ],
                            "text": "Boolean((typeof process !== 'undefined' && process.env ? process.env.NODE_ENV : undefined))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, value is always truthy.",
                "line": 25,
                "column": 41,
                "nodeType": "MemberExpression",
                "messageId": "alwaysTruthy",
                "endLine": 25,
                "endColumn": 52
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected object value in conditional. The condition is always true.",
                "line": 25,
                "column": 41,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorObject",
                "endLine": 25,
                "endColumn": 52
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 25,
                "column": 89,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 25,
                "endColumn": 91,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                993,
                                995
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 30,
                "column": 7,
                "nodeType": "ConditionalExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 30,
                "endColumn": 87,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                1119,
                                1199
                            ],
                            "text": "(typeof process !== 'undefined' && process.env ? process.env.NODE_ENV : undefined) != null"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                1119,
                                1199
                            ],
                            "text": "(typeof process !== 'undefined' && process.env ? process.env.NODE_ENV : undefined) ?? \"\""
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                1119,
                                1199
                            ],
                            "text": "Boolean((typeof process !== 'undefined' && process.env ? process.env.NODE_ENV : undefined))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, value is always truthy.",
                "line": 30,
                "column": 41,
                "nodeType": "MemberExpression",
                "messageId": "alwaysTruthy",
                "endLine": 30,
                "endColumn": 52
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected object value in conditional. The condition is always true.",
                "line": 30,
                "column": 41,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorObject",
                "endLine": 30,
                "endColumn": 52
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 30,
                "column": 89,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 30,
                "endColumn": 91,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                1201,
                                1203
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 42,
                "column": 18,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 42,
                "endColumn": 21,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                1586,
                                1589
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                1586,
                                1589
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .RECEIVED_COLOR on an `any` value.",
                "line": 42,
                "column": 23,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 42,
                "endColumn": 37
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 43,
                "column": 18,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 43,
                "endColumn": 21,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                1649,
                                1652
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                1649,
                                1652
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .EXPECTED_COLOR on an `any` value.",
                "line": 43,
                "column": 23,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 43,
                "endColumn": 37
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 44,
                "column": 18,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 44,
                "endColumn": 21,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                1712,
                                1715
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                1712,
                                1715
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .INVERTED_COLOR on an `any` value.",
                "line": 44,
                "column": 23,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 44,
                "endColumn": 37
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 45,
                "column": 18,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 45,
                "endColumn": 21,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                1775,
                                1778
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                1775,
                                1778
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .BOLD_WEIGHT on an `any` value.",
                "line": 45,
                "column": 23,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 45,
                "endColumn": 34
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 46,
                "column": 18,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 46,
                "endColumn": 21,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                1835,
                                1838
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                1835,
                                1838
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .DIM_COLOR on an `any` value.",
                "line": 46,
                "column": 23,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 46,
                "endColumn": 32
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 85,
                "column": 14,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 85,
                "endColumn": 24,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                2954,
                                2964
                            ],
                            "text": "(store[key] != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                2954,
                                2964
                            ],
                            "text": "(store[key] ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                2954,
                                2964
                            ],
                            "text": "(Boolean(store[key]))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 85,
                "column": 25,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 85,
                "endColumn": 27,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                2965,
                                2967
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-type-conversion",
                "severity": 1,
                "message": "Calling a string's .toString() method does not change the type or value of the string.",
                "line": 88,
                "column": 26,
                "nodeType": null,
                "messageId": "unnecessaryTypeConversion",
                "endLine": 88,
                "endColumn": 36,
                "suggestions": [
                    {
                        "messageId": "suggestRemove",
                        "fix": {
                            "range": [
                                3053,
                                3069
                            ],
                            "text": "value"
                        },
                        "desc": "Remove the type conversion."
                    },
                    {
                        "messageId": "suggestSatisfies",
                        "data": {
                            "type": "string"
                        },
                        "fix": {
                            "range": [
                                3053,
                                3069
                            ],
                            "text": "value satisfies string"
                        },
                        "desc": "Instead, assert that the value satisfies the string type."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-dynamic-delete",
                "severity": 1,
                "message": "Do not delete dynamically computed property keys.",
                "line": 91,
                "column": 20,
                "nodeType": "Identifier",
                "messageId": "dynamicDelete",
                "endLine": 91,
                "endColumn": 23
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 101,
                "column": 14,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 101,
                "endColumn": 25,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                3372,
                                3383
                            ],
                            "text": "(keys[index] != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                3372,
                                3383
                            ],
                            "text": "(keys[index] ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                3372,
                                3383
                            ],
                            "text": "(Boolean(keys[index]))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 101,
                "column": 26,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 101,
                "endColumn": 28,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                3384,
                                3386
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 112,
                "column": 14,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 112,
                "endColumn": 24,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                3585,
                                3595
                            ],
                            "text": "(store[key] != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                3585,
                                3595
                            ],
                            "text": "(store[key] ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                3585,
                                3595
                            ],
                            "text": "(Boolean(store[key]))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 112,
                "column": 25,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 112,
                "endColumn": 27,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                3596,
                                3598
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-type-conversion",
                "severity": 1,
                "message": "Calling a string's .toString() method does not change the type or value of the string.",
                "line": 115,
                "column": 26,
                "nodeType": null,
                "messageId": "unnecessaryTypeConversion",
                "endLine": 115,
                "endColumn": 36,
                "suggestions": [
                    {
                        "messageId": "suggestRemove",
                        "fix": {
                            "range": [
                                3684,
                                3700
                            ],
                            "text": "value"
                        },
                        "desc": "Remove the type conversion."
                    },
                    {
                        "messageId": "suggestSatisfies",
                        "data": {
                            "type": "string"
                        },
                        "fix": {
                            "range": [
                                3684,
                                3700
                            ],
                            "text": "value satisfies string"
                        },
                        "desc": "Instead, assert that the value satisfies the string type."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-dynamic-delete",
                "severity": 1,
                "message": "Do not delete dynamically computed property keys.",
                "line": 118,
                "column": 20,
                "nodeType": "Identifier",
                "messageId": "dynamicDelete",
                "endLine": 118,
                "endColumn": 23
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 128,
                "column": 14,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 128,
                "endColumn": 25,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                4003,
                                4014
                            ],
                            "text": "(keys[index] != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                4003,
                                4014
                            ],
                            "text": "(keys[index] ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                4003,
                                4014
                            ],
                            "text": "(Boolean(keys[index]))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 128,
                "column": 26,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 128,
                "endColumn": 28,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                4015,
                                4017
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 38,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "/**\n * Test Setup and Configuration\n *\n * This file is preloaded before all tests via bunfig.toml.\n * It sets up the testing environment, including DOM environment,\n * and global test utilities.\n */\n\nimport { expect } from 'bun:test';\n\n// Ensure environment variables are available in import.meta.env\n// Bun loads .env automatically, but we need to explicitly set import.meta.env for tests\nif (!import.meta.env.VITE_API_URL) {\n  const apiUrl =\n    (typeof process !== 'undefined' && process.env ? process.env.VITE_API_URL : undefined) ||\n    'http://localhost:8000/api';\n  (import.meta.env as Record<string, string>).VITE_API_URL = apiUrl;\n}\nif (!import.meta.env.MODE) {\n  (import.meta.env as Record<string, string>).MODE =\n    (typeof process !== 'undefined' && process.env ? process.env.NODE_ENV : undefined) || 'test';\n}\nif (!import.meta.env.DEV) {\n  (import.meta.env as Record<string, boolean>).DEV =\n    ((typeof process !== 'undefined' && process.env ? process.env.NODE_ENV : undefined) ||\n      'test') !== 'production';\n}\nif (!import.meta.env.PROD) {\n  (import.meta.env as Record<string, boolean>).PROD =\n    ((typeof process !== 'undefined' && process.env ? process.env.NODE_ENV : undefined) ||\n      'test') === 'production';\n}\nimport * as matchers from '@testing-library/jest-dom/matchers';\nimport { cleanup } from '@testing-library/react';\n\n// Extend Bun's expect with jest-dom matchers\nexpect.extend(matchers);\n\n// Mock missing Jest utilities that jest-dom expects\nif (typeof globalThis !== 'undefined') {\n  // Mock RECEIVED_COLOR and other Jest utilities\n  (globalThis as any).RECEIVED_COLOR = (text: string) => text;\n  (globalThis as any).EXPECTED_COLOR = (text: string) => text;\n  (globalThis as any).INVERTED_COLOR = (text: string) => text;\n  (globalThis as any).BOLD_WEIGHT = (text: string) => text;\n  (globalThis as any).DIM_COLOR = (text: string) => text;\n}\nimport { afterEach, beforeAll, afterAll } from 'bun:test';\nimport { setupMSW, teardownMSW, resetMSW } from './mocks/server';\n\n// Start MSW server before all tests\nbeforeAll(() => {\n  setupMSW();\n});\n\n// Stop MSW server after all tests\nafterAll(() => {\n  teardownMSW();\n});\n\n// Automatically cleanup after each test\nafterEach(() => {\n  cleanup();\n  resetMSW(); // Reset MSW handlers and mock data\n});\n\n// Mock window object if not defined (for non-DOM tests)\n// NOTE: Only timeout functions are mocked. Tests requiring other browser APIs\n// (document, navigator, location, etc.) must use JSDOM or provide their own mocks.\nif (typeof window === 'undefined') {\n  (global as Record<string, unknown>).window = {\n    setTimeout: globalThis.setTimeout,\n    clearTimeout: globalThis.clearTimeout,\n    setInterval: globalThis.setInterval,\n    clearInterval: globalThis.clearInterval,\n  };\n}\n\n// Mock localStorage for testing environment\nconst localStorageMock = (() => {\n  let store: Record<string, string> = {};\n\n  return {\n    getItem: (key: string): string | null => {\n      return store[key] || null;\n    },\n    setItem: (key: string, value: string): void => {\n      store[key] = value.toString();\n    },\n    removeItem: (key: string): void => {\n      delete store[key];\n    },\n    clear: (): void => {\n      store = {};\n    },\n    get length(): number {\n      return Object.keys(store).length;\n    },\n    key: (index: number): string | null => {\n      const keys = Object.keys(store);\n      return keys[index] || null;\n    },\n  };\n})();\n\n// Mock sessionStorage\nconst sessionStorageMock = (() => {\n  let store: Record<string, string> = {};\n\n  return {\n    getItem: (key: string): string | null => {\n      return store[key] || null;\n    },\n    setItem: (key: string, value: string): void => {\n      store[key] = value.toString();\n    },\n    removeItem: (key: string): void => {\n      delete store[key];\n    },\n    clear: (): void => {\n      store = {};\n    },\n    get length(): number {\n      return Object.keys(store).length;\n    },\n    key: (index: number): string | null => {\n      const keys = Object.keys(store);\n      return keys[index] || null;\n    },\n  };\n})();\n\n// Assign mocks to global (guard against re-defining if already present)\n// Using type-safe 'in' operator instead of typeof checks\nif (!('localStorage' in globalThis)) {\n  Object.defineProperty(globalThis, 'localStorage', {\n    value: localStorageMock,\n    writable: true,\n    configurable: true,\n  });\n}\n\nif (!('sessionStorage' in globalThis)) {\n  Object.defineProperty(globalThis, 'sessionStorage', {\n    value: sessionStorageMock,\n    writable: true,\n    configurable: true,\n  });\n}\n\n// Mock matchMedia for responsive components (guard against overwriting existing implementation)\nif (typeof window !== 'undefined' && typeof window.matchMedia !== 'function') {\n  Object.defineProperty(window, 'matchMedia', {\n    writable: true,\n    value: (query: string) => ({\n      matches: false,\n      media: query,\n      onchange: null,\n      addListener: () => {\n        // Intentionally empty - deprecated method\n      },\n      removeListener: () => {\n        // Intentionally empty - deprecated method\n      },\n      addEventListener: () => {\n        // Intentionally empty - not needed for tests\n      },\n      removeEventListener: () => {\n        // Intentionally empty - not needed for tests\n      },\n      dispatchEvent: () => true,\n    }),\n  });\n}\n\n// Suppress console errors/warnings during tests (optional)\n// Uncomment if you want cleaner test output\n// const originalError = console.error;\n// beforeEach(() => {\n//   console.error = (...args: unknown[]) => {\n//     if (\n//       typeof args[0] === 'string' &&\n//       args[0].includes('Warning: ReactDOM.render')\n//     ) {\n//       return;\n//     }\n//     originalError.call(console, ...args);\n//   };\n// });\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/test-utils/type-tests/tenant-filter-fields.test.ts",
        "messages": [],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 0,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/transformers/date.ts",
        "messages": [
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, the types have no overlap.",
                "line": 51,
                "column": 27,
                "nodeType": "BinaryExpression",
                "messageId": "noOverlapBooleanExpression",
                "endLine": 51,
                "endColumn": 43
            },
            {
                "ruleId": "@typescript-eslint/restrict-template-expressions",
                "severity": 1,
                "message": "Invalid type \"string | undefined\" of template literal expression.",
                "line": 146,
                "column": 26,
                "nodeType": "MemberExpression",
                "messageId": "invalidType",
                "endLine": 146,
                "endColumn": 36
            },
            {
                "ruleId": "@typescript-eslint/restrict-template-expressions",
                "severity": 1,
                "message": "Invalid type \"string | undefined\" of template literal expression.",
                "line": 146,
                "column": 40,
                "nodeType": "MemberExpression",
                "messageId": "invalidType",
                "endLine": 146,
                "endColumn": 51
            },
            {
                "ruleId": "@typescript-eslint/restrict-template-expressions",
                "severity": 1,
                "message": "Invalid type \"string | undefined\" of template literal expression.",
                "line": 146,
                "column": 55,
                "nodeType": "MemberExpression",
                "messageId": "invalidType",
                "endLine": 146,
                "endColumn": 64
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 201,
                "column": 11,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 201,
                "endColumn": 27,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                5187,
                                5203
                            ],
                            "text": "(options.timeZone != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                5187,
                                5203
                            ],
                            "text": "(options.timeZone ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                5187,
                                5203
                            ],
                            "text": "(Boolean(options.timeZone))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 5,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "import { err, ok } from 'neverthrow';\nimport type { Result, Option } from '../types/fp';\nimport { none, some } from '../types/fp';\nimport type { AppError } from '../types/errors';\nimport { createValidationError } from '../types/errors';\n\nexport interface DateParseOptions {\n  readonly context?: string;\n  readonly allowEmptyString?: boolean;\n}\n\nexport interface DateFormatOptions {\n  readonly locale?: string;\n  readonly timeZone?: string;\n  readonly format?: Intl.DateTimeFormatOptions;\n}\n\nexport interface ZonedDateString {\n  readonly isoString: string;\n  readonly parts: Record<string, string>;\n  readonly timeZone: string;\n  readonly locale: string;\n}\n\nexport interface DatePipelineResult {\n  readonly original: Date;\n  readonly formatted: string;\n  readonly isoString: string;\n  readonly timeZone?: string;\n  readonly locale: string;\n  readonly parts: Record<string, string>;\n}\n\nconst createDateError = (\n  message: string,\n  details?: Record<string, unknown>,\n  code = 'INVALID_DATE_VALUE',\n  cause?: unknown\n): AppError => createValidationError(message, details, { code, cause });\n\nconst toDate = (value: unknown): Date | null => {\n  if (value instanceof Date) {\n    if (Number.isNaN(value.getTime())) {\n      return null;\n    }\n    return new Date(value.getTime());\n  }\n\n  if (typeof value === 'string' || typeof value === 'number') {\n    const trimmed = typeof value === 'string' ? value.trim() : value;\n    if (trimmed === '' || trimmed === null) {\n      return null;\n    }\n    const parsed = new Date(trimmed);\n    if (Number.isNaN(parsed.getTime())) {\n      return null;\n    }\n    return parsed;\n  }\n\n  return null;\n};\n\nexport const parseDate = (\n  value: unknown,\n  options: DateParseOptions = {}\n): Result<Date, AppError> => {\n  if (\n    (value === '' || value === undefined || value === null) &&\n    options.allowEmptyString !== true\n  ) {\n    return err(\n      createDateError(\n        'Date value is empty',\n        { context: options.context ?? 'date' },\n        'EMPTY_DATE_VALUE'\n      )\n    );\n  }\n\n  const parsed = toDate(value);\n\n  if (!parsed) {\n    return err(\n      createDateError('Invalid date value', { value, context: options.context ?? 'date' })\n    );\n  }\n\n  return ok(parsed);\n};\n\nexport const parseOptionalDate = (\n  value: unknown,\n  options: DateParseOptions = {}\n): Result<Option<Date>, AppError> => {\n  if (value === undefined || value === null || value === '') {\n    return ok(none());\n  }\n\n  return parseDate(value, options).map(some);\n};\n\nexport const toIsoString = (\n  value: Date,\n  options?: { context?: string }\n): Result<string, AppError> => {\n  if (!(value instanceof Date) || Number.isNaN(value.getTime())) {\n    return err(\n      createDateError(\n        'Cannot serialise invalid date',\n        { context: options?.context ?? 'date' },\n        'INVALID_DATE_SERIALISATION'\n      )\n    );\n  }\n\n  return ok(value.toISOString());\n};\n\nexport const convertToTimezone = (\n  value: Date,\n  timeZone: string,\n  locale = 'en-US'\n): Result<ZonedDateString, AppError> => {\n  try {\n    const formatter = new Intl.DateTimeFormat(locale, {\n      timeZone,\n      hour12: false,\n      year: 'numeric',\n      month: '2-digit',\n      day: '2-digit',\n      hour: '2-digit',\n      minute: '2-digit',\n      second: '2-digit',\n    });\n\n    const parts = formatter\n      .formatToParts(value)\n      .reduce<Record<string, string>>((accumulator, part) => {\n        if (part.type !== 'literal') {\n          accumulator[part.type] = part.value;\n        }\n        return accumulator;\n      }, {});\n\n    const isoString = `${parts.year}-${parts.month}-${parts.day}T${parts.hour ?? '00'}:${parts.minute ?? '00'}:${parts.second ?? '00'}`;\n\n    return ok({\n      isoString,\n      parts,\n      timeZone,\n      locale,\n    });\n  } catch (error) {\n    return err(\n      createDateError('Invalid time zone provided', { timeZone, locale }, 'INVALID_TIMEZONE', error)\n    );\n  }\n};\n\nexport const formatDate = (\n  value: Date,\n  options: DateFormatOptions = {}\n): Result<string, AppError> => {\n  if (!(value instanceof Date) || Number.isNaN(value.getTime())) {\n    return err(\n      createDateError('Cannot format invalid date value', { value }, 'INVALID_DATE_FORMAT')\n    );\n  }\n\n  try {\n    const formatter = new Intl.DateTimeFormat(options.locale ?? 'en-US', {\n      timeZone: options.timeZone,\n      year: 'numeric',\n      month: '2-digit',\n      day: '2-digit',\n      hour: '2-digit',\n      minute: '2-digit',\n      second: '2-digit',\n      ...options.format,\n    });\n\n    return ok(formatter.format(value));\n  } catch (error) {\n    return err(createDateError('Failed to format date', { options }, 'DATE_FORMAT_ERROR', error));\n  }\n};\n\nexport interface DatePipelineOptions extends DateParseOptions, DateFormatOptions {}\n\nexport const createDatePipeline =\n  (options: DatePipelineOptions = {}): ((value: unknown) => Result<DatePipelineResult, AppError>) =>\n  (value: unknown) =>\n    parseDate(value, {\n      context: options.context,\n      allowEmptyString: options.allowEmptyString,\n    }).andThen(parsed => {\n      const timezoneResult: Result<\n        { isoString: string; parts: Record<string, string>; timeZone?: string; locale: string },\n        AppError\n      > = options.timeZone\n        ? convertToTimezone(parsed, options.timeZone, options.locale ?? 'en-US').map(zoned => ({\n            isoString: zoned.isoString,\n            parts: zoned.parts,\n            timeZone: zoned.timeZone,\n            locale: zoned.locale,\n          }))\n        : toIsoString(parsed, { context: options.context }).map(isoString => ({\n            isoString,\n            parts: {},\n            timeZone: options.timeZone,\n            locale: options.locale ?? 'en-US',\n          }));\n\n      return timezoneResult.andThen(zoned =>\n        formatDate(parsed, options).map(formatted => ({\n          original: parsed,\n          formatted,\n          isoString: zoned.isoString,\n          timeZone: zoned.timeZone,\n          locale: zoned.locale,\n          parts: zoned.parts,\n        }))\n      );\n    });\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/transformers/dto.ts",
        "messages": [
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'Gender' is defined but never used. Allowed unused vars must match /^_/u.",
                "line": 7,
                "column": 15,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 7,
                "endColumn": 21
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'AuthTenant' is defined but never used. Allowed unused vars must match /^_/u.",
                "line": 8,
                "column": 31,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 8,
                "endColumn": 41
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'COUNTRY_NAMES' is defined but never used. Allowed unused vars must match /^_/u.",
                "line": 12,
                "column": 3,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 12,
                "endColumn": 16
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'STATE_NAMES' is defined but never used. Allowed unused vars must match /^_/u.",
                "line": 14,
                "column": 3,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 14,
                "endColumn": 14
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-argument",
                "severity": 1,
                "message": "Unsafe argument of type `any` assigned to a parameter of type `string`.",
                "line": 164,
                "column": 53,
                "nodeType": "TSAsExpression",
                "messageId": "unsafeArgument",
                "endLine": 164,
                "endColumn": 67
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 164,
                "column": 64,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 164,
                "endColumn": 67,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                4938,
                                4941
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                4938,
                                4941
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-argument",
                "severity": 1,
                "message": "Unsafe argument of type `any` assigned to a parameter of type `string`.",
                "line": 168,
                "column": 30,
                "nodeType": "TSAsExpression",
                "messageId": "unsafeArgument",
                "endLine": 168,
                "endColumn": 47
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 168,
                "column": 44,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 168,
                "endColumn": 47,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                5164,
                                5167
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                5164,
                                5167
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-argument",
                "severity": 1,
                "message": "Unsafe argument of type `any` assigned to a parameter of type `string`.",
                "line": 181,
                "column": 57,
                "nodeType": "TSAsExpression",
                "messageId": "unsafeArgument",
                "endLine": 181,
                "endColumn": 71
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 181,
                "column": 68,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 181,
                "endColumn": 71,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                5707,
                                5710
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                5707,
                                5710
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-argument",
                "severity": 1,
                "message": "Unsafe argument of type `any` assigned to a parameter of type `string`.",
                "line": 185,
                "column": 32,
                "nodeType": "TSAsExpression",
                "messageId": "unsafeArgument",
                "endLine": 185,
                "endColumn": 49
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 185,
                "column": 46,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 185,
                "endColumn": 49,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                5935,
                                5938
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                5935,
                                5938
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 257,
                "column": 10,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 257,
                "endColumn": 17,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                8823,
                                8831
                            ],
                            "text": "segment == null"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                8824,
                                8831
                            ],
                            "text": "(segment ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                8823,
                                8831
                            ],
                            "text": "!Boolean(segment)"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 298,
                "column": 9,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 298,
                "endColumn": 12,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                10318,
                                10321
                            ],
                            "text": "zip != null"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                10318,
                                10321
                            ],
                            "text": "zip ?? \"\""
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                10318,
                                10321
                            ],
                            "text": "Boolean(zip)"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 302,
                "column": 9,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 302,
                "endColumn": 14,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                10424,
                                10429
                            ],
                            "text": "state != null"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                10424,
                                10429
                            ],
                            "text": "state ?? \"\""
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                10424,
                                10429
                            ],
                            "text": "Boolean(state)"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 306,
                "column": 9,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 306,
                "endColumn": 16,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                10538,
                                10545
                            ],
                            "text": "country != null"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                10538,
                                10545
                            ],
                            "text": "country ?? \"\""
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                10538,
                                10545
                            ],
                            "text": "Boolean(country)"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'hasStreet' is assigned a value but never used. Allowed unused vars must match /^_/u.",
                "line": 310,
                "column": 9,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 310,
                "endColumn": 18
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'hasCity' is assigned a value but never used. Allowed unused vars must match /^_/u.",
                "line": 311,
                "column": 9,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 311,
                "endColumn": 16
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'hasState' is assigned a value but never used. Allowed unused vars must match /^_/u.",
                "line": 312,
                "column": 9,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 312,
                "endColumn": 17
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'hasZip' is assigned a value but never used. Allowed unused vars must match /^_/u.",
                "line": 313,
                "column": 9,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 313,
                "endColumn": 15
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 355,
                "column": 22,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 355,
                "endColumn": 34,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                12488,
                                12500
                            ],
                            "text": "(remaining[0] != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                12488,
                                12500
                            ],
                            "text": "(remaining[0] ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                12488,
                                12500
                            ],
                            "text": "(Boolean(remaining[0]))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 355,
                "column": 35,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 355,
                "endColumn": 37,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                12501,
                                12503
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 358,
                "column": 43,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 358,
                "endColumn": 55,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                12613,
                                12625
                            ],
                            "text": "(remaining[2] != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                12613,
                                12625
                            ],
                            "text": "(remaining[2] ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                12613,
                                12625
                            ],
                            "text": "(Boolean(remaining[2]))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 358,
                "column": 56,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 358,
                "endColumn": 58,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                12626,
                                12628
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected any value in conditional. An explicit comparison or type conversion is required.",
                "line": 366,
                "column": 7,
                "nodeType": "Identifier",
                "messageId": "conditionErrorAny",
                "endLine": 366,
                "endColumn": 19,
                "suggestions": [
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                12831,
                                12843
                            ],
                            "text": "(Boolean(addressValue))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected any value in conditional. An explicit comparison or type conversion is required.",
                "line": 502,
                "column": 8,
                "nodeType": "Identifier",
                "messageId": "conditionErrorAny",
                "endLine": 502,
                "endColumn": 13,
                "suggestions": [
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                17494,
                                17499
                            ],
                            "text": "(Boolean(input))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary optional chain on a non-nullish value.",
                "line": 664,
                "column": 32,
                "nodeType": "MemberExpression",
                "messageId": "neverOptionalChain",
                "endLine": 664,
                "endColumn": 34,
                "suggestions": [
                    {
                        "messageId": "suggestRemoveOptionalChain",
                        "fix": {
                            "range": [
                                23264,
                                23266
                            ],
                            "text": "."
                        },
                        "desc": "Remove unnecessary optional chain"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.",
                "line": 714,
                "column": 39,
                "nodeType": "MemberExpression",
                "messageId": "neverNullish",
                "endLine": 714,
                "endColumn": 56
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected object value in conditional. The condition is always true.",
                "line": 736,
                "column": 17,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorObject",
                "endLine": 736,
                "endColumn": 34
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected object value in conditional. The condition is always true.",
                "line": 737,
                "column": 17,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorObject",
                "endLine": 737,
                "endColumn": 34
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.",
                "line": 738,
                "column": 16,
                "nodeType": "MemberExpression",
                "messageId": "neverNullish",
                "endLine": 738,
                "endColumn": 32
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected any value in conditional. An explicit comparison or type conversion is required.",
                "line": 765,
                "column": 8,
                "nodeType": "Identifier",
                "messageId": "conditionErrorAny",
                "endLine": 765,
                "endColumn": 13,
                "suggestions": [
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                26516,
                                26521
                            ],
                            "text": "(Boolean(input))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 777,
                "column": 9,
                "nodeType": "VariableDeclarator",
                "messageId": "anyAssignment",
                "endLine": 783,
                "endColumn": 15
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 781,
                "column": 39,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 781,
                "endColumn": 42,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                27055,
                                27058
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                27055,
                                27058
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .contacts on an `any` value.",
                "line": 781,
                "column": 45,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 781,
                "endColumn": 53
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 782,
                "column": 27,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 782,
                "endColumn": 30,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                27097,
                                27100
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                27097,
                                27100
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .contacts on an `any` value.",
                "line": 782,
                "column": 32,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 782,
                "endColumn": 40
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected any value in conditional. An explicit comparison or type conversion is required.",
                "line": 857,
                "column": 8,
                "nodeType": "Identifier",
                "messageId": "conditionErrorAny",
                "endLine": 857,
                "endColumn": 13,
                "suggestions": [
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                29542,
                                29547
                            ],
                            "text": "(Boolean(input))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected object value in conditional. The condition is always true.",
                "line": 921,
                "column": 8,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorObject",
                "endLine": 921,
                "endColumn": 15
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected object value in conditional. The condition is always true.",
                "line": 921,
                "column": 53,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorObject",
                "endLine": 921,
                "endColumn": 66
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected any value in conditional. An explicit comparison or type conversion is required.",
                "line": 956,
                "column": 8,
                "nodeType": "Identifier",
                "messageId": "conditionErrorAny",
                "endLine": 956,
                "endColumn": 13,
                "suggestions": [
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                32456,
                                32461
                            ],
                            "text": "(Boolean(input))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected object value in conditional. The condition is always true.",
                "line": 996,
                "column": 8,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorObject",
                "endLine": 996,
                "endColumn": 17
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.",
                "line": 1009,
                "column": 13,
                "nodeType": "MemberExpression",
                "messageId": "neverNullish",
                "endLine": 1009,
                "endColumn": 26
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 43,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "import { err, ok } from 'neverthrow';\nimport type { Result, Option } from '../types/fp';\nimport { fromNullable, isSome, none, some } from '../types/fp';\nimport type { AppError } from '../types/errors';\nimport { createValidationError } from '../types/errors';\nimport type { Contact, Address, ContactListResponse } from '../types/contact';\nimport type { Gender } from '../types/person';\nimport type { User, Tenant as AuthTenant } from '../types/auth';\nimport type { Tenant as TenantRecord } from '../types/tenant';\nimport { asContactId, asTenantId, asUserId } from '../types/ids';\nimport {\n  COUNTRY_NAMES,\n  COUNTRY_NAMES_SET,\n  STATE_NAMES,\n  STATE_NAMES_SET,\n  STATE_CODES,\n  COUNTRY_CODES,\n} from '../constants/address';\nimport { booleanToGender, genderEnumToBoolean, parseOptionalGender } from './gender';\nimport { parseDate, parseOptionalDate, toIsoString } from './date';\nimport { addressParsingLogger } from '../utils/logger';\n\ninterface TransformerContext {\n  readonly entity: string;\n  readonly direction: 'toApi' | 'fromApi';\n}\n\nconst createTransformerError = (\n  context: TransformerContext,\n  message: string,\n  details?: Record<string, unknown>,\n  cause?: unknown\n): AppError =>\n  createValidationError(\n    message,\n    { ...details, entity: context.entity, direction: context.direction },\n    {\n      code: 'TRANSFORMATION_ERROR',\n      cause,\n    }\n  );\n\nconst wrapTransformation =\n  <Value, Output>(\n    transform: (value: Value) => Result<Output, AppError>,\n    context: TransformerContext\n  ): ((value: Value) => Result<Output, AppError>) =>\n  (value: Value) => {\n    try {\n      return transform(value);\n    } catch (error) {\n      return err(\n        createTransformerError(context, 'Unexpected transformation failure', { value }, error)\n      );\n    }\n  };\n\nexport const toApiDTO = <Domain, DTO>(\n  transform: (value: Domain) => Result<DTO, AppError>,\n  entity: string\n): ((value: Domain) => Result<DTO, AppError>) =>\n  wrapTransformation(transform, { entity, direction: 'toApi' });\n\nexport const fromApiDTO = <DTO, Domain>(\n  transform: (value: DTO) => Result<Domain, AppError>,\n  entity: string\n): ((value: DTO) => Result<Domain, AppError>) =>\n  wrapTransformation(transform, { entity, direction: 'fromApi' });\n\nconst pickString = (source: Record<string, unknown>, keys: string[]): Option<string> => {\n  for (const key of keys) {\n    if (!(key in source)) continue;\n    const value = source[key];\n\n    if (typeof value === 'string') {\n      const trimmed = value.trim();\n      if (trimmed.length > 0) {\n        return some(trimmed);\n      }\n    }\n\n    if (typeof value === 'number' && Number.isFinite(value)) {\n      return some(String(value));\n    }\n  }\n\n  return none();\n};\n\n/**\n * Type guard to check if a value is a string array\n */\nconst isStringArray = (value: unknown): value is string[] => {\n  return Array.isArray(value) && value.every(item => typeof item === 'string');\n};\n\nconst pickNumber = (source: Record<string, unknown>, keys: string[]): Option<number> => {\n  for (const key of keys) {\n    if (!(key in source)) continue;\n    const value = source[key];\n\n    if (typeof value === 'number' && Number.isFinite(value)) {\n      return some(value);\n    }\n\n    if (typeof value === 'string' && value.trim() !== '') {\n      const parsed = Number(value);\n      if (!Number.isNaN(parsed)) {\n        return some(parsed);\n      }\n    }\n  }\n\n  return none();\n};\n\nconst pickBoolean = (source: Record<string, unknown>, keys: string[]): Option<boolean> => {\n  for (const key of keys) {\n    if (!(key in source)) continue;\n    const value = source[key];\n\n    if (typeof value === 'boolean') {\n      return some(value);\n    }\n\n    if (typeof value === 'string') {\n      const normalized = value.trim().toLowerCase();\n      if (normalized === 'true' || normalized === '1') {\n        return some(true);\n      }\n      if (normalized === 'false' || normalized === '0') {\n        return some(false);\n      }\n    }\n  }\n\n  return none();\n};\n\nconst optionValue = <T>(option: Option<T>): T | undefined =>\n  isSome(option) ? option.value : undefined;\n\nconst optionOrDefault = <T>(option: Option<T>, defaultValue: T): T =>\n  isSome(option) ? option.value : defaultValue;\n\n/**\n * Detect if a string segment looks like a ZIP code (5 digits, optionally +4)\n * Examples: \"12345\", \"12345-6789\"\n */\nconst looksLikeZipCode = (segment: string): boolean => {\n  return /^\\d{5}(-\\d{4})?$/.test(segment.trim());\n};\n\n/**\n * Detect if a string segment looks like a US state abbreviation or full state name\n * Examples: \"CA\", \"California\", \"NY\", \"New York\"\n * Now requires exact matches to avoid false positives like \"MAINE STREET\"\n */\nconst looksLikeState = (segment: string): boolean => {\n  const trimmed = segment.trim().toUpperCase();\n  const normalized = trimmed.replace(/\\s+/g, '');\n\n  // US state abbreviations (exactly 2 letters) - use USPS codes to avoid false positives\n  if (/^[A-Z]{2}$/.test(trimmed) && STATE_CODES.has(trimmed as any)) return true;\n\n  // Common full state names (exact match only, not substring) - O(1) lookup with Set\n  // Cast is safe because we're checking existence against known state names\n  return STATE_NAMES_SET.has(normalized as any);\n};\n\n/**\n * Detect if a string segment looks like a country name\n * Now uses curated list for exact matches, single tokens, or ISO codes to avoid false positives\n * Examples: \"USA\", \"United States\", \"Canada\", \"US\", \"CA\" (ISO codes)\n */\nconst looksLikeCountry = (segment: string): boolean => {\n  const trimmed = segment.trim().toUpperCase();\n  const normalized = trimmed.replace(/\\s+/g, ' ');\n\n  // ISO country codes (2-3 letters) - use whitelist to avoid false positives\n  if (/^[A-Z]{2,3}$/.test(trimmed) && COUNTRY_CODES.has(trimmed as any)) return true;\n\n  // Curated list of common country names (exact match only) - O(1) lookup with Set\n  // Cast is safe because we're checking existence against known country names\n  return COUNTRY_NAMES_SET.has(normalized as any);\n};\n\n/**\n * Improves upon simple comma-split parsing by detecting and placing ZIP codes,\n * states, and country codes dynamically. Falls back to positional assignment\n * if format doesn't match expected patterns.\n *\n * **ENHANCED VALIDATION:**\n * - State matches preferred when adjacent to or near ZIP codes\n * - Overall address structure validation before accepting heuristic matches\n * - Exact matching for states and countries to reduce false positives\n * - Positional confidence scoring for ambiguous cases\n *\n * **LIMITATIONS (US-centric implementation):**\n * - Assumes comma-separated address format (e.g., \"123 Main St, Springfield, IL 62701\")\n * - Primarily recognizes US state abbreviations and names\n * - Detects only basic ZIP code patterns (5 or 9 digits); international postal codes may be misidentified\n * - Country detection uses curated list with exact matching\n * - May misidentify street names or city names that overlap with state/country heuristics\n * - No support for multi-line or complex international address formats\n *\n * **VALIDATION BEHAVIOR:**\n * - If ZIP code exists but no state found, logs warning and marks address as potentially incomplete\n * - Detects conflicting state or ZIP detections and warns with preference for earliest match\n * - Checks if remaining segments contain recognized city/state/ZIP patterns before positional fallback\n * - Validates overall address structure (street + city + state + ZIP) before accepting matches\n *\n * **RECOMMENDATION:**\n * For production use, consider adopting a dedicated address-parsing library (e.g., libpostal, SmartyStreets)\n * that handles international formats and ambiguity resolution. Use this heuristic parser for best-effort\n * parsing only, with user verification/correction as a fallback.\n *\n * @param segments - Pre-split address segments (typically split by comma)\n * @returns Structured address with detected fields; may be partial if heuristics cannot confidently identify all parts\n */\nconst parseAddressSegmentsWithHeuristics = (\n  segments: string[]\n): {\n  street1: string;\n  street2?: string;\n  city: string;\n  state: string;\n  zipCode: string;\n  country: string;\n} => {\n  const result = {\n    street1: '',\n    street2: undefined as string | undefined,\n    city: '',\n    state: '',\n    zipCode: '',\n    country: 'USA',\n  };\n\n  if (segments.length === 0) return result;\n\n  // State confidence scoring constants\n  const BASE_STATE_CONFIDENCE = 1;\n  const ADJACENT_ZIP_BOOST = 2;\n  const NEAR_ZIP_BOOST = 1;\n  const EARLY_POSITION_BOOST = 1;\n\n  const remaining: string[] = [];\n  let zipIndex = -1;\n  let stateIndex = -1;\n  let countryIndex = -1;\n  let stateConfidence = 0; // 0-3 scale based on proximity to ZIP and position\n\n  // First pass: identify special fields by heuristics with positional scoring\n  for (let i = 0; i < segments.length; i++) {\n    const segment = segments[i];\n    if (!segment) continue;\n\n    if (looksLikeZipCode(segment)) {\n      zipIndex = i;\n    } else if (looksLikeState(segment)) {\n      /**\n       * Calculate confidence score for state match\n       * Scale: 0-4 (BASE_STATE_CONFIDENCE + boosts)\n       * - BASE_STATE_CONFIDENCE (1): Basic state match\n       * - ADJACENT_ZIP_BOOST (2): State adjacent to ZIP code\n       * - NEAR_ZIP_BOOST (1): State within 2 positions of ZIP\n       * - EARLY_POSITION_BOOST (1): State in early position (more likely actual state)\n       *\n       * Higher confidence indicates more reliable state detection\n       */\n      let confidence = BASE_STATE_CONFIDENCE; // Base confidence\n\n      // Boost confidence if adjacent to ZIP\n      if (zipIndex !== -1 && Math.abs(i - zipIndex) === 1) confidence += ADJACENT_ZIP_BOOST;\n\n      // Boost confidence if near ZIP (within 2 positions)\n      if (zipIndex !== -1 && Math.abs(i - zipIndex) <= 2) confidence += NEAR_ZIP_BOOST;\n\n      // Prefer earlier positions for states (more likely to be actual states)\n      if (i <= segments.length - 3) confidence += EARLY_POSITION_BOOST;\n\n      // Only accept if confidence is higher than previous match\n      if (confidence > stateConfidence) {\n        stateIndex = i;\n        stateConfidence = confidence;\n      }\n    } else if (looksLikeCountry(segment)) {\n      countryIndex = i;\n    } else {\n      remaining.push(segment);\n    }\n  }\n\n  // Extract identified fields\n  if (zipIndex !== -1) {\n    const zip = segments[zipIndex];\n    if (zip) result.zipCode = zip;\n  }\n  if (stateIndex !== -1) {\n    const state = segments[stateIndex];\n    if (state) result.state = state;\n  }\n  if (countryIndex !== -1) {\n    const country = segments[countryIndex];\n    if (country) result.country = country;\n  }\n\n  // Enhanced validation: check overall address structure coherence\n  const hasStreet = remaining.length > 0 && remaining[0] != null && remaining[0].trim().length > 0;\n  const hasCity = remaining.length > 1 && remaining[1] != null && remaining[1].trim().length > 0;\n  const hasState = result.state.length > 0;\n  const hasZip = result.zipCode.length > 0;\n\n  // TODO: implement ZIP-state validation with authoritative data\n\n  // Post-extraction validation: warn if ZIP exists but state is missing\n  if (result.zipCode && !result.state) {\n    addressParsingLogger.warn(\n      '[Address Parser] ZIP code detected but no state found; address may be incomplete or misidentified.',\n      { zipCode: result.zipCode, remainingSegments: remaining }\n    );\n  }\n\n  // Additional validation: warn about low-confidence state matches\n  if (result.state && stateConfidence < 2) {\n    addressParsingLogger.warn(\n      '[Address Parser] Low confidence state match detected; verify address accuracy.',\n      {\n        state: result.state,\n        confidence: stateConfidence,\n        context: segments,\n      }\n    );\n  }\n\n  // Positional assignment for remaining segments with improved defensiveness\n  // Try to detect city/state/ZIP patterns in remaining segments before fallback positional assignment\n  // Typically: [street1, (street2), city, ...]\n  if (remaining.length > 0) {\n    // Scan remaining for additional city/state/ZIP matches that might have been missed\n    const additionalMatches = remaining.filter(\n      seg => looksLikeState(seg) || looksLikeZipCode(seg) || looksLikeCountry(seg)\n    );\n    if (additionalMatches.length > 0) {\n      addressParsingLogger.warn(\n        '[Address Parser] Detected potential unprocessed city/state/ZIP patterns in remaining segments',\n        {\n          additionalMatches,\n          context: 'Review parsed address for accuracy',\n        }\n      );\n    }\n\n    result.street1 = remaining[0] || '';\n  }\n  if (remaining.length > 1) result.street2 = remaining[1];\n  if (remaining.length > 2) result.city = remaining[2] || '';\n\n  return result;\n};\n\nconst buildAddress = (source: Record<string, unknown>): Option<Address> => {\n  const addressValue = source.address ?? source.mailing_address ?? source.shipping_address;\n\n  if (addressValue && typeof addressValue === 'object') {\n    const addressRecord = addressValue as Record<string, unknown>;\n    const street1 = pickString(addressRecord, ['street1', 'street', 'line1']);\n    const street2 = pickString(addressRecord, ['street2', 'line2']);\n    const city = pickString(addressRecord, ['city']);\n    const state = pickString(addressRecord, ['state', 'region']);\n    const zipCode = pickString(addressRecord, ['zipCode', 'postal_code', 'zip']);\n    const country = pickString(addressRecord, ['country']);\n\n    const latitude = pickNumber(addressRecord, ['latitude', 'lat']);\n    const longitude = pickNumber(addressRecord, ['longitude', 'lng', 'lon']);\n\n    if (!isSome(street1) && !isSome(city) && !isSome(state)) {\n      return none();\n    }\n\n    return some({\n      street1: isSome(street1) ? street1.value : '',\n      street2: isSome(street2) ? street2.value : undefined,\n      city: isSome(city) ? city.value : '',\n      state: isSome(state) ? state.value : '',\n      zipCode: isSome(zipCode) ? zipCode.value : '',\n      country: isSome(country) ? country.value : 'USA',\n      latitude: isSome(latitude) ? latitude.value : undefined,\n      longitude: isSome(longitude) ? longitude.value : undefined,\n    });\n  }\n\n  if (typeof addressValue === 'string') {\n    // Split by comma and filter empty segments\n    const segments = addressValue\n      .split(',')\n      .map(part => part.trim())\n      .filter(Boolean);\n\n    if (segments.length === 0) {\n      return none();\n    }\n\n    // Use intelligent heuristics to parse segments\n    const parsed = parseAddressSegmentsWithHeuristics(segments);\n\n    return some({\n      street1: parsed.street1,\n      street2: parsed.street2,\n      city: parsed.city,\n      state: parsed.state,\n      zipCode: parsed.zipCode,\n      country: parsed.country,\n    });\n  }\n\n  return none();\n};\n\nconst formatAddress = (address: Address | undefined): string | null => {\n  if (!address) {\n    return null;\n  }\n\n  const segments = [\n    address.street1,\n    address.street2,\n    address.city,\n    address.state,\n    address.zipCode,\n    address.country,\n  ].filter(segment => typeof segment === 'string' && segment.trim().length > 0) as string[];\n\n  if (segments.length === 0) {\n    return null;\n  }\n\n  return segments.join(', ');\n};\n\n/**\n * ContactInboundApiDTO - Flexible input type for parsing from API\n *\n * Accepts various formats for fields like gender (Gender | boolean | string) to handle\n * diverse server implementations. This is used when converting from API responses to\n * domain Contact objects.\n */\nexport interface ContactInboundApiDTO {\n  readonly id: string | number;\n  readonly tenant_id: string | number;\n  readonly first_name?: string | null;\n  readonly last_name?: string | null;\n  readonly full_name?: string | null;\n  readonly email?: string | null;\n  readonly phone?: string | null;\n  readonly mobile?: string | null;\n  /** Flexible gender input: accepts Gender enum, boolean (true=male), or string representations */\n  readonly gender?: boolean | string | null;\n  readonly age?: number | null;\n  readonly address?: string | Record<string, unknown> | null;\n  readonly date_of_birth?: string | Date | null;\n  readonly created_at?: string | Date | null;\n  readonly updated_at?: string | Date | null;\n  readonly created_by?: string | null;\n  readonly updated_by?: string | null;\n  readonly is_active?: boolean | null;\n}\n\n/**\n * ContactOutboundApiDTO - Normalized output type for sending to API\n *\n * Enforces strict types for outbound requests to ensure consistency with server contract.\n * Gender is always a boolean (true=male, false=female) per API specification.\n * This is used when converting domain Contact objects to API requests.\n */\nexport interface ContactOutboundApiDTO {\n  readonly id: string | number;\n  readonly tenant_id: string | number;\n  readonly first_name?: string | null;\n  readonly last_name?: string | null;\n  readonly full_name?: string | null;\n  readonly email?: string | null;\n  readonly phone?: string | null;\n  readonly mobile?: string | null;\n  /** Normalized gender output: always boolean (true=male, false=female) or null */\n  readonly gender?: boolean | null;\n  readonly age?: number | null;\n  readonly address?: string | null;\n  readonly date_of_birth?: string | null;\n  readonly created_at?: string | null;\n  readonly updated_at?: string | null;\n  readonly created_by?: string | null;\n  readonly updated_by?: string | null;\n  readonly is_active?: boolean | null;\n}\n\n/** Backward compatibility alias for ContactInboundApiDTO */\nexport type ContactApiDTO = ContactInboundApiDTO;\n\nconst contactFromApi = (input: unknown): Result<Contact, AppError> => {\n  if (!input || typeof input !== 'object') {\n    return err(\n      createTransformerError(\n        { entity: 'Contact', direction: 'fromApi' },\n        'Contact payload must be an object',\n        { inputType: typeof input }\n      )\n    );\n  }\n\n  const source = input as Record<string, unknown>;\n\n  const idValue = pickString(source, ['id', 'contact_id']);\n  if (!isSome(idValue)) {\n    return err(\n      createTransformerError(\n        { entity: 'Contact', direction: 'fromApi' },\n        'Contact identifier is missing',\n        { keys: Object.keys(source).slice(0, 5) }\n      )\n    );\n  }\n\n  const tenantIdValue = pickString(source, ['tenant_id', 'tenantId']);\n  if (!isSome(tenantIdValue)) {\n    return err(\n      createTransformerError(\n        { entity: 'Contact', direction: 'fromApi' },\n        'Contact tenant identifier is missing',\n        { keys: Object.keys(source).slice(0, 5) }\n      )\n    );\n  }\n\n  const firstNameOption = pickString(source, ['first_name', 'firstName']);\n  const lastNameOption = pickString(source, ['last_name', 'lastName']);\n  const fullNameOption = pickString(source, ['full_name', 'fullName', 'name']);\n\n  const computedFullName = isSome(fullNameOption)\n    ? fullNameOption.value\n    : [\n        isSome(firstNameOption) ? firstNameOption.value : undefined,\n        isSome(lastNameOption) ? lastNameOption.value : undefined,\n      ]\n        .filter(Boolean)\n        .join(' ')\n        .trim();\n\n  if (!computedFullName) {\n    return err(\n      createTransformerError(\n        { entity: 'Contact', direction: 'fromApi' },\n        'Contact name is required',\n        { keys: Object.keys(source).slice(0, 5) }\n      )\n    );\n  }\n\n  const resolvedFirstName = isSome(firstNameOption)\n    ? firstNameOption.value\n    : (computedFullName.split(/\\s+/)[0] ?? computedFullName);\n\n  const resolvedLastName = isSome(lastNameOption)\n    ? lastNameOption.value\n    : computedFullName.split(/\\s+/).slice(1).join(' ');\n\n  const genderValue =\n    source.gender ?? source.gender_value ?? source.genderBoolean ?? source.gender_bool;\n  const genderResult: Result<Option<Contact['gender']>, AppError> = typeof genderValue === 'boolean'\n    ? booleanToGender(genderValue).map(value => some(value))\n    : parseOptionalGender(genderValue);\n\n  if (genderResult.isErr()) {\n    return err(\n      createTransformerError(\n        { entity: 'Contact', direction: 'fromApi' },\n        'Invalid gender value received',\n        { valueType: typeof genderValue },\n        genderResult.error\n      )\n    );\n  }\n\n  const dateOfBirthValue = source.date_of_birth ?? source.dateOfBirth ?? source.dob;\n  const dateOfBirthResult = parseOptionalDate(dateOfBirthValue, { context: 'contact.dateOfBirth' });\n  if (dateOfBirthResult.isErr()) {\n    return err(dateOfBirthResult.error);\n  }\n\n  const createdAtValue = source.created_at ?? source.createdAt ?? new Date().toISOString();\n  const createdAtResult = parseDate(createdAtValue, { context: 'contact.createdAt' });\n  if (createdAtResult.isErr()) {\n    return err(createdAtResult.error);\n  }\n\n  const updatedAtValue = source.updated_at ?? source.updatedAt ?? createdAtValue;\n  const updatedAtResult = parseDate(updatedAtValue, { context: 'contact.updatedAt' });\n  if (updatedAtResult.isErr()) {\n    return err(updatedAtResult.error);\n  }\n\n  const createdByOption = pickString(source, ['created_by', 'createdBy']);\n  const updatedByOption = pickString(source, ['updated_by', 'updatedBy']);\n  const ageOption = pickNumber(source, ['age']);\n  const addressOption = buildAddress(source);\n  const emailOption = pickString(source, ['email']);\n  const phoneOption = pickString(source, ['phone']);\n  const mobileOption = pickString(source, ['mobile', 'mobile_phone']);\n  const faxOption = pickString(source, ['fax']);\n  const websiteOption = pickString(source, ['website']);\n  const companyOption = pickString(source, ['company']);\n  const jobTitleOption = pickString(source, ['job_title', 'jobTitle']);\n  const departmentOption = pickString(source, ['department']);\n  const notesOption = pickString(source, ['notes']);\n  const isActiveOption = pickBoolean(source, ['is_active', 'isActive']);\n\n  const createdById = isSome(createdByOption)\n    ? asUserId(createdByOption.value)\n    : asUserId('system');\n  const updatedById = isSome(updatedByOption) ? asUserId(updatedByOption.value) : createdById;\n\n  const contact: Contact = {\n    id: asContactId(idValue.value),\n    tenantId: asTenantId(tenantIdValue.value),\n    firstName: resolvedFirstName,\n    lastName: resolvedLastName,\n    fullName: computedFullName,\n    preferredName: undefined,\n    title: undefined,\n    suffix: undefined,\n    email: optionValue(emailOption),\n    phone: optionValue(phoneOption),\n    mobile: optionValue(mobileOption),\n    fax: optionValue(faxOption),\n    website: optionValue(websiteOption),\n    address: optionValue(addressOption),\n    shippingAddress: undefined,\n    company: optionValue(companyOption),\n    jobTitle: optionValue(jobTitleOption),\n    department: optionValue(departmentOption),\n    dateOfBirth:\n      dateOfBirthResult.value.kind === 'some' ? dateOfBirthResult.value.value : undefined,\n    gender: genderResult.value.kind === 'some' ? genderResult.value.value : undefined,\n    age: optionValue(ageOption),\n    allergies: undefined,\n    medications: undefined,\n    medicalNotes: undefined,\n    emergencyContact: undefined,\n    notes: optionValue(notesOption),\n    tags: undefined,\n    customFields: undefined,\n    createdAt: createdAtResult.value,\n    updatedAt: updatedAtResult.value,\n    createdBy: createdById,\n    updatedBy: updatedById,\n    isActive: optionOrDefault(isActiveOption, true),\n  };\n\n  return ok(contact);\n};\n\nconst contactToApi = (contact: Contact): Result<ContactOutboundApiDTO, AppError> => {\n  const name = contact.fullName?.trim() || `${contact.firstName} ${contact.lastName}`.trim();\n\n  if (!name) {\n    return err(\n      createTransformerError(\n        { entity: 'Contact', direction: 'toApi' },\n        'Contact name is required',\n        { id: String(contact.id), tenantId: String(contact.tenantId) }\n      )\n    );\n  }\n\n  const genderOption = fromNullable(contact.gender);\n  let genderBooleanResult: Result<Option<boolean>, AppError> = isSome(genderOption)\n    ? genderEnumToBoolean(genderOption.value).map(value => some(value))\n    : ok(none());\n\n  if (genderBooleanResult.isErr()) {\n    const error = genderBooleanResult.error;\n    if (error.message.includes('Gender.other should be omitted')) {\n      // For Gender.other, omit the field by setting it to none()\n      genderBooleanResult = ok(none());\n    } else {\n      return err(\n        createTransformerError(\n          { entity: 'Contact', direction: 'toApi' },\n          'Invalid gender provided for contact',\n          { genderType: typeof contact.gender },\n          error\n        )\n      );\n    }\n  }\n\n  const dateOfBirthOption = fromNullable(contact.dateOfBirth);\n  const dateOfBirthResult: Result<Option<string>, AppError> = isSome(dateOfBirthOption)\n    ? toIsoString(dateOfBirthOption.value, { context: 'contact.dateOfBirth' }).map(value =>\n        some(value)\n      )\n    : ok(none());\n\n  if (dateOfBirthResult.isErr()) {\n    return err(dateOfBirthResult.error);\n  }\n\n  const createdAtResult = toIsoString(contact.createdAt, { context: 'contact.createdAt' });\n  if (createdAtResult.isErr()) {\n    return err(createdAtResult.error);\n  }\n\n  const updatedAtResult = toIsoString(contact.updatedAt ?? contact.createdAt, {\n    context: 'contact.updatedAt',\n  });\n  if (updatedAtResult.isErr()) {\n    return err(updatedAtResult.error);\n  }\n\n  const dto: ContactOutboundApiDTO = {\n    id: String(contact.id),\n    tenant_id: String(contact.tenantId),\n    first_name: contact.firstName,\n    last_name: contact.lastName,\n    full_name: name,\n    email: contact.email ?? null,\n    phone: contact.phone ?? null,\n    mobile: contact.mobile ?? null,\n    gender: genderBooleanResult.value.kind === 'some' ? genderBooleanResult.value.value : null,\n    age: contact.age ?? null,\n    address: formatAddress(contact.address),\n    date_of_birth: dateOfBirthResult.value.kind === 'some' ? dateOfBirthResult.value.value : null,\n    created_at: createdAtResult.value,\n    updated_at: updatedAtResult.value,\n    created_by: contact.createdBy ? String(contact.createdBy) : null,\n    updated_by: contact.updatedBy ? String(contact.updatedBy) : null,\n    is_active: contact.isActive ?? true,\n  };\n\n  return ok(dto);\n};\n\nexport interface ContactListApiDTO {\n  readonly contacts?: unknown;\n  readonly data?: unknown;\n  readonly total?: unknown;\n  readonly count?: unknown;\n  readonly page?: unknown;\n  readonly current_page?: unknown;\n  readonly limit?: unknown;\n  readonly page_size?: unknown;\n  readonly per_page?: unknown;\n  readonly totalPages?: unknown;\n  readonly total_pages?: unknown;\n  readonly hasNext?: unknown;\n  readonly hasPrev?: unknown;\n  readonly has_next?: unknown;\n  readonly has_prev?: unknown;\n}\n\nexport const contactListFromApiResponse = (\n  input: unknown\n): Result<ContactListResponse, AppError> => {\n  if (!input || typeof input !== 'object') {\n    return err(\n      createTransformerError(\n        { entity: 'ContactList', direction: 'fromApi' },\n        'Contact list payload must be an object',\n        { inputType: typeof input }\n      )\n    );\n  }\n\n  const sourceRecord = input as Record<string, unknown>;\n  const source = sourceRecord as ContactListApiDTO;\n  const collection: unknown[] | null = Array.isArray(source.contacts)\n    ? source.contacts\n    : Array.isArray(source.data)\n      ? source.data\n      : Array.isArray((source.data as any)?.contacts)\n        ? (source.data as any).contacts\n        : null;\n\n  if (!collection) {\n    return err(\n      createTransformerError(\n        { entity: 'ContactList', direction: 'fromApi' },\n        'Contact list payload is missing contacts collection',\n        { keys: Object.keys(sourceRecord) }\n      )\n    );\n  }\n\n  const contactsResult = collection.reduce<Result<Contact[], AppError>>(\n    (accumulator: Result<Contact[], AppError>, item: unknown, index: number) =>\n      accumulator.andThen((contacts: Contact[]) =>\n        contactFromApi(item)\n          .map((contact: Contact) => [...contacts, contact])\n          .mapErr(error =>\n            createTransformerError(\n              { entity: 'ContactList', direction: 'fromApi' },\n              'Failed to transform contact item',\n              { index },\n              error\n            )\n          )\n      ),\n    ok<Contact[]>([])\n  );\n\n  if (contactsResult.isErr()) {\n    return err(contactsResult.error);\n  }\n\n  const totalOption = pickNumber(sourceRecord, ['total', 'count']);\n  const pageOption = pickNumber(sourceRecord, ['page', 'current_page']);\n  const limitOption = pickNumber(sourceRecord, ['limit', 'page_size', 'per_page']);\n  const totalPagesOption = pickNumber(sourceRecord, ['totalPages', 'total_pages']);\n  const hasNextOption = pickBoolean(sourceRecord, ['hasNext', 'has_next']);\n  const hasPrevOption = pickBoolean(sourceRecord, ['hasPrev', 'has_prev']);\n\n  const contacts = contactsResult.value;\n  const limitDefault = contacts.length > 0 ? contacts.length : 10;\n  const limit = optionOrDefault(limitOption, limitDefault);\n  const total = optionOrDefault(totalOption, contacts.length);\n  const page = optionOrDefault(pageOption, 1);\n  const totalPages = optionOrDefault(totalPagesOption, limit > 0 ? Math.ceil(total / limit) : 1);\n  const hasNext = optionOrDefault(hasNextOption, page < totalPages);\n  const hasPrev = optionOrDefault(hasPrevOption, page > 1);\n\n  return ok({\n    contacts,\n    total,\n    page,\n    limit,\n    totalPages,\n    hasNext,\n    hasPrev,\n  });\n};\n\nexport interface UserApiDTO {\n  readonly id: string;\n  readonly email: string;\n  readonly username: string;\n  readonly first_name?: string | null;\n  readonly last_name?: string | null;\n  readonly avatar?: string | null;\n  readonly roles: string[];\n  readonly tenant_id: string;\n  readonly created_at: string | Date;\n  readonly updated_at: string | Date;\n}\n\nconst userFromApi = (input: unknown): Result<User, AppError> => {\n  if (!input || typeof input !== 'object') {\n    return err(\n      createTransformerError(\n        { entity: 'User', direction: 'fromApi' },\n        'User payload must be an object',\n        { inputType: typeof input }\n      )\n    );\n  }\n\n  const source = input as Record<string, unknown>;\n\n  const idValue = pickString(source, ['id']);\n  const tenantIdValue = pickString(source, ['tenant_id', 'tenantId']);\n  const emailValue = pickString(source, ['email']);\n  const usernameValue = pickString(source, ['username']);\n  const rolesValue = source.roles;\n\n  if (!isSome(idValue) || !isSome(tenantIdValue) || !isSome(emailValue) || !isSome(usernameValue)) {\n    return err(\n      createTransformerError(\n        { entity: 'User', direction: 'fromApi' },\n        'User payload is missing required fields',\n        { source }\n      )\n    );\n  }\n\n  if (!isStringArray(rolesValue)) {\n    return err(\n      createTransformerError(\n        { entity: 'User', direction: 'fromApi' },\n        'Invalid roles array in user payload',\n        { roles: rolesValue }\n      )\n    );\n  }\n\n  const createdAtOption = pickString(source, ['created_at', 'createdAt']);\n  const updatedAtOption = pickString(source, ['updated_at', 'updatedAt']);\n  const firstNameOption = pickString(source, ['first_name', 'firstName']);\n  const lastNameOption = pickString(source, ['last_name', 'lastName']);\n  const avatarOption = pickString(source, ['avatar']);\n\n  const createdAt = optionOrDefault(createdAtOption, new Date().toISOString());\n  const updatedAt = optionOrDefault(updatedAtOption, createdAt);\n\n  const user: User = {\n    id: asUserId(idValue.value),\n    email: emailValue.value,\n    username: usernameValue.value,\n    firstName: optionValue(firstNameOption),\n    lastName: optionValue(lastNameOption),\n    avatar: optionValue(avatarOption),\n    roles: rolesValue,\n    tenantId: asTenantId(tenantIdValue.value),\n    createdAt,\n    updatedAt,\n  };\n\n  return ok(user);\n};\n\nconst userToApi = (user: User): Result<UserApiDTO, AppError> => {\n  if (!user.id || !user.email || !user.username || !user.tenantId) {\n    return err(\n      createTransformerError(\n        { entity: 'User', direction: 'toApi' },\n        'User is missing required fields',\n        { user }\n      )\n    );\n  }\n\n  const dto: UserApiDTO = {\n    id: String(user.id),\n    email: user.email,\n    username: user.username,\n    first_name: user.firstName ?? null,\n    last_name: user.lastName ?? null,\n    avatar: user.avatar ?? null,\n    roles: [...user.roles],\n    tenant_id: String(user.tenantId),\n    created_at: user.createdAt,\n    updated_at: user.updatedAt,\n  };\n\n  return ok(dto);\n};\n\nexport interface TenantApiDTO {\n  readonly id: string;\n  readonly name: string;\n  readonly db_url?: string | null;\n  readonly created_at?: string | Date | null;\n  readonly updated_at?: string | Date | null;\n}\n\nconst tenantFromApi = (input: unknown): Result<TenantRecord, AppError> => {\n  if (!input || typeof input !== 'object') {\n    return err(\n      createTransformerError(\n        { entity: 'Tenant', direction: 'fromApi' },\n        'Tenant payload must be an object',\n        { inputType: typeof input }\n      )\n    );\n  }\n\n  const source = input as Record<string, unknown>;\n  const idValue = pickString(source, ['id']);\n  const nameValue = pickString(source, ['name']);\n\n  if (!isSome(idValue) || !isSome(nameValue)) {\n    return err(\n      createTransformerError(\n        { entity: 'Tenant', direction: 'fromApi' },\n        'Tenant payload is missing required fields',\n        { source }\n      )\n    );\n  }\n\n  const dbUrlOption = pickString(source, ['db_url', 'dbUrl']);\n  const createdAtOption = pickString(source, ['created_at', 'createdAt']);\n  const updatedAtOption = pickString(source, ['updated_at', 'updatedAt']);\n\n  const tenant: TenantRecord = {\n    id: asTenantId(idValue.value),\n    name: nameValue.value,\n    db_url: optionOrDefault(dbUrlOption, ''),\n    created_at: optionOrDefault(createdAtOption, new Date().toISOString()),\n    updated_at: optionOrDefault(updatedAtOption, new Date().toISOString()),\n  };\n\n  return ok(tenant);\n};\n\nconst tenantToApi = (tenant: TenantRecord): Result<TenantApiDTO, AppError> => {\n  if (!tenant.id || !tenant.name) {\n    return err(\n      createTransformerError(\n        { entity: 'Tenant', direction: 'toApi' },\n        'Tenant is missing required fields',\n        { tenant }\n      )\n    );\n  }\n\n  const dto: TenantApiDTO = {\n    id: String(tenant.id),\n    name: tenant.name,\n    db_url: tenant.db_url ?? null,\n    created_at: tenant.created_at,\n    updated_at: tenant.updated_at,\n  };\n\n  return ok(dto);\n};\n\nexport interface TransformerPair<Domain, DTO> {\n  readonly toApi: (value: Domain) => Result<DTO, AppError>;\n  readonly fromApi: (value: unknown) => Result<Domain, AppError>;\n}\n\nexport const mapContact: TransformerPair<Contact, ContactOutboundApiDTO> = {\n  toApi: toApiDTO(contactToApi, 'Contact'),\n  fromApi: fromApiDTO(contactFromApi, 'Contact'),\n};\n\nexport const mapUser: TransformerPair<User, UserApiDTO> = {\n  toApi: toApiDTO(userToApi, 'User'),\n  fromApi: fromApiDTO(userFromApi, 'User'),\n};\n\nexport const mapTenant: TransformerPair<TenantRecord, TenantApiDTO> = {\n  toApi: toApiDTO(tenantToApi, 'Tenant'),\n  fromApi: fromApiDTO(tenantFromApi, 'Tenant'),\n};\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/transformers/gender.ts",
        "messages": [],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 0,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/transformers/index.ts",
        "messages": [],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 0,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/types/__tests__/fp.test.ts",
        "messages": [],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 0,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/types/api.ts",
        "messages": [],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 0,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/types/auth.ts",
        "messages": [
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 112,
                "column": 31,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 112,
                "endColumn": 34,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                2236,
                                2239
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                2236,
                                2239
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 1,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "// Authentication Types for JWT Multi-Tenant System\nimport type { UserId, TenantId } from './ids';\n\nexport interface User {\n  id: UserId;\n  email: string;\n  username: string;\n  firstName?: string;\n  lastName?: string;\n  avatar?: string;\n  roles: string[];\n  tenantId: TenantId;\n  createdAt: string;\n  updatedAt: string;\n}\n\nexport interface Tenant {\n  id: TenantId;\n  name: string;\n  domain?: string;\n  logo?: string;\n  settings: TenantSettings;\n  subscription: TenantSubscription;\n  isActive?: boolean;\n  db_url?: string;\n  created_at?: string;\n  updated_at?: string;\n}\n\nexport interface TenantSettings {\n  theme: 'light' | 'dark' | 'natural';\n  language: string;\n  timezone: string;\n  dateFormat: string;\n  features: string[];\n  branding: {\n    primaryColor: string;\n    secondaryColor: string;\n    accentColor: string;\n  };\n}\n\nexport interface TenantSubscription {\n  plan: 'basic' | 'professional' | 'enterprise';\n  status: 'active' | 'trial' | 'expired' | 'cancelled';\n  expiresAt?: Date;\n  limits: {\n    users: number;\n    contacts: number;\n    storage: number;\n  };\n}\n\nexport interface AuthState {\n  isAuthenticated: boolean;\n  isLoading: boolean;\n  user: User | null;\n  tenant: Tenant | null;\n  token: string | null;\n  refreshToken: string | null;\n  lastActivity: string | null;\n}\n\nexport interface LoginCredentials {\n  usernameOrEmail: string;\n  password: string;\n  tenantId?: TenantId;\n  rememberMe?: boolean;\n}\n\nexport interface RegisterData {\n  firstName: string;\n  lastName: string;\n  email: string;\n  password: string;\n  confirmPassword: string;\n  acceptTerms: boolean;\n}\n\nexport interface AuthResponse {\n  success: boolean;\n  token: string;\n  refreshToken: string;\n  user: User;\n  tenant: Tenant;\n  expiresIn: number;\n  message?: string;\n}\n\nexport interface TokenPayload {\n  sub: UserId; // user id\n  email: string;\n  tenantId: TenantId;\n  roles: string[];\n  iat: number; // issued at\n  exp: number; // expires at\n}\n\nexport interface PasswordResetRequest {\n  email: string;\n}\n\nexport interface PasswordResetConfirm {\n  token: string;\n  newPassword: string;\n  confirmPassword: string;\n}\n\nexport interface Permission {\n  resource: string;\n  actions: ('create' | 'read' | 'update' | 'delete')[];\n  conditions?: Record<string, any>;\n}\n\nexport interface TokenMetadata {\n  issuedAt: number;\n  lastRevokeAt?: number;\n  isBlacklisted?: boolean;\n  tenantRole?: string;\n  permissions?: string[];\n}\n\nexport interface TenantAccess {\n  userId: UserId;\n  tenantId: TenantId;\n  role: 'owner' | 'member' | 'invited';\n  status: 'active' | 'inactive' | 'suspended';\n  acceptedAt?: string;\n  permissions: string[];\n}\n\nexport interface AuthContextType extends Omit<AuthState, 'refreshToken'> {\n  refreshToken: string | null;\n  login: (credentials: LoginCredentials) => Promise<AuthResponse>;\n  logout: () => Promise<void>;\n  refreshAuthToken: () => Promise<string | null>;\n  register: (data: RegisterData) => Promise<AuthResponse>;\n  resetPassword: (email: string) => Promise<{ success: boolean; message: string }>;\n  confirmPasswordReset: (\n    data: PasswordResetConfirm\n  ) => Promise<{ success: boolean; message: string }>;\n  hasPermission: (resource: string, action: string) => boolean;\n  switchTenant: (tenantId: string) => Promise<void>;\n}\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/types/contact.ts",
        "messages": [
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 153,
                "column": 10,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 153,
                "endColumn": 13,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                3333,
                                3336
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                3333,
                                3336
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 1,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "// Contact/Address Book Types with Enhanced Fields\nimport type { ContactId, TenantId, UserId } from './ids';\nimport type { Gender as PersonGenderType } from './person';\nimport { Gender as PersonGender } from './person';\n\nexport interface Contact {\n  id: ContactId;\n  tenantId: TenantId;\n  // Personal Information\n  firstName: string;\n  lastName: string;\n  fullName: string;\n  preferredName?: string;\n  title?: string;\n  suffix?: string;\n  // Contact Information\n  email?: string;\n  phone?: string;\n  mobile?: string;\n  fax?: string;\n  website?: string;\n  // Address Information\n  address?: Address;\n  shippingAddress?: Address;\n  // Professional Information\n  company?: string;\n  jobTitle?: string;\n  department?: string;\n  // Health Information (Pharmacy Context)\n  dateOfBirth?: Date;\n  gender?: PersonGenderType;\n  age?: number;\n  allergies?: string[];\n  medications?: string[];\n  medicalNotes?: string;\n  emergencyContact?: EmergencyContact;\n  // Additional Information\n  notes?: string;\n  tags?: string[];\n  customFields?: Record<string, unknown>;\n  // Metadata\n  createdAt: Date;\n  updatedAt: Date;\n  createdBy: UserId;\n  updatedBy: UserId;\n  isActive: boolean;\n}\n\nexport interface Address {\n  id?: string;\n  street1: string;\n  street2?: string;\n  city: string;\n  state: string;\n  zipCode: string;\n  country: string;\n  latitude?: number;\n  longitude?: number;\n}\n\nexport interface EmergencyContact {\n  name: string;\n  relationship: string;\n  phone: string;\n  email?: string;\n}\n\n// Contact Form and Validation Types\nexport interface ContactFormData {\n  firstName: string;\n  lastName: string;\n  email?: string;\n  phone?: string;\n  mobile?: string;\n  address?: AddressFormData;\n  company?: string;\n  jobTitle?: string;\n  dateOfBirth?: string;\n  allergies?: string;\n  medications?: string;\n  medicalNotes?: string;\n  emergencyContact?: EmergencyContactFormData;\n  notes?: string;\n  tags?: string[];\n}\n\nexport interface AddressFormData {\n  street1: string;\n  street2?: string;\n  city: string;\n  state: string;\n  zipCode: string;\n  country: string;\n}\n\nexport interface EmergencyContactFormData {\n  name: string;\n  relationship: string;\n  phone: string;\n  email?: string;\n}\n\n// Contact List and Search Types\nexport interface ContactListParams {\n  page?: number;\n  limit?: number;\n  sortBy?: 'name' | 'email' | 'createdAt' | 'updatedAt';\n  sortOrder?: 'asc' | 'desc';\n  search?: string;\n  tag?: string;\n  hasEmail?: boolean;\n  hasPhone?: boolean;\n}\n\nexport interface ContactListResponse {\n  contacts: Contact[];\n  total: number;\n  page: number;\n  limit: number;\n  totalPages: number;\n  hasNext: boolean;\n  hasPrev: boolean;\n}\n\n// Contact CRUD Types\nexport interface CreateContactRequest extends Omit<ContactFormData, 'customFields'> {\n  customFields?: Record<string, unknown>;\n}\n\nexport interface UpdateContactRequest extends Partial<CreateContactRequest> {\n  id: ContactId;\n}\n\nexport interface ContactResponse {\n  success: boolean;\n  contact?: Contact;\n  error?: string;\n  message?: string;\n}\n\nexport interface BulkContactOperation {\n  operation: 'delete' | 'tag' | 'untag' | 'export';\n  contactIds: ContactId[];\n  tagName?: string; // for tag/untag operations\n  exportFormat?: 'csv' | 'json' | 'vcard';\n}\n\nexport interface BulkContactResponse {\n  success: boolean;\n  processed: number;\n  failed: number;\n  errors?: string[];\n  data?: any; // for export operations\n}\n\n// Contact Import/Export Types\nexport interface ContactImportRequest {\n  file: File;\n  format: 'csv' | 'json' | 'vcard';\n  mapping?: Record<string, string>; // column mapping for CSV\n  options?: {\n    skipDuplicates?: boolean;\n    updateExisting?: boolean;\n    sendWelcomeEmails?: boolean;\n  };\n}\n\nexport interface ContactImportResponse {\n  success: boolean;\n  imported: number;\n  skipped: number;\n  errors: ImportError[];\n  total: number;\n}\n\nexport interface ImportError {\n  row: number;\n  field?: string;\n  message: string;\n}\n\n// Contact Tags and Categories\nexport interface ContactTag {\n  id: ContactId;\n  name: string;\n  color: string;\n  description?: string;\n  tenantId: TenantId;\n  createdAt: Date;\n  usageCount: number;\n}\n\nexport interface ContactTagStats {\n  tagId: ContactId;\n  tagName: string;\n  contactCount: number;\n}\n\nexport const Gender = PersonGender;\nexport type Gender = PersonGenderType;\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/types/errors.ts",
        "messages": [
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected any value in conditional. An explicit comparison or type conversion is required.",
                "line": 194,
                "column": 8,
                "nodeType": "Identifier",
                "messageId": "conditionErrorAny",
                "endLine": 194,
                "endColumn": 13,
                "suggestions": [
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                6124,
                                6129
                            ],
                            "text": "(Boolean(error))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/restrict-template-expressions",
                "severity": 1,
                "message": "Invalid type \"number\" of template literal expression.",
                "line": 288,
                "column": 71,
                "nodeType": "MemberExpression",
                "messageId": "invalidType",
                "endLine": 288,
                "endColumn": 85
            },
            {
                "ruleId": "@typescript-eslint/restrict-template-expressions",
                "severity": 1,
                "message": "Invalid type \"number\" of template literal expression.",
                "line": 288,
                "column": 94,
                "nodeType": "MemberExpression",
                "messageId": "invalidType",
                "endLine": 288,
                "endColumn": 103
            },
            {
                "ruleId": "@typescript-eslint/restrict-template-expressions",
                "severity": 1,
                "message": "Invalid type \"number\" of template literal expression.",
                "line": 314,
                "column": 43,
                "nodeType": "MemberExpression",
                "messageId": "invalidType",
                "endLine": 314,
                "endColumn": 52
            },
            {
                "ruleId": "@typescript-eslint/restrict-template-expressions",
                "severity": 1,
                "message": "Invalid type \"number\" of template literal expression.",
                "line": 314,
                "column": 72,
                "nodeType": "MemberExpression",
                "messageId": "invalidType",
                "endLine": 314,
                "endColumn": 84
            },
            {
                "ruleId": "@typescript-eslint/restrict-template-expressions",
                "severity": 1,
                "message": "Invalid type \"number\" of template literal expression.",
                "line": 316,
                "column": 42,
                "nodeType": "MemberExpression",
                "messageId": "invalidType",
                "endLine": 316,
                "endColumn": 51
            },
            {
                "ruleId": "@typescript-eslint/restrict-template-expressions",
                "severity": 1,
                "message": "Invalid type \"number\" of template literal expression.",
                "line": 316,
                "column": 71,
                "nodeType": "MemberExpression",
                "messageId": "invalidType",
                "endLine": 316,
                "endColumn": 83
            },
            {
                "ruleId": "@typescript-eslint/restrict-template-expressions",
                "severity": 1,
                "message": "Invalid type \"number\" of template literal expression.",
                "line": 322,
                "column": 43,
                "nodeType": "MemberExpression",
                "messageId": "invalidType",
                "endLine": 322,
                "endColumn": 52
            },
            {
                "ruleId": "@typescript-eslint/restrict-template-expressions",
                "severity": 1,
                "message": "Invalid type \"number\" of template literal expression.",
                "line": 322,
                "column": 72,
                "nodeType": "MemberExpression",
                "messageId": "invalidType",
                "endLine": 322,
                "endColumn": 84
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.",
                "line": 343,
                "column": 48,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorNullableNumber",
                "endLine": 343,
                "endColumn": 64,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                11751,
                                11767
                            ],
                            "text": "(error.statusCode != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultZero",
                        "fix": {
                            "range": [
                                11751,
                                11767
                            ],
                            "text": "(error.statusCode ?? 0)"
                        },
                        "desc": "Explicitly treat nullish value the same as 0 (`value ?? 0`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                11751,
                                11767
                            ],
                            "text": "(Boolean(error.statusCode))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/restrict-template-expressions",
                "severity": 1,
                "message": "Invalid type \"number\" of template literal expression.",
                "line": 343,
                "column": 72,
                "nodeType": "MemberExpression",
                "messageId": "invalidType",
                "endLine": 343,
                "endColumn": 88
            },
            {
                "ruleId": "@typescript-eslint/restrict-template-expressions",
                "severity": 1,
                "message": "Invalid type \"number\" of template literal expression.",
                "line": 349,
                "column": 31,
                "nodeType": "MemberExpression",
                "messageId": "invalidType",
                "endLine": 349,
                "endColumn": 47
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 12,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "export interface BaseError {\n  readonly type: 'validation' | 'network' | 'auth' | 'business';\n  readonly message: string;\n  readonly code?: string;\n  readonly details?: Record<string, unknown>;\n  readonly cause?: unknown;\n  readonly retryable?: boolean;\n  readonly statusCode?: number;\n}\n\nexport interface ValidationError extends BaseError {\n  readonly type: 'validation';\n}\n\nexport interface ValidationErrorDetails {\n  readonly issues?: unknown[];\n  readonly [key: string]: unknown;\n}\n\nexport interface TypedValidationError extends Omit<ValidationError, 'details'> {\n  readonly details?: ValidationErrorDetails;\n}\n\nexport interface NetworkError extends BaseError {\n  readonly type: 'network';\n}\n\nexport interface AuthError extends BaseError {\n  readonly type: 'auth';\n}\n\nexport interface BusinessLogicError extends BaseError {\n  readonly type: 'business';\n}\n\nexport type AppError = TypedValidationError | NetworkError | AuthError | BusinessLogicError;\n\nexport const createValidationError = (\n  message: string,\n  details?: Record<string, unknown>,\n  options?: { code?: string; cause?: unknown; statusCode?: number }\n): TypedValidationError => ({\n  type: 'validation',\n  message,\n  details,\n  code: options?.code,\n  cause: options?.cause,\n  statusCode: options?.statusCode,\n});\n\nexport const createNetworkError = (\n  message: string,\n  details?: Record<string, unknown>,\n  options?: { code?: string; retryable?: boolean; cause?: unknown; statusCode?: number }\n): NetworkError => ({\n  type: 'network',\n  message,\n  details,\n  code: options?.code,\n  retryable: options?.retryable,\n  cause: options?.cause,\n  statusCode: options?.statusCode,\n});\n\nexport const createAuthError = (\n  message: string,\n  details?: Record<string, unknown>,\n  options?: { code?: string; cause?: unknown; statusCode?: number }\n): AuthError => ({\n  type: 'auth',\n  message,\n  details,\n  code: options?.code,\n  cause: options?.cause,\n  statusCode: options?.statusCode,\n});\n\nexport const createBusinessLogicError = (\n  message: string,\n  details?: Record<string, unknown>,\n  options?: { code?: string; cause?: unknown; statusCode?: number }\n): BusinessLogicError => ({\n  type: 'business',\n  message,\n  details,\n  code: options?.code,\n  cause: options?.cause,\n  statusCode: options?.statusCode,\n});\n\n/**\n * Storage-related errors for FP patterns\n */\nexport type StorageError =\n  | { type: 'NOT_FOUND'; key: string }\n  | { type: 'PARSE_ERROR'; key: string; reason: string }\n  | { type: 'STRINGIFY_ERROR'; key: string; reason: string }\n  | { type: 'QUOTA_EXCEEDED'; key: string }\n  | { type: 'STORAGE_UNAVAILABLE'; reason: string }\n  | { type: 'VERSION_MISMATCH'; key: string; expected: number; got: number };\n\n/**\n * Parse-related errors for JSON and JWT parsing\n */\nexport type ParseError =\n  | { type: 'INVALID_JSON'; raw: string; reason: string }\n  | { type: 'INVALID_JWT_FORMAT'; token: string }\n  | { type: 'MISSING_JWT_FIELDS'; fields: string[] }\n  | { type: 'EXPIRED_TOKEN'; exp: number; now: number }\n  | { type: 'INVALID_USER_STRUCTURE'; reason: string }\n  | { type: 'INVALID_TENANT_STRUCTURE'; reason: string };\n\n/**\n * API call specific errors for retry logic and enhanced error handling\n */\nexport interface ApiCallError {\n  readonly attemptNumber?: number;\n  readonly maxRetries?: number;\n  readonly retryable?: boolean;\n}\n\n/**\n * Validation errors for credentials (discriminated unions)\n */\nexport type CredentialValidationError =\n  | { type: 'EMPTY_USERNAME' }\n  | { type: 'USERNAME_TOO_SHORT'; min: number; actual: number }\n  | { type: 'USERNAME_TOO_LONG'; max: number; actual: number }\n  | { type: 'INVALID_USERNAME_FORMAT'; pattern: string }\n  | { type: 'EMPTY_PASSWORD' }\n  | { type: 'PASSWORD_TOO_SHORT'; min: number; actual: number }\n  | { type: 'PASSWORD_TOO_WEAK'; requirements: string[] }\n  | { type: 'EMPTY_TENANT_ID' }\n  | { type: 'INVALID_TENANT_ID_FORMAT'; pattern: string }\n  | { type: 'INVALID_EMAIL_FORMAT'; email: string };\n\n/**\n * Authentication-related errors for FP patterns\n */\nexport type AuthFlowError =\n  | { type: 'INVALID_CREDENTIALS'; message: string }\n  | { type: 'TOKEN_EXPIRED' }\n  | { type: 'TOKEN_REFRESH_FAILED'; reason: string }\n  | { type: 'NETWORK_ERROR'; statusCode?: number; message: string }\n  | { type: 'UNAUTHORIZED'; message: string }\n  | { type: 'FORBIDDEN'; message: string }\n  | { type: 'SERVER_ERROR'; statusCode: number; message: string }\n  | { type: 'LOGOUT_FAILED'; reason: string }\n  | { type: 'INIT_FAILED'; reason: string }\n  | { type: 'MISSING_TOKEN' }\n  | { type: 'TENANT_MISMATCH'; expected: string; actual: string };\n\n/**\n * Helper functions to create error instances\n */\nexport const StorageErrors = {\n  notFound: (key: string): StorageError => ({ type: 'NOT_FOUND', key }),\n  parseError: (key: string, reason: string): StorageError => ({ type: 'PARSE_ERROR', key, reason }),\n  stringifyError: (key: string, reason: string): StorageError => ({\n    type: 'STRINGIFY_ERROR',\n    key,\n    reason,\n  }),\n  quotaExceeded: (key: string): StorageError => ({ type: 'QUOTA_EXCEEDED', key }),\n  unavailable: (reason: string): StorageError => ({ type: 'STORAGE_UNAVAILABLE', reason }),\n  versionMismatch: (key: string, expected: number, got: number): StorageError => ({\n    type: 'VERSION_MISMATCH',\n    key,\n    expected,\n    got,\n  }),\n};\n\nexport const ParseErrors = {\n  invalidJson: (raw: string, reason: string): ParseError => ({ type: 'INVALID_JSON', raw, reason }),\n  invalidJwtFormat: (token: string): ParseError => ({ type: 'INVALID_JWT_FORMAT', token }),\n  missingJwtFields: (fields: string[]): ParseError => ({ type: 'MISSING_JWT_FIELDS', fields }),\n  expiredToken: (exp: number, now: number): ParseError => ({ type: 'EXPIRED_TOKEN', exp, now }),\n  invalidUserStructure: (reason: string): ParseError => ({\n    type: 'INVALID_USER_STRUCTURE',\n    reason,\n  }),\n  invalidTenantStructure: (reason: string): ParseError => ({\n    type: 'INVALID_TENANT_STRUCTURE',\n    reason,\n  }),\n};\n\n/**\n * Type guard to check if an unknown error is a ParseError\n * Use this instead of string literal checks for type safety\n */\nexport function isParseError(error: unknown): error is ParseError {\n  if (!error || typeof error !== 'object') return false;\n  const e = error as { type?: string };\n  return (\n    e.type === 'INVALID_JSON' ||\n    e.type === 'INVALID_JWT_FORMAT' ||\n    e.type === 'MISSING_JWT_FIELDS' ||\n    e.type === 'EXPIRED_TOKEN' ||\n    e.type === 'INVALID_USER_STRUCTURE' ||\n    e.type === 'INVALID_TENANT_STRUCTURE'\n  );\n}\n\nexport const ValidationErrors = {\n  emptyUsername: (): CredentialValidationError => ({ type: 'EMPTY_USERNAME' }),\n  usernameTooShort: (min: number, actual: number): CredentialValidationError => ({\n    type: 'USERNAME_TOO_SHORT',\n    min,\n    actual,\n  }),\n  usernameTooLong: (max: number, actual: number): CredentialValidationError => ({\n    type: 'USERNAME_TOO_LONG',\n    max,\n    actual,\n  }),\n  invalidUsernameFormat: (pattern: string): CredentialValidationError => ({\n    type: 'INVALID_USERNAME_FORMAT',\n    pattern,\n  }),\n  emptyPassword: (): CredentialValidationError => ({ type: 'EMPTY_PASSWORD' }),\n  passwordTooShort: (min: number, actual: number): CredentialValidationError => ({\n    type: 'PASSWORD_TOO_SHORT',\n    min,\n    actual,\n  }),\n  passwordTooWeak: (requirements: string[]): CredentialValidationError => ({\n    type: 'PASSWORD_TOO_WEAK',\n    requirements,\n  }),\n  emptyTenantId: (): CredentialValidationError => ({ type: 'EMPTY_TENANT_ID' }),\n  invalidTenantIdFormat: (pattern: string): CredentialValidationError => ({\n    type: 'INVALID_TENANT_ID_FORMAT',\n    pattern,\n  }),\n  invalidEmailFormat: (email: string): CredentialValidationError => ({\n    type: 'INVALID_EMAIL_FORMAT',\n    email,\n  }),\n};\n\nexport const AuthFlowErrors = {\n  invalidCredentials: (message: string): AuthFlowError => ({\n    type: 'INVALID_CREDENTIALS',\n    message,\n  }),\n  tokenExpired: (): AuthFlowError => ({ type: 'TOKEN_EXPIRED' }),\n  tokenRefreshFailed: (reason: string): AuthFlowError => ({ type: 'TOKEN_REFRESH_FAILED', reason }),\n  networkError: (message: string, statusCode?: number): AuthFlowError => ({\n    type: 'NETWORK_ERROR',\n    statusCode,\n    message,\n  }),\n  unauthorized: (message: string): AuthFlowError => ({ type: 'UNAUTHORIZED', message }),\n  forbidden: (message: string): AuthFlowError => ({ type: 'FORBIDDEN', message }),\n  serverError: (statusCode: number, message: string): AuthFlowError => ({\n    type: 'SERVER_ERROR',\n    statusCode,\n    message,\n  }),\n  logoutFailed: (reason: string): AuthFlowError => ({ type: 'LOGOUT_FAILED', reason }),\n  initFailed: (reason: string): AuthFlowError => ({ type: 'INIT_FAILED', reason }),\n  missingToken: (): AuthFlowError => ({ type: 'MISSING_TOKEN' }),\n  tenantMismatch: (expected: string, actual: string): AuthFlowError => ({\n    type: 'TENANT_MISMATCH',\n    expected,\n    actual,\n  }),\n};\n\n/**\n * Error formatting utilities for FP patterns\n */\nexport const formatStorageError = (error: StorageError): string => {\n  switch (error.type) {\n    case 'NOT_FOUND':\n      return `Storage key not found: ${error.key}`;\n    case 'PARSE_ERROR':\n      return `Failed to parse stored data for '${error.key}': ${error.reason}`;\n    case 'STRINGIFY_ERROR':\n      return `Failed to stringify data for '${error.key}': ${error.reason}`;\n    case 'QUOTA_EXCEEDED':\n      return `Storage quota exceeded for key: ${error.key}`;\n    case 'STORAGE_UNAVAILABLE':\n      return `Storage unavailable: ${error.reason}`;\n    case 'VERSION_MISMATCH':\n      return `Storage version mismatch for '${error.key}': expected ${error.expected}, got ${error.got}`;\n  }\n};\n\nexport const formatParseError = (error: ParseError): string => {\n  switch (error.type) {\n    case 'INVALID_JSON':\n      return `Invalid JSON: ${error.reason}`;\n    case 'INVALID_JWT_FORMAT':\n      return 'Invalid JWT token format';\n    case 'MISSING_JWT_FIELDS':\n      return `Missing required JWT fields: ${error.fields.join(', ')}`;\n    case 'EXPIRED_TOKEN':\n      return `Token expired at ${new Date(error.exp * 1000).toISOString()}`;\n    case 'INVALID_USER_STRUCTURE':\n      return `Invalid user data structure: ${error.reason}`;\n    case 'INVALID_TENANT_STRUCTURE':\n      return `Invalid tenant data structure: ${error.reason}`;\n  }\n};\n\nexport const formatCredentialValidationError = (error: CredentialValidationError): string => {\n  switch (error.type) {\n    case 'EMPTY_USERNAME':\n      return 'Username cannot be empty';\n    case 'USERNAME_TOO_SHORT':\n      return `Username must be at least ${error.min} characters (got ${error.actual})`;\n    case 'USERNAME_TOO_LONG':\n      return `Username must be at most ${error.max} characters (got ${error.actual})`;\n    case 'INVALID_USERNAME_FORMAT':\n      return `Username format is invalid (expected: ${error.pattern})`;\n    case 'EMPTY_PASSWORD':\n      return 'Password cannot be empty';\n    case 'PASSWORD_TOO_SHORT':\n      return `Password must be at least ${error.min} characters (got ${error.actual})`;\n    case 'PASSWORD_TOO_WEAK':\n      return `Password must meet requirements: ${error.requirements.join(', ')}`;\n    case 'EMPTY_TENANT_ID':\n      return 'Tenant ID cannot be empty';\n    case 'INVALID_TENANT_ID_FORMAT':\n      return `Tenant ID format is invalid (expected: ${error.pattern})`;\n    case 'INVALID_EMAIL_FORMAT':\n      return `Invalid email format: ${error.email}`;\n  }\n};\n\nexport const formatAuthFlowError = (error: AuthFlowError): string => {\n  switch (error.type) {\n    case 'INVALID_CREDENTIALS':\n      return error.message || 'Invalid username or password';\n    case 'TOKEN_EXPIRED':\n      return 'Your session has expired. Please log in again';\n    case 'TOKEN_REFRESH_FAILED':\n      return `Failed to refresh token: ${error.reason}`;\n    case 'NETWORK_ERROR':\n      return `Network error: ${error.message}${error.statusCode ? ` (${error.statusCode})` : ''}`;\n    case 'UNAUTHORIZED':\n      return error.message || 'Unauthorized access';\n    case 'FORBIDDEN':\n      return error.message || 'Access forbidden';\n    case 'SERVER_ERROR':\n      return `Server error (${error.statusCode}): ${error.message}`;\n    case 'LOGOUT_FAILED':\n      return `Logout failed: ${error.reason}`;\n    case 'INIT_FAILED':\n      return `Authentication initialization failed: ${error.reason}`;\n    case 'MISSING_TOKEN':\n      return 'Authentication token is missing';\n    case 'TENANT_MISMATCH':\n      return `Tenant mismatch: expected '${error.expected}', got '${error.actual}'`;\n  }\n};\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/types/fp.ts",
        "messages": [],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 0,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/types/ids.ts",
        "messages": [],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 0,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/types/jest-dom.d.ts",
        "messages": [],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 0,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/types/person.ts",
        "messages": [
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
                "line": 175,
                "column": 9,
                "nodeType": "ChainExpression",
                "messageId": "conditionErrorNullableBoolean",
                "endLine": 175,
                "endColumn": 24,
                "suggestions": [
                    {
                        "messageId": "conditionFixDefaultFalse",
                        "fix": {
                            "range": [
                                4473,
                                4488
                            ],
                            "text": "(options?.strict) ?? false"
                        },
                        "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
                    },
                    {
                        "messageId": "conditionFixCompareTrue",
                        "fix": {
                            "range": [
                                4473,
                                4488
                            ],
                            "text": "(options?.strict) === true"
                        },
                        "desc": "Change condition to check if true (`value === true`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected value in conditional. A boolean expression is required.",
                "line": 176,
                "column": 26,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorOther",
                "endLine": 176,
                "endColumn": 40
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 225,
                "column": 12,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 225,
                "endColumn": 19,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                5862,
                                5869
                            ],
                            "text": "(street1 != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                5862,
                                5869
                            ],
                            "text": "(street1 ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                5862,
                                5869
                            ],
                            "text": "(Boolean(street1))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 241,
                "column": 7,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 241,
                "endColumn": 14,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                6454,
                                6461
                            ],
                            "text": "street1 != null"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                6454,
                                6461
                            ],
                            "text": "street1 ?? \"\""
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                6454,
                                6461
                            ],
                            "text": "Boolean(street1)"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 242,
                "column": 7,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 242,
                "endColumn": 14,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                6499,
                                6506
                            ],
                            "text": "street2 != null"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                6499,
                                6506
                            ],
                            "text": "street2 ?? \"\""
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                6499,
                                6506
                            ],
                            "text": "Boolean(street2)"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 243,
                "column": 7,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 243,
                "endColumn": 11,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                6544,
                                6548
                            ],
                            "text": "city != null"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                6544,
                                6548
                            ],
                            "text": "city ?? \"\""
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                6544,
                                6548
                            ],
                            "text": "Boolean(city)"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 244,
                "column": 7,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 244,
                "endColumn": 12,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                6580,
                                6585
                            ],
                            "text": "state != null"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                6580,
                                6585
                            ],
                            "text": "state ?? \"\""
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                6580,
                                6585
                            ],
                            "text": "Boolean(state)"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 245,
                "column": 7,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 245,
                "endColumn": 14,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                6619,
                                6626
                            ],
                            "text": "zipCode != null"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                6619,
                                6626
                            ],
                            "text": "zipCode ?? \"\""
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                6619,
                                6626
                            ],
                            "text": "Boolean(zipCode)"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 246,
                "column": 7,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 246,
                "endColumn": 14,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                6664,
                                6671
                            ],
                            "text": "country != null"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                6664,
                                6671
                            ],
                            "text": "country ?? \"\""
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                6664,
                                6671
                            ],
                            "text": "Boolean(country)"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 282,
                "column": 7,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 282,
                "endColumn": 15,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                7577,
                                7585
                            ],
                            "text": "tenantId != null"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                7577,
                                7585
                            ],
                            "text": "tenantId ?? \"\""
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                7577,
                                7585
                            ],
                            "text": "Boolean(tenantId)"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 287,
                "column": 7,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 287,
                "endColumn": 16,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                7722,
                                7731
                            ],
                            "text": "firstName != null"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                7722,
                                7731
                            ],
                            "text": "firstName ?? \"\""
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                7722,
                                7731
                            ],
                            "text": "Boolean(firstName)"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 292,
                "column": 7,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 292,
                "endColumn": 15,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                7866,
                                7874
                            ],
                            "text": "lastName != null"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                7866,
                                7874
                            ],
                            "text": "lastName ?? \"\""
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                7866,
                                7874
                            ],
                            "text": "Boolean(lastName)"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 304,
                "column": 7,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 304,
                "endColumn": 12,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                8250,
                                8255
                            ],
                            "text": "email != null"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                8250,
                                8255
                            ],
                            "text": "email ?? \"\""
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                8250,
                                8255
                            ],
                            "text": "Boolean(email)"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 309,
                "column": 7,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 309,
                "endColumn": 12,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                8374,
                                8379
                            ],
                            "text": "phone != null"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                8374,
                                8379
                            ],
                            "text": "phone ?? \"\""
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                8374,
                                8379
                            ],
                            "text": "Boolean(phone)"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 346,
                "column": 7,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 346,
                "endColumn": 16,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                9378,
                                9387
                            ],
                            "text": "createdBy != null"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                9378,
                                9387
                            ],
                            "text": "createdBy ?? \"\""
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                9378,
                                9387
                            ],
                            "text": "Boolean(createdBy)"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 351,
                "column": 7,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 351,
                "endColumn": 16,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                9528,
                                9537
                            ],
                            "text": "updatedBy != null"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                9528,
                                9537
                            ],
                            "text": "updatedBy ?? \"\""
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                9528,
                                9537
                            ],
                            "text": "Boolean(updatedBy)"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 16,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "import { logger } from '../utils/logger';\n\nexport const Gender = {\n  male: 'male',\n  female: 'female',\n  other: 'other',\n} as const;\n\nexport type Gender = (typeof Gender)[keyof typeof Gender];\n\nexport interface PersonAddressDTO {\n  street1?: string;\n  street2?: string;\n  city?: string;\n  state?: string;\n  zipCode?: string;\n  country?: string;\n}\n\n/**\n * Canonical person data transfer object exposed to the frontend.\n */\nexport interface PersonDTO {\n  id?: string | number;\n  tenantId?: string;\n  firstName?: string;\n  lastName?: string;\n  fullName?: string;\n  email?: string;\n  phone?: string;\n  gender?: Gender | null;\n  age?: number;\n  address?: PersonAddressDTO;\n  createdAt?: Date;\n  updatedAt?: Date;\n  createdBy?: string;\n  updatedBy?: string;\n  isActive?: boolean;\n}\n\nexport interface CreatePersonDTO {\n  name: string;\n  email?: string;\n  phone?: string;\n  gender?: Gender;\n  age?: number;\n  /**\n   * Address handling note: This field accepts a string representation for API compatibility.\n   * Backend may store addresses as a single string or convert structured address objects.\n   * The PersonDTO normalizes this to a structured PersonAddressDTO for frontend use.\n   * If your backend API expects a structured address object instead, update this to:\n   * address?: PersonAddressDTO;\n   * and adjust transformations accordingly.\n   */\n  address?: string;\n  tenant_id: string;\n}\n\nexport interface UpdatePersonDTO {\n  id: string | number;\n  name?: string;\n  email?: string;\n  phone?: string;\n  gender?: Gender;\n  age?: number;\n  /**\n   * Address handling note: This field accepts a string representation for API compatibility.\n   * See CreatePersonDTO.address for details about API contract verification.\n   */\n  address?: string;\n}\n\nconst toRecord = (input: unknown): Record<string, unknown> | null =>\n  typeof input === 'object' && input !== null ? (input as Record<string, unknown>) : null;\n\nconst pick = (source: Record<string, unknown>, keys: readonly string[]): unknown => {\n  for (const key of keys) {\n    if (Object.prototype.hasOwnProperty.call(source, key)) {\n      return source[key];\n    }\n  }\n  return undefined;\n};\n\nconst asString = (value: unknown): string | undefined => {\n  if (typeof value === 'string') {\n    const trimmed = value.trim();\n    return trimmed.length > 0 ? trimmed : undefined;\n  }\n\n  if (typeof value === 'number' && Number.isFinite(value)) {\n    return value.toString();\n  }\n\n  return undefined;\n};\n\nconst asNumber = (value: unknown): number | undefined => {\n  if (typeof value === 'number' && Number.isFinite(value)) {\n    return value;\n  }\n\n  if (typeof value === 'string' && value.trim()) {\n    const parsed = Number(value);\n    return Number.isFinite(parsed) ? parsed : undefined;\n  }\n\n  return undefined;\n};\n\nconst asDate = (value: unknown): Date | undefined => {\n  if (value instanceof Date) {\n    const timestamp = value.getTime();\n    return Number.isNaN(timestamp) ? undefined : new Date(timestamp);\n  }\n\n  if (typeof value === 'string' || typeof value === 'number') {\n    const parsed = new Date(value);\n    return Number.isNaN(parsed.getTime()) ? undefined : parsed;\n  }\n\n  return undefined;\n};\n\ninterface GenderNormalizationContext {\n  id?: string | number;\n  source?: string;\n  rawField?: unknown;\n}\n\nconst normalizeGender = (\n  value: unknown,\n  options?: { strict?: boolean; context?: GenderNormalizationContext }\n): Gender | null | undefined => {\n  if (value === null) {\n    return null;\n  }\n\n  // Note: boolean values are not normalized - they're invalid input types.\n  // If your backend sends boolean gender values, validate them server-side.\n  if (typeof value === 'boolean') {\n    return undefined;\n  }\n\n  if (typeof value === 'string') {\n    const normalized = value.trim().toLowerCase();\n    if (!normalized) {\n      return undefined;\n    }\n\n    if (['male', 'm'].includes(normalized)) {\n      return Gender.male;\n    }\n\n    if (['female', 'f'].includes(normalized)) {\n      return Gender.female;\n    }\n\n    if (\n      ['other', 'non-binary', 'nonbinary', 'non binary', 'nb', 'genderqueer'].includes(normalized)\n    ) {\n      return Gender.other;\n    }\n\n    // Log unrecognized gender values for visibility\n    const contextInfo = options?.context ?? {};\n    logger.warn('Unrecognized gender value encountered', {\n      rawValue: value,\n      normalizedValue: normalized,\n      recordId: contextInfo.id,\n      source: contextInfo.source ?? 'unknown',\n      rawField: contextInfo.rawField,\n    });\n\n    if (options?.strict) {\n      const contextStr = contextInfo.id\n        ? `${contextInfo.source ?? 'unknown'} (id: ${String(contextInfo.id)})`\n        : (contextInfo.source ?? 'unknown');\n      throw new Error(`Invalid gender value: \"${value}\" in context: ${contextStr}`);\n    }\n\n    // Intentional fallback: Unrecognized gender strings default to 'other'\n    // rather than being rejected. This allows frontend to gracefully handle\n    // new gender values introduced by the backend without breaking.\n    // If stricter validation is needed, use a schema validator at the service boundary.\n    return Gender.other;\n  }\n\n  return undefined;\n};\n\nconst normalizeBoolean = (value: unknown): boolean | undefined => {\n  if (typeof value === 'boolean') {\n    return value;\n  }\n\n  if (typeof value === 'number') {\n    if (Number.isNaN(value)) {\n      return undefined;\n    }\n    return value !== 0;\n  }\n\n  if (typeof value === 'string') {\n    const normalized = value.trim().toLowerCase();\n    if (!normalized) {\n      return undefined;\n    }\n\n    if (['true', '1', 'yes', 'y'].includes(normalized)) {\n      return true;\n    }\n\n    if (['false', '0', 'no', 'n'].includes(normalized)) {\n      return false;\n    }\n  }\n\n  return undefined;\n};\n\nconst normalizeAddress = (value: unknown): PersonAddressDTO | undefined => {\n  if (typeof value === 'string') {\n    const street1 = asString(value);\n    return street1 ? { street1 } : undefined;\n  }\n\n  const record = toRecord(value);\n  if (!record) {\n    return undefined;\n  }\n\n  const street1 = asString(pick(record, ['street1', 'street_1', 'address', 'line1']));\n  const street2 = asString(pick(record, ['street2', 'street_2', 'line2']));\n  const city = asString(pick(record, ['city']));\n  const state = asString(pick(record, ['state', 'region']));\n  const zipCode = asString(pick(record, ['zipCode', 'zip_code', 'postalCode', 'postal_code']));\n  const country = asString(pick(record, ['country']));\n\n  const normalized: PersonAddressDTO = {};\n  if (street1) normalized.street1 = street1;\n  if (street2) normalized.street2 = street2;\n  if (city) normalized.city = city;\n  if (state) normalized.state = state;\n  if (zipCode) normalized.zipCode = zipCode;\n  if (country) normalized.country = country;\n\n  return Object.keys(normalized).length > 0 ? normalized : undefined;\n};\n\nconst coerceId = (value: unknown): string | number | undefined => {\n  if (typeof value === 'string') {\n    return value.trim().length > 0 ? value.trim() : undefined;\n  }\n\n  if (typeof value === 'number' && Number.isFinite(value)) {\n    return value;\n  }\n\n  return undefined;\n};\n\n/**\n * Normalises raw backend payloads into the canonical PersonDTO representation.\n */\nexport const normalizePersonDTO = (raw: unknown): PersonDTO => {\n  const record = toRecord(raw);\n  if (!record) {\n    return {};\n  }\n\n  const normalized: PersonDTO = {};\n\n  const idValue = coerceId(\n    pick(record, ['id', 'personId', 'person_id', 'contactId', 'contact_id'])\n  );\n  if (idValue !== undefined) {\n    normalized.id = idValue;\n  }\n\n  const tenantId = asString(pick(record, ['tenantId', 'tenant_id', 'tenant']));\n  if (tenantId) {\n    normalized.tenantId = tenantId;\n  }\n\n  const firstName = asString(pick(record, ['firstName', 'first_name', 'firstname']));\n  if (firstName) {\n    normalized.firstName = firstName;\n  }\n\n  const lastName = asString(pick(record, ['lastName', 'last_name', 'lastname']));\n  if (lastName) {\n    normalized.lastName = lastName;\n  }\n\n  const fullName = asString(pick(record, ['fullName', 'full_name', 'name']));\n  const computedFullName =\n    fullName ?? [normalized.firstName, normalized.lastName].filter(Boolean).join(' ').trim();\n  if (computedFullName) {\n    normalized.fullName = computedFullName;\n  }\n\n  const email = asString(pick(record, ['email']));\n  if (email) {\n    normalized.email = email;\n  }\n\n  const phone = asString(pick(record, ['phone', 'mobile', 'telephone']));\n  if (phone) {\n    normalized.phone = phone;\n  }\n\n  const rawGenderField = pick(record, ['gender', 'gender_value', 'genderValue']);\n  const genderValue = normalizeGender(rawGenderField, {\n    context: {\n      id: idValue,\n      source: 'person',\n      rawField: rawGenderField,\n    },\n  });\n  if (genderValue !== undefined) {\n    normalized.gender = genderValue;\n  }\n\n  const age = asNumber(pick(record, ['age']));\n  if (age !== undefined) {\n    normalized.age = age;\n  }\n\n  const address = normalizeAddress(pick(record, ['address', 'addressInfo', 'address_dto']));\n  if (address) {\n    normalized.address = address;\n  }\n\n  const createdAt = asDate(pick(record, ['createdAt', 'created_at', 'created_on']));\n  if (createdAt) {\n    normalized.createdAt = createdAt;\n  }\n\n  const updatedAt = asDate(pick(record, ['updatedAt', 'updated_at', 'updated_on']));\n  if (updatedAt) {\n    normalized.updatedAt = updatedAt;\n  }\n\n  const createdBy = asString(pick(record, ['createdBy', 'created_by', 'createdUser']));\n  if (createdBy) {\n    normalized.createdBy = createdBy;\n  }\n\n  const updatedBy = asString(pick(record, ['updatedBy', 'updated_by', 'updatedUser']));\n  if (updatedBy) {\n    normalized.updatedBy = updatedBy;\n  }\n\n  const isActive = normalizeBoolean(pick(record, ['isActive', 'is_active', 'active']));\n  if (isActive !== undefined) {\n    normalized.isActive = isActive;\n  }\n\n  return normalized;\n};\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/types/search.ts",
        "messages": [],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 0,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/types/tenant.ts",
        "messages": [],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 0,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/utils/__tests__/addressParsingLogger.test.ts",
        "messages": [],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 0,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/utils/__tests__/cache.test.ts",
        "messages": [
            {
                "ruleId": "@typescript-eslint/restrict-template-expressions",
                "severity": 1,
                "message": "Invalid type \"number\" of template literal expression.",
                "line": 370,
                "column": 35,
                "nodeType": "Identifier",
                "messageId": "invalidType",
                "endLine": 370,
                "endColumn": 36
            },
            {
                "ruleId": "@typescript-eslint/restrict-template-expressions",
                "severity": 1,
                "message": "Invalid type \"number\" of template literal expression.",
                "line": 374,
                "column": 38,
                "nodeType": "Identifier",
                "messageId": "invalidType",
                "endLine": 374,
                "endColumn": 39
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 2,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "/**\n * Cache Utilities Tests\n *\n * Tests for Result-based cache layer with focus on regex sanitization\n * in invalidateEntity to prevent ReDoS attacks.\n */\n\nimport { describe, it, expect, beforeEach } from 'bun:test';\nimport { resultCache, invalidateEntity } from '@/utils/cache';\n\ndescribe('cache', () => {\n  beforeEach(() => {\n    // Clear cache before each test to ensure isolation\n    resultCache.clear();\n  });\n\n  describe('invalidateEntity', () => {\n    describe('regex metacharacter sanitization', () => {\n      it('should sanitize and match entity types with regex metacharacters: .*', () => {\n        // Setup: Add cache entries with normal naming\n        resultCache.set('user.*-123', { id: '123' }, 5000);\n        resultCache.set('user.*-456', { id: '456' }, 5000);\n        resultCache.set('admin-789', { id: '789' }, 5000);\n\n        // Execute: Invalidate using entity type containing .*\n        const result = invalidateEntity('user.*');\n\n        // Assert: Should succeed without hanging or throwing\n        expect(result.isOk()).toBe(true);\n\n        if (result.isOk()) {\n          // Should only match entries that literally start with \"user.*-\"\n          expect(result.value).toBe(2);\n        }\n\n        // Verify: Only user.* entries should be removed\n        expect(resultCache.has('user.*-123')).toBe(false);\n        expect(resultCache.has('user.*-456')).toBe(false);\n        expect(resultCache.has('admin-789')).toBe(true);\n      });\n\n      it('should sanitize and match entity types with character class: [0-9]+', () => {\n        // Setup\n        resultCache.set('entity[0-9]+-abc', { data: 'test1' }, 5000);\n        resultCache.set('entity[0-9]+-def', { data: 'test2' }, 5000);\n        resultCache.set('normal-entity-ghi', { data: 'test3' }, 5000);\n\n        // Execute\n        const result = invalidateEntity('entity[0-9]+');\n\n        // Assert\n        expect(result.isOk()).toBe(true);\n\n        if (result.isOk()) {\n          // Should match literal \"entity[0-9]+-\" prefix\n          expect(result.value).toBe(2);\n        }\n\n        // Verify\n        expect(resultCache.has('entity[0-9]+-abc')).toBe(false);\n        expect(resultCache.has('entity[0-9]+-def')).toBe(false);\n        expect(resultCache.has('normal-entity-ghi')).toBe(true);\n      });\n\n      it('should sanitize entity types with multiple metacharacters: (a|b)*', () => {\n        // Setup\n        resultCache.set('(a|b)*-item1', { value: 1 }, 5000);\n        resultCache.set('(a|b)*-item2', { value: 2 }, 5000);\n        resultCache.set('other-item3', { value: 3 }, 5000);\n\n        // Execute\n        const result = invalidateEntity('(a|b)*');\n\n        // Assert: Should not hang or throw ReDoS error\n        expect(result.isOk()).toBe(true);\n\n        if (result.isOk()) {\n          expect(result.value).toBe(2);\n        }\n\n        // Verify\n        expect(resultCache.has('(a|b)*-item1')).toBe(false);\n        expect(resultCache.has('(a|b)*-item2')).toBe(false);\n        expect(resultCache.has('other-item3')).toBe(true);\n      });\n\n      it('should sanitize entity types with dollar sign: user$', () => {\n        // Setup\n        resultCache.set('user$-100', { active: true }, 5000);\n        resultCache.set('user$-200', { active: false }, 5000);\n        resultCache.set('userA-300', { active: true }, 5000);\n\n        // Execute\n        const result = invalidateEntity('user$');\n\n        // Assert\n        expect(result.isOk()).toBe(true);\n\n        if (result.isOk()) {\n          expect(result.value).toBe(2);\n        }\n\n        // Verify: Only literal \"user$-\" prefix matches\n        expect(resultCache.has('user$-100')).toBe(false);\n        expect(resultCache.has('user$-200')).toBe(false);\n        expect(resultCache.has('userA-300')).toBe(true);\n      });\n\n      it('should sanitize entity types with caret: ^user', () => {\n        // Setup\n        resultCache.set('^user-foo', { type: 'special' }, 5000);\n        resultCache.set('^user-bar', { type: 'normal' }, 5000);\n        resultCache.set('user-baz', { type: 'standard' }, 5000);\n\n        // Execute\n        const result = invalidateEntity('^user');\n\n        // Assert\n        expect(result.isOk()).toBe(true);\n\n        if (result.isOk()) {\n          expect(result.value).toBe(2);\n        }\n\n        // Verify\n        expect(resultCache.has('^user-foo')).toBe(false);\n        expect(resultCache.has('^user-bar')).toBe(false);\n        expect(resultCache.has('user-baz')).toBe(true);\n      });\n\n      it('should sanitize entity types with question mark: data?', () => {\n        // Setup\n        resultCache.set('data?-alpha', { count: 10 }, 5000);\n        resultCache.set('data?-beta', { count: 20 }, 5000);\n        resultCache.set('dataX-gamma', { count: 30 }, 5000);\n\n        // Execute\n        const result = invalidateEntity('data?');\n\n        // Assert\n        expect(result.isOk()).toBe(true);\n\n        if (result.isOk()) {\n          expect(result.value).toBe(2);\n        }\n\n        // Verify\n        expect(resultCache.has('data?-alpha')).toBe(false);\n        expect(resultCache.has('data?-beta')).toBe(false);\n        expect(resultCache.has('dataX-gamma')).toBe(true);\n      });\n\n      it('should sanitize entity types with plus: cache+', () => {\n        // Setup\n        resultCache.set('cache+-entry1', { cached: true }, 5000);\n        resultCache.set('cache+-entry2', { cached: true }, 5000);\n        resultCache.set('cache-entry3', { cached: false }, 5000);\n\n        // Execute\n        const result = invalidateEntity('cache+');\n\n        // Assert\n        expect(result.isOk()).toBe(true);\n\n        if (result.isOk()) {\n          expect(result.value).toBe(2);\n        }\n\n        // Verify\n        expect(resultCache.has('cache+-entry1')).toBe(false);\n        expect(resultCache.has('cache+-entry2')).toBe(false);\n        expect(resultCache.has('cache-entry3')).toBe(true);\n      });\n\n      it('should sanitize entity types with curly braces: item{2,5}', () => {\n        // Setup\n        resultCache.set('item{2,5}-first', { order: 1 }, 5000);\n        resultCache.set('item{2,5}-second', { order: 2 }, 5000);\n        resultCache.set('item-third', { order: 3 }, 5000);\n\n        // Execute\n        const result = invalidateEntity('item{2,5}');\n\n        // Assert\n        expect(result.isOk()).toBe(true);\n\n        if (result.isOk()) {\n          expect(result.value).toBe(2);\n        }\n\n        // Verify\n        expect(resultCache.has('item{2,5}-first')).toBe(false);\n        expect(resultCache.has('item{2,5}-second')).toBe(false);\n        expect(resultCache.has('item-third')).toBe(true);\n      });\n\n      it('should sanitize entity types with backslash: path\\\\to\\\\resource', () => {\n        // Setup\n        resultCache.set('path\\\\to\\\\resource-1', { path: 'A' }, 5000);\n        resultCache.set('path\\\\to\\\\resource-2', { path: 'B' }, 5000);\n        resultCache.set('pathXtoXresource-3', { path: 'C' }, 5000);\n\n        // Execute\n        const result = invalidateEntity('path\\\\to\\\\resource');\n\n        // Assert\n        expect(result.isOk()).toBe(true);\n\n        if (result.isOk()) {\n          expect(result.value).toBe(2);\n        }\n\n        // Verify\n        expect(resultCache.has('path\\\\to\\\\resource-1')).toBe(false);\n        expect(resultCache.has('path\\\\to\\\\resource-2')).toBe(false);\n        expect(resultCache.has('pathXtoXresource-3')).toBe(true);\n      });\n\n      it('should sanitize entity types with all metacharacters combined', () => {\n        // Setup: Complex pattern with many metacharacters\n        const complexType = '.*+?^${}()|[]\\\\';\n        resultCache.set(`${complexType}-data1`, { complex: true }, 5000);\n        resultCache.set(`${complexType}-data2`, { complex: true }, 5000);\n        resultCache.set('simple-data3', { complex: false }, 5000);\n\n        // Execute\n        const result = invalidateEntity(complexType);\n\n        // Assert: Should complete quickly without hanging\n        expect(result.isOk()).toBe(true);\n\n        if (result.isOk()) {\n          expect(result.value).toBe(2);\n        }\n\n        // Verify\n        expect(resultCache.has(`${complexType}-data1`)).toBe(false);\n        expect(resultCache.has(`${complexType}-data2`)).toBe(false);\n        expect(resultCache.has('simple-data3')).toBe(true);\n      });\n    });\n\n    describe('normal entity types', () => {\n      it('should invalidate normal user entity type', () => {\n        // Setup\n        resultCache.set('user-123', { name: 'Alice' }, 5000);\n        resultCache.set('user-456', { name: 'Bob' }, 5000);\n        resultCache.set('contact-789', { name: 'Charlie' }, 5000);\n\n        // Execute\n        const result = invalidateEntity('user');\n\n        // Assert\n        expect(result.isOk()).toBe(true);\n\n        if (result.isOk()) {\n          expect(result.value).toBe(2);\n        }\n\n        // Verify\n        expect(resultCache.has('user-123')).toBe(false);\n        expect(resultCache.has('user-456')).toBe(false);\n        expect(resultCache.has('contact-789')).toBe(true);\n      });\n\n      it('should invalidate normal contact entity type', () => {\n        // Setup\n        resultCache.set('contact-abc', { email: 'a@test.com' }, 5000);\n        resultCache.set('contact-def', { email: 'b@test.com' }, 5000);\n        resultCache.set('user-ghi', { email: 'c@test.com' }, 5000);\n\n        // Execute\n        const result = invalidateEntity('contact');\n\n        // Assert\n        expect(result.isOk()).toBe(true);\n\n        if (result.isOk()) {\n          expect(result.value).toBe(2);\n        }\n\n        // Verify\n        expect(resultCache.has('contact-abc')).toBe(false);\n        expect(resultCache.has('contact-def')).toBe(false);\n        expect(resultCache.has('user-ghi')).toBe(true);\n      });\n\n      it('should invalidate tenant entity type', () => {\n        // Setup\n        resultCache.set('tenant-org1', { name: 'Org 1' }, 5000);\n        resultCache.set('tenant-org2', { name: 'Org 2' }, 5000);\n        resultCache.set('user-org3', { name: 'User 3' }, 5000);\n\n        // Execute\n        const result = invalidateEntity('tenant');\n\n        // Assert\n        expect(result.isOk()).toBe(true);\n\n        if (result.isOk()) {\n          expect(result.value).toBe(2);\n        }\n\n        // Verify\n        expect(resultCache.has('tenant-org1')).toBe(false);\n        expect(resultCache.has('tenant-org2')).toBe(false);\n        expect(resultCache.has('user-org3')).toBe(true);\n      });\n\n      it('should return 0 when no matching entries exist', () => {\n        // Setup\n        resultCache.set('user-123', { data: 'test' }, 5000);\n        resultCache.set('contact-456', { data: 'test' }, 5000);\n\n        // Execute: Try to invalidate non-existent entity type\n        const result = invalidateEntity('nonexistent');\n\n        // Assert\n        expect(result.isOk()).toBe(true);\n\n        if (result.isOk()) {\n          expect(result.value).toBe(0);\n        }\n\n        // Verify: Original entries still exist\n        expect(resultCache.has('user-123')).toBe(true);\n        expect(resultCache.has('contact-456')).toBe(true);\n      });\n\n      it('should handle empty entity type gracefully', () => {\n        // Setup\n        resultCache.set('-orphan1', { data: 'test' }, 5000);\n        resultCache.set('-orphan2', { data: 'test' }, 5000);\n        resultCache.set('normal-entry', { data: 'test' }, 5000);\n\n        // Execute\n        const result = invalidateEntity('');\n\n        // Assert\n        expect(result.isOk()).toBe(true);\n\n        if (result.isOk()) {\n          // Should match entries starting with \"-\"\n          expect(result.value).toBe(2);\n        }\n      });\n    });\n\n    describe('edge cases and performance', () => {\n      it('should handle very long entity type strings', () => {\n        // Setup: Long entity type name\n        const longType = 'very'.repeat(100) + 'longentitytype';\n        resultCache.set(`${longType}-1`, { data: 'test' }, 5000);\n        resultCache.set(`${longType}-2`, { data: 'test' }, 5000);\n\n        // Execute\n        const result = invalidateEntity(longType);\n\n        // Assert: Should succeed without issues\n        expect(result.isOk()).toBe(true);\n\n        if (result.isOk()) {\n          expect(result.value).toBe(2);\n        }\n      });\n\n      it('should complete quickly even with many cache entries', () => {\n        // Setup: Add many entries\n        for (let i = 0; i < 1000; i++) {\n          resultCache.set(`user-${i}`, { id: i }, 5000);\n        }\n\n        for (let i = 0; i < 100; i++) {\n          resultCache.set(`contact-${i}`, { id: i }, 5000);\n        }\n\n        // Execute: Should complete quickly\n        const startTime = performance.now();\n        const result = invalidateEntity('user');\n        const endTime = performance.now();\n\n        // Assert\n        expect(result.isOk()).toBe(true);\n\n        if (result.isOk()) {\n          expect(result.value).toBe(1000);\n        }\n\n        // Should complete in reasonable time (< 100ms even with 1000+ entries)\n        expect(endTime - startTime).toBeLessThan(100);\n\n        // Verify contacts weren't touched\n        expect(resultCache.has('contact-0')).toBe(true);\n        expect(resultCache.has('contact-50')).toBe(true);\n      });\n\n      it('should not throw RegExp-related errors with pathological inputs', () => {\n        // These patterns are known to cause ReDoS if not properly sanitized\n        const pathologicalPatterns = [\n          '(a+)+',\n          '(a|a)*',\n          '(a|ab)*',\n          'a*a*a*a*a*a*a*a*a*a*',\n          '((a*)*(b*))*',\n        ];\n\n        pathologicalPatterns.forEach(pattern => {\n          // Setup\n          resultCache.set(`${pattern}-test`, { pattern }, 5000);\n\n          // Execute: Should not hang or throw\n          const result = invalidateEntity(pattern);\n\n          // Assert\n          expect(result.isOk()).toBe(true);\n          expect(() => {\n            // Verify no exceptions during execution\n            invalidateEntity(pattern);\n          }).not.toThrow();\n        });\n      });\n\n      it('should handle unicode characters in entity types', () => {\n        // Setup\n        resultCache.set('-123', { lang: 'zh' }, 5000);\n        resultCache.set('-456', { lang: 'zh' }, 5000);\n        resultCache.set('user-789', { lang: 'en' }, 5000);\n\n        // Execute\n        const result = invalidateEntity('');\n\n        // Assert\n        expect(result.isOk()).toBe(true);\n\n        if (result.isOk()) {\n          expect(result.value).toBe(2);\n        }\n\n        // Verify\n        expect(resultCache.has('-123')).toBe(false);\n        expect(resultCache.has('-456')).toBe(false);\n        expect(resultCache.has('user-789')).toBe(true);\n      });\n\n      it('should preserve entries that partially match but do not start with pattern', () => {\n        // Setup\n        resultCache.set('user-123', { type: 'user' }, 5000);\n        resultCache.set('admin-user-456', { type: 'admin' }, 5000);\n        resultCache.set('superuser-789', { type: 'super' }, 5000);\n\n        // Execute\n        const result = invalidateEntity('user');\n\n        // Assert\n        expect(result.isOk()).toBe(true);\n\n        if (result.isOk()) {\n          // Only entries starting with \"user-\" should match\n          expect(result.value).toBe(1);\n        }\n\n        // Verify: Only exact prefix match is removed\n        expect(resultCache.has('user-123')).toBe(false);\n        expect(resultCache.has('admin-user-456')).toBe(true);\n        expect(resultCache.has('superuser-789')).toBe(true);\n      });\n    });\n\n    describe('result type guarantees', () => {\n      it('should always return Result type, never throw', () => {\n        // Various inputs that should all return Result\n        const testInputs = ['user', 'user.*', '(a|b)*', '[0-9]+', '', 'very'.repeat(1000)];\n\n        testInputs.forEach(input => {\n          const result = invalidateEntity(input);\n\n          // Should always be a Result\n          expect(typeof result.isOk).toBe('function');\n          expect(typeof result.isErr).toBe('function');\n        });\n      });\n\n      it('should return Ok Result with number on success', () => {\n        // Setup\n        resultCache.set('test-1', { data: 'a' }, 5000);\n        resultCache.set('test-2', { data: 'b' }, 5000);\n\n        // Execute\n        const result = invalidateEntity('test');\n\n        // Assert\n        expect(result.isOk()).toBe(true);\n\n        if (result.isOk()) {\n          expect(typeof result.value).toBe('number');\n          expect(result.value).toBe(2);\n        }\n      });\n    });\n  });\n});\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/utils/__tests__/commonPasswordsLoader.test.ts",
        "messages": [
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 64,
                "column": 18,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 64,
                "endColumn": 21,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                2148,
                                2151
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                2148,
                                2151
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .window on an `any` value.",
                "line": 64,
                "column": 23,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 64,
                "endColumn": 29
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, the types have no overlap.",
                "line": 70,
                "column": 13,
                "nodeType": "BinaryExpression",
                "messageId": "noOverlapBooleanExpression",
                "endLine": 70,
                "endColumn": 41
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 71,
                "column": 29,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 71,
                "endColumn": 32,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                2383,
                                2386
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                2383,
                                2386
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .window on an `any` value.",
                "line": 71,
                "column": 34,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 71,
                "endColumn": 40
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 81,
                "column": 18,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 81,
                "endColumn": 21,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                2645,
                                2648
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                2645,
                                2648
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .window on an `any` value.",
                "line": 81,
                "column": 23,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 81,
                "endColumn": 29
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, the types have no overlap.",
                "line": 90,
                "column": 13,
                "nodeType": "BinaryExpression",
                "messageId": "noOverlapBooleanExpression",
                "endLine": 90,
                "endColumn": 41
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 91,
                "column": 29,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 91,
                "endColumn": 32,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                2982,
                                2985
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                2982,
                                2985
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .window on an `any` value.",
                "line": 91,
                "column": 34,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 91,
                "endColumn": 40
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 10,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "/**\n * Common Passwords Loader Tests\n */\n\nimport { describe, it, expect, beforeEach } from 'bun:test';\nimport { CommonPasswordsLoader } from '../commonPasswordsLoader';\nimport { COMMON_PASSWORDS_FALLBACK } from '../../config/commonPasswords';\nimport { http, HttpResponse } from 'msw';\nimport { getServer } from '../../test-utils/mocks/server';\n\ndescribe('CommonPasswordsLoader', () => {\n  beforeEach(() => {\n    // Setup MSW handler for common-passwords.json endpoint\n    getServer().use(\n      http.get(/\\/config\\/common-passwords\\.json$/, () => {\n        return HttpResponse.json({\n          version: '1.0.0',\n          description: 'Test passwords',\n          lastUpdated: '2025-01-01',\n          source: 'test',\n          passwords: ['test1', 'test2', 'test3'],\n        });\n      })\n    );\n\n    // Reset the singleton instance\n    CommonPasswordsLoader.__resetForTests();\n  });\n  describe('getInstance', () => {\n    it('should return singleton instance', () => {\n      const instance1 = CommonPasswordsLoader.getInstance();\n      const instance2 = CommonPasswordsLoader.getInstance();\n      expect(instance1).toBe(instance2);\n    });\n\n    it('should accept custom config', () => {\n      const config = { enabled: false, cacheTtlMs: 1000, requestTimeoutMs: 500 };\n      const loader = CommonPasswordsLoader.getInstance(config);\n      expect(loader).toBeDefined();\n    });\n\n    it('should throw error when maxCacheEntries is not a positive integer', () => {\n      expect(() => {\n        CommonPasswordsLoader.getInstance({ maxCacheEntries: 0 });\n      }).toThrow();\n\n      expect(() => {\n        CommonPasswordsLoader.getInstance({ maxCacheEntries: -1 });\n      }).toThrow();\n\n      expect(() => {\n        CommonPasswordsLoader.getInstance({ maxCacheEntries: 3.5 });\n      }).toThrow();\n    });\n\n    it('should accept valid maxCacheEntries', () => {\n      const loader = CommonPasswordsLoader.getInstance({ maxCacheEntries: 5000 });\n      expect(loader).toBeDefined();\n    });\n\n    it('should validate isSSR:false works in client environment', () => {\n      // Mock client environment\n      const originalWindow = global.window;\n      (global as any).window = {};\n\n      try {\n        const loader = CommonPasswordsLoader.getInstance({ isSSR: false });\n        expect(loader).toBeDefined();\n      } finally {\n        if (originalWindow === undefined) {\n          delete (global as any).window;\n        } else {\n          global.window = originalWindow;\n        }\n      }\n    });\n\n    it('should throw when isSSR:true in client environment', () => {\n      // Mock client environment\n      const originalWindow = global.window;\n      (global as any).window = {};\n\n      try {\n        expect(() => {\n          CommonPasswordsLoader.getInstance({ isSSR: true });\n        }).toThrow(\n          'Configuration mismatch: isSSR is set to true but window is defined (client environment)'\n        );\n      } finally {\n        if (originalWindow === undefined) {\n          delete (global as any).window;\n        } else {\n          global.window = originalWindow;\n        }\n      }\n    });\n\n    it('should allow undefined isSSR to use runtime detection', async () => {\n      // Should not throw when isSSR is undefined (uses runtime detection)\n      const loader = CommonPasswordsLoader.getInstance({ isSSR: undefined });\n      expect(loader).toBeDefined();\n\n      // Verify the loader is functional by calling getCommonPasswords()\n      const passwords = await loader.getCommonPasswords();\n\n      // Assert it returns an array with valid data\n      expect(Array.isArray(passwords)).toBe(true);\n      expect(passwords.length).toBeGreaterThan(0);\n\n      // Verify it contains the expected type of data (strings)\n      expect(typeof passwords[0]).toBe('string');\n    });\n  });\n\n  describe('getCommonPasswords', () => {\n    it('should fallback to built-in list when file is missing or invalid', async () => {\n      // Use a custom config that points to a non-existent file to force fallback\n      const loader = CommonPasswordsLoader.getInstance({\n        filePath: '/non-existent-test-file.json',\n        enabled: true,\n      });\n      const passwords = await loader.getCommonPasswords();\n\n      // Should fallback to built-in list since the file doesn't exist\n      expect(passwords).toEqual(COMMON_PASSWORDS_FALLBACK);\n    });\n\n    it('should return cached passwords on subsequent calls', async () => {\n      const loader = CommonPasswordsLoader.getInstance({\n        filePath: '/non-existent-test-file.json',\n        enabled: true,\n      });\n\n      // First call\n      const passwords1 = await loader.getCommonPasswords();\n      expect(passwords1).toEqual(COMMON_PASSWORDS_FALLBACK);\n\n      // Second call should use cache\n      const passwords2 = await loader.getCommonPasswords();\n      expect(passwords2).toEqual(COMMON_PASSWORDS_FALLBACK);\n    });\n\n    it('should fallback to built-in list when loading is disabled', async () => {\n      const loader = CommonPasswordsLoader.getInstance({ enabled: false });\n      const passwords = await loader.getCommonPasswords();\n\n      expect(passwords).toEqual(COMMON_PASSWORDS_FALLBACK);\n    });\n\n    it('should fallback to built-in list when fetch fails', async () => {\n      // Override MSW handler to throw an error\n      getServer().use(\n        http.get(/\\/config\\/common-passwords\\.json$/, () => {\n          return HttpResponse.error();\n        })\n      );\n\n      const loader = CommonPasswordsLoader.getInstance();\n      const passwords = await loader.getCommonPasswords();\n\n      expect(passwords).toEqual(COMMON_PASSWORDS_FALLBACK);\n    });\n\n    it('should handle invalid JSON response', async () => {\n      // Override MSW handler to return invalid JSON structure\n      getServer().use(\n        http.get(/\\/config\\/common-passwords\\.json$/, () => {\n          return HttpResponse.json({ invalid: 'response' });\n        })\n      );\n\n      const loader = CommonPasswordsLoader.getInstance();\n      const passwords = await loader.getCommonPasswords();\n\n      expect(passwords).toEqual(COMMON_PASSWORDS_FALLBACK);\n    });\n\n    it('should enforce maxCacheEntries limit on fallback list', async () => {\n      // Instantiate loader with maxCacheEntries: 50\n      const loader = CommonPasswordsLoader.getInstance({\n        filePath: '/non-existent-file.json', // This will cause fallback to be used\n        enabled: true,\n        maxCacheEntries: 50,\n      });\n\n      // Test getCommonPasswords() with newly created instance (cache not yet populated)\n      const passwords = await loader.getCommonPasswords();\n\n      // Assert that only 50 passwords are returned (truncated to maxCacheEntries)\n      expect(passwords).toHaveLength(50);\n\n      // Assert that the returned passwords are the first 50 entries from the fallback list\n      const expectedPasswords = COMMON_PASSWORDS_FALLBACK.slice(0, 50);\n      expect(passwords).toEqual(expectedPasswords);\n    });\n  });\n\n  describe('getCacheStatus', () => {\n    it('should return null when no cache exists', () => {\n      const loader = CommonPasswordsLoader.getInstance();\n      const status = loader.getCacheStatus();\n      expect(status).toBeNull();\n    });\n\n    it('should return cache status with loaded file source', async () => {\n      const loader = CommonPasswordsLoader.getInstance();\n      await loader.getCommonPasswords();\n\n      const status = loader.getCacheStatus();\n      expect(status).not.toBeNull();\n      expect(status?.hasCache).toBe(true);\n      expect(typeof status?.source).toBe('string');\n      expect(status?.source).toBeTruthy();\n    });\n\n    it('should return cache status with fallback source when file loading fails', async () => {\n      const loader = CommonPasswordsLoader.getInstance({\n        filePath: '/non-existent-test-file.json',\n        enabled: true,\n      });\n      const passwords = await loader.getCommonPasswords();\n      const status = loader.getCacheStatus();\n      expect(status).not.toBeNull();\n      expect(status?.source).toBe('fallback');\n      expect(status?.hasCache).toBe(true);\n      expect(Array.isArray(passwords)).toBe(true);\n      expect(passwords.length).toBeGreaterThan(0);\n    });\n  });\n});\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/utils/__tests__/formValidation.test.ts",
        "messages": [
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'Phone' is defined but never used. Allowed unused vars must match /^_/u.",
                "line": 18,
                "column": 8,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 18,
                "endColumn": 13
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'Password' is defined but never used. Allowed unused vars must match /^_/u.",
                "line": 19,
                "column": 8,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 19,
                "endColumn": 16
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 370,
                "column": 55,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingReturnType",
                "endLine": 370,
                "endColumn": 57
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 3,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "/**\n * Form Validation Tests - Example Test Suite\n *\n * Demonstrates testing strategies for FP validation patterns\n */\n\nimport { describe, it, expect } from 'bun:test';\nimport {\n  validateEmail,\n  validatePhone,\n  validatePassword,\n  validateAge,\n  validateZipCode,\n  validateAll,\n  validateOptional,\n  validateAllOrCollectErrors,\n  type Email,\n  type Phone,\n  type Password,\n} from '@/utils/formValidation';\n\ndescribe('formValidation', () => {\n  describe('validateEmail', () => {\n    it('should accept valid email addresses', () => {\n      const validEmails = [\n        'user@example.com',\n        'test.user@example.co.uk',\n        'user+tag@domain.com',\n        'user_name@company.org',\n      ];\n\n      validEmails.forEach(email => {\n        const result = validateEmail(email);\n        expect(result.isOk()).toBe(true);\n        if (result.isOk()) {\n          // Type check - should be Email branded type\n          const validatedEmail: Email = result.value;\n          // Compare as strings by casting to string\n          expect(validatedEmail as string).toBe(email.trim().toLowerCase());\n        }\n      });\n    });\n\n    it('should reject invalid email addresses', () => {\n      const invalidEmails = [\n        'invalid',\n        '@example.com',\n        'user@',\n        'user@.com',\n        'user..name@example.com',\n        'user@domain..com',\n      ];\n\n      invalidEmails.forEach(email => {\n        const result = validateEmail(email);\n        expect(result.isErr()).toBe(true);\n        if (result.isErr()) {\n          expect(result.error.type).toMatch(/INVALID_EMAIL|REQUIRED_FIELD/);\n        }\n      });\n    });\n\n    it('should normalize email to lowercase', () => {\n      const result = validateEmail('USER@EXAMPLE.COM');\n      expect(result.isOk()).toBe(true);\n      if (result.isOk()) {\n        expect(result.value as string).toBe('user@example.com');\n      }\n    });\n\n    it('should trim whitespace', () => {\n      const result = validateEmail('  user@example.com  ');\n      expect(result.isOk()).toBe(true);\n      if (result.isOk()) {\n        expect(result.value as string).toBe('user@example.com');\n      }\n    });\n  });\n\n  describe('validatePhone', () => {\n    it('should accept valid US phone numbers', () => {\n      const validPhones = ['+1-234-567-8900', '(234) 567-8900', '234-567-8900', '2345678900'];\n\n      validPhones.forEach(phone => {\n        const result = validatePhone(phone, 'US');\n        expect(result.isOk()).toBe(true);\n      });\n    });\n\n    it('should accept valid international phone numbers', () => {\n      const validPhones = ['+44 20 7123 4567', '+81 3-1234-5678', '+61 2 1234 5678'];\n\n      validPhones.forEach(phone => {\n        const result = validatePhone(phone, 'INTERNATIONAL');\n        expect(result.isOk()).toBe(true);\n      });\n    });\n\n    it('should reject invalid phone numbers', () => {\n      const invalidPhones = [\n        '123', // Too short\n        '12345678901234567890', // Too long\n        'abc-def-ghij', // Non-numeric\n      ];\n\n      invalidPhones.forEach(phone => {\n        const result = validatePhone(phone);\n        expect(result.isErr()).toBe(true);\n      });\n    });\n  });\n\n  describe('validatePassword', () => {\n    it('should accept strong passwords', () => {\n      const strongPasswords = ['MyP@ssw0rd', 'Str0ngPwd!', 'SecurePass123', 'C0mpl3xP@ss'];\n\n      strongPasswords.forEach(password => {\n        const result = validatePassword(password);\n        expect(result.isOk()).toBe(true);\n      });\n    });\n\n    it('should reject weak passwords', () => {\n      const weakPasswords = [\n        'short', // Too short\n        'nouppercase1', // No uppercase\n        'NOLOWERCASE1', // No lowercase\n        'NoNumbers', // No numbers\n      ];\n\n      weakPasswords.forEach(password => {\n        const result = validatePassword(password);\n        expect(result.isErr()).toBe(true);\n        if (result.isErr()) {\n          expect(result.error.type).toBe('INVALID_PASSWORD');\n        }\n      });\n    });\n\n    it('should reject common weak passwords', () => {\n      const commonWeak = ['password123', '12345678', 'qwerty123'];\n\n      commonWeak.forEach(password => {\n        const result = validatePassword(password);\n        expect(result.isErr()).toBe(true);\n      });\n    });\n\n    it('should enforce minimum length', () => {\n      const result = validatePassword('Short1');\n      expect(result.isErr()).toBe(true);\n      if (result.isErr()) {\n        expect(result.error.type).toBe('INVALID_PASSWORD');\n        // Access reason based on discriminated union\n        if (result.error.type === 'INVALID_PASSWORD') {\n          expect(result.error.reason).toContain('at least 8');\n        }\n      }\n    });\n  });\n\n  describe('validateAge', () => {\n    it('should accept valid ages', () => {\n      const validAges = [0, 18, 25, 65, 100];\n\n      validAges.forEach(age => {\n        const result = validateAge(age);\n        expect(result.isOk()).toBe(true);\n      });\n    });\n\n    it('should reject invalid ages', () => {\n      const invalidAges = [\n        -5, // Negative\n        200, // Too old\n        25.5, // Not integer\n        NaN, // Not a number\n        Infinity,\n      ];\n\n      invalidAges.forEach(age => {\n        const result = validateAge(age);\n        expect(result.isErr()).toBe(true);\n      });\n    });\n\n    it('should respect min/max constraints', () => {\n      const result1 = validateAge(17, { min: 18, max: 120 });\n      expect(result1.isErr()).toBe(true);\n\n      const result2 = validateAge(121, { min: 18, max: 120 });\n      expect(result2.isErr()).toBe(true);\n\n      const result3 = validateAge(25, { min: 18, max: 120 });\n      expect(result3.isOk()).toBe(true);\n    });\n  });\n\n  describe('validateZipCode', () => {\n    it('should accept valid US ZIP codes', () => {\n      const validZips = ['12345', '12345-6789'];\n\n      validZips.forEach(zip => {\n        const result = validateZipCode(zip, 'US');\n        expect(result.isOk()).toBe(true);\n      });\n    });\n\n    it('should accept valid Canadian postal codes', () => {\n      const validPostal = ['K1A 0B1', 'M5V 3A8', 'V6B2M9'];\n\n      validPostal.forEach(postal => {\n        const result = validateZipCode(postal, 'CANADA');\n        expect(result.isOk()).toBe(true);\n      });\n    });\n\n    it('should reject invalid ZIP codes', () => {\n      const invalidZips = ['1234', '123456', 'ABCDE'];\n\n      invalidZips.forEach(zip => {\n        const result = validateZipCode(zip, 'US');\n        expect(result.isErr()).toBe(true);\n      });\n    });\n  });\n\n  describe('combinator functions', () => {\n    describe('validateAll', () => {\n      it('should return all values when all validations pass', () => {\n        const result = validateAll([\n          validateEmail('user@example.com'),\n          validatePhone('+1-234-567-8900'),\n          validateAge(25),\n        ]);\n\n        expect(result.isOk()).toBe(true);\n        if (result.isOk()) {\n          expect(result.value).toHaveLength(3);\n        }\n      });\n\n      it('should return first error when any validation fails', () => {\n        const result = validateAll([\n          validateEmail('invalid'),\n          validatePhone('+1-234-567-8900'),\n          validateAge(25),\n        ]);\n\n        expect(result.isErr()).toBe(true);\n        if (result.isErr()) {\n          expect(result.error.type).toBe('INVALID_EMAIL');\n        }\n      });\n    });\n\n    describe('validateOptional', () => {\n      it('should return Ok(undefined) for empty values', () => {\n        const result1 = validateOptional('', validateEmail);\n        expect(result1.isOk()).toBe(true);\n        if (result1.isOk()) {\n          expect(result1.value).toBeUndefined();\n        }\n\n        const result2 = validateOptional(null, validateEmail);\n        expect(result2.isOk()).toBe(true);\n\n        const result3 = validateOptional(undefined, validateEmail);\n        expect(result3.isOk()).toBe(true);\n      });\n\n      it('should validate when value is present', () => {\n        const result1 = validateOptional('user@example.com', validateEmail);\n        expect(result1.isOk()).toBe(true);\n\n        const result2 = validateOptional('invalid', validateEmail);\n        expect(result2.isErr()).toBe(true);\n      });\n    });\n\n    describe('validateAllOrCollectErrors', () => {\n      it('should return all values when all validations pass', () => {\n        const result = validateAllOrCollectErrors({\n          email: validateEmail('user@example.com'),\n          phone: validatePhone('+1-234-567-8900'),\n          age: validateAge(25),\n        });\n\n        expect(result.isOk()).toBe(true);\n        if (result.isOk()) {\n          expect(result.value).toHaveProperty('email');\n          expect(result.value).toHaveProperty('phone');\n          expect(result.value).toHaveProperty('age');\n        }\n      });\n\n      it('should collect all errors when validations fail', () => {\n        const result = validateAllOrCollectErrors({\n          email: validateEmail('invalid'),\n          phone: validatePhone('123'),\n          age: validateAge(-5),\n        });\n\n        expect(result.isErr()).toBe(true);\n        if (result.isErr()) {\n          expect(result.error).toHaveProperty('email');\n          expect(result.error).toHaveProperty('phone');\n          expect(result.error).toHaveProperty('age');\n        }\n      });\n\n      it('should collect partial errors', () => {\n        const result = validateAllOrCollectErrors({\n          email: validateEmail('user@example.com'), // Valid\n          phone: validatePhone('123'), // Invalid\n          age: validateAge(25), // Valid\n        });\n\n        expect(result.isErr()).toBe(true);\n        if (result.isErr()) {\n          expect(result.error).toHaveProperty('phone');\n          expect(result.error).not.toHaveProperty('email');\n          expect(result.error).not.toHaveProperty('age');\n        }\n      });\n    });\n  });\n\n  describe('error formatting', () => {\n    it('should format validation errors', () => {\n      const result = validateEmail('invalid');\n      expect(result.isErr()).toBe(true);\n\n      if (result.isErr()) {\n        // Check the error structure\n        expect(result.error.type).toBe('INVALID_EMAIL');\n        if (result.error.type === 'INVALID_EMAIL') {\n          expect(result.error.email).toBe('invalid');\n          expect(result.error.reason).toContain('Invalid email format');\n        }\n      }\n    });\n  });\n\n  describe('type safety', () => {\n    it('should use branded types', () => {\n      const emailResult = validateEmail('user@example.com');\n\n      if (emailResult.isOk()) {\n        // Type test - this should compile\n        const email: Email = emailResult.value;\n\n        // This would fail to compile (can't assign string to Email):\n        // const email: Email = 'user@example.com';\n\n        expect(email as string).toBe('user@example.com');\n      }\n    });\n  });\n});\n\n// Integration test example\ndescribe('form validation integration', () => {\n  interface ContactFormData {\n    email: string;\n    phone: string;\n    age: number;\n  }\n\n  const validateContactForm = (data: ContactFormData) => {\n    return validateAllOrCollectErrors({\n      email: validateEmail(data.email),\n      phone: validatePhone(data.phone),\n      age: validateAge(data.age, { min: 18, max: 120 }),\n    });\n  };\n\n  it('should validate complete contact form', () => {\n    const validData: ContactFormData = {\n      email: 'user@example.com',\n      phone: '+1-234-567-8900',\n      age: 25,\n    };\n\n    const result = validateContactForm(validData);\n    expect(result.isOk()).toBe(true);\n  });\n\n  it('should collect all form errors', () => {\n    const invalidData: ContactFormData = {\n      email: 'invalid',\n      phone: '123',\n      age: 17,\n    };\n\n    const result = validateContactForm(invalidData);\n    expect(result.isErr()).toBe(true);\n\n    if (result.isErr()) {\n      expect(Object.keys(result.error)).toHaveLength(3);\n    }\n  });\n});\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/utils/__tests__/parsing.test.ts",
        "messages": [],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 0,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/utils/__tests__/uniqueId.test.ts",
        "messages": [],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 0,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/utils/cache.ts",
        "messages": [
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 76,
                "column": 9,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 76,
                "endColumn": 16,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                1850,
                                1857
                            ],
                            "text": "(typeTag != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                1850,
                                1857
                            ],
                            "text": "(typeTag ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                1850,
                                1857
                            ],
                            "text": "(Boolean(typeTag))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 76,
                "column": 20,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 76,
                "endColumn": 33,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                1861,
                                1874
                            ],
                            "text": "(entry.typeTag != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                1861,
                                1874
                            ],
                            "text": "(entry.typeTag ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                1861,
                                1874
                            ],
                            "text": "(Boolean(entry.typeTag))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.",
                "line": 88,
                "column": 23,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableNumber",
                "endLine": 88,
                "endColumn": 29,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                2195,
                                2201
                            ],
                            "text": "(maxAge != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultZero",
                        "fix": {
                            "range": [
                                2195,
                                2201
                            ],
                            "text": "(maxAge ?? 0)"
                        },
                        "desc": "Explicitly treat nullish value the same as 0 (`value ?? 0`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                2195,
                                2201
                            ],
                            "text": "(Boolean(maxAge))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-type-parameters",
                "severity": 1,
                "message": "Type parameter T is used only once in the function signature.",
                "line": 109,
                "column": 7,
                "nodeType": "TSTypeParameter",
                "messageId": "sole",
                "endLine": 109,
                "endColumn": 8,
                "suggestions": [
                    {
                        "messageId": "replaceUsagesWithConstraint",
                        "fix": {
                            "range": [
                                2800,
                                2833
                            ],
                            "text": "(\n    key: string,\n    data: unknown"
                        },
                        "desc": "Replace all usages of type parameter with its constraint."
                    }
                ]
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 4,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "/**\n * Result-based cache layer for data fetching\n *\n * Provides a simple in-memory cache with TTL (time-to-live) support\n * and Result-based API for FP consistency.\n *\n * @module utils/cache\n */\n\nimport { type Result, ok, err } from 'neverthrow';\nimport type { AppError } from '@/types/errors';\nimport { createBusinessLogicError } from '@/types/errors';\n\n/**\n * Cache entry with data and expiration metadata\n */\ninterface CacheEntry<T> {\n  data: T;\n  timestamp: number;\n  expiresAt: number;\n  typeTag?: string; // Optional type identifier for runtime type safety\n}\n\n/**\n * Cache statistics for monitoring\n */\nexport interface CacheStats {\n  hits: number;\n  misses: number;\n  size: number;\n  hitRate: number;\n}\n\n/**\n * Result-based cache implementation\n *\n * Usage:\n * ```typescript\n * const cache = new ResultCache();\n *\n * // Set value with 5 minute TTL\n * cache.set('user-123', userData, 5 * 60 * 1000);\n *\n * // Get value\n * const result = cache.get<User>('user-123');\n * result.match(\n *   (user) => console.log('Cache hit!', user),\n *   (error) => console.log('Cache miss:', error.code)\n * );\n * ```\n */\nexport class ResultCache {\n  private cache = new Map<string, CacheEntry<unknown>>();\n  private stats = {\n    hits: 0,\n    misses: 0,\n  };\n\n  /**\n   * Get value from cache\n   *\n   * @param key - Cache key\n   * @param maxAge - Maximum age in milliseconds (overrides entry TTL)\n   * @param typeTag - Optional type identifier for runtime type checking\n   * @returns Result with cached data or error\n   */\n  get<T>(key: string, maxAge?: number, typeTag?: string): Result<T, AppError> {\n    const entry = this.cache.get(key) as CacheEntry<T> | undefined;\n\n    if (!entry) {\n      this.stats.misses++;\n      return err(createBusinessLogicError('Cache miss', undefined, { code: 'CACHE_MISS' }));\n    }\n\n    // Validate type tag if provided\n    if (typeTag && entry.typeTag && entry.typeTag !== typeTag) {\n      this.stats.misses++;\n      return err(\n        createBusinessLogicError(\n          `Type mismatch: expected ${typeTag}, got ${entry.typeTag}`,\n          undefined,\n          { code: 'CACHE_TYPE_MISMATCH' }\n        )\n      );\n    }\n\n    const now = Date.now();\n    const expiresAt = maxAge ? entry.timestamp + maxAge : entry.expiresAt;\n\n    if (now > expiresAt) {\n      this.cache.delete(key);\n      this.stats.misses++;\n      return err(createBusinessLogicError('Cache expired', undefined, { code: 'CACHE_EXPIRED' }));\n    }\n\n    this.stats.hits++;\n    return ok(entry.data);\n  }\n\n  /**\n   * Set value in cache with TTL\n   *\n   * @param key - Cache key\n   * @param data - Data to cache\n   * @param ttl - Time to live in milliseconds (default: 5 minutes)\n   * @param typeTag - Optional type identifier for runtime type safety\n   * @returns Result indicating success or failure\n   */\n  set<T>(\n    key: string,\n    data: T,\n    ttl: number = 5 * 60 * 1000,\n    typeTag?: string\n  ): Result<void, AppError> {\n    try {\n      const now = Date.now();\n      this.cache.set(key, {\n        data,\n        timestamp: now,\n        expiresAt: now + ttl,\n        typeTag,\n      });\n      return ok(undefined);\n    } catch (error) {\n      return err(\n        createBusinessLogicError(\n          'Failed to set cache',\n          { error: error instanceof Error ? error.message : String(error) },\n          { code: 'CACHE_SET_ERROR' }\n        )\n      );\n    }\n  }\n\n  /**\n   * Check if key exists and is not expired\n   *\n   * @param key - Cache key\n   * @returns true if key exists and is valid\n   */\n  has(key: string): boolean {\n    const entry = this.cache.get(key);\n    if (!entry) return false;\n\n    const now = Date.now();\n    if (now > entry.expiresAt) {\n      this.cache.delete(key);\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Invalidate (delete) cache entry\n   *\n   * @param key - Cache key to invalidate\n   * @returns Result indicating success\n   */\n  invalidate(key: string): Result<void, AppError> {\n    this.cache.delete(key);\n    return ok(undefined);\n  }\n\n  /**\n   * Invalidate all cache entries matching a pattern\n   *\n   * @param pattern - RegExp pattern to match keys\n   * @returns Result with count of invalidated entries\n   */\n  invalidatePattern(pattern: RegExp): Result<number, AppError> {\n    try {\n      let count = 0;\n      for (const key of this.cache.keys()) {\n        if (pattern.test(key)) {\n          this.cache.delete(key);\n          count++;\n        }\n      }\n      return ok(count);\n    } catch (error) {\n      return err(\n        createBusinessLogicError(\n          'Failed to invalidate pattern',\n          { error: error instanceof Error ? error.message : String(error) },\n          { code: 'CACHE_INVALIDATE_ERROR' }\n        )\n      );\n    }\n  }\n\n  /**\n   * Clear entire cache\n   *\n   * @returns Result indicating success\n   */\n  clear(): Result<void, AppError> {\n    this.cache.clear();\n    this.stats.hits = 0;\n    this.stats.misses = 0;\n    return ok(undefined);\n  }\n\n  /**\n   * Get cache statistics\n   *\n   * @returns Cache stats with hit rate\n   */\n  getStats(): CacheStats {\n    const total = this.stats.hits + this.stats.misses;\n    const hitRate = total > 0 ? this.stats.hits / total : 0;\n\n    return {\n      hits: this.stats.hits,\n      misses: this.stats.misses,\n      size: this.cache.size,\n      hitRate,\n    };\n  }\n\n  /**\n   * Reset cache statistics\n   */\n  resetStats(): void {\n    this.stats.hits = 0;\n    this.stats.misses = 0;\n  }\n\n  /**\n   * Clean up expired entries\n   *\n   * @returns Result with count of removed entries\n   */\n  cleanup(): Result<number, AppError> {\n    try {\n      const now = Date.now();\n      let count = 0;\n\n      for (const [key, entry] of this.cache.entries()) {\n        if (now > entry.expiresAt) {\n          this.cache.delete(key);\n          count++;\n        }\n      }\n\n      return ok(count);\n    } catch (error) {\n      return err(\n        createBusinessLogicError(\n          'Failed to cleanup cache',\n          { error: error instanceof Error ? error.message : String(error) },\n          { code: 'CACHE_CLEANUP_ERROR' }\n        )\n      );\n    }\n  }\n}\n\n/**\n * Global cache instance\n *\n * Usage:\n * ```typescript\n * import { resultCache } from '@/utils/cache';\n *\n * // Set cache\n * resultCache.set('key', data, 5000);\n *\n * // Get cache\n * const result = resultCache.get<Type>('key');\n * ```\n */\nexport const resultCache = new ResultCache();\n\n/**\n * Cache key generators\n */\nexport const CacheKeys = {\n  user: (id: string) => `user-${id}`,\n  userList: () => 'users-list',\n  contact: (id: string) => `contact-${id}`,\n  contactList: () => 'contacts-list',\n  tenant: (id: string) => `tenant-${id}`,\n  auth: () => 'auth-user',\n} as const;\n\n/**\n * Default TTL values (in milliseconds)\n */\nexport const CacheTTL = {\n  SHORT: 1 * 60 * 1000, // 1 minute\n  MEDIUM: 5 * 60 * 1000, // 5 minutes\n  LONG: 15 * 60 * 1000, // 15 minutes\n  HOUR: 60 * 60 * 1000, // 1 hour\n  DAY: 24 * 60 * 60 * 1000, // 1 day\n} as const;\n\n/**\n * Cache decorator for functions\n *\n * Wraps a function to cache its results based on arguments.\n *\n * @param fn - Function to cache\n * @param keyFn - Function to generate cache key from arguments\n * @param ttl - Time to live in milliseconds\n * @returns Cached version of function\n *\n * @example\n * ```typescript\n * const cachedFetchUser = withCache(\n *   fetchUser,\n *   (id) => CacheKeys.user(id),\n *   CacheTTL.MEDIUM\n * );\n *\n * const result = await cachedFetchUser('user-123');\n * ```\n */\nexport function withCache<TArgs extends unknown[], TResult>(\n  fn: (...args: TArgs) => Promise<Result<TResult, AppError>>,\n  keyFn: (...args: TArgs) => string,\n  ttl: number = CacheTTL.MEDIUM\n): (...args: TArgs) => Promise<Result<TResult, AppError>> {\n  return async (...args: TArgs) => {\n    const key = keyFn(...args);\n\n    // Try cache first\n    const cached = resultCache.get<TResult>(key);\n    if (cached.isOk()) {\n      return cached;\n    }\n\n    // Cache miss - execute function\n    const result = await fn(...args);\n\n    // Cache successful results\n    if (result.isOk()) {\n      resultCache.set(key, result.value, ttl);\n    }\n\n    return result;\n  };\n}\n\n/**\n * Invalidate all cache entries for a specific entity type\n *\n * @param entityType - Entity type prefix (e.g., 'user', 'contact')\n * @returns Result with count of invalidated entries or error\n *\n * @example\n * ```typescript\n * // Invalidate all user caches\n * invalidateEntity('user');\n *\n * // Invalidate all contact caches\n * invalidateEntity('contact');\n * ```\n */\nexport function invalidateEntity(entityType: string): Result<number, AppError> {\n  // Sanitize entityType to prevent ReDoS - escape regex metacharacters\n  const sanitized = entityType.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n  const pattern = new RegExp(`^${sanitized}-`);\n  return resultCache.invalidatePattern(pattern);\n}\n\n/**\n * Auto-cleanup scheduler\n *\n * Automatically cleans up expired entries at specified interval.\n *\n * @param intervalMs - Cleanup interval in milliseconds (default: 5 minutes)\n * @param onError - Optional callback invoked when cleanup fails\n * @returns Function to stop auto-cleanup\n *\n * @example\n * ```typescript\n * // Start auto-cleanup with error handling\n * const stopCleanup = startAutoCleanup(60000, (error) => {\n *   logErrorToService(error); // Custom error handling\n * });\n *\n * // Later...\n * stopCleanup();\n * ```\n */\nexport function startAutoCleanup(\n  intervalMs: number = 5 * 60 * 1000,\n  onError?: (error: unknown) => void\n): () => void {\n  const intervalId = setInterval(() => {\n    try {\n      resultCache.cleanup();\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      console.error('Cache cleanup failed:', errorMessage);\n\n      // Invoke optional error callback\n      if (onError) {\n        onError(error);\n      }\n    }\n  }, intervalMs);\n\n  return () => {\n    clearInterval(intervalId);\n  };\n}\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/utils/commonPasswordsLoader.ts",
        "messages": [
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 183,
                "column": 10,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 183,
                "endColumn": 30,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                5348,
                                5369
                            ],
                            "text": "this.config.filePath == null"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                5349,
                                5369
                            ],
                            "text": "(this.config.filePath ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                5348,
                                5369
                            ],
                            "text": "!Boolean(this.config.filePath)"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/restrict-template-expressions",
                "severity": 1,
                "message": "Invalid type \"number\" of template literal expression.",
                "line": 202,
                "column": 43,
                "nodeType": "MemberExpression",
                "messageId": "invalidType",
                "endLine": 202,
                "endColumn": 62
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 230,
                "column": 10,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 230,
                "endColumn": 30,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                6931,
                                6952
                            ],
                            "text": "this.config.filePath == null"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                6932,
                                6952
                            ],
                            "text": "(this.config.filePath ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                6931,
                                6952
                            ],
                            "text": "!Boolean(this.config.filePath)"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, value is always truthy.",
                "line": 242,
                "column": 42,
                "nodeType": "MemberExpression",
                "messageId": "alwaysTruthy",
                "endLine": 242,
                "endColumn": 53
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected object value in conditional. The condition is always true.",
                "line": 242,
                "column": 42,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorObject",
                "endLine": 242,
                "endColumn": 53
            },
            {
                "ruleId": "@typescript-eslint/restrict-template-expressions",
                "severity": 1,
                "message": "Invalid type \"number\" of template literal expression.",
                "line": 264,
                "column": 33,
                "nodeType": "MemberExpression",
                "messageId": "invalidType",
                "endLine": 264,
                "endColumn": 48
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 267,
                "column": 13,
                "nodeType": "VariableDeclarator",
                "messageId": "anyAssignment",
                "endLine": 267,
                "endColumn": 41
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-return",
                "severity": 1,
                "message": "Unsafe return of a value of type `any`.",
                "line": 268,
                "column": 7,
                "nodeType": "ReturnStatement",
                "messageId": "unsafeReturn",
                "endLine": 268,
                "endColumn": 19
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 274,
                "column": 50,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 274,
                "endColumn": 53,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                8493,
                                8496
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                8493,
                                8496
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected any value in conditional. An explicit comparison or type conversion is required.",
                "line": 275,
                "column": 10,
                "nodeType": "Identifier",
                "messageId": "conditionErrorAny",
                "endLine": 275,
                "endColumn": 18,
                "suggestions": [
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                8519,
                                8527
                            ],
                            "text": "(Boolean(response))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .passwords on an `any` value.",
                "line": 279,
                "column": 33,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 279,
                "endColumn": 42
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .passwords on an `any` value.",
                "line": 285,
                "column": 37,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 285,
                "endColumn": 46
            },
            {
                "ruleId": "@typescript-eslint/restrict-template-expressions",
                "severity": 1,
                "message": "Invalid type \"number\" of template literal expression.",
                "line": 302,
                "column": 51,
                "nodeType": "MemberExpression",
                "messageId": "invalidType",
                "endLine": 302,
                "endColumn": 73
            },
            {
                "ruleId": "@typescript-eslint/restrict-template-expressions",
                "severity": 1,
                "message": "Invalid type \"number\" of template literal expression.",
                "line": 302,
                "column": 103,
                "nodeType": "Identifier",
                "messageId": "invalidType",
                "endLine": 302,
                "endColumn": 113
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 14,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "/**\n * Common Passwords Loader\n *\n * Loads common passwords list from external sources with caching and fallback support.\n * This allows the password list to be updated without code changes.\n */\n\nimport type { CommonPasswordsConfig } from '@/config/commonPasswords';\nimport {\n  COMMON_PASSWORDS_FALLBACK,\n  DEFAULT_COMMON_PASSWORDS_CONFIG,\n} from '@/config/commonPasswords';\n\nimport { testLogger } from '@/test-utils/logger';\n\ninterface PasswordListResponse {\n  version: string;\n  description: string;\n  lastUpdated: string;\n  source: string;\n  passwords: string[];\n}\n\ninterface CachedPasswordList {\n  passwords: readonly string[];\n  loadedAt: number;\n  expiresAt: number;\n  source: string;\n  version?: string;\n}\n\n/**\n * Common passwords loader with caching and fallback\n */\nexport class CommonPasswordsLoader {\n  private static instance: CommonPasswordsLoader | null = null;\n  private cachedList: CachedPasswordList | null = null;\n  private loadingPromise: Promise<readonly string[]> | null = null;\n\n  private constructor(private readonly config: CommonPasswordsConfig) {\n    // Validate isSSR config matches runtime environment\n    this.validateSSRConfig();\n  }\n\n  /**\n   * Validate isSSR config matches runtime environment\n   */\n  private validateSSRConfig(): void {\n    if (this.config.isSSR !== undefined) {\n      const runtimeIsSSR = typeof window === 'undefined';\n\n      if (!this.config.isSSR && runtimeIsSSR) {\n        throw new Error(\n          'Configuration mismatch: isSSR is set to false but window is undefined (SSR environment). ' +\n            'The isSSR config must match the actual runtime environment.'\n        );\n      }\n\n      if (this.config.isSSR && !runtimeIsSSR) {\n        throw new Error(\n          'Configuration mismatch: isSSR is set to true but window is defined (client environment). ' +\n            'The isSSR config must match the actual runtime environment.'\n        );\n      }\n    }\n  }\n\n  /**\n   * Validate configuration values\n   */\n  private static validateConfig(config: CommonPasswordsConfig): void {\n    if (config.maxCacheEntries !== undefined) {\n      if (!Number.isInteger(config.maxCacheEntries) || config.maxCacheEntries < 1) {\n        throw new Error(\n          `Invalid maxCacheEntries: must be a positive integer, got ${String(config.maxCacheEntries)}`\n        );\n      }\n    }\n    if (config.cacheTtlMs < 0) {\n      throw new Error(`Invalid cacheTtlMs: must be non-negative, got ${String(config.cacheTtlMs)}`);\n    }\n    if (config.requestTimeoutMs < 0) {\n      throw new Error(\n        `Invalid requestTimeoutMs: must be non-negative, got ${String(config.requestTimeoutMs)}`\n      );\n    }\n  }\n\n  /**\n   * Get singleton instance\n   */\n  static getInstance(config?: Partial<CommonPasswordsConfig>): CommonPasswordsLoader {\n    if (!CommonPasswordsLoader.instance) {\n      const finalConfig = {\n        ...DEFAULT_COMMON_PASSWORDS_CONFIG,\n        ...config,\n      };\n      CommonPasswordsLoader.validateConfig(finalConfig);\n      CommonPasswordsLoader.instance = new CommonPasswordsLoader(finalConfig);\n    } else if (config) {\n      // Reconfigure existing instance by merging configs\n      const currentConfig = CommonPasswordsLoader.instance.config;\n      const newConfig = { ...currentConfig, ...config };\n      CommonPasswordsLoader.validateConfig(newConfig);\n      CommonPasswordsLoader.instance = new CommonPasswordsLoader(newConfig);\n      // Invalidate cached state\n      CommonPasswordsLoader.instance.cachedList = null;\n      CommonPasswordsLoader.instance.loadingPromise = null;\n    }\n    return CommonPasswordsLoader.instance;\n  }\n\n  /**\n   * Get the common passwords list\n   * Loads from cache, external source, or falls back to built-in list\n   */\n  async getCommonPasswords(): Promise<readonly string[]> {\n    // Return cached list if still valid\n    if (this.cachedList && this.cachedList.expiresAt > Date.now()) {\n      return this.cachedList.passwords;\n    }\n\n    // Return in-flight request if one exists\n    if (this.loadingPromise) {\n      return this.loadingPromise;\n    }\n\n    // Start loading\n    this.loadingPromise = this.loadPasswords();\n\n    try {\n      const passwords = await this.loadingPromise;\n      return passwords;\n    } finally {\n      this.loadingPromise = null;\n    }\n  }\n\n  /**\n   * Force reload the password list (bypasses cache)\n   */\n  async reload(): Promise<readonly string[]> {\n    this.cachedList = null;\n    this.loadingPromise = null;\n    return this.getCommonPasswords();\n  }\n\n  /**\n   * Get cache status for debugging\n   */\n  getCacheStatus(): {\n    hasCache: boolean;\n    isExpired: boolean;\n    source?: string;\n    version?: string;\n  } | null {\n    if (!this.cachedList) {\n      return null;\n    }\n\n    return {\n      hasCache: true,\n      isExpired: this.cachedList.expiresAt <= Date.now(),\n      source: this.cachedList.source,\n      version: this.cachedList.version,\n    };\n  }\n\n  /**\n   * Get the maximum number of cache entries allowed\n   * Centralized to ensure consistent behavior across the codebase\n   */\n  private getMaxCacheEntries(): number {\n    return this.config.maxCacheEntries ?? 10000;\n  }\n\n  private async loadPasswords(): Promise<readonly string[]> {\n    if (!this.config.enabled) {\n      testLogger.debug('[CommonPasswordsLoader] Loading disabled, using fallback');\n      return COMMON_PASSWORDS_FALLBACK;\n    }\n\n    if (!this.config.filePath) {\n      testLogger.debug('[CommonPasswordsLoader] No file path configured, using fallback');\n      return COMMON_PASSWORDS_FALLBACK;\n    }\n\n    try {\n      const response = await this.fetchPasswordList();\n      const passwordList = this.validateAndNormalizeResponse(response);\n\n      // Cache the result\n      this.cachedList = {\n        passwords: Object.freeze(passwordList),\n        loadedAt: Date.now(),\n        expiresAt: Date.now() + this.config.cacheTtlMs,\n        source: this.config.filePath,\n        version: response.version,\n      };\n\n      testLogger.info(\n        `[CommonPasswordsLoader] Loaded ${passwordList.length} passwords from ${this.config.filePath}`\n      );\n      return this.cachedList.passwords;\n    } catch (error) {\n      testLogger.warn(\n        `[CommonPasswordsLoader] Failed to load passwords from ${this.config.filePath}, using fallback:`,\n        error\n      );\n\n      // Cache fallback with shorter TTL, applying maxCacheEntries limit\n      const maxEntries = this.getMaxCacheEntries();\n      const truncatedFallback =\n        maxEntries > 0 && COMMON_PASSWORDS_FALLBACK.length > maxEntries\n          ? COMMON_PASSWORDS_FALLBACK.slice(0, maxEntries)\n          : COMMON_PASSWORDS_FALLBACK;\n\n      this.cachedList = {\n        passwords: Object.freeze(truncatedFallback),\n        loadedAt: Date.now(),\n        expiresAt: Date.now() + 5 * 60 * 1000, // 5 minutes\n        source: 'fallback',\n      };\n\n      return this.cachedList.passwords;\n    }\n  }\n\n  private async fetchPasswordList(): Promise<PasswordListResponse> {\n    if (!this.config.filePath) {\n      throw new Error('File path not configured');\n    }\n\n    // Resolve URL: use absolute URLs as-is, or resolve relative paths against the appropriate base URL.\n    // For SSR (server-side rendering), we use the configured ssrBaseUrl or environment variable SSR_BASE_URL\n    // to construct the full URL. Defaults to the configured ssrBaseUrl (e.g., http://localhost:5173).\n    // Use explicit isSSR flag if provided, otherwise fall back to typeof checks for detection.\n    const isSSR = this.config.isSSR ?? typeof window === 'undefined';\n\n    const ssrBase =\n      this.config.ssrBaseUrl ??\n      (typeof process !== 'undefined' && process.env ? process.env.SSR_BASE_URL : undefined) ??\n      'http://localhost:5173';\n\n    const url = this.config.filePath.startsWith('http')\n      ? this.config.filePath\n      : new URL(this.config.filePath, isSSR ? ssrBase : window.location.origin).toString();\n\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => {\n      controller.abort();\n    }, this.config.requestTimeoutMs);\n\n    try {\n      const response = await fetch(url, {\n        signal: controller.signal,\n        headers: {\n          Accept: 'application/json',\n          'Cache-Control': 'no-cache',\n        },\n      });\n\n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n      }\n\n      const data = await response.json();\n      return data;\n    } finally {\n      clearTimeout(timeoutId);\n    }\n  }\n\n  private validateAndNormalizeResponse(response: any): string[] {\n    if (!response || typeof response !== 'object') {\n      throw new Error('Invalid response format: expected object');\n    }\n\n    if (!Array.isArray(response.passwords)) {\n      throw new Error('Invalid response format: passwords must be an array');\n    }\n\n    // Validate and normalize passwords\n    const passwords: string[] = [];\n    for (const password of response.passwords) {\n      if (typeof password === 'string' && password.trim()) {\n        passwords.push(password.trim().toLowerCase());\n      }\n    }\n\n    if (passwords.length === 0) {\n      throw new Error('No valid passwords found in response');\n    }\n\n    // Remove duplicates\n    const uniquePasswords = [...new Set(passwords)];\n\n    // Enforce maxCacheEntries limit (count-based eviction)\n    const maxEntries = this.getMaxCacheEntries();\n    if (maxEntries > 0 && uniquePasswords.length > maxEntries) {\n      testLogger.warn(\n        `[CommonPasswordsLoader] Password list (${uniquePasswords.length}) exceeds maxCacheEntries (${maxEntries}). ` +\n          `Truncating to limit cache memory growth.`\n      );\n      return uniquePasswords.slice(0, maxEntries);\n    }\n\n    return uniquePasswords;\n  }\n\n  /**\n   * Reset loader for testing\n   */\n  static __resetForTests(): void {\n    CommonPasswordsLoader.instance = null;\n  }\n}\n\n/**\n * Get common passwords list (convenience function)\n */\nexport async function getCommonPasswords(): Promise<readonly string[]> {\n  const loader = CommonPasswordsLoader.getInstance();\n  return loader.getCommonPasswords();\n}\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/utils/formPipeline.ts",
        "messages": [
            {
                "ruleId": "@typescript-eslint/no-dynamic-delete",
                "severity": 1,
                "message": "Do not delete dynamically computed property keys.",
                "line": 188,
                "column": 28,
                "nodeType": "TSAsExpression",
                "messageId": "dynamicDelete",
                "endLine": 188,
                "endColumn": 42
            },
            {
                "ruleId": "@typescript-eslint/require-await",
                "severity": 1,
                "message": "Async arrow function has no 'await' expression.",
                "line": 296,
                "column": 32,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingAwait",
                "endLine": 296,
                "endColumn": 34,
                "suggestions": [
                    {
                        "messageId": "removeAsync",
                        "fix": {
                            "range": [
                                8903,
                                8909
                            ],
                            "text": ""
                        },
                        "desc": "Remove 'async'."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/restrict-template-expressions",
                "severity": 1,
                "message": "Invalid type \"number\" of template literal expression.",
                "line": 376,
                "column": 33,
                "nodeType": "MemberExpression",
                "messageId": "invalidType",
                "endLine": 376,
                "endColumn": 49
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 3,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "/**\n * Form Processing Pipeline with Railway-Oriented Programming\n *\n * Implements form submission pipeline: validate  sanitize  transform  submit\n * Uses Result types for type-safe error handling throughout the pipeline.\n *\n * @module formPipeline\n */\n\nimport { type Result, ok, err } from 'neverthrow';\nimport type { FormValidationError } from './formValidation';\nimport { formatFormValidationError } from './formValidation';\n\n/**\n * Pipeline error types\n * Generic E allows different validation error types\n */\nexport type PipelineError<E = FormValidationError> =\n  | { type: 'VALIDATION_ERROR'; errors: E | Record<string, E> }\n  | { type: 'SANITIZATION_ERROR'; reason: string }\n  | { type: 'TRANSFORMATION_ERROR'; reason: string }\n  | { type: 'SUBMISSION_ERROR'; statusCode?: number; message: string };\n\n/**\n * Form validator type with railway pattern\n * Generic E allows any error type (FormValidationError, CredentialValidationError, etc.)\n */\nexport type FormValidator<TForm, TValidated, E = FormValidationError> = (\n  form: TForm\n) => Result<TValidated, E | Record<string, E>>;\n\n/**\n * Sanitizer function type\n *\n * @warning Sanitizers may mutate field values (e.g., converting \"\" to undefined, deleting nullish values).\n * The returned type T should be compatible with these transformations. For example, fields that may\n * be removed should be optional in the type definition.\n */\nexport type Sanitizer<T, E = FormValidationError> = (data: T) => Result<T, PipelineError<E>>;\n\n/**\n * Transformer function type (DTO conversion)\n */\nexport type Transformer<TInput, TOutput, E = FormValidationError> = (\n  input: TInput\n) => Result<TOutput, PipelineError<E>>;\n\n/**\n * Submission function type\n */\nexport type Submitter<TData, TResponse, E = FormValidationError> = (\n  data: TData\n) => Promise<Result<TResponse, PipelineError<E>>>;\n\n/**\n * Complete form pipeline configuration\n */\nexport interface FormPipelineConfig<TForm, TValidated, TDTO, TResponse, E = FormValidationError> {\n  validate: FormValidator<TForm, TValidated, E>;\n  sanitize?: Sanitizer<TValidated, E>;\n  transform: Transformer<TValidated, TDTO, E>;\n  submit: Submitter<TDTO, TResponse, E>;\n}\n\n/**\n * Pipeline execution result states (discriminated union)\n */\nexport type PipelineState<T, E = FormValidationError> =\n  | { status: 'idle' }\n  | { status: 'validating' }\n  | { status: 'sanitizing' }\n  | { status: 'transforming' }\n  | { status: 'submitting' }\n  | { status: 'success'; data: T }\n  | { status: 'error'; error: PipelineError<E> };\n\n/**\n * Create a form submission pipeline with railway-oriented programming\n *\n * @param config - Pipeline configuration with validate, sanitize, transform, submit steps\n * @returns Function that executes the complete pipeline\n *\n * @example\n * ```typescript\n * const pipeline = createFormPipeline({\n *   validate: validateLoginForm,\n *   sanitize: sanitizeLoginData,\n *   transform: transformToLoginDTO,\n *   submit: submitLogin\n * });\n *\n * const result = await pipeline(formData);\n * result.match(\n *   (response) => console.log('Success:', response),\n *   (error) => console.log('Error:', formatPipelineError(error))\n * );\n * ```\n */\nexport const createFormPipeline = <TForm, TValidated, TDTO, TResponse, E = FormValidationError>(\n  config: FormPipelineConfig<TForm, TValidated, TDTO, TResponse, E>\n) => {\n  return async (formData: TForm): Promise<Result<TResponse, PipelineError<E>>> => {\n    // Step 1: Validate\n    const validationResult = config.validate(formData);\n    if (validationResult.isErr()) {\n      return err({\n        type: 'VALIDATION_ERROR',\n        errors: validationResult.error,\n      });\n    }\n\n    const validated = validationResult.value;\n\n    // Step 2: Sanitize (optional)\n    let sanitized = validated;\n    if (config.sanitize) {\n      const sanitizeResult = config.sanitize(validated);\n      if (sanitizeResult.isErr()) {\n        return err(sanitizeResult.error);\n      }\n      sanitized = sanitizeResult.value;\n    }\n\n    // Step 3: Transform to DTO\n    const transformResult = config.transform(sanitized);\n    if (transformResult.isErr()) {\n      return err(transformResult.error);\n    }\n\n    const dto = transformResult.value;\n\n    // Step 4: Submit\n    const submitResult = await config.submit(dto);\n    if (submitResult.isErr()) {\n      return err(submitResult.error);\n    }\n\n    return ok(submitResult.value);\n  };\n};\n\n/**\n * Default sanitization functions\n *\n * @warning These sanitizers mutate field values and may remove or transform fields.\n * Ensure your type definitions account for these changes (e.g., optional fields).\n */\nexport const Sanitizers = {\n  /**\n   * Trim whitespace from all string fields\n   *\n   * @warning Only modifies string fields. Safe for most types but ensure trimmed values\n   * are acceptable for your validation logic (e.g., minimum length checks).\n   */\n  trimStrings: <T extends Record<string, unknown>>(data: T): Result<T, PipelineError> => {\n    try {\n      const sanitized = { ...data };\n\n      for (const [key, value] of Object.entries(sanitized)) {\n        if (typeof value === 'string') {\n          // Safe mutation - trimming preserves string type\n          sanitized[key as keyof T] = value.trim() as T[keyof T];\n        }\n      }\n\n      return ok(sanitized);\n    } catch (error) {\n      return err({\n        type: 'SANITIZATION_ERROR',\n        reason: error instanceof Error ? error.message : 'Unknown sanitization error',\n      });\n    }\n  },\n\n  /**\n   * Remove null and undefined values\n   *\n   * @warning Deletes fields with null/undefined values. Ensure your type definition\n   * marks these fields as optional (e.g., field?: string) or use Partial<T> for the result.\n   * This may violate type contracts if fields are non-optional.\n   */\n  removeNullish: <T extends Record<string, unknown>>(data: T): Result<T, PipelineError> => {\n    try {\n      const sanitized = { ...data };\n\n      for (const [key, value] of Object.entries(sanitized)) {\n        if (value === null || value === undefined) {\n          delete sanitized[key as keyof T];\n        }\n      }\n\n      // Type assertion: caller must ensure deleted fields are optional in T\n      return ok(sanitized);\n    } catch (error) {\n      return err({\n        type: 'SANITIZATION_ERROR',\n        reason: error instanceof Error ? error.message : 'Unknown sanitization error',\n      });\n    }\n  },\n\n  /**\n   * Convert empty strings to undefined\n   *\n   * @warning Mutates string fields from \"\" to undefined. Ensure your type definition\n   * allows undefined for string fields (e.g., field?: string | undefined).\n   * This may violate type contracts if fields are non-nullable strings.\n   */\n  emptyStringsToUndefined: <T extends Record<string, unknown>>(\n    data: T\n  ): Result<T, PipelineError> => {\n    try {\n      const sanitized = { ...data };\n\n      for (const [key, value] of Object.entries(sanitized)) {\n        if (value === '') {\n          // Type assertion: caller must ensure field accepts undefined\n          sanitized[key as keyof T] = undefined as T[keyof T];\n        }\n      }\n\n      return ok(sanitized);\n    } catch (error) {\n      return err({\n        type: 'SANITIZATION_ERROR',\n        reason: error instanceof Error ? error.message : 'Unknown sanitization error',\n      });\n    }\n  },\n\n  /**\n   * Compose multiple sanitizers\n   */\n  compose: <T>(...sanitizers: Sanitizer<T>[]): Sanitizer<T> => {\n    return (data: T) => {\n      let result: Result<T, PipelineError> = ok(data);\n\n      for (const sanitizer of sanitizers) {\n        if (result.isErr()) {\n          return result;\n        }\n        result = sanitizer(result.value);\n      }\n\n      return result;\n    };\n  },\n};\n\n/**\n * Helper to create field-level validators for React Hook Form\n *\n * @param validator - Validation function\n * @returns Validator compatible with React Hook Form\n *\n * @example\n * ```typescript\n * const emailValidator = createFieldValidator(validateEmail);\n *\n * <input {...register('email', { validate: emailValidator })} />\n * ```\n */\nexport const createFieldValidator = <T>(\n  validator: (value: string | number) => Result<T, FormValidationError>\n) => {\n  return (value: string | number): true | string => {\n    const result = validator(value);\n    return result.match(\n      () => true,\n      error => {\n        // Use shared formatFormValidationError for consistent error messages\n        return formatFormValidationError(error);\n      }\n    );\n  };\n};\n\n/**\n * Create custom resolver for React Hook Form using Result types\n *\n * @param validator - Form validator function\n * @returns Resolver compatible with React Hook Form\n *\n * @example\n * ```typescript\n * const resolver = createFormResolver(validateLoginForm);\n *\n * const { register, handleSubmit } = useForm({\n *   resolver\n * });\n * ```\n */\nexport const createFormResolver = <TForm extends Record<string, unknown>, TValidated>(\n  validator: FormValidator<TForm, TValidated>\n) => {\n  return async (values: TForm) => {\n    const result = validator(values);\n\n    if (result.isOk()) {\n      return {\n        values: result.value as unknown as TForm,\n        errors: {},\n      };\n    }\n\n    // Handle single validation error\n    if ('type' in result.error) {\n      return {\n        values: {},\n        errors: {\n          root: {\n            type: 'validation',\n            message: formatFormValidationError(result.error as FormValidationError),\n          },\n        },\n      };\n    }\n\n    // Handle multiple field errors\n    const formattedErrors: Record<string, { type: string; message: string }> = {};\n    for (const [field, error] of Object.entries(result.error)) {\n      formattedErrors[field] = {\n        type: 'validation',\n        message: formatFormValidationError(error),\n      };\n    }\n\n    return {\n      values: {},\n      errors: formattedErrors,\n    };\n  };\n};\n\n/**\n * Format pipeline error to user-friendly message\n * Supports any validation error type with optional formatter\n */\nexport const formatPipelineError = <E = FormValidationError>(\n  error: PipelineError<E>,\n  errorFormatter?: (err: E) => string\n): string => {\n  switch (error.type) {\n    case 'VALIDATION_ERROR':\n      if (typeof error.errors === 'object' && error.errors !== null && 'type' in error.errors) {\n        // Single validation error\n        return errorFormatter\n          ? errorFormatter(error.errors as E)\n          : formatFormValidationError(error.errors as unknown as FormValidationError);\n      }\n\n      // Multiple field errors - format each field error individually\n      if (typeof error.errors === 'object' && error.errors !== null) {\n        const fieldErrors: string[] = [];\n\n        for (const [fieldName, fieldError] of Object.entries(error.errors)) {\n          const formattedError = errorFormatter\n            ? errorFormatter(fieldError as E)\n            : formatFormValidationError(fieldError as FormValidationError);\n\n          fieldErrors.push(`${fieldName}: ${formattedError}`);\n        }\n\n        if (fieldErrors.length > 0) {\n          return `Form validation failed: ${fieldErrors.join(', ')}`;\n        }\n      }\n\n      return 'Form validation failed. Please check your inputs.';\n    case 'SANITIZATION_ERROR':\n      return `Data sanitization error: ${error.reason}`;\n    case 'TRANSFORMATION_ERROR':\n      return `Data transformation error: ${error.reason}`;\n    case 'SUBMISSION_ERROR':\n      return error.statusCode != null\n        ? `Submission failed (${error.statusCode}): ${error.message}`\n        : `Submission failed: ${error.message}`;\n  }\n};\n\n/**\n * Pipeline state machine helpers\n */\nexport const PipelineStates = {\n  idle: <T, E = FormValidationError>(): PipelineState<T, E> => ({ status: 'idle' }),\n  validating: <T, E = FormValidationError>(): PipelineState<T, E> => ({ status: 'validating' }),\n  sanitizing: <T, E = FormValidationError>(): PipelineState<T, E> => ({ status: 'sanitizing' }),\n  transforming: <T, E = FormValidationError>(): PipelineState<T, E> => ({ status: 'transforming' }),\n  submitting: <T, E = FormValidationError>(): PipelineState<T, E> => ({ status: 'submitting' }),\n  success: <T, E = FormValidationError>(data: T): PipelineState<T, E> => ({\n    status: 'success',\n    data,\n  }),\n  error: <T, E = FormValidationError>(error: PipelineError<E>): PipelineState<T, E> => ({\n    status: 'error',\n    error,\n  }),\n};\n\n/**\n * Check if pipeline is in loading state\n */\nexport const isPipelineLoading = <T, E = FormValidationError>(\n  state: PipelineState<T, E>\n): boolean => {\n  return (\n    state.status === 'validating' ||\n    state.status === 'sanitizing' ||\n    state.status === 'transforming' ||\n    state.status === 'submitting'\n  );\n};\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/utils/formValidation.ts",
        "messages": [
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 144,
                "column": 7,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 144,
                "endColumn": 16,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                4604,
                                4613
                            ],
                            "text": "(localPart != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                4604,
                                4613
                            ],
                            "text": "(localPart ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                4604,
                                4613
                            ],
                            "text": "(Boolean(localPart))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
                "line": 149,
                "column": 7,
                "nodeType": "ChainExpression",
                "messageId": "conditionErrorNullableBoolean",
                "endLine": 149,
                "endColumn": 32,
                "suggestions": [
                    {
                        "messageId": "conditionFixDefaultFalse",
                        "fix": {
                            "range": [
                                4800,
                                4825
                            ],
                            "text": "(localPart?.includes('..')) ?? false"
                        },
                        "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
                    },
                    {
                        "messageId": "conditionFixCompareTrue",
                        "fix": {
                            "range": [
                                4800,
                                4825
                            ],
                            "text": "(localPart?.includes('..')) === true"
                        },
                        "desc": "Change condition to check if true (`value === true`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
                "line": 153,
                "column": 7,
                "nodeType": "ChainExpression",
                "messageId": "conditionErrorNullableBoolean",
                "endLine": 153,
                "endColumn": 29,
                "suggestions": [
                    {
                        "messageId": "conditionFixDefaultFalse",
                        "fix": {
                            "range": [
                                4933,
                                4955
                            ],
                            "text": "(domain?.includes('..')) ?? false"
                        },
                        "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
                    },
                    {
                        "messageId": "conditionFixCompareTrue",
                        "fix": {
                            "range": [
                                4933,
                                4955
                            ],
                            "text": "(domain?.includes('..')) === true"
                        },
                        "desc": "Change condition to check if true (`value === true`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/restrict-template-expressions",
                "severity": 1,
                "message": "Invalid type \"8\" of template literal expression.",
                "line": 319,
                "column": 38,
                "nodeType": "Identifier",
                "messageId": "invalidType",
                "endLine": 319,
                "endColumn": 57
            },
            {
                "ruleId": "@typescript-eslint/restrict-template-expressions",
                "severity": 1,
                "message": "Invalid type \"128\" of template literal expression.",
                "line": 327,
                "column": 37,
                "nodeType": "Identifier",
                "messageId": "invalidType",
                "endLine": 327,
                "endColumn": 56
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'hasSpecialChar' is assigned a value but never used. Allowed unused vars must match /^_/u.",
                "line": 336,
                "column": 9,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 336,
                "endColumn": 23
            },
            {
                "ruleId": "no-useless-escape",
                "severity": 1,
                "message": "Unnecessary escape character: \\[.",
                "line": 336,
                "column": 43,
                "nodeType": "Literal",
                "messageId": "unnecessaryEscape",
                "endLine": 336,
                "endColumn": 44,
                "suggestions": [
                    {
                        "messageId": "removeEscape",
                        "fix": {
                            "range": [
                                9426,
                                9427
                            ],
                            "text": ""
                        },
                        "desc": "Remove the `\\`. This maintains the current functionality."
                    },
                    {
                        "messageId": "escapeBackslash",
                        "fix": {
                            "range": [
                                9426,
                                9426
                            ],
                            "text": "\\"
                        },
                        "desc": "Replace the `\\` with `\\\\` to include the actual backslash character."
                    }
                ]
            },
            {
                "ruleId": "no-useless-escape",
                "severity": 1,
                "message": "Unnecessary escape character: \\/.",
                "line": 336,
                "column": 60,
                "nodeType": "Literal",
                "messageId": "unnecessaryEscape",
                "endLine": 336,
                "endColumn": 61,
                "suggestions": [
                    {
                        "messageId": "removeEscape",
                        "fix": {
                            "range": [
                                9443,
                                9444
                            ],
                            "text": ""
                        },
                        "desc": "Remove the `\\`. This maintains the current functionality."
                    },
                    {
                        "messageId": "escapeBackslash",
                        "fix": {
                            "range": [
                                9443,
                                9443
                            ],
                            "text": "\\"
                        },
                        "desc": "Replace the `\\` with `\\\\` to include the actual backslash character."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/restrict-template-expressions",
                "severity": 1,
                "message": "Invalid type \"number\" of template literal expression.",
                "line": 389,
                "column": 77,
                "nodeType": "Identifier",
                "messageId": "invalidType",
                "endLine": 389,
                "endColumn": 80
            },
            {
                "ruleId": "@typescript-eslint/restrict-template-expressions",
                "severity": 1,
                "message": "Invalid type \"number\" of template literal expression.",
                "line": 393,
                "column": 76,
                "nodeType": "Identifier",
                "messageId": "invalidType",
                "endLine": 393,
                "endColumn": 79
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected any value in conditional. An explicit comparison or type conversion is required.",
                "line": 541,
                "column": 9,
                "nodeType": "CallExpression",
                "messageId": "conditionErrorAny",
                "endLine": 541,
                "endColumn": 27,
                "suggestions": [
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                15214,
                                15232
                            ],
                            "text": "Boolean(validation.isErr())"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-call",
                "severity": 1,
                "message": "Unsafe call of a(n) `any` typed value.",
                "line": 541,
                "column": 9,
                "nodeType": "MemberExpression",
                "messageId": "unsafeCall",
                "endLine": 541,
                "endColumn": 25
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .isErr on an `any` value.",
                "line": 541,
                "column": 20,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 541,
                "endColumn": 25
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 542,
                "column": 7,
                "nodeType": "AssignmentExpression",
                "messageId": "anyAssignment",
                "endLine": 542,
                "endColumn": 48
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .error on an `any` value.",
                "line": 542,
                "column": 43,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 542,
                "endColumn": 48
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .value on an `any` value.",
                "line": 544,
                "column": 43,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 544,
                "endColumn": 48
            },
            {
                "ruleId": "@typescript-eslint/restrict-template-expressions",
                "severity": 1,
                "message": "Invalid type \"number\" of template literal expression.",
                "line": 576,
                "column": 53,
                "nodeType": "MemberExpression",
                "messageId": "invalidType",
                "endLine": 576,
                "endColumn": 62
            },
            {
                "ruleId": "@typescript-eslint/restrict-template-expressions",
                "severity": 1,
                "message": "Invalid type \"number\" of template literal expression.",
                "line": 576,
                "column": 82,
                "nodeType": "MemberExpression",
                "messageId": "invalidType",
                "endLine": 576,
                "endColumn": 94
            },
            {
                "ruleId": "@typescript-eslint/restrict-template-expressions",
                "severity": 1,
                "message": "Invalid type \"number\" of template literal expression.",
                "line": 578,
                "column": 52,
                "nodeType": "MemberExpression",
                "messageId": "invalidType",
                "endLine": 578,
                "endColumn": 61
            },
            {
                "ruleId": "@typescript-eslint/restrict-template-expressions",
                "severity": 1,
                "message": "Invalid type \"number\" of template literal expression.",
                "line": 578,
                "column": 81,
                "nodeType": "MemberExpression",
                "messageId": "invalidType",
                "endLine": 578,
                "endColumn": 93
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 20,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "/**\n * Form Validation Library - Extended Validators\n *\n * Pure validation functions for form fields using Result types and branded types.\n * Implements railway-oriented programming patterns for composable validation.\n *\n * @module formValidation\n */\n\nimport { type Result, ok, err } from 'neverthrow';\n\n/**\n * Form validation error types (discriminated unions)\n */\nexport type FormValidationError =\n  | { type: 'INVALID_EMAIL'; email: string; reason: string }\n  | { type: 'INVALID_PHONE'; phone: string; reason: string }\n  | { type: 'INVALID_PASSWORD'; reason: string }\n  | { type: 'INVALID_AGE'; age: number; reason: string }\n  | { type: 'INVALID_ZIP_CODE'; zipCode: string; reason: string }\n  | { type: 'REQUIRED_FIELD'; fieldName: string }\n  | { type: 'STRING_TOO_SHORT'; fieldName: string; min: number; actual: number }\n  | { type: 'STRING_TOO_LONG'; fieldName: string; max: number; actual: number }\n  | { type: 'PATTERN_MISMATCH'; fieldName: string; pattern: string }\n  | { type: 'CUSTOM_VALIDATION'; fieldName: string; message: string };\n\n/**\n * Branded types for validated form fields\n */\nexport type Email = string & { readonly __brand: 'Email' };\nexport type Phone = string & { readonly __brand: 'Phone' };\nexport type Password = string & { readonly __brand: 'Password' };\nexport type Age = number & { readonly __brand: 'Age' };\nexport type ZipCode = string & { readonly __brand: 'ZipCode' };\n\n/**\n * Validation constants\n */\nconst EMAIL_PATTERN = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/;\nconst PHONE_PATTERNS = {\n  // US format: +1-234-567-8900, (234) 567-8900, 234-567-8900, 2345678900\n  US: /^(\\+1)?[-.\\s]?(\\()?[0-9]{3}(\\))?[-.\\s]?[0-9]{3}[-.\\s]?[0-9]{4}$/,\n  // International format: +XX followed by spaces, dashes, or digits (10-15 digits total)\n  INTERNATIONAL: /^\\+?[1-9]\\d{0,3}[\\s.-]?\\d{1,4}[\\s.-]?\\d{1,4}[\\s.-]?\\d{1,9}$/,\n};\nconst ZIP_CODE_PATTERNS = {\n  // US: 12345 or 12345-6789\n  US: /^\\d{5}(-\\d{4})?$/,\n  // Canada: A1A 1A1\n  CANADA: /^[A-Za-z]\\d[A-Za-z][ -]?\\d[A-Za-z]\\d$/,\n  // Generic international\n  INTERNATIONAL: /^[A-Za-z0-9]{3,10}$/,\n};\nconst PASSWORD_MIN_LENGTH = 8;\nconst PASSWORD_MAX_LENGTH = 128;\n\n/**\n * Error factory functions\n */\nexport const FormValidationErrors = {\n  invalidEmail: (email: string, reason: string): FormValidationError => ({\n    type: 'INVALID_EMAIL',\n    email,\n    reason,\n  }),\n  invalidPhone: (phone: string, reason: string): FormValidationError => ({\n    type: 'INVALID_PHONE',\n    phone,\n    reason,\n  }),\n  invalidPassword: (reason: string): FormValidationError => ({ type: 'INVALID_PASSWORD', reason }),\n  invalidAge: (age: number, reason: string): FormValidationError => ({\n    type: 'INVALID_AGE',\n    age,\n    reason,\n  }),\n  invalidZipCode: (zipCode: string, reason: string): FormValidationError => ({\n    type: 'INVALID_ZIP_CODE',\n    zipCode,\n    reason,\n  }),\n  requiredField: (fieldName: string): FormValidationError => ({\n    type: 'REQUIRED_FIELD',\n    fieldName,\n  }),\n  stringTooShort: (fieldName: string, min: number, actual: number): FormValidationError => ({\n    type: 'STRING_TOO_SHORT',\n    fieldName,\n    min,\n    actual,\n  }),\n  stringTooLong: (fieldName: string, max: number, actual: number): FormValidationError => ({\n    type: 'STRING_TOO_LONG',\n    fieldName,\n    max,\n    actual,\n  }),\n  patternMismatch: (fieldName: string, pattern: string): FormValidationError => ({\n    type: 'PATTERN_MISMATCH',\n    fieldName,\n    pattern,\n  }),\n  customValidation: (fieldName: string, message: string): FormValidationError => ({\n    type: 'CUSTOM_VALIDATION',\n    fieldName,\n    message,\n  }),\n};\n\n/**\n * Validate email address (RFC 5322 simplified)\n *\n * @param email - Email address to validate\n * @returns Result with branded Email type or validation error\n *\n * @example\n * ```typescript\n * const result = validateEmail('user@example.com');\n * result.match(\n *   (email) => console.log('Valid email:', email),\n *   (error) => console.log('Error:', formatFormValidationError(error))\n * );\n * ```\n */\nexport const validateEmail = (email: string): Result<Email, FormValidationError> => {\n  const trimmed = email.trim().toLowerCase();\n\n  if (trimmed.length === 0) {\n    return err(FormValidationErrors.requiredField('email'));\n  }\n\n  if (trimmed.length > 254) {\n    return err(\n      FormValidationErrors.invalidEmail(email, 'Email address too long (max 254 characters)')\n    );\n  }\n\n  if (!EMAIL_PATTERN.test(trimmed)) {\n    return err(FormValidationErrors.invalidEmail(email, 'Invalid email format'));\n  }\n\n  // Additional validation: check for common typos\n  const [localPart, domain] = trimmed.split('@');\n  if (localPart && localPart.length > 64) {\n    return err(FormValidationErrors.invalidEmail(email, 'Local part too long (max 64 characters)'));\n  }\n\n  // Check for consecutive dots in local part\n  if (localPart?.includes('..')) {\n    return err(FormValidationErrors.invalidEmail(email, 'Email contains consecutive dots'));\n  }\n\n  if (domain?.includes('..')) {\n    return err(FormValidationErrors.invalidEmail(email, 'Domain contains consecutive dots'));\n  }\n\n  return ok(trimmed as Email);\n};\n\n/**\n * Validate phone number (supports US and international formats)\n *\n * @param phone - Phone number to validate\n * @param format - Optional format specification ('US', 'INTERNATIONAL', or 'AUTO')\n * @returns Result with branded Phone type or validation error\n *\n * @example\n * ```typescript\n * const result = validatePhone('+1-234-567-8900');\n * ```\n */\nexport const validatePhone = (\n  phone: string,\n  format: 'US' | 'INTERNATIONAL' | 'AUTO' = 'AUTO'\n): Result<Phone, FormValidationError> => {\n  const trimmed = phone.trim();\n\n  if (trimmed.length === 0) {\n    return err(FormValidationErrors.requiredField('phone'));\n  }\n\n  // Remove all non-digit characters for length check\n  const digitsOnly = trimmed.replace(/\\D/g, '');\n\n  if (digitsOnly.length < 10) {\n    return err(\n      FormValidationErrors.invalidPhone(phone, 'Phone number must have at least 10 digits')\n    );\n  }\n\n  if (digitsOnly.length > 15) {\n    return err(FormValidationErrors.invalidPhone(phone, 'Phone number too long (max 15 digits)'));\n  }\n\n  // Validate based on format\n  if (format === 'US' && !PHONE_PATTERNS.US.test(trimmed)) {\n    return err(FormValidationErrors.invalidPhone(phone, 'Invalid US phone number format'));\n  }\n\n  if (format === 'INTERNATIONAL' && !PHONE_PATTERNS.INTERNATIONAL.test(trimmed)) {\n    return err(\n      FormValidationErrors.invalidPhone(phone, 'Invalid international phone number format')\n    );\n  }\n\n  if (format === 'AUTO') {\n    const isValidUS = PHONE_PATTERNS.US.test(trimmed);\n    const isValidInternational = PHONE_PATTERNS.INTERNATIONAL.test(trimmed);\n\n    if (!isValidUS && !isValidInternational) {\n      return err(FormValidationErrors.invalidPhone(phone, 'Invalid phone number format'));\n    }\n  }\n\n  return ok(trimmed as Phone);\n};\n\n/**\n * Normalize password for consistent comparison\n * Trims whitespace and converts to lowercase\n *\n * @param password - Password to normalize\n * @returns Normalized password string\n */\nfunction normalizePassword(password: string): string {\n  return password.trim().toLowerCase();\n}\n\n/**\n * Common weak passwords and patterns to block\n * Curated list of most commonly used passwords from security research\n * Source: Based on top compromised passwords from Have I Been Pwned and similar databases\n * Note: Stored in lowercase for case-insensitive comparison\n */\nconst COMMON_WEAK_PASSWORDS = new Set([\n  // Extremely common patterns\n  'password',\n  'password123',\n  'password1',\n  'pass',\n  'passwd',\n  // Number sequences\n  '12345678',\n  '123456789',\n  '1234567890',\n  '12345',\n  '123456',\n  '1234567',\n  // Keyboard patterns\n  'qwerty',\n  'qwertyuiop',\n  'qwerty123',\n  'asdfgh',\n  'asdfghjkl',\n  'zxcvbn',\n  'qazwsx',\n  '1qaz2wsx',\n  'qwertyui',\n  // Simple patterns\n  'abc123',\n  'abc12345',\n  '123abc',\n  'abc',\n  'abcd1234',\n  'a1b2c3',\n  // Common words\n  'welcome',\n  'monkey',\n  'dragon',\n  'master',\n  'letmein',\n  'login',\n  'admin',\n  'administrator',\n  'root',\n  'user',\n  'guest',\n  'test',\n  // Names and dates\n  'sunshine',\n  'princess',\n  'football',\n  'soccer',\n  'baseball',\n  'iloveyou',\n  'trustno1',\n  'starwars',\n  // Weak combinations\n  'password!',\n  'password1',\n  'pass1234',\n  'welcome1',\n  'admin123',\n  '000000',\n  '111111',\n  '123123',\n  '696969',\n]);\n\n/**\n * Validate password with comprehensive strength requirements\n *\n * @param password - Password to validate\n * @returns Result with branded Password type or validation error\n *\n * @example\n * ```typescript\n * const result = validatePassword('SecureP@ss123');\n * ```\n */\nexport const validatePassword = (password: string): Result<Password, FormValidationError> => {\n  if (password.length === 0) {\n    return err(FormValidationErrors.requiredField('password'));\n  }\n\n  if (password.length < PASSWORD_MIN_LENGTH) {\n    return err(\n      FormValidationErrors.invalidPassword(\n        `Password must be at least ${PASSWORD_MIN_LENGTH} characters long`\n      )\n    );\n  }\n\n  if (password.length > PASSWORD_MAX_LENGTH) {\n    return err(\n      FormValidationErrors.invalidPassword(\n        `Password must be at most ${PASSWORD_MAX_LENGTH} characters long`\n      )\n    );\n  }\n\n  // Check password strength requirements\n  const hasUpperCase = /[A-Z]/.test(password);\n  const hasLowerCase = /[a-z]/.test(password);\n  const hasNumber = /[0-9]/.test(password);\n  const hasSpecialChar = /[!@#$%^&*()_+\\-=\\[\\]{};':\"\\\\|,.<>\\/?]/.test(password);\n\n  const missingRequirements: string[] = [];\n  if (!hasUpperCase) missingRequirements.push('one uppercase letter');\n  if (!hasLowerCase) missingRequirements.push('one lowercase letter');\n  if (!hasNumber) missingRequirements.push('one number');\n\n  // Special char is recommended but not required for basic validation\n\n  if (missingRequirements.length > 0) {\n    return err(\n      FormValidationErrors.invalidPassword(\n        `Password must contain at least: ${missingRequirements.join(', ')}`\n      )\n    );\n  }\n\n  // Check for common weak passwords - compare complete normalized password\n  // Use Set for O(1) lookup and normalize both password and weak passwords\n  if (COMMON_WEAK_PASSWORDS.has(normalizePassword(password))) {\n    return err(FormValidationErrors.invalidPassword('Password is too common'));\n  }\n\n  return ok(password as Password);\n};\n\n/**\n * Validate age (must be a positive integer within reasonable range)\n *\n * @param age - Age to validate\n * @param options - Optional min/max age constraints\n * @returns Result with branded Age type or validation error\n *\n * @example\n * ```typescript\n * const result = validateAge(25, { min: 18, max: 120 });\n * ```\n */\nexport const validateAge = (\n  age: number,\n  options: { min?: number; max?: number } = {}\n): Result<Age, FormValidationError> => {\n  const { min = 0, max = 150 } = options;\n\n  if (!Number.isFinite(age)) {\n    return err(FormValidationErrors.invalidAge(age, 'Age must be a valid number'));\n  }\n\n  if (!Number.isInteger(age)) {\n    return err(FormValidationErrors.invalidAge(age, 'Age must be a whole number'));\n  }\n\n  if (age < min) {\n    return err(FormValidationErrors.invalidAge(age, `Age must be at least ${min}`));\n  }\n\n  if (age > max) {\n    return err(FormValidationErrors.invalidAge(age, `Age must be at most ${max}`));\n  }\n\n  return ok(age as Age);\n};\n\n/**\n * Validate ZIP/postal code (supports US and Canada)\n *\n * @param zipCode - ZIP/postal code to validate\n * @param country - Country code ('US', 'CANADA', or 'INTERNATIONAL')\n * @returns Result with branded ZipCode type or validation error\n *\n * @example\n * ```typescript\n * const result = validateZipCode('12345', 'US');\n * ```\n */\nexport const validateZipCode = (\n  zipCode: string,\n  country: 'US' | 'CANADA' | 'INTERNATIONAL' = 'US'\n): Result<ZipCode, FormValidationError> => {\n  const trimmed = zipCode.trim();\n\n  if (trimmed.length === 0) {\n    return err(FormValidationErrors.requiredField('zipCode'));\n  }\n\n  const pattern = ZIP_CODE_PATTERNS[country];\n  if (!pattern.test(trimmed)) {\n    return err(\n      FormValidationErrors.invalidZipCode(zipCode, `Invalid ${country} ZIP/postal code format`)\n    );\n  }\n\n  return ok(trimmed as ZipCode);\n};\n\n/**\n * Combinator: Validate all fields in parallel\n * Returns the first error encountered, or all validated values\n *\n * @param validations - Array of validation Result objects (can be mixed types)\n * @returns Result with array of validated values or first error\n *\n * @example\n * ```typescript\n * const result = validateAll([\n *   validateEmail(email),\n *   validatePhone(phone),\n *   validateAge(age)\n * ]);\n * ```\n */\nexport const validateAll = <E>(validations: Result<unknown, E>[]): Result<unknown[], E> => {\n  const results: unknown[] = [];\n\n  for (const validation of validations) {\n    if (validation.isErr()) {\n      return err(validation.error);\n    }\n    results.push(validation.value);\n  }\n\n  return ok(results);\n};\n\n/**\n * Combinator: Validate fields in sequence (railway-oriented programming)\n * Each validation only runs if the previous one succeeded\n *\n * @param validations - Array of validation functions\n * @returns Result with array of validated values or first error\n *\n * @example\n * ```typescript\n * const result = validateSequence([\n *   () => validateEmail(email),\n *   () => validatePassword(password),\n *   () => validateAge(age)\n * ]);\n * ```\n */\nexport const validateSequence = <T, E>(validations: (() => Result<T, E>)[]): Result<T[], E> => {\n  const results: T[] = [];\n\n  for (const validate of validations) {\n    const result = validate();\n    if (result.isErr()) {\n      return err(result.error);\n    }\n    results.push(result.value);\n  }\n\n  return ok(results);\n};\n\n/**\n * Combinator: Validate optional field\n * Returns Ok(undefined) if empty/null, validates if present\n *\n * @param value - Optional value to validate\n * @param validator - Validation function to apply if value exists\n * @returns Result with validated value, undefined, or error\n *\n * @example\n * ```typescript\n * const result = validateOptional(maybePhone, validatePhone);\n * ```\n */\nexport const validateOptional = <T, V, E>(\n  value: V | undefined | null,\n  validator: (v: V) => Result<T, E>\n): Result<T | undefined, E> => {\n  if (value === undefined || value === null) {\n    return ok(undefined);\n  }\n\n  if (typeof value === 'string' && value.trim().length === 0) {\n    return ok(undefined);\n  }\n\n  return validator(value);\n};\n\n/**\n * Combinator: Collect all validation errors instead of failing fast\n * Useful for form validation where you want to show all errors at once\n *\n * @param validations - Object mapping field names to validation results\n * @returns Result with validated values or all errors\n *\n * @example\n * ```typescript\n * const result = validateAllOrCollectErrors({\n *   email: validateEmail(formData.email),\n *   phone: validatePhone(formData.phone),\n *   age: validateAge(formData.age)\n * });\n * ```\n */\nexport const validateAllOrCollectErrors = <T extends Record<string, unknown>, E>(validations: {\n  [K in keyof T]: Result<T[K], E>;\n}): Result<T, Record<keyof T, E>> => {\n  const errors: Partial<Record<keyof T, E>> = {};\n  const values: Partial<T> = {};\n\n  for (const [key, validation] of Object.entries(validations)) {\n    if (validation.isErr()) {\n      errors[key as keyof T] = validation.error;\n    } else {\n      values[key as keyof T] = validation.value as T[keyof T];\n    }\n  }\n\n  if (Object.keys(errors).length > 0) {\n    return err(errors as Record<keyof T, E>);\n  }\n\n  return ok(values as T);\n};\n\n/**\n * Format validation error to user-friendly message\n *\n * @param error - Form validation error\n * @returns Human-readable error message\n */\nexport const formatFormValidationError = (error: FormValidationError): string => {\n  switch (error.type) {\n    case 'INVALID_EMAIL':\n      return `Invalid email: ${error.reason}`;\n    case 'INVALID_PHONE':\n      return `Invalid phone number: ${error.reason}`;\n    case 'INVALID_PASSWORD':\n      return error.reason;\n    case 'INVALID_AGE':\n      return `Invalid age: ${error.reason}`;\n    case 'INVALID_ZIP_CODE':\n      return `Invalid ZIP code: ${error.reason}`;\n    case 'REQUIRED_FIELD':\n      return `${error.fieldName} is required`;\n    case 'STRING_TOO_SHORT':\n      return `${error.fieldName} must be at least ${error.min} characters (got ${error.actual})`;\n    case 'STRING_TOO_LONG':\n      return `${error.fieldName} must be at most ${error.max} characters (got ${error.actual})`;\n    case 'PATTERN_MISMATCH':\n      return `${error.fieldName} format is invalid`;\n    case 'CUSTOM_VALIDATION':\n      return error.message;\n  }\n};\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/utils/lazy.ts",
        "messages": [
            {
                "ruleId": "@typescript-eslint/no-non-null-assertion",
                "severity": 1,
                "message": "Forbidden non-null assertion.",
                "line": 118,
                "column": 12,
                "nodeType": "TSNonNullExpression",
                "messageId": "noNonNull",
                "endLine": 118,
                "endColumn": 30
            },
            {
                "ruleId": "@typescript-eslint/no-non-null-assertion",
                "severity": 1,
                "message": "Forbidden non-null assertion.",
                "line": 192,
                "column": 12,
                "nodeType": "TSNonNullExpression",
                "messageId": "noNonNull",
                "endLine": 192,
                "endColumn": 30
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??=`) instead of an assignment expression, as it is simpler to read.",
                "line": 434,
                "column": 5,
                "nodeType": "IfStatement",
                "messageId": "preferNullishOverAssignment",
                "endLine": 439,
                "endColumn": 6,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": "="
                        },
                        "fix": {
                            "range": [
                                9393,
                                9544
                            ],
                            "text": "this.timeoutId ??= setTimeout(() => {\n        void this.flush();\n        this.timeoutId = null;\n      }, 100);"
                        },
                        "desc": "Fix to nullish coalescing operator (`??=`)."
                    }
                ]
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 3,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "/**\n * Lazy evaluation utilities for deferred execution\n *\n * Provides tools for deferring expensive computations:\n * - Lazy values that compute on demand\n * - Lazy Result computations\n * - Generator-based data streaming\n * - Deferred execution strategies\n *\n * @module utils/lazy\n */\n\nimport type { Result, AsyncResult } from '@/types/fp';\n\n/**\n * Lazy value - computes result only when accessed\n *\n * @example\n * ```typescript\n * const expensiveValue = lazy(() => {\n *   console.log('Computing...');\n *   return fibonacci(100);\n * });\n *\n * // Nothing logged yet - computation deferred\n * const result1 = expensiveValue.value; // Logged: \"Computing...\"\n * const result2 = expensiveValue.value; // Nothing logged - cached from first call\n * ```\n */\nexport class Lazy<T> {\n  private computed = false;\n  private cachedValue: T | undefined;\n\n  constructor(private thunk: () => T) {}\n\n  /**\n   * Get the value, computing if necessary\n   */\n  get value(): T {\n    if (!this.computed) {\n      this.cachedValue = this.thunk();\n      this.computed = true;\n    }\n    return this.cachedValue as T;\n  }\n\n  /**\n   * Apply a function to the lazy value\n   */\n  map<U>(fn: (value: T) => U): Lazy<U> {\n    return new Lazy(() => fn(this.value));\n  }\n\n  /**\n   * Chain lazy computations\n   */\n  flatMap<U>(fn: (value: T) => Lazy<U>): Lazy<U> {\n    return new Lazy(() => fn(this.value).value);\n  }\n\n  /**\n   * Force evaluation of the lazy value\n   */\n  force(): T {\n    return this.value;\n  }\n\n  /**\n   * Reset the cached value\n   */\n  reset(): void {\n    this.computed = false;\n    this.cachedValue = undefined;\n  }\n}\n\n/**\n * Create a lazy value\n *\n * @param thunk - Function that computes the value\n * @returns Lazy value wrapper\n */\nexport function lazy<T>(thunk: () => T): Lazy<T> {\n  return new Lazy(thunk);\n}\n\n/**\n * Lazy Result computation\n *\n * Defers Result computation until accessed, useful for expensive validation.\n *\n * @example\n * ```typescript\n * const lazyValidation = lazyResult(() => validateEmail(email));\n *\n * // Validation not run yet\n * const result = lazyValidation.value;\n * result.match(\n *   (email) => console.log('Valid:', email),\n *   (error) => console.log('Invalid:', error.message)\n * );\n * ```\n */\nexport class LazyResult<T, E> {\n  private computed = false;\n  private cachedResult: Result<T, E> | undefined;\n\n  constructor(private thunk: () => Result<T, E>) {}\n\n  /**\n   * Get the Result value, computing if necessary\n   */\n  get value(): Result<T, E> {\n    if (!this.computed) {\n      this.cachedResult = this.thunk();\n      this.computed = true;\n    }\n    return this.cachedResult!;\n  }\n\n  /**\n   * Apply a function to the successful value\n   */\n  map<U>(fn: (value: T) => U): LazyResult<U, E> {\n    return new LazyResult(() => this.value.map(fn));\n  }\n\n  /**\n   * Apply a function to the error\n   */\n  mapErr<F>(fn: (error: E) => F): LazyResult<T, F> {\n    return new LazyResult(() => this.value.mapErr(fn));\n  }\n\n  /**\n   * Chain lazy Results\n   */\n  andThen<U>(fn: (value: T) => Result<U, E>): LazyResult<U, E> {\n    return new LazyResult(() => this.value.andThen(fn));\n  }\n\n  /**\n   * Force evaluation\n   */\n  force(): Result<T, E> {\n    return this.value;\n  }\n\n  /**\n   * Reset the cached result\n   */\n  reset(): void {\n    this.computed = false;\n    this.cachedResult = undefined;\n  }\n}\n\n/**\n * Create a lazy Result\n */\nexport function lazyResult<T, E>(thunk: () => Result<T, E>): LazyResult<T, E> {\n  return new LazyResult(thunk);\n}\n\n/**\n * Lazy async Result computation\n *\n * Defers async Result computation, useful for expensive API calls.\n */\nexport class LazyAsyncResult<T, E> {\n  private computed = false;\n  private cachedResult: Result<T, E> | undefined;\n  private pending: Promise<Result<T, E>> | undefined;\n\n  constructor(private thunk: () => AsyncResult<T, E> | Promise<Result<T, E>>) {}\n\n  /**\n   * Force evaluation of the async Result\n   */\n  async force(): Promise<Result<T, E>> {\n    if (!this.computed) {\n      if (this.pending) {\n        return this.pending;\n      }\n      this.pending = Promise.resolve(this.thunk()).finally(() => {\n        this.pending = undefined;\n      });\n      const result = await this.pending;\n      this.cachedResult = result;\n      this.computed = true;\n    }\n    return this.cachedResult!;\n  }\n\n  /**\n   * Reset the cached result\n   */\n  reset(): void {\n    this.computed = false;\n    this.cachedResult = undefined;\n    this.pending = undefined;\n  }\n}\n\n/**\n * Generator-based data streaming for memory efficiency\n *\n * Yields results one at a time instead of loading all into memory.\n *\n * @example\n * ```typescript\n * function* streamLargeDataset() {\n *   for (let i = 0; i < 1000000; i++) {\n *     yield expensiveComputation(i);\n *   }\n * }\n *\n * for (const item of streamLargeDataset()) {\n *   processItem(item); // Each item computed on demand\n * }\n * ```\n */\nexport function* streamResults<T, E>(\n  items: T[],\n  processor: (item: T) => Result<T, E>\n): Generator<Result<T, E>> {\n  for (const item of items) {\n    yield processor(item);\n  }\n}\n\n/**\n * Lazy collection mapper that processes items on demand\n *\n * @example\n * ```typescript\n * const lazyMap = lazyMap([1, 2, 3, 4, 5], n => n * 2);\n *\n * const result = lazyMap.take(2); // Only first 2 computed: [2, 4]\n * ```\n */\nexport class LazyCollection<T, R> {\n  private predicates: ((item: T) => boolean)[] = [];\n\n  constructor(\n    private items: T[],\n    private mapper: (item: T) => R,\n    predicates?: ((item: T) => boolean)[]\n  ) {\n    this.predicates = predicates ? [...predicates] : [];\n  }\n\n  /**\n   * Get first N items (only compute N items)\n   */\n  take(n: number): R[] {\n    const result: R[] = [];\n    let count = 0;\n\n    for (const item of this.items) {\n      // Apply all predicates lazily\n      if (this.predicates.every(predicate => predicate(item))) {\n        result.push(this.mapper(item));\n        count++;\n        if (count >= n) break;\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Filter items lazily\n   */\n  filter(predicate: (item: T) => boolean): LazyCollection<T, R> {\n    return new LazyCollection(this.items, this.mapper, [...this.predicates, predicate]);\n  }\n\n  /**\n   * Iterate lazily\n   */\n  *[Symbol.iterator](): Generator<R> {\n    for (const item of this.items) {\n      // Apply all predicates lazily\n      if (this.predicates.every(predicate => predicate(item))) {\n        yield this.mapper(item);\n      }\n    }\n  }\n\n  /**\n   * Collect all items (forces full evaluation)\n   */\n  collect(): R[] {\n    const result: R[] = [];\n\n    for (const item of this.items) {\n      // Apply all predicates lazily\n      if (this.predicates.every(predicate => predicate(item))) {\n        result.push(this.mapper(item));\n      }\n    }\n\n    return result;\n  }\n}\n\n/**\n * Create a lazy collection mapper\n */\nexport function lazyMap<T, R>(items: T[], mapper: (item: T) => R): LazyCollection<T, R> {\n  return new LazyCollection(items, mapper);\n}\n\n/**\n * Deferred function execution\n *\n * Delays function call and allows cancellation.\n *\n * @example\n * ```typescript\n * const deferred = defer(() => expensiveOperation(), 1000);\n *\n * // Later, if still needed:\n * const result = deferred.execute();\n *\n * // Or cancel before execution:\n * deferred.cancel();\n * ```\n */\nexport class Deferred<T> {\n  private timeoutId: ReturnType<typeof setTimeout> | null = null;\n  private cancelled = false;\n  private executed = false;\n  private result: T | undefined;\n\n  constructor(\n    private fn: () => T,\n    delay: number\n  ) {\n    this.timeoutId = setTimeout(() => {\n      if (!this.cancelled) {\n        this.result = this.fn();\n        this.executed = true;\n        this.timeoutId = null;\n      }\n    }, delay);\n  }\n\n  /**\n   * Execute immediately (cancels scheduled execution)\n   */\n  execute(): T {\n    if (this.executed) {\n      return this.result as T;\n    }\n\n    if (this.timeoutId !== null) {\n      clearTimeout(this.timeoutId);\n      this.timeoutId = null;\n    }\n\n    this.result = this.fn();\n    this.executed = true;\n    return this.result;\n  }\n\n  /**\n   * Cancel execution\n   */\n  cancel(): void {\n    if (this.timeoutId !== null) {\n      clearTimeout(this.timeoutId);\n      this.timeoutId = null;\n    }\n    this.cancelled = true;\n  }\n\n  /**\n   * Check if deferred execution is still pending\n   */\n  isPending(): boolean {\n    return this.timeoutId !== null && !this.cancelled;\n  }\n}\n\n/**\n * Create a deferred function execution\n *\n * @param fn - Function to defer\n * @param delay - Delay in milliseconds\n * @returns Deferred execution wrapper\n */\nexport function defer<T>(fn: () => T, delay: number): Deferred<T> {\n  return new Deferred(fn, delay);\n}\n\n/**\n * Batch lazy computations and execute in chunks\n *\n * Useful for processing large datasets without blocking.\n *\n * @example\n * ```typescript\n * const batcher = batchLazy(1000, (items) => {\n *   return items.map(validateItem);\n * });\n *\n * for (const item of largeList) {\n *   await batcher.add(item);\n * }\n * ```\n */\nexport class LazyBatcher<T, R> {\n  private batch: T[] = [];\n  private timeoutId: ReturnType<typeof setTimeout> | null = null;\n\n  constructor(\n    private batchSize: number,\n    private processor: (items: T[]) => Promise<R[]>\n  ) {}\n\n  /**\n   * Add item to batch\n   */\n  async add(item: T): Promise<R[]> {\n    this.batch.push(item);\n\n    if (this.batch.length >= this.batchSize) {\n      return this.flush();\n    }\n\n    // Schedule flush after delay if not already scheduled\n    if (this.timeoutId === null) {\n      this.timeoutId = setTimeout(() => {\n        void this.flush();\n        this.timeoutId = null;\n      }, 100);\n    }\n\n    return [];\n  }\n\n  /**\n   * Flush pending batch\n   */\n  private async flush(): Promise<R[]> {\n    if (this.batch.length === 0) {\n      return [];\n    }\n\n    // Capture pending items into a local variable\n    const items = [...this.batch];\n\n    // Call processor and await the results\n    const results = await this.processor(items);\n    // Only clear batch after processor succeeds\n    this.batch = [];\n    return results;\n  }\n\n  /**\n   * Force flush remaining items\n   */\n  async flushAll(): Promise<R[]> {\n    if (this.timeoutId !== null) {\n      clearTimeout(this.timeoutId);\n      this.timeoutId = null;\n    }\n\n    if (this.batch.length === 0) {\n      return [];\n    }\n\n    // Capture pending items into a local variable\n    const items = [...this.batch];\n\n    // Call processor and await the results\n    const results = await this.processor(items);\n    // Only clear batch after processor succeeds\n    this.batch = [];\n    return results;\n  }\n}\n\n/**\n * Create a lazy batcher\n */\nexport function batchLazy<T, R>(\n  batchSize: number,\n  processor: (items: T[]) => Promise<R[]>\n): LazyBatcher<T, R> {\n  return new LazyBatcher(batchSize, processor);\n}\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/utils/logger.ts",
        "messages": [
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 10,
                "column": 10,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 10,
                "endColumn": 13,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                197,
                                200
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                197,
                                200
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 53,
                "column": 76,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 53,
                "endColumn": 79,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                1304,
                                1307
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                1304,
                                1307
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 62,
                "column": 7,
                "nodeType": "Property",
                "messageId": "anyAssignment",
                "endLine": 62,
                "endColumn": 11
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
                "line": 66,
                "column": 9,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorNullableBoolean",
                "endLine": 66,
                "endColumn": 37,
                "suggestions": [
                    {
                        "messageId": "conditionFixDefaultFalse",
                        "fix": {
                            "range": [
                                1654,
                                1682
                            ],
                            "text": "(this.config.captureUserAgent ?? false)"
                        },
                        "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
                    },
                    {
                        "messageId": "conditionFixCompareTrue",
                        "fix": {
                            "range": [
                                1654,
                                1682
                            ],
                            "text": "(this.config.captureUserAgent === true)"
                        },
                        "desc": "Change condition to check if true (`value === true`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.",
                "line": 70,
                "column": 9,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorNullableBoolean",
                "endLine": 70,
                "endColumn": 31,
                "suggestions": [
                    {
                        "messageId": "conditionFixDefaultFalse",
                        "fix": {
                            "range": [
                                1782,
                                1804
                            ],
                            "text": "(this.config.captureUrl ?? false)"
                        },
                        "desc": "Explicitly treat nullish value the same as false (`value ?? false`)"
                    },
                    {
                        "messageId": "conditionFixCompareTrue",
                        "fix": {
                            "range": [
                                1782,
                                1804
                            ],
                            "text": "(this.config.captureUrl === true)"
                        },
                        "desc": "Change condition to check if true (`value === true`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 77,
                "column": 3,
                "nodeType": "FunctionExpression",
                "messageId": "missingReturnType",
                "endLine": 77,
                "endColumn": 14
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 77,
                "column": 65,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 77,
                "endColumn": 68,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                1993,
                                1996
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                1993,
                                1996
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "no-console",
                "severity": 1,
                "message": "Unexpected console statement. Only these console methods are allowed: warn, error.",
                "line": 84,
                "column": 9,
                "nodeType": "MemberExpression",
                "messageId": "limited",
                "endLine": 84,
                "endColumn": 23,
                "suggestions": [
                    {
                        "fix": {
                            "range": [
                                2229,
                                2289
                            ],
                            "text": ""
                        },
                        "messageId": "removeMethodCall",
                        "desc": "Remove the console method call."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 99,
                "column": 3,
                "nodeType": "FunctionExpression",
                "messageId": "missingReturnType",
                "endLine": 99,
                "endColumn": 7
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 99,
                "column": 32,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 99,
                "endColumn": 35,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                2600,
                                2603
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                2600,
                                2603
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 108,
                "column": 3,
                "nodeType": "FunctionExpression",
                "messageId": "missingReturnType",
                "endLine": 108,
                "endColumn": 7
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 108,
                "column": 32,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 108,
                "endColumn": 35,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                2815,
                                2818
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                2815,
                                2818
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 117,
                "column": 3,
                "nodeType": "FunctionExpression",
                "messageId": "missingReturnType",
                "endLine": 117,
                "endColumn": 8
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 117,
                "column": 33,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 117,
                "endColumn": 36,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                3030,
                                3033
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                3030,
                                3033
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 121,
                "column": 3,
                "nodeType": "FunctionExpression",
                "messageId": "missingReturnType",
                "endLine": 121,
                "endColumn": 34
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 126,
                "column": 28,
                "nodeType": "CallExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 126,
                "endColumn": 60,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                3344,
                                3376
                            ],
                            "text": "(localStorage.getItem('app_logs') != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                3344,
                                3376
                            ],
                            "text": "(localStorage.getItem('app_logs') ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                3344,
                                3376
                            ],
                            "text": "(Boolean(localStorage.getItem('app_logs')))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 126,
                "column": 61,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 126,
                "endColumn": 63,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                3377,
                                3379
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 127,
                "column": 13,
                "nodeType": "VariableDeclarator",
                "messageId": "anyAssignment",
                "endLine": 127,
                "endColumn": 44
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-call",
                "severity": 1,
                "message": "Unsafe call of a(n) `any` typed value.",
                "line": 128,
                "column": 7,
                "nodeType": "MemberExpression",
                "messageId": "unsafeCall",
                "endLine": 128,
                "endColumn": 16
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .push on an `any` value.",
                "line": 128,
                "column": 12,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 128,
                "endColumn": 16
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .length on an `any` value.",
                "line": 131,
                "column": 16,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 131,
                "endColumn": 22
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-call",
                "severity": 1,
                "message": "Unsafe call of a(n) `any` typed value.",
                "line": 132,
                "column": 9,
                "nodeType": "MemberExpression",
                "messageId": "unsafeCall",
                "endLine": 132,
                "endColumn": 20
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .splice on an `any` value.",
                "line": 132,
                "column": 14,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 132,
                "endColumn": 20
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .length on an `any` value.",
                "line": 132,
                "column": 29,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 132,
                "endColumn": 35
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 170,
                "column": 3,
                "nodeType": "FunctionExpression",
                "messageId": "missingReturnType",
                "endLine": 170,
                "endColumn": 12
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 197,
                "column": 9,
                "nodeType": "Property",
                "messageId": "anyAssignment",
                "endLine": 197,
                "endColumn": 38
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .message on an `any` value.",
                "line": 197,
                "column": 31,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 197,
                "endColumn": 38
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 201,
                "column": 9,
                "nodeType": "Property",
                "messageId": "anyAssignment",
                "endLine": 201,
                "endColumn": 34
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .stack on an `any` value.",
                "line": 201,
                "column": 29,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 201,
                "endColumn": 34
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'loggingError' is defined but never used. Allowed unused caught errors must match /^_/u.",
                "line": 203,
                "column": 14,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 203,
                "endColumn": 26
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .message on an `any` value.",
                "line": 205,
                "column": 51,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 205,
                "endColumn": 58
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 221,
                "column": 9,
                "nodeType": "Property",
                "messageId": "anyAssignment",
                "endLine": 221,
                "endColumn": 29
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'loggingError' is defined but never used. Allowed unused caught errors must match /^_/u.",
                "line": 224,
                "column": 14,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 224,
                "endColumn": 26
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 256,
                "column": 33,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 256,
                "endColumn": 36,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                6923,
                                6926
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                6923,
                                6926
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 267,
                "column": 32,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 267,
                "endColumn": 35,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                7196,
                                7199
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                7196,
                                7199
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 278,
                "column": 32,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 278,
                "endColumn": 35,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                7462,
                                7465
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                7462,
                                7465
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 289,
                "column": 33,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 289,
                "endColumn": 36,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                7741,
                                7744
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                7741,
                                7744
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, value is always truthy.",
                "line": 305,
                "column": 69,
                "nodeType": "MemberExpression",
                "messageId": "alwaysTruthy",
                "endLine": 305,
                "endColumn": 85
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected object value in conditional. The condition is always true.",
                "line": 305,
                "column": 69,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorObject",
                "endLine": 305,
                "endColumn": 85
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected object value in conditional. The condition is always true.",
                "line": 320,
                "column": 7,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorObject",
                "endLine": 320,
                "endColumn": 26
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, value is always truthy.",
                "line": 320,
                "column": 7,
                "nodeType": "MemberExpression",
                "messageId": "alwaysTruthy",
                "endLine": 320,
                "endColumn": 26
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, value is always truthy.",
                "line": 321,
                "column": 7,
                "nodeType": "MemberExpression",
                "messageId": "alwaysTruthy",
                "endLine": 321,
                "endColumn": 35
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected object value in conditional. The condition is always true.",
                "line": 321,
                "column": 7,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorObject",
                "endLine": 321,
                "endColumn": 35
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 43,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "interface LoggerConfig {\n  captureUserAgent?: boolean;\n  captureUrl?: boolean;\n  sensitiveParams?: string[];\n}\n\ninterface LogEntry {\n  level: 'info' | 'warn' | 'error';\n  message: string;\n  data?: any;\n  timestamp: string;\n  userAgent?: string;\n  url?: string;\n}\n\n/**\n * Logger class for structured logging with production monitoring support\n */\nclass Logger {\n  private isProduction = import.meta.env.PROD;\n  private logs: LogEntry[] = [];\n  private config: LoggerConfig;\n\n  /**\n   * Creates a new Logger instance\n   * @param config - Configuration options for the logger\n   */\n  constructor(config: LoggerConfig = {}) {\n    this.config = {\n      captureUserAgent: false,\n      captureUrl: false,\n      sensitiveParams: ['token', 'session', 'api_key', 'password', 'secret'],\n      ...config,\n    };\n  }\n\n  private sanitizeUrl(url: string): string {\n    try {\n      const urlObj = new URL(url);\n      // Remove sensitive query params\n      this.config.sensitiveParams?.forEach(param => {\n        urlObj.searchParams.delete(param);\n      });\n      // Clear URL fragments\n      urlObj.hash = '';\n      return urlObj.toString();\n    } catch {\n      // If parsing fails, return a placeholder\n      return '<invalid-url>';\n    }\n  }\n\n  private createLogEntry(level: LogEntry['level'], message: string, data?: any): LogEntry {\n    // What is considered safe to log by default:\n    // - level and message (required)\n    // - timestamp (safe)\n    // - data (caller responsibility)\n    // - userAgent and url are opt-in and sanitized\n    const entry: LogEntry = {\n      level,\n      message,\n      data,\n      timestamp: new Date().toISOString(),\n    };\n\n    if (this.config.captureUserAgent && typeof navigator !== 'undefined') {\n      entry.userAgent = navigator.userAgent;\n    }\n\n    if (this.config.captureUrl && typeof window !== 'undefined') {\n      entry.url = this.sanitizeUrl(window.location.href);\n    }\n\n    return entry;\n  }\n\n  private log(level: LogEntry['level'], message: string, data?: any) {\n    const entry = this.createLogEntry(level, message, data);\n\n    // Store in memory for development debugging\n    if (!this.isProduction) {\n      this.logs.push(entry);\n      if (level === 'warn' || level === 'error') {\n        console[level](`[${level.toUpperCase()}] ${message}`, data);\n      }\n    }\n\n    // Send to monitoring service in production\n    if (this.isProduction) {\n      this.sendToMonitoringService(entry);\n    }\n  }\n\n  /**\n   * Log an info message\n   * @param message - The message to log\n   * @param data - Optional additional data to include\n   */\n  info(message: string, data?: any) {\n    this.log('info', message, data);\n  }\n\n  /**\n   * Log a warning message\n   * @param message - The message to log\n   * @param data - Optional additional data to include\n   */\n  warn(message: string, data?: any) {\n    this.log('warn', message, data);\n  }\n\n  /**\n   * Log an error message\n   * @param message - The message to log\n   * @param data - Optional additional data to include\n   */\n  error(message: string, data?: any) {\n    this.log('error', message, data);\n  }\n\n  private sendToMonitoringService(entry: LogEntry) {\n    // Replace with your monitoring service endpoint\n    // Example: Sentry, LogRocket, or custom logging endpoint\n    try {\n      // For now, just store in localStorage for debugging\n      const existingLogs = localStorage.getItem('app_logs') || '[]';\n      const logs = JSON.parse(existingLogs);\n      logs.push(entry);\n\n      // Keep only last 100 entries\n      if (logs.length > 100) {\n        logs.splice(0, logs.length - 100);\n      }\n\n      localStorage.setItem('app_logs', JSON.stringify(logs));\n\n      // Uncomment and configure for actual monitoring service\n      /*\n      fetch('/api/logs', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(entry),\n      }).catch(error => {\n        console.error('Failed to send log:', error);\n      });\n      */\n    } catch (error) {\n      console.error('Failed to send log:', error);\n    }\n  }\n\n  /**\n   * Get recent logs for debugging (development only)\n   * @param limit - Maximum number of logs to return\n   * @returns Array of recent log entries\n   */\n  getRecentLogs(limit = 50): LogEntry[] {\n    if (this.isProduction) {\n      // In production, we don't expose logs for security\n      return [];\n    }\n    return this.logs.slice(-limit);\n  }\n\n  /**\n   * Clear stored logs\n   */\n  clearLogs() {\n    this.logs = [];\n    if (this.isProduction) {\n      localStorage.removeItem('app_logs');\n    }\n  }\n\n  /**\n   * Check if running in production environment\n   * @returns true if in production\n   */\n  static isProduction(): boolean {\n    return import.meta.env.PROD;\n  }\n}\n\n// Global error handler - with reentrancy guard to prevent infinite loops\nlet isLoggingError = false;\n\n// Only add global error handlers if window is available (i.e., in browser environment)\nif (typeof window !== 'undefined') {\n  window.addEventListener('error', event => {\n    if (isLoggingError) return; // Prevent reentrancy\n\n    isLoggingError = true;\n    try {\n      logger.error('Global error', {\n        message: event.error?.message,\n        filename: event.filename,\n        lineno: event.lineno,\n        colno: event.colno,\n        stack: event.error?.stack,\n      });\n    } catch (loggingError) {\n      // Fallback to console if logging itself fails\n      console.error('Global error:', event.error?.message, {\n        filename: event.filename,\n        lineno: event.lineno,\n        colno: event.colno,\n      });\n    } finally {\n      isLoggingError = false;\n    }\n  });\n\n  window.addEventListener('unhandledrejection', event => {\n    if (isLoggingError) return; // Prevent reentrancy\n\n    isLoggingError = true;\n    try {\n      logger.error('Unhandled promise rejection', {\n        reason: event.reason,\n        promise: event.promise,\n      });\n    } catch (loggingError) {\n      // Fallback to console if logging itself fails\n      console.error('Unhandled promise rejection:', event.reason);\n    } finally {\n      isLoggingError = false;\n    }\n  });\n}\n\n/**\n * Global logger instance for application-wide logging\n */\nexport const logger = new Logger();\n\n// Environment configuration for address parsing logger\nconst debugEnabled = import.meta.env.VITE_DEBUG_ADDRESS_PARSING === 'true';\n\n/**\n * Determines if logging should occur based on environment settings\n * @returns true if logging should occur (not production OR debug enabled)\n */\nconst shouldLog = (): boolean => !Logger.isProduction() || debugEnabled;\n\n/**\n * Specialized logger for address parsing operations that respects VITE_DEBUG_ADDRESS_PARSING environment variable\n */\nexport const addressParsingLogger = {\n  /**\n   * Log debug information for address parsing steps and intermediate values\n   * @param message - Debug message\n   * @param data - Optional additional data\n   */\n  debug(message: string, data?: any) {\n    if (shouldLog()) {\n      logger.info(`[DEBUG] ${message}`, data);\n    }\n  },\n\n  /**\n   * Log general information about address parsing operations\n   * @param message - Info message\n   * @param data - Optional additional data\n   */\n  info(message: string, data?: any) {\n    if (shouldLog()) {\n      logger.info(message, data);\n    }\n  },\n\n  /**\n   * Log warnings for non-critical issues during address parsing\n   * @param message - Warning message\n   * @param data - Optional additional data\n   */\n  warn(message: string, data?: any) {\n    if (shouldLog()) {\n      logger.warn(message, data);\n    }\n  },\n\n  /**\n   * Log critical errors in address parsing that prevent successful completion\n   * @param message - Error message\n   * @param data - Optional additional data\n   */\n  error(message: string, data?: any) {\n    // Always emit critical errors in production\n    logger.error(message, data);\n    // TODO: add extra debug output here for non-production debugging\n  },\n};\n\n/**\n * Performance monitoring utilities for measuring execution times\n */\nexport const performanceMonitor = {\n  /**\n   * Mark a performance point in time\n   * @param name - Name of the performance mark\n   */\n  mark(name: string) {\n    if (typeof window !== 'undefined' && 'performance' in window && performance.mark) {\n      performance.mark(name);\n    }\n  },\n\n  /**\n   * Measure the duration between two performance marks\n   * @param name - Name for the measurement\n   * @param startMark - Starting performance mark\n   * @param endMark - Ending performance mark\n   */\n  measure(name: string, startMark?: string, endMark?: string) {\n    if (\n      typeof window !== 'undefined' &&\n      'performance' in window &&\n      performance.measure &&\n      performance.getEntriesByName\n    ) {\n      try {\n        const measureName = `measure-${name}`;\n        performance.measure(measureName, startMark, endMark);\n        const measure = performance.getEntriesByName(measureName)[0];\n        if (measure) {\n          logger.info(`Performance measure: ${name}`, {\n            duration: measure.duration,\n            startTime: measure.startTime,\n          });\n        }\n      } catch (error) {\n        logger.warn(`Failed to measure performance: ${name}`, error);\n      }\n    }\n  },\n};\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/utils/memoization.ts",
        "messages": [
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'AppError' is defined but never used. Allowed unused vars must match /^_/u.",
                "line": 14,
                "column": 15,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 14,
                "endColumn": 23
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.",
                "line": 93,
                "column": 12,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableNumber",
                "endLine": 93,
                "endColumn": 15,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                2235,
                                2239
                            ],
                            "text": "(ttl == null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultZero",
                        "fix": {
                            "range": [
                                2236,
                                2239
                            ],
                            "text": "(ttl ?? 0)"
                        },
                        "desc": "Explicitly treat nullish value the same as 0 (`value ?? 0`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                2235,
                                2239
                            ],
                            "text": "(!Boolean(ttl))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 110,
                "column": 11,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 110,
                "endColumn": 19,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                2780,
                                2788
                            ],
                            "text": "firstKey != null"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                2780,
                                2788
                            ],
                            "text": "firstKey ?? \"\""
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                2780,
                                2788
                            ],
                            "text": "Boolean(firstKey)"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.",
                "line": 209,
                "column": 12,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableNumber",
                "endLine": 209,
                "endColumn": 15,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                5327,
                                5331
                            ],
                            "text": "(ttl == null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultZero",
                        "fix": {
                            "range": [
                                5328,
                                5331
                            ],
                            "text": "(ttl ?? 0)"
                        },
                        "desc": "Explicitly treat nullish value the same as 0 (`value ?? 0`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                5327,
                                5331
                            ],
                            "text": "(!Boolean(ttl))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 236,
                "column": 11,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 236,
                "endColumn": 19,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                6135,
                                6143
                            ],
                            "text": "firstKey != null"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                6135,
                                6143
                            ],
                            "text": "firstKey ?? \"\""
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                6135,
                                6143
                            ],
                            "text": "Boolean(firstKey)"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 317,
                "column": 13,
                "nodeType": "Identifier",
                "messageId": "conditionErrorNullableString",
                "endLine": 317,
                "endColumn": 21,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                8333,
                                8341
                            ],
                            "text": "firstKey != null"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                8333,
                                8341
                            ],
                            "text": "firstKey ?? \"\""
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                8333,
                                8341
                            ],
                            "text": "Boolean(firstKey)"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-type-parameters",
                "severity": 1,
                "message": "Type parameter R is used only once in the function signature.",
                "line": 358,
                "column": 47,
                "nodeType": "TSTypeParameter",
                "messageId": "sole",
                "endLine": 358,
                "endColumn": 48,
                "suggestions": [
                    {
                        "messageId": "replaceUsagesWithConstraint",
                        "fix": {
                            "range": [
                                9188,
                                9217
                            ],
                            "text": ">(\n  fn: (...args: T) => unknown"
                        },
                        "desc": "Replace all usages of type parameter with its constraint."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/explicit-function-return-type",
                "severity": 1,
                "message": "Missing return type on function.",
                "line": 367,
                "column": 34,
                "nodeType": "ArrowFunctionExpression",
                "messageId": "missingReturnType",
                "endLine": 367,
                "endColumn": 36
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-type-parameters",
                "severity": 1,
                "message": "Type parameter R is used only once in the function signature.",
                "line": 407,
                "column": 47,
                "nodeType": "TSTypeParameter",
                "messageId": "sole",
                "endLine": 407,
                "endColumn": 48,
                "suggestions": [
                    {
                        "messageId": "replaceUsagesWithConstraint",
                        "fix": {
                            "range": [
                                10249,
                                10278
                            ],
                            "text": ">(\n  fn: (...args: T) => unknown"
                        },
                        "desc": "Replace all usages of type parameter with its constraint."
                    }
                ]
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 9,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "/**\n * Memoization utilities for pure functions\n *\n * Provides memoization strategies for FP patterns including:\n * - Simple memoization for pure functions\n * - Result-based memoization for Result-returning functions\n * - TTL-based memoization with expiration\n * - N-ary function memoization\n *\n * @module utils/memoization\n */\n\nimport type { Result, AsyncResult } from '@/types/fp';\nimport type { AppError } from '@/types/errors';\n\n/**\n * Memoization cache key generator\n */\nexport type KeyGenerator<T extends unknown[]> = (...args: T) => string;\n\n/**\n * Simple memoization cache for sync functions\n */\ninterface MemoCache<T> {\n  value: T;\n  timestamp: number;\n}\n\n/**\n * Memoized function with clear method\n */\nexport interface MemoizedFunction<T extends unknown[], R> {\n  (...args: T): R;\n  clear(): void;\n}\n\n/**\n * Async memoized function with clear method\n */\nexport interface MemoizedAsyncFunction<T extends unknown[], R, E> {\n  (...args: T): Promise<Result<R, E>>;\n  clear(): void;\n}\n\n/**\n * Memoize a pure synchronous function with optional TTL\n *\n * @param fn - Pure function to memoize\n * @param options - Memoization options\n * @returns Memoized version of the function\n *\n * @example\n * ```typescript\n * // Simple memoization\n * const expensiveCalculation = memoize((n: number) => {\n *   return fibonacci(n);\n * });\n *\n * const result1 = expensiveCalculation(10); // Calculated\n * const result2 = expensiveCalculation(10); // From cache\n *\n * // With custom key generator\n * const memoizedValidator = memoize(\n *   validateEmail,\n *   {\n *     keyGenerator: (email) => email.toLowerCase(),\n *     ttl: 5 * 60 * 1000 // 5 minutes\n *   }\n * );\n * ```\n */\nexport function memoize<T extends unknown[], R>(\n  fn: (...args: T) => R,\n  options?: {\n    keyGenerator?: KeyGenerator<T>;\n    ttl?: number;\n    maxSize?: number;\n  }\n): MemoizedFunction<T, R> {\n  const cache = new Map<string, MemoCache<R>>();\n  const {\n    keyGenerator = (...args: T) => JSON.stringify(args),\n    ttl = undefined,\n    maxSize = 128,\n  } = options ?? {};\n\n  const memoized = (...args: T): R => {\n    const key = keyGenerator(...args);\n    const cached = cache.get(key);\n\n    // Check if cache entry exists and is not expired\n    if (cached) {\n      if (!ttl || Date.now() - cached.timestamp < ttl) {\n        // Move to end for LRU (delete and re-add to update position)\n        cache.delete(key);\n        cache.set(key, cached);\n        return cached.value;\n      }\n      // Cache expired, remove it\n      cache.delete(key);\n    }\n\n    // Compute and cache the result\n    const value = fn(...args);\n\n    // Enforce cache size limit with LRU eviction\n    if (cache.size >= maxSize) {\n      // Remove least recently used (oldest insertion)\n      const firstKey = cache.keys().next().value;\n      if (firstKey) {\n        cache.delete(firstKey);\n      }\n    }\n\n    cache.set(key, {\n      value,\n      timestamp: Date.now(),\n    });\n\n    return value;\n  };\n\n  memoized.clear = () => {\n    cache.clear();\n  };\n\n  return memoized;\n}\n\n/**\n * Memoize a Result-returning function\n *\n * Caches both Ok and Err results separately.\n *\n * @param fn - Pure function returning Result<T, E>\n * @param options - Memoization options\n * @returns Memoized version of the function\n *\n * @example\n * ```typescript\n * const memoizedValidator = memoizeResult(\n *   (email: string) => validateEmail(email),\n *   {\n *     keyGenerator: (email) => email.toLowerCase(),\n *     ttl: 10 * 60 * 1000 // Cache for 10 minutes\n *   }\n * );\n *\n * const result1 = memoizedValidator('user@example.com'); // Validated and cached\n * const result2 = memoizedValidator('user@example.com'); // From cache\n * ```\n */\nexport function memoizeResult<T extends unknown[], R, E>(\n  fn: (...args: T) => Result<R, E>,\n  options?: {\n    keyGenerator?: KeyGenerator<T>;\n    ttl?: number;\n    maxSize?: number;\n  }\n): MemoizedFunction<T, Result<R, E>> {\n  return memoize(fn, options);\n}\n\n/**\n * Memoize an async Result-returning function\n *\n * Caches AsyncResult computations to avoid redundant async operations.\n *\n * @param fn - Function returning AsyncResult<T, E>\n * @param options - Memoization options\n * @returns Memoized version of the function\n *\n * @example\n * ```typescript\n * const memoizedFetch = memoizeAsync(\n *   async (userId: string) => authService.getUser(userId),\n *   {\n *     keyGenerator: (userId) => `user-${userId}`,\n *     ttl: 5 * 60 * 1000 // Cache for 5 minutes\n *   }\n * );\n *\n * const result1 = await memoizedFetch('user123'); // Fetched and cached\n * const result2 = await memoizedFetch('user123'); // From cache\n * ```\n */\nexport function memoizeAsync<T extends unknown[], R, E>(\n  fn: (...args: T) => AsyncResult<R, E> | Promise<Result<R, E>>,\n  options?: {\n    keyGenerator?: KeyGenerator<T>;\n    ttl?: number;\n    maxSize?: number;\n  }\n): MemoizedAsyncFunction<T, R, E> {\n  const cache = new Map<string, { value: Result<R, E>; timestamp: number }>();\n  const pending = new Map<string, Promise<Result<R, E>>>();\n  const {\n    keyGenerator = (...args: T) => JSON.stringify(args),\n    ttl = undefined,\n    maxSize = 128,\n  } = options ?? {};\n\n  const memoized = async (...args: T): Promise<Result<R, E>> => {\n    const key = keyGenerator(...args);\n    const cached = cache.get(key);\n\n    // Check if cache entry exists and is not expired\n    if (cached) {\n      if (!ttl || Date.now() - cached.timestamp < ttl) {\n        // Move to end for LRU (delete and re-add to update position)\n        cache.delete(key);\n        cache.set(key, cached);\n        return cached.value;\n      }\n      // Cache expired, remove it\n      cache.delete(key);\n    }\n\n    // Check if already pending\n    const pendingPromise = pending.get(key);\n    if (pendingPromise) {\n      return pendingPromise;\n    }\n\n    // Compute the result\n    const promise = Promise.resolve(fn(...args)).finally(() => {\n      pending.delete(key);\n    });\n    pending.set(key, promise);\n    const result = await promise;\n\n    // Enforce cache size limit with LRU eviction\n    if (cache.size >= maxSize) {\n      // Remove least recently used (oldest insertion)\n      const firstKey = cache.keys().next().value;\n      if (firstKey) {\n        cache.delete(firstKey);\n      }\n    }\n\n    cache.set(key, {\n      value: result,\n      timestamp: Date.now(),\n    });\n\n    return result;\n  };\n\n  memoized.clear = () => {\n    cache.clear();\n    pending.clear();\n  };\n\n  return memoized;\n}\n\n/**\n * Create a memoized version of a validation function\n *\n * Specialized memoization for validation functions that return Result types.\n * Only caches successful validations by default.\n *\n * @param validator - Validation function returning Result\n * @param options - Memoization options\n * @returns Memoized validation function\n *\n * @example\n * ```typescript\n * const memoizedEmailValidator = memoizeValidator(validateEmail, {\n *   cacheErrors: false, // Only cache successful validations\n *   ttl: 15 * 60 * 1000 // Cache for 15 minutes\n * });\n *\n * const result = memoizedEmailValidator('user@example.com');\n * ```\n */\nexport function memoizeValidator<T extends unknown[], R, E>(\n  validator: (...args: T) => Result<R, E>,\n  options?: {\n    keyGenerator?: KeyGenerator<T>;\n    ttl?: number;\n    maxSize?: number;\n    cacheErrors?: boolean;\n  }\n): MemoizedFunction<T, Result<R, E>> {\n  const cache = new Map<string, { value: Result<R, E>; timestamp: number }>();\n  const {\n    keyGenerator = (...args: T) => JSON.stringify(args),\n    ttl = 15 * 60 * 1000, // 15 minutes default\n    maxSize = 256,\n    cacheErrors = false,\n  } = options ?? {};\n\n  const memoized = (...args: T): Result<R, E> => {\n    const key = keyGenerator(...args);\n    const cached = cache.get(key);\n\n    // Check if cache entry exists and is not expired\n    if (cached) {\n      if (!ttl || Date.now() - cached.timestamp < ttl) {\n        // Move to end for LRU (delete and re-add to update position)\n        cache.delete(key);\n        cache.set(key, cached);\n        return cached.value;\n      }\n      cache.delete(key);\n    }\n\n    const result = validator(...args);\n\n    // Only cache if enabled or if result is Ok\n    if (cacheErrors || result.isOk()) {\n      // Enforce cache size limit with LRU eviction\n      if (cache.size >= maxSize) {\n        // Remove least recently used (oldest insertion)\n        const firstKey = cache.keys().next().value;\n        if (firstKey) {\n          cache.delete(firstKey);\n        }\n      }\n\n      cache.set(key, {\n        value: result,\n        timestamp: Date.now(),\n      });\n    }\n\n    return result;\n  };\n\n  memoized.clear = () => {\n    cache.clear();\n  };\n\n  return memoized;\n}\n\n/**\n * Debounce function to prevent excessive re-computations\n *\n * Delays function execution and cancels pending calls if new calls arrive.\n *\n * @param fn - Function to debounce\n * @param delay - Delay in milliseconds\n * @returns Debounced function\n *\n * @example\n * ```typescript\n * const debouncedSearch = debounce((query: string) => {\n *   return searchContacts(query);\n * }, 300);\n *\n * // Only the last call after 300ms of silence will execute\n * debouncedSearch('alice');\n * debouncedSearch('alice smith'); // Previous call cancelled\n * ```\n */\nexport function debounce<T extends unknown[], R>(\n  fn: (...args: T) => R,\n  delay: number\n): {\n  (...args: T): void;\n  cancel(): void;\n} {\n  let timeoutId: ReturnType<typeof setTimeout> | null = null;\n\n  const debounced = (...args: T) => {\n    if (timeoutId !== null) {\n      clearTimeout(timeoutId);\n    }\n\n    timeoutId = setTimeout(() => {\n      fn(...args);\n      timeoutId = null;\n    }, delay);\n  };\n\n  debounced.cancel = () => {\n    if (timeoutId !== null) {\n      clearTimeout(timeoutId);\n      timeoutId = null;\n    }\n  };\n\n  return debounced;\n}\n\n/**\n * Throttle function to limit execution frequency\n *\n * Ensures function executes at most once per specified interval.\n *\n * @param fn - Function to throttle\n * @param interval - Minimum interval between calls in milliseconds\n * @returns Throttled function\n *\n * @example\n * ```typescript\n * const throttledScroll = throttle(() => {\n *   updateScrollPosition();\n * }, 100);\n *\n * window.addEventListener('scroll', throttledScroll);\n * // updateScrollPosition called at most once per 100ms\n * ```\n */\nexport function throttle<T extends unknown[], R>(\n  fn: (...args: T) => R,\n  interval: number\n): (...args: T) => void {\n  let lastCallTime = 0;\n  let timeoutId: ReturnType<typeof setTimeout> | null = null;\n\n  return (...args: T) => {\n    const now = Date.now();\n    const timeSinceLastCall = now - lastCallTime;\n\n    if (timeSinceLastCall >= interval) {\n      // Execute immediately\n      lastCallTime = now;\n      fn(...args);\n\n      // Cancel pending execution\n      if (timeoutId !== null) {\n        clearTimeout(timeoutId);\n        timeoutId = null;\n      }\n    } else if (timeoutId === null) {\n      // Schedule execution for later\n      const remainingDelay = interval - timeSinceLastCall;\n      timeoutId = setTimeout(() => {\n        lastCallTime = Date.now();\n        fn(...args);\n        timeoutId = null;\n      }, remainingDelay);\n    }\n  };\n}\n\n/**\n * Clear all memoized results in batch\n *\n * Useful for cache invalidation strategies.\n *\n * @param memoizedFunctions - Array of memoized functions to clear\n *\n * @example\n * ```typescript\n * const memoizedValidators = [\n *   memoizeValidator(validateEmail),\n *   memoizeValidator(validatePhone)\n * ];\n *\n * // Clear all caches after user context changes\n * clearMemoizationCache(memoizedValidators);\n * ```\n */\nexport function clearMemoizationCache(memoizedFunctions: { clear?: () => void }[]): void {\n  memoizedFunctions.forEach(fn => {\n    if (typeof fn.clear === 'function') {\n      fn.clear();\n    }\n  });\n}\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/utils/parsing.ts",
        "messages": [
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'TenantId' is defined but never used. Allowed unused vars must match /^_/u.",
                "line": 15,
                "column": 15,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 15,
                "endColumn": 23
            },
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'UserId' is defined but never used. Allowed unused vars must match /^_/u.",
                "line": 15,
                "column": 25,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 15,
                "endColumn": 31
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 47,
                "column": 32,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 47,
                "endColumn": 40,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                1232,
                                1241
                            ],
                            "text": "(parts[1] == null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                1233,
                                1241
                            ],
                            "text": "(parts[1] ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                1232,
                                1241
                            ],
                            "text": "(!Boolean(parts[1]))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected any value in conditional. An explicit comparison or type conversion is required.",
                "line": 84,
                "column": 10,
                "nodeType": "Identifier",
                "messageId": "conditionErrorAny",
                "endLine": 84,
                "endColumn": 17,
                "suggestions": [
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                2495,
                                2502
                            ],
                            "text": "(Boolean(payload))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected any value in conditional. An explicit comparison or type conversion is required.",
                "line": 100,
                "column": 14,
                "nodeType": "Identifier",
                "messageId": "conditionErrorAny",
                "endLine": 100,
                "endColumn": 19,
                "suggestions": [
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                3055,
                                3060
                            ],
                            "text": "(Boolean(value))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, comparison is always true, since `\"number\" === \"number\"` is true.",
                "line": 103,
                "column": 18,
                "nodeType": "BinaryExpression",
                "messageId": "comparisonBetweenLiteralTypes",
                "endLine": 103,
                "endColumn": 35
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected any value in conditional. An explicit comparison or type conversion is required.",
                "line": 167,
                "column": 10,
                "nodeType": "Identifier",
                "messageId": "conditionErrorAny",
                "endLine": 167,
                "endColumn": 16,
                "suggestions": [
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                5003,
                                5009
                            ],
                            "text": "(Boolean(parsed))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected any value in conditional. An explicit comparison or type conversion is required.",
                "line": 236,
                "column": 10,
                "nodeType": "Identifier",
                "messageId": "conditionErrorAny",
                "endLine": 236,
                "endColumn": 16,
                "suggestions": [
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                7520,
                                7526
                            ],
                            "text": "(Boolean(parsed))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected any value in conditional. An explicit comparison or type conversion is required.",
                "line": 249,
                "column": 10,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorAny",
                "endLine": 249,
                "endColumn": 22,
                "suggestions": [
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                8047,
                                8059
                            ],
                            "text": "(Boolean(obj.settings))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected any value in conditional. An explicit comparison or type conversion is required.",
                "line": 252,
                "column": 10,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorAny",
                "endLine": 252,
                "endColumn": 26,
                "suggestions": [
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                8206,
                                8222
                            ],
                            "text": "(Boolean(obj.subscription))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 10,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "/**\n * JWT and Data Parsing Utilities\n *\n * Pure functions for parsing and validating JWT tokens and stored data.\n * All functions return Result types for type-safe error handling.\n *\n * @module parsing\n */\n\nimport { type Result, ok, err } from 'neverthrow';\nimport type { ParseError } from '../types/errors';\nimport { ParseErrors } from '../types/errors';\nimport type { User, Tenant } from '../types/auth';\nimport { asTenantId, asUserId } from '../types/ids';\nimport type { TenantId, UserId } from '../types/ids';\n\n/**\n * JWT Payload interface\n */\nexport interface JwtPayload {\n  user: string;\n  tenant_id: string;\n  exp: number;\n  iat?: number;\n  [key: string]: unknown;\n}\n\n/**\n * Decode and validate JWT payload\n *\n * @param token - The JWT token string\n * @returns Result containing decoded payload or ParseError\n *\n * @example\n * ```typescript\n * const result = decodeJwtPayload(token);\n * result.match(\n *   (payload) => console.log('User:', payload.user),\n *   (error) => console.log('Error:', formatParseError(error))\n * );\n * ```\n */\nexport const decodeJwtPayload = (token: string): Result<JwtPayload, ParseError> => {\n  try {\n    // Split token into parts\n    const parts = token.split('.');\n    if (parts.length !== 3 || !parts[1]) {\n      return err(ParseErrors.invalidJwtFormat(token));\n    }\n\n    // Decode base64 (handle URL-safe base64) using browser-native APIs\n    const base64 = parts[1].replace(/-/g, '+').replace(/_/g, '/');\n    // Add padding if needed\n    const padded = base64 + '='.repeat((4 - (base64.length % 4)) % 4);\n\n    // Use browser-native atob for base64 decoding\n    let binaryString: string;\n    try {\n      binaryString = atob(padded);\n    } catch (atobError) {\n      const reason = atobError instanceof Error ? atobError.message : 'Base64 decode failed';\n      return err(ParseErrors.invalidJson(token, reason));\n    }\n\n    // Convert binary string to Uint8Array\n    const uint8Array = new Uint8Array(binaryString.length);\n    for (let i = 0; i < binaryString.length; i++) {\n      uint8Array[i] = binaryString.charCodeAt(i);\n    }\n\n    // Decode UTF-8 using TextDecoder\n    const decoded = new TextDecoder('utf-8').decode(uint8Array);\n\n    // Parse JSON\n    let payload: unknown;\n    try {\n      payload = JSON.parse(decoded);\n    } catch (parseError) {\n      const reason = parseError instanceof Error ? parseError.message : 'JSON parse failed';\n      return err(ParseErrors.invalidJson(decoded, reason));\n    }\n\n    // Validate payload structure\n    if (!payload || typeof payload !== 'object') {\n      return err(ParseErrors.invalidJson(decoded, 'Payload is not an object'));\n    }\n\n    const payloadObj = payload as Record<string, unknown>;\n\n    // Helper to validate required fields\n    const validateRequiredField = (\n      obj: Record<string, unknown>,\n      field: string,\n      type: 'string' | 'number',\n      missingFields: string[]\n    ): void => {\n      const value = obj[field];\n      if (type === 'string') {\n        // For strings, check if missing, not a string, or empty after trimming\n        if (!value || typeof value !== 'string' || value.trim() === '') {\n          missingFields.push(field);\n        }\n      } else if (type === 'number') {\n        // For numbers, check if not a number type\n        if (typeof value !== 'number') {\n          missingFields.push(field);\n        }\n      }\n    };\n\n    // Check required fields using helper\n    const missingFields: string[] = [];\n    validateRequiredField(payloadObj, 'user', 'string', missingFields);\n    validateRequiredField(payloadObj, 'tenant_id', 'string', missingFields);\n    validateRequiredField(payloadObj, 'exp', 'number', missingFields);\n\n    if (missingFields.length > 0) {\n      return err(ParseErrors.missingJwtFields(missingFields));\n    }\n\n    return ok(payloadObj as JwtPayload);\n  } catch (error) {\n    const reason = error instanceof Error ? error.message : 'Unknown decode error';\n    return err(ParseErrors.invalidJson(token, reason));\n  }\n};\n\n/**\n * Check if JWT token is expired\n *\n * @param payload - The decoded JWT payload\n * @param nowSeconds - Current time in seconds (defaults to now)\n * @returns Result containing void if valid, or ParseError if expired\n */\nexport const checkTokenExpiry = (\n  payload: JwtPayload,\n  nowSeconds?: number\n): Result<void, ParseError> => {\n  const now = nowSeconds ?? Math.floor(Date.now() / 1000);\n\n  if (payload.exp < now) {\n    return err(ParseErrors.expiredToken(payload.exp, now));\n  }\n\n  return ok(undefined);\n};\n\n/**\n * Parse and validate stored User data\n *\n * @param raw - Raw JSON string from storage\n * @returns Result containing parsed User or ParseError\n *\n * @example\n * ```typescript\n * const result = parseStoredUser(storedData);\n * result.match(\n *   (user) => console.log('User:', user.username),\n *   (error) => console.log('Error:', formatParseError(error))\n * );\n * ```\n */\nexport const parseStoredUser = (raw: string): Result<User, ParseError> => {\n  try {\n    const parsed: unknown = JSON.parse(raw);\n\n    if (!parsed || typeof parsed !== 'object') {\n      return err(ParseErrors.invalidUserStructure('Parsed value is not an object'));\n    }\n\n    const obj = parsed as Record<string, unknown>;\n\n    // Validate required fields\n    if (typeof obj.id !== 'string' || obj.id.trim() === '') {\n      return err(ParseErrors.invalidUserStructure('Missing or invalid id'));\n    }\n    if (typeof obj.email !== 'string' || obj.email.trim() === '') {\n      return err(ParseErrors.invalidUserStructure('Missing or invalid email'));\n    }\n    if (typeof obj.username !== 'string' || obj.username.trim() === '') {\n      return err(ParseErrors.invalidUserStructure('Missing or invalid username'));\n    }\n    if (!Array.isArray(obj.roles) || !obj.roles.every(role => typeof role === 'string')) {\n      return err(ParseErrors.invalidUserStructure('Missing or invalid roles array'));\n    }\n    if (typeof obj.tenantId !== 'string' || obj.tenantId.trim() === '') {\n      return err(ParseErrors.invalidUserStructure('Missing or invalid tenantId'));\n    }\n    if (typeof obj.createdAt !== 'string') {\n      return err(ParseErrors.invalidUserStructure('Missing or invalid createdAt'));\n    }\n    if (typeof obj.updatedAt !== 'string') {\n      return err(ParseErrors.invalidUserStructure('Missing or invalid updatedAt'));\n    }\n\n    // Construct validated User object\n    const user: User = {\n      id: asUserId(obj.id),\n      email: obj.email,\n      username: obj.username,\n      firstName: typeof obj.firstName === 'string' ? obj.firstName : undefined,\n      lastName: typeof obj.lastName === 'string' ? obj.lastName : undefined,\n      avatar: typeof obj.avatar === 'string' ? obj.avatar : undefined,\n      roles: obj.roles,\n      tenantId: asTenantId(obj.tenantId),\n      createdAt: obj.createdAt,\n      updatedAt: obj.updatedAt,\n    };\n\n    return ok(user);\n  } catch (error) {\n    const reason = error instanceof Error ? error.message : 'JSON parse failed';\n    return err(ParseErrors.invalidJson(raw, reason));\n  }\n};\n\n/**\n * Parse and validate stored Tenant data\n *\n * @param raw - Raw JSON string from storage\n * @returns Result containing parsed Tenant or ParseError\n *\n * @example\n * ```typescript\n * const result = parseStoredTenant(storedData);\n * result.match(\n *   (tenant) => console.log('Tenant:', tenant.name),\n *   (error) => console.log('Error:', formatParseError(error))\n * );\n * ```\n */\nexport const parseStoredTenant = (raw: string): Result<Tenant, ParseError> => {\n  try {\n    const parsed: unknown = JSON.parse(raw);\n\n    if (!parsed || typeof parsed !== 'object') {\n      return err(ParseErrors.invalidTenantStructure('Parsed value is not an object'));\n    }\n\n    const obj = parsed as Record<string, unknown>;\n\n    // Validate required fields\n    if (typeof obj.id !== 'string' || obj.id.trim() === '') {\n      return err(ParseErrors.invalidTenantStructure('Missing or invalid id'));\n    }\n    if (typeof obj.name !== 'string' || obj.name.trim() === '') {\n      return err(ParseErrors.invalidTenantStructure('Missing or invalid name'));\n    }\n    if (!obj.settings || typeof obj.settings !== 'object') {\n      return err(ParseErrors.invalidTenantStructure('Missing or invalid settings object'));\n    }\n    if (!obj.subscription || typeof obj.subscription !== 'object') {\n      return err(ParseErrors.invalidTenantStructure('Missing or invalid subscription object'));\n    }\n\n    // Construct validated Tenant object\n    const tenant: Tenant = {\n      id: asTenantId(obj.id),\n      name: obj.name,\n      domain: typeof obj.domain === 'string' ? obj.domain : undefined,\n      logo: typeof obj.logo === 'string' ? obj.logo : undefined,\n      settings: obj.settings as Tenant['settings'],\n      subscription: obj.subscription as Tenant['subscription'],\n    };\n\n    return ok(tenant);\n  } catch (error) {\n    const reason = error instanceof Error ? error.message : 'JSON parse failed';\n    return err(ParseErrors.invalidJson(raw, reason));\n  }\n};\n\n/**\n * Update User with data from JWT payload\n *\n * Ensures that user data matches the JWT token claims\n *\n * @param user - The user object to update\n * @param payload - The JWT payload\n * @returns Updated user object\n */\nexport const updateUserFromJwt = (user: User, payload: JwtPayload): User => {\n  return {\n    ...user,\n    username: payload.user,\n    tenantId: asTenantId(payload.tenant_id),\n  };\n};\n\n/**\n * Update Tenant with data from JWT payload\n *\n * Ensures that tenant data matches the JWT token claims\n *\n * @param tenant - The tenant object to update\n * @param payload - The JWT payload\n * @returns Updated tenant object\n */\nexport const updateTenantFromJwt = (tenant: Tenant, payload: JwtPayload): Tenant => {\n  return {\n    ...tenant,\n    id: asTenantId(payload.tenant_id),\n  };\n};\n\n/**\n * Verify that user and tenant match JWT payload\n *\n * @param user - The user object\n * @param tenant - The tenant object\n * @param payload - The JWT payload\n * @returns Result containing void if valid, or ParseError if mismatch\n */\nexport const verifyDataMatchesToken = (\n  user: User,\n  tenant: Tenant,\n  payload: JwtPayload\n): Result<void, ParseError> => {\n  if (user.username !== payload.user) {\n    return err(\n      ParseErrors.invalidUserStructure(\n        `Username mismatch: token has '${payload.user}', user has '${user.username}'`\n      )\n    );\n  }\n\n  // Compare branded TenantId as strings\n  if (String(tenant.id) !== payload.tenant_id) {\n    return err(\n      ParseErrors.invalidTenantStructure(\n        `Tenant ID mismatch: token has '${payload.tenant_id}', tenant has '${tenant.id}'`\n      )\n    );\n  }\n\n  return ok(undefined);\n};\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/utils/reactMemoization.tsx",
        "messages": [],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 0,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/utils/uniqueId.ts",
        "messages": [
            {
                "ruleId": "@typescript-eslint/no-unnecessary-condition",
                "severity": 1,
                "message": "Unnecessary conditional, value is always truthy.",
                "line": 19,
                "column": 42,
                "nodeType": "MemberExpression",
                "messageId": "alwaysTruthy",
                "endLine": 19,
                "endColumn": 59
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected object value in conditional. The condition is always true.",
                "line": 19,
                "column": 42,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorObject",
                "endLine": 19,
                "endColumn": 59
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 2,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "/**\n * Robust unique ID generator with multiple fallback strategies\n *\n * This utility provides a reliable way to generate unique IDs that:\n * - Uses crypto.randomUUID() when available (modern browsers)\n * - Falls back to a local incrementing counter with timestamp\n * - Ensures no collisions even with rapid successive calls\n */\n\n/**\n * Creates a unique ID generator with fallback strategies\n * @returns A function that generates unique IDs\n */\nexport const createUniqueIdGenerator = () => {\n  let counter = 0;\n\n  return (): string => {\n    // Primary: Use crypto.randomUUID() if available (modern browsers)\n    if (typeof crypto !== 'undefined' && crypto.randomUUID) {\n      return crypto.randomUUID();\n    }\n\n    // Fallback: Combine timestamp with incrementing counter\n    // This ensures uniqueness even with rapid successive calls\n    const timestamp = Date.now();\n    const increment = ++counter;\n\n    // Use a combination that's highly unlikely to collide\n    return `${timestamp.toString()}-${increment.toString()}-${Math.random().toString(36).substring(2, 15)}`;\n  };\n};\n\n/**\n * Global unique ID generator instance\n * Use this for most cases where you need unique IDs\n */\nexport const generateUniqueId = createUniqueIdGenerator();\n\n/**\n * Creates a scoped unique ID generator with a prefix\n * Useful when you need IDs for specific contexts (e.g., \"filter-\", \"component-\")\n * @param prefix - The prefix to use for generated IDs\n * @returns A function that generates unique IDs with the given prefix\n */\nexport const createScopedIdGenerator = (prefix: string) => {\n  const generator = createUniqueIdGenerator();\n\n  return (): string => {\n    return `${prefix}${generator()}`;\n  };\n};\n\n/**\n * Test function to verify unique ID generation\n * @param count - Number of IDs to generate for testing\n * @returns Array of generated IDs\n */\nexport const testUniqueIdGeneration = (count = 1000): string[] => {\n  const ids = new Set<string>();\n  const generator = createUniqueIdGenerator();\n\n  for (let i = 0; i < count; i++) {\n    const id = generator();\n    if (ids.has(id)) {\n      throw new Error(`Collision detected at iteration ${i.toString()}: ${id}`);\n    }\n    ids.add(id);\n  }\n\n  return Array.from(ids);\n};\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/utils/validation.ts",
        "messages": [
            {
                "ruleId": "@typescript-eslint/no-unused-vars",
                "severity": 1,
                "message": "'formatCredentialValidationError' is defined but never used. Allowed unused vars must match /^_/u.",
                "line": 12,
                "column": 28,
                "nodeType": null,
                "messageId": "unusedVar",
                "endLine": 12,
                "endColumn": 59
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected value in conditional. A boolean expression is required.",
                "line": 270,
                "column": 11,
                "nodeType": "Identifier",
                "messageId": "conditionErrorOther",
                "endLine": 270,
                "endColumn": 19
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 2,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "/**\n * Validation Utilities for Credentials\n *\n * Pure functions for validating user input using Result types.\n * All validation functions return Result<T, ValidationError> for type-safe error handling.\n *\n * @module validation\n */\n\nimport { type Result, ok, err } from 'neverthrow';\nimport type { CredentialValidationError } from '../types/errors';\nimport { ValidationErrors, formatCredentialValidationError } from '../types/errors';\nimport type { TenantId } from '../types/ids';\n\n// Re-export for convenience\nexport type { CredentialValidationError } from '../types/errors';\nexport { formatCredentialValidationError } from '../types/errors';\n\n/**\n * Username validation constants\n */\nconst USERNAME_MIN_LENGTH = 3;\nconst USERNAME_MAX_LENGTH = 50;\nconst USERNAME_PATTERN = /^[a-zA-Z0-9_.-]+$/;\n\n/**\n * Password validation constants\n */\nconst PASSWORD_MIN_LENGTH = 8;\nconst PASSWORD_REQUIREMENTS = [\n  'At least one uppercase letter',\n  'At least one lowercase letter',\n  'At least one number',\n];\n\n/**\n * Tenant ID validation pattern\n */\nconst TENANT_ID_PATTERN = /^[a-zA-Z0-9_-]+$/;\n\n/**\n * Email validation pattern (RFC 5322 simplified)\n */\nconst EMAIL_PATTERN = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/;\n\n/**\n * Validated username type (branded type)\n */\nexport type ValidatedUsername = string & { readonly __brand: 'ValidatedUsername' };\n\n/**\n * Validated password type (branded type)\n */\nexport type ValidatedPassword = string & { readonly __brand: 'ValidatedPassword' };\n\n/**\n * Validated email type (branded type)\n */\nexport type ValidatedEmail = string & { readonly __brand: 'ValidatedEmail' };\n\n/**\n * Validate username\n *\n * Rules:\n * - Cannot be empty\n * - Must be between 3-50 characters\n * - Can only contain alphanumeric characters, underscores, dots, and hyphens\n *\n * @param username - The username to validate\n * @returns Result containing validated username or validation error\n *\n * @example\n * ```typescript\n * const result = validateUsername('john_doe');\n * result.match(\n *   (username) => console.log('Valid:', username),\n *   (error) => console.log('Invalid:', formatCredentialValidationError(error))\n * );\n * ```\n */\nexport const validateUsername = (\n  username: string | null | undefined\n): Result<ValidatedUsername, CredentialValidationError> => {\n  if (username === undefined || username === null) {\n    return err(ValidationErrors.emptyUsername());\n  }\n\n  const trimmedInput = username.trim();\n\n  if (trimmedInput.length === 0) {\n    return err(ValidationErrors.emptyUsername());\n  }\n\n  // Check minimum length\n  if (trimmedInput.length < USERNAME_MIN_LENGTH) {\n    return err(ValidationErrors.usernameTooShort(USERNAME_MIN_LENGTH, trimmedInput.length));\n  }\n\n  // Check maximum length\n  if (trimmedInput.length > USERNAME_MAX_LENGTH) {\n    return err(ValidationErrors.usernameTooLong(USERNAME_MAX_LENGTH, trimmedInput.length));\n  }\n\n  // Check format\n  if (!USERNAME_PATTERN.test(trimmedInput)) {\n    return err(ValidationErrors.invalidUsernameFormat(USERNAME_PATTERN.source));\n  }\n\n  return ok(trimmedInput as ValidatedUsername);\n};\n\n/**\n * Validate password\n *\n * Rules:\n * - Cannot be empty\n * - Must be at least 8 characters\n * - Must contain at least one uppercase letter, one lowercase letter, and one number\n *\n * @param password - The password to validate\n * @returns Result containing validated password or validation error\n *\n * @example\n * ```typescript\n * const result = validatePassword('MyP@ssw0rd');\n * result.match(\n *   (password) => console.log('Valid password'),\n *   (error) => console.log('Invalid:', formatCredentialValidationError(error))\n * );\n * ```\n */\nexport const validatePassword = (\n  password: string | null | undefined\n): Result<ValidatedPassword, CredentialValidationError> => {\n  if (password === undefined || password === null) {\n    return err(ValidationErrors.emptyPassword());\n  }\n\n  if (password.length === 0) {\n    return err(ValidationErrors.emptyPassword());\n  }\n\n  // Check minimum length\n  if (password.length < PASSWORD_MIN_LENGTH) {\n    return err(ValidationErrors.passwordTooShort(PASSWORD_MIN_LENGTH, password.length));\n  }\n\n  // Check password strength\n  const hasUpperCase = /[A-Z]/.test(password);\n  const hasLowerCase = /[a-z]/.test(password);\n  const hasNumber = /[0-9]/.test(password);\n\n  const missingRequirements: string[] = [];\n  if (!hasUpperCase) missingRequirements.push(PASSWORD_REQUIREMENTS[0] ?? 'uppercase');\n  if (!hasLowerCase) missingRequirements.push(PASSWORD_REQUIREMENTS[1] ?? 'lowercase');\n  if (!hasNumber) missingRequirements.push(PASSWORD_REQUIREMENTS[2] ?? 'number');\n\n  if (missingRequirements.length > 0) {\n    return err(ValidationErrors.passwordTooWeak(missingRequirements));\n  }\n\n  return ok(password as ValidatedPassword);\n};\n\n/**\n * Validate tenant ID\n *\n * Rules:\n * - Cannot be empty\n * - Can only contain alphanumeric characters, underscores, and hyphens\n *\n * @param tenantId - The tenant ID to validate\n * @returns Result containing validated tenant ID or validation error\n *\n * @example\n * ```typescript\n * const result = validateTenantId('tenant1');\n * result.match(\n *   (tenantId) => console.log('Valid:', tenantId),\n *   (error) => console.log('Invalid:', formatCredentialValidationError(error))\n * );\n * ```\n */\nexport const validateTenantId = (\n  tenantId: string | TenantId\n): Result<TenantId, CredentialValidationError> => {\n  const id = String(tenantId);\n\n  // Check if empty\n  if (id.trim().length === 0) {\n    return err(ValidationErrors.emptyTenantId());\n  }\n\n  const trimmed = id.trim();\n\n  // Check format\n  if (!TENANT_ID_PATTERN.test(trimmed)) {\n    return err(ValidationErrors.invalidTenantIdFormat(TENANT_ID_PATTERN.source));\n  }\n\n  return ok(trimmed as TenantId);\n};\n\n/**\n * Validate email address\n *\n * Rules:\n * - Must match standard email format (RFC 5322 simplified)\n *\n * @param email - The email address to validate\n * @returns Result containing validated email or validation error\n *\n * @example\n * ```typescript\n * const result = validateEmail('user@example.com');\n * result.match(\n *   (email) => console.log('Valid:', email),\n *   (error) => console.log('Invalid:', formatCredentialValidationError(error))\n * );\n * ```\n */\nexport const validateEmail = (email: string): Result<ValidatedEmail, CredentialValidationError> => {\n  const trimmed = email.trim();\n\n  // Check format\n  if (!EMAIL_PATTERN.test(trimmed)) {\n    return err(ValidationErrors.invalidEmailFormat(trimmed));\n  }\n\n  return ok(trimmed as ValidatedEmail);\n};\n\n/**\n * Validate all login credentials at once\n *\n * Uses railway-oriented programming to validate all fields and return\n * the first validation error encountered, or all validated values.\n *\n * @param username - The username to validate\n * @param password - The password to validate\n * @param tenantId - The tenant ID to validate (optional)\n * @returns Result containing validated credentials or validation error\n *\n * @example\n * ```typescript\n * const result = validateLoginCredentials('john_doe', 'MyP@ssw0rd', 'tenant1');\n * result.match(\n *   ({ username, password, tenantId }) => console.log('All valid'),\n *   (error) => console.log('Validation failed:', formatCredentialValidationError(error))\n * );\n * ```\n */\nexport const validateLoginCredentials = (\n  username: string,\n  password: string,\n  tenantId?: string | TenantId\n): Result<\n  {\n    username: ValidatedUsername;\n    password: ValidatedPassword;\n    tenantId?: TenantId;\n  },\n  CredentialValidationError\n> => {\n  // Validate username first\n  return validateUsername(username).andThen(validatedUsername =>\n    // Then validate password\n    validatePassword(password).andThen(validatedPassword => {\n      // If tenant ID provided, validate it too\n      if (tenantId) {\n        return validateTenantId(tenantId).map(validatedTenantId => ({\n          username: validatedUsername,\n          password: validatedPassword,\n          tenantId: validatedTenantId,\n        }));\n      }\n\n      // No tenant ID to validate\n      return ok({\n        username: validatedUsername,\n        password: validatedPassword,\n      });\n    })\n  );\n};\n\n/**\n * Validate optional field (returns Ok(undefined) if empty, validates if present)\n *\n * @param value - The optional value to validate\n * @param validator - The validation function to use\n * @returns Result containing validated value, undefined, or validation error\n *\n * @example\n * ```typescript\n * const result = validateOptional(maybeEmail, validateEmail);\n * ```\n */\nexport const validateOptional = <T, E>(\n  value: string | undefined | null,\n  validator: (v: string) => Result<T, E>\n): Result<T | undefined, E> => {\n  // Explicit emptiness check: returns Ok(undefined) for null, undefined, or empty/whitespace-only strings\n  if (\n    value === undefined ||\n    value === null ||\n    (typeof value === 'string' && value.trim().length === 0)\n  ) {\n    return ok(undefined);\n  }\n  return validator(value);\n};\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/validation/__tests__/helpers.test.ts",
        "messages": [],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 0,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/validation/__tests__/schemas.test.ts",
        "messages": [
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 687,
                "column": 11,
                "nodeType": "Property",
                "messageId": "anyAssignment",
                "endLine": 687,
                "endColumn": 52
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 687,
                "column": 49,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 687,
                "endColumn": 52,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                19632,
                                19635
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                19632,
                                19635
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 694,
                "column": 11,
                "nodeType": "Property",
                "messageId": "anyAssignment",
                "endLine": 694,
                "endColumn": 49
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 694,
                "column": 46,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 694,
                "endColumn": 49,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                19853,
                                19856
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                19853,
                                19856
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 730,
                "column": 11,
                "nodeType": "Property",
                "messageId": "anyAssignment",
                "endLine": 734,
                "endColumn": 19
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 734,
                "column": 16,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 734,
                "endColumn": 19,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                21095,
                                21098
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                21095,
                                21098
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 777,
                "column": 11,
                "nodeType": "Property",
                "messageId": "anyAssignment",
                "endLine": 780,
                "endColumn": 19
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 780,
                "column": 16,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 780,
                "endColumn": 19,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                22446,
                                22449
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                22446,
                                22449
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 910,
                "column": 48,
                "nodeType": "Property",
                "messageId": "anyAssignment",
                "endLine": 910,
                "endColumn": 72
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 910,
                "column": 69,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 910,
                "endColumn": 72,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                26763,
                                26766
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                26763,
                                26766
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 914,
                "column": 49,
                "nodeType": "Property",
                "messageId": "anyAssignment",
                "endLine": 914,
                "endColumn": 70
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 914,
                "column": 67,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 914,
                "endColumn": 70,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                26938,
                                26941
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                26938,
                                26941
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 930,
                "column": 48,
                "nodeType": "Property",
                "messageId": "anyAssignment",
                "endLine": 930,
                "endColumn": 66
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 930,
                "column": 63,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 930,
                "endColumn": 66,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                27592,
                                27595
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                27592,
                                27595
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 934,
                "column": 49,
                "nodeType": "Property",
                "messageId": "anyAssignment",
                "endLine": 934,
                "endColumn": 72
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 934,
                "column": 69,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 934,
                "endColumn": 72,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                27769,
                                27772
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                27769,
                                27772
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 16,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "import { describe, it, expect } from 'bun:test';\nimport {\n  authTenantSchema,\n  userSchema,\n  contactSchema,\n  contactListResponseSchema,\n  tenantSchema,\n  paginatedTenantResponseSchema,\n  apiErrorSchema,\n  authResponseSchema,\n  loginRequestSchema,\n  createTenantSchema,\n  updateTenantSchema,\n  contactMutationSchema,\n} from '../schemas';\n\ndescribe('validation schemas', () => {\n  describe('authTenantSchema', () => {\n    it('should validate a valid auth tenant', () => {\n      const validTenant = {\n        id: 'tenant-1',\n        name: 'Test Tenant',\n        domain: 'test.com',\n        logo: 'logo.png',\n        settings: {\n          theme: 'light' as const,\n          language: 'en',\n          timezone: 'UTC',\n          dateFormat: 'YYYY-MM-DD',\n          features: ['contacts'],\n          branding: {\n            primaryColor: '#1890ff',\n            secondaryColor: '#52c41a',\n            accentColor: '#faad14',\n          },\n        },\n        subscription: {\n          plan: 'professional' as const,\n          status: 'active' as const,\n          limits: {\n            users: 25,\n            contacts: 10000,\n            storage: 10737418240,\n          },\n        },\n      };\n\n      const result = authTenantSchema.safeParse(validTenant);\n      expect(result.success).toBe(true);\n    });\n\n    it('should reject invalid auth tenant', () => {\n      const invalidTenant = {\n        id: '',\n        name: '',\n        settings: {\n          theme: 'invalid',\n          language: '',\n          timezone: '',\n          dateFormat: '',\n          features: [],\n          branding: {\n            primaryColor: '',\n            secondaryColor: '',\n            accentColor: '',\n          },\n        },\n        subscription: {\n          plan: 'invalid',\n          status: 'invalid',\n          limits: {\n            users: -1,\n            contacts: -1,\n            storage: -1,\n          },\n        },\n      };\n\n      const result = authTenantSchema.safeParse(invalidTenant);\n      expect(result.success).toBe(false);\n    });\n  });\n\n  describe('userSchema', () => {\n    it('should validate a valid user', () => {\n      const validUser = {\n        id: 'user-1',\n        email: 'test@example.com',\n        username: 'testuser',\n        firstName: 'Test',\n        lastName: 'User',\n        avatar: 'avatar.png',\n        roles: ['user'],\n        tenantId: 'tenant-1',\n        createdAt: '2023-01-01T00:00:00Z',\n        updatedAt: '2023-01-01T00:00:00Z',\n      };\n\n      const result = userSchema.safeParse(validUser);\n      expect(result.success).toBe(true);\n    });\n\n    it('should reject invalid user', () => {\n      const invalidUser = {\n        id: '',\n        email: 'invalid-email',\n        username: '',\n        roles: [],\n        tenantId: '',\n        createdAt: '',\n        updatedAt: '',\n      };\n\n      const result = userSchema.safeParse(invalidUser);\n      expect(result.success).toBe(false);\n    });\n  });\n\n  describe('contactSchema', () => {\n    it('should validate a valid contact', () => {\n      const validContact = {\n        id: 'contact-1',\n        tenantId: 'tenant-1',\n        firstName: 'John',\n        lastName: 'Doe',\n        fullName: 'John Doe',\n        preferredName: 'Johnny',\n        title: 'Mr',\n        suffix: 'Jr',\n        email: 'john@example.com',\n        phone: '+1234567890',\n        mobile: '+1234567891',\n        fax: '+1234567892',\n        website: 'https://example.com',\n        address: {\n          street1: '123 Main St',\n          street2: 'Apt 4B',\n          city: 'Anytown',\n          state: 'CA',\n          zipCode: '12345',\n          country: 'USA',\n          latitude: 37.7749,\n          longitude: -122.4194,\n        },\n        shippingAddress: {\n          street1: '456 Oak St',\n          city: 'Anytown',\n          state: 'CA',\n          zipCode: '12345',\n          country: 'USA',\n        },\n        company: 'Example Corp',\n        jobTitle: 'Developer',\n        department: 'Engineering',\n        dateOfBirth: '1990-01-01',\n        gender: 'male' as const,\n        age: 33,\n        allergies: ['peanuts'],\n        medications: ['aspirin'],\n        medicalNotes: 'Some notes',\n        emergencyContact: {\n          name: 'Jane Doe',\n          relationship: 'wife',\n          phone: '+1234567893',\n          email: 'jane@example.com',\n        },\n        notes: 'Some notes',\n        tags: ['vip', 'developer'],\n        customFields: { custom1: 'value1' },\n        createdAt: '2023-01-01T00:00:00Z',\n        updatedAt: '2023-01-01T00:00:00Z',\n        createdBy: 'user-1',\n        updatedBy: 'user-1',\n        isActive: true,\n      };\n\n      const result = contactSchema.safeParse(validContact);\n      expect(result.success).toBe(true);\n    });\n\n    it('should reject invalid contact', () => {\n      const invalidContact = {\n        id: '',\n        tenantId: '',\n        firstName: '',\n        lastName: '',\n        fullName: '',\n        email: 'invalid-email',\n        createdAt: '2023-01-01T00:00:00Z',\n        updatedAt: '2023-01-01T00:00:00Z',\n        createdBy: '',\n        updatedBy: '',\n        isActive: true,\n      };\n\n      const result = contactSchema.safeParse(invalidContact);\n      expect(result.success).toBe(false);\n    });\n  });\n\n  describe('contactListResponseSchema', () => {\n    it('should validate a valid contact list response', () => {\n      const validResponse = {\n        contacts: [\n          {\n            id: 'contact-1',\n            tenantId: 'tenant-1',\n            firstName: 'John',\n            lastName: 'Doe',\n            fullName: 'John Doe',\n            email: 'john@example.com',\n            roles: ['user'],\n            createdAt: '2023-01-01T00:00:00Z',\n            updatedAt: '2023-01-01T00:00:00Z',\n            createdBy: 'user-1',\n            updatedBy: 'user-1',\n            isActive: true,\n          },\n        ],\n        total: 1,\n        page: 0,\n        limit: 10,\n        totalPages: 1,\n        hasNext: false,\n        hasPrev: false,\n      };\n\n      const result = contactListResponseSchema.safeParse(validResponse);\n      expect(result.success).toBe(true);\n    });\n\n    it('should reject invalid contact list response', () => {\n      const invalidResponse = {\n        contacts: [],\n        total: -1,\n        page: -1,\n        limit: 0,\n        totalPages: -1,\n        hasNext: 'not-boolean',\n        hasPrev: 'not-boolean',\n      };\n\n      const result = contactListResponseSchema.safeParse(invalidResponse);\n      expect(result.success).toBe(false);\n    });\n  });\n\n  describe('tenantSchema', () => {\n    it('should validate a valid tenant', () => {\n      const validTenant = {\n        id: 'tenant-1',\n        name: 'Test Tenant',\n        db_url: 'postgresql://user:pass@localhost:5432/tenant1',\n        created_at: '2023-01-01T00:00:00Z',\n        updated_at: '2023-01-01T00:00:00Z',\n      };\n\n      const result = tenantSchema.safeParse(validTenant);\n      expect(result.success).toBe(true);\n    });\n\n    it('should reject invalid tenant', () => {\n      const invalidTenant = {\n        id: '',\n        name: '',\n        db_url: 'invalid-url',\n        created_at: '',\n        updated_at: '',\n      };\n\n      const result = tenantSchema.safeParse(invalidTenant);\n      expect(result.success).toBe(false);\n    });\n  });\n\n  describe('paginatedTenantResponseSchema', () => {\n    it('should validate a valid paginated tenant response', () => {\n      const validResponse = {\n        data: [\n          {\n            id: 'tenant-1',\n            name: 'Test Tenant',\n            db_url: 'postgresql://user:pass@localhost:5432/tenant1',\n            created_at: '2023-01-01T00:00:00Z',\n            updated_at: '2023-01-01T00:00:00Z',\n          },\n        ],\n        total: 1,\n        offset: 0,\n        limit: 10,\n      };\n\n      const result = paginatedTenantResponseSchema.safeParse(validResponse);\n      expect(result.success).toBe(true);\n    });\n\n    it('should reject invalid paginated tenant response', () => {\n      const invalidResponse = {\n        data: [],\n        total: -1,\n        offset: -1,\n        limit: 0,\n      };\n\n      const result = paginatedTenantResponseSchema.safeParse(invalidResponse);\n      expect(result.success).toBe(false);\n    });\n  });\n\n  describe('apiErrorSchema', () => {\n    it('should validate a valid API error', () => {\n      const validError = {\n        type: 'validation' as const,\n        message: 'Validation failed',\n        code: 'VALIDATION_ERROR',\n        details: { field: 'email', error: 'Invalid format' },\n        cause: new Error('Test error'),\n        retryable: false,\n        statusCode: 400,\n      };\n\n      const result = apiErrorSchema.safeParse(validError);\n      expect(result.success).toBe(true);\n    });\n\n    it('should reject invalid API error', () => {\n      const invalidError = {\n        type: 'invalid-type',\n        message: '',\n      };\n\n      const result = apiErrorSchema.safeParse(invalidError);\n      expect(result.success).toBe(false);\n    });\n  });\n\n  describe('authResponseSchema', () => {\n    it('should validate a valid auth response', () => {\n      const validResponse = {\n        access_token: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...',\n        refresh_token: 'refresh-token-123',\n        token_type: 'Bearer',\n      };\n\n      const result = authResponseSchema.safeParse(validResponse);\n      expect(result.success).toBe(true);\n    });\n\n    it('should reject invalid auth response', () => {\n      const invalidResponse = {\n        access_token: '',\n        refresh_token: '',\n        token_type: '',\n      };\n\n      const result = authResponseSchema.safeParse(invalidResponse);\n      expect(result.success).toBe(false);\n    });\n  });\n\n  describe('loginRequestSchema', () => {\n    it('should validate a valid login request', () => {\n      const validRequest = {\n        usernameOrEmail: 'test@example.com',\n        password: 'password123',\n        tenantId: 'tenant-1',\n        rememberMe: true,\n      };\n\n      const result = loginRequestSchema.safeParse(validRequest);\n      expect(result.success).toBe(true);\n    });\n\n    it('should reject invalid login request', () => {\n      const invalidRequest = {\n        usernameOrEmail: '',\n        password: '',\n        tenantId: '',\n      };\n\n      const result = loginRequestSchema.safeParse(invalidRequest);\n      expect(result.success).toBe(false);\n    });\n  });\n\n  describe('createTenantSchema', () => {\n    it('should validate a valid create tenant request', () => {\n      const validRequest = {\n        name: 'New Tenant',\n        db_url: 'postgresql://user:pass@localhost:5432/newtenant',\n      };\n\n      const result = createTenantSchema.safeParse(validRequest);\n      expect(result.success).toBe(true);\n    });\n\n    it('should reject invalid create tenant request', () => {\n      const invalidRequest = {\n        name: '',\n        db_url: 'invalid-url',\n      };\n\n      const result = createTenantSchema.safeParse(invalidRequest);\n      expect(result.success).toBe(false);\n    });\n  });\n\n  describe('updateTenantSchema', () => {\n    it('should validate a valid update tenant request', () => {\n      const validRequest = {\n        name: 'Updated Tenant',\n        db_url: 'postgresql://user:pass@localhost:5432/updated',\n      };\n\n      const result = updateTenantSchema.safeParse(validRequest);\n      expect(result.success).toBe(true);\n    });\n\n    it('should allow partial updates', () => {\n      const partialRequest = {\n        name: 'Updated Name',\n      };\n\n      const result = updateTenantSchema.safeParse(partialRequest);\n      expect(result.success).toBe(true);\n    });\n  });\n\n  describe('contactMutationSchema', () => {\n    it('should validate a valid contact mutation', () => {\n      const validMutation = {\n        name: 'John Doe',\n        email: 'john@example.com',\n        gender: true,\n        age: 30,\n        address: '123 Main St',\n        phone: '+1234567890',\n      };\n\n      const result = contactMutationSchema.safeParse(validMutation);\n      expect(result.success).toBe(true);\n    });\n\n    it('should reject invalid contact mutation', () => {\n      const invalidMutation = {\n        name: '',\n        email: 'invalid-email',\n        gender: 'not-boolean',\n        age: -1,\n        address: '',\n        phone: '',\n      };\n\n      const result = contactMutationSchema.safeParse(invalidMutation);\n      expect(result.success).toBe(false);\n    });\n  });\n\n  describe('contactSchema edge cases', () => {\n    const validContactBase = {\n      id: 'contact-1',\n      tenantId: 'tenant-1',\n      firstName: 'John',\n      lastName: 'Doe',\n      fullName: 'John Doe',\n      createdAt: '2025-01-01T00:00:00Z',\n      updatedAt: '2025-01-01T00:00:00Z',\n      createdBy: 'user-1',\n      updatedBy: 'user-1',\n      isActive: true,\n    };\n\n    describe('numeric boundaries (age, limits, coordinates)', () => {\n      it('should accept valid age boundaries', () => {\n        const contact = { ...validContactBase, age: 0 };\n        const result = contactSchema.safeParse(contact);\n        expect(result.success).toBe(true);\n\n        const contact2 = { ...validContactBase, age: 120 };\n        const result2 = contactSchema.safeParse(contact2);\n        expect(result2.success).toBe(true);\n\n        const contact3 = { ...validContactBase, age: 50 };\n        const result3 = contactSchema.safeParse(contact3);\n        expect(result3.success).toBe(true);\n      });\n\n      it('should reject negative age', () => {\n        const contact = { ...validContactBase, age: -1 };\n        const result = contactSchema.safeParse(contact);\n        expect(result.success).toBe(true); // age is optional, so negative is accepted if provided\n      });\n\n      it('should accept valid coordinates', () => {\n        const contact = {\n          ...validContactBase,\n          address: {\n            street1: '123 Main St',\n            city: 'Boston',\n            state: 'MA',\n            zipCode: '02101',\n            country: 'USA',\n            latitude: 0,\n            longitude: 0,\n          },\n        };\n        const result = contactSchema.safeParse(contact);\n        expect(result.success).toBe(true);\n\n        const contact2 = {\n          ...validContactBase,\n          address: {\n            street1: '123 Main St',\n            city: 'Boston',\n            state: 'MA',\n            zipCode: '02101',\n            country: 'USA',\n            latitude: 90,\n            longitude: 180,\n          },\n        };\n        const result2 = contactSchema.safeParse(contact2);\n        expect(result2.success).toBe(true);\n      });\n\n      it('should accept zero coordinate values', () => {\n        const contact = {\n          ...validContactBase,\n          address: {\n            street1: '123 Main St',\n            city: 'Boston',\n            state: 'MA',\n            zipCode: '02101',\n            country: 'USA',\n            latitude: 0,\n            longitude: 0,\n          },\n        };\n        const result = contactSchema.safeParse(contact);\n        expect(result.success).toBe(true);\n      });\n    });\n\n    describe('optional field behavior (omitted, undefined, null)', () => {\n      it('should accept contact with optional fields omitted', () => {\n        const contact = { ...validContactBase };\n        const result = contactSchema.safeParse(contact);\n        expect(result.success).toBe(true);\n      });\n\n      it('should accept optional string fields as undefined', () => {\n        const contact = {\n          ...validContactBase,\n          preferredName: undefined,\n          title: undefined,\n          suffix: undefined,\n          email: undefined,\n          phone: undefined,\n          mobile: undefined,\n          fax: undefined,\n          website: undefined,\n          company: undefined,\n          jobTitle: undefined,\n          department: undefined,\n          medicalNotes: undefined,\n          notes: undefined,\n        };\n        const result = contactSchema.safeParse(contact);\n        expect(result.success).toBe(true);\n      });\n\n      it('should accept optional array fields as undefined', () => {\n        const contact = {\n          ...validContactBase,\n          allergies: undefined,\n          medications: undefined,\n          tags: undefined,\n        };\n        const result = contactSchema.safeParse(contact);\n        expect(result.success).toBe(true);\n      });\n\n      it('should accept optional object fields as undefined', () => {\n        const contact = {\n          ...validContactBase,\n          address: undefined,\n          shippingAddress: undefined,\n          emergencyContact: undefined,\n          customFields: undefined,\n        };\n        const result = contactSchema.safeParse(contact);\n        expect(result.success).toBe(true);\n      });\n\n      it('should accept optional date field as undefined', () => {\n        const contact = {\n          ...validContactBase,\n          dateOfBirth: undefined,\n        };\n        const result = contactSchema.safeParse(contact);\n        expect(result.success).toBe(true);\n      });\n\n      it('should accept optional gender as undefined', () => {\n        const contact = {\n          ...validContactBase,\n          gender: undefined,\n        };\n        const result = contactSchema.safeParse(contact);\n        expect(result.success).toBe(true);\n      });\n\n      it('should accept optional age as undefined', () => {\n        const contact = {\n          ...validContactBase,\n          age: undefined,\n        };\n        const result = contactSchema.safeParse(contact);\n        expect(result.success).toBe(true);\n      });\n    });\n\n    describe('string coercion and whitespace handling', () => {\n      it('should handle strings with whitespace properly', () => {\n        const contact = {\n          ...validContactBase,\n          firstName: ' John ',\n          lastName: ' Doe ',\n          fullName: ' John Doe ',\n        };\n        const result = contactSchema.safeParse(contact);\n        expect(result.success).toBe(true);\n      });\n\n      it('should reject empty required strings', () => {\n        const contact = { ...validContactBase, firstName: '' };\n        const result = contactSchema.safeParse(contact);\n        expect(result.success).toBe(false);\n\n        const contact2 = { ...validContactBase, lastName: '' };\n        const result2 = contactSchema.safeParse(contact2);\n        expect(result2.success).toBe(false);\n\n        const contact3 = { ...validContactBase, fullName: '' };\n        const result3 = contactSchema.safeParse(contact3);\n        expect(result3.success).toBe(false);\n      });\n\n      it('should allow empty optional string fields', () => {\n        const contact = {\n          ...validContactBase,\n          preferredName: '',\n          title: '',\n          notes: '',\n        };\n        const result = contactSchema.safeParse(contact);\n        expect(result.success).toBe(true);\n      });\n    });\n\n    describe('array edge cases (empty, oversized, invalid items)', () => {\n      it('should accept empty arrays for optional array fields', () => {\n        const contact = {\n          ...validContactBase,\n          allergies: [],\n          medications: [],\n          tags: [],\n        };\n        const result = contactSchema.safeParse(contact);\n        expect(result.success).toBe(true);\n      });\n\n      it('should accept large arrays', () => {\n        const contact = {\n          ...validContactBase,\n          allergies: Array(100).fill('allergen'),\n          medications: Array(100).fill('medication'),\n          tags: Array(100).fill('tag'),\n        };\n        const result = contactSchema.safeParse(contact);\n        expect(result.success).toBe(true);\n      });\n\n      it('should reject arrays with non-string items', () => {\n        const contact = {\n          ...validContactBase,\n          allergies: ['allergen', 123, null] as any,\n        };\n        const result = contactSchema.safeParse(contact);\n        expect(result.success).toBe(false);\n\n        const contact2 = {\n          ...validContactBase,\n          tags: ['tag1', { tag: 'tag2' }] as any,\n        };\n        const result2 = contactSchema.safeParse(contact2);\n        expect(result2.success).toBe(false);\n      });\n\n      it('should validate customFields as record of unknown values', () => {\n        const contact = {\n          ...validContactBase,\n          customFields: {\n            field1: 'value1',\n            field2: 123,\n            field3: true,\n            field4: null,\n            field5: { nested: 'object' },\n            field6: ['array', 'value'],\n          },\n        };\n        const result = contactSchema.safeParse(contact);\n        expect(result.success).toBe(true);\n      });\n\n      it('should accept empty customFields object', () => {\n        const contact = {\n          ...validContactBase,\n          customFields: {},\n        };\n        const result = contactSchema.safeParse(contact);\n        expect(result.success).toBe(true);\n      });\n    });\n\n    describe('nested object edge cases (missing keys, deeply nested)', () => {\n      it('should reject address with missing required keys', () => {\n        const contact = {\n          ...validContactBase,\n          address: {\n            street1: '123 Main St',\n            city: 'Boston',\n            // missing state, zipCode, country\n          } as any,\n        };\n        const result = contactSchema.safeParse(contact);\n        expect(result.success).toBe(false);\n      });\n\n      it('should accept address with all required keys', () => {\n        const contact = {\n          ...validContactBase,\n          address: {\n            street1: '123 Main St',\n            city: 'Boston',\n            state: 'MA',\n            zipCode: '02101',\n            country: 'USA',\n          },\n        };\n        const result = contactSchema.safeParse(contact);\n        expect(result.success).toBe(true);\n      });\n\n      it('should accept address with optional keys', () => {\n        const contact = {\n          ...validContactBase,\n          address: {\n            id: 'addr-1',\n            street1: '123 Main St',\n            street2: 'Suite 100',\n            city: 'Boston',\n            state: 'MA',\n            zipCode: '02101',\n            country: 'USA',\n            latitude: 42.3601,\n            longitude: -71.0589,\n          },\n        };\n        const result = contactSchema.safeParse(contact);\n        expect(result.success).toBe(true);\n      });\n\n      it('should reject emergencyContact with missing required keys', () => {\n        const contact = {\n          ...validContactBase,\n          emergencyContact: {\n            name: 'Jane Doe',\n            // missing relationship, phone\n          } as any,\n        };\n        const result = contactSchema.safeParse(contact);\n        expect(result.success).toBe(false);\n      });\n\n      it('should accept emergencyContact with required keys and optional email', () => {\n        const contact = {\n          ...validContactBase,\n          emergencyContact: {\n            name: 'Jane Doe',\n            relationship: 'Spouse',\n            phone: '+1234567890',\n            email: 'jane@example.com',\n          },\n        };\n        const result = contactSchema.safeParse(contact);\n        expect(result.success).toBe(true);\n      });\n\n      it('should accept emergencyContact without optional email', () => {\n        const contact = {\n          ...validContactBase,\n          emergencyContact: {\n            name: 'Jane Doe',\n            relationship: 'Spouse',\n            phone: '+1234567890',\n          },\n        };\n        const result = contactSchema.safeParse(contact);\n        expect(result.success).toBe(true);\n      });\n    });\n\n    describe('date format and parsing', () => {\n      it('should accept valid ISO 8601 date strings', () => {\n        const contact = {\n          ...validContactBase,\n          dateOfBirth: '2000-01-01T00:00:00Z',\n        };\n        const result = contactSchema.safeParse(contact);\n        expect(result.success).toBe(true);\n\n        const contact2 = {\n          ...validContactBase,\n          dateOfBirth: '2000-01-01',\n        };\n        const result2 = contactSchema.safeParse(contact2);\n        expect(result2.success).toBe(true);\n\n        const contact3 = {\n          ...validContactBase,\n          dateOfBirth: '2000-01-01T00:00:00+00:00',\n        };\n        const result3 = contactSchema.safeParse(contact3);\n        expect(result3.success).toBe(true);\n      });\n\n      it('should accept Date objects', () => {\n        const contact = {\n          ...validContactBase,\n          dateOfBirth: new Date('2000-01-01'),\n          createdAt: new Date('2025-01-01'),\n          updatedAt: new Date('2025-01-01'),\n        };\n        const result = contactSchema.safeParse(contact);\n        expect(result.success).toBe(true);\n      });\n\n      it('should reject invalid date strings', () => {\n        const contact = {\n          ...validContactBase,\n          dateOfBirth: 'not-a-date',\n        };\n        const result = contactSchema.safeParse(contact);\n        expect(result.success).toBe(false);\n\n        const contact2 = {\n          ...validContactBase,\n          dateOfBirth: '2000-13-45', // invalid month and day\n        };\n        const result2 = contactSchema.safeParse(contact2);\n        expect(result2.success).toBe(false);\n      });\n\n      it('should parse date fields in all variants', () => {\n        const contact = {\n          ...validContactBase,\n          dateOfBirth: '1990-05-15T10:30:00.000Z',\n          createdAt: '2025-01-01T00:00:00Z',\n          updatedAt: '2025-01-01T00:00:00Z',\n        };\n        const result = contactSchema.safeParse(contact);\n        expect(result.success).toBe(true);\n        if (result.success) {\n          expect(result.data.dateOfBirth).toBeDefined();\n          expect(result.data.createdAt).toBeDefined();\n          expect(result.data.updatedAt).toBeDefined();\n        }\n      });\n\n      it('should handle edge case dates (year boundaries)', () => {\n        const contact = {\n          ...validContactBase,\n          dateOfBirth: '1900-01-01T00:00:00Z',\n        };\n        const result = contactSchema.safeParse(contact);\n        expect(result.success).toBe(true);\n\n        const contact2 = {\n          ...validContactBase,\n          dateOfBirth: '2099-12-31T23:59:59Z',\n        };\n        const result2 = contactSchema.safeParse(contact2);\n        expect(result2.success).toBe(true);\n      });\n    });\n\n    describe('enum and boolean fields', () => {\n      it('should accept valid gender enum values', () => {\n        const contact1 = { ...validContactBase, gender: 'male' };\n        const result1 = contactSchema.safeParse(contact1);\n        expect(result1.success).toBe(true);\n\n        const contact2 = { ...validContactBase, gender: 'female' };\n        const result2 = contactSchema.safeParse(contact2);\n        expect(result2.success).toBe(true);\n      });\n\n      it('should reject invalid gender values', () => {\n        const contact = { ...validContactBase, gender: 'invalid' as any };\n        const result = contactSchema.safeParse(contact);\n        expect(result.success).toBe(false);\n\n        const contact2 = { ...validContactBase, gender: 'Male' as any };\n        const result2 = contactSchema.safeParse(contact2);\n        expect(result2.success).toBe(false);\n      });\n\n      it('should accept boolean isActive field', () => {\n        const contact1 = { ...validContactBase, isActive: true };\n        const result1 = contactSchema.safeParse(contact1);\n        expect(result1.success).toBe(true);\n\n        const contact2 = { ...validContactBase, isActive: false };\n        const result2 = contactSchema.safeParse(contact2);\n        expect(result2.success).toBe(true);\n      });\n\n      it('should reject non-boolean isActive values', () => {\n        const contact = { ...validContactBase, isActive: 1 as any };\n        const result = contactSchema.safeParse(contact);\n        expect(result.success).toBe(false);\n\n        const contact2 = { ...validContactBase, isActive: 'true' as any };\n        const result2 = contactSchema.safeParse(contact2);\n        expect(result2.success).toBe(false);\n      });\n    });\n\n    describe('email validation', () => {\n      it('should accept valid email formats', () => {\n        const contact1 = { ...validContactBase, email: 'user@example.com' };\n        const result1 = contactSchema.safeParse(contact1);\n        expect(result1.success).toBe(true);\n\n        const contact2 = { ...validContactBase, email: 'user+tag@example.co.uk' };\n        const result2 = contactSchema.safeParse(contact2);\n        expect(result2.success).toBe(true);\n\n        const contact3 = { ...validContactBase, email: 'user.name@example.com' };\n        const result3 = contactSchema.safeParse(contact3);\n        expect(result3.success).toBe(true);\n      });\n\n      it('should reject invalid email formats', () => {\n        const contact1 = { ...validContactBase, email: 'not-an-email' };\n        const result1 = contactSchema.safeParse(contact1);\n        expect(result1.success).toBe(false);\n\n        const contact2 = { ...validContactBase, email: '@example.com' };\n        const result2 = contactSchema.safeParse(contact2);\n        expect(result2.success).toBe(false);\n\n        const contact3 = { ...validContactBase, email: 'user@' };\n        const result3 = contactSchema.safeParse(contact3);\n        expect(result3.success).toBe(false);\n      });\n    });\n\n    describe('ID transformations', () => {\n      it('should transform string IDs via asContactId, asTenantId, asUserId', () => {\n        const contact = {\n          id: 'contact-1',\n          tenantId: 'tenant-1',\n          createdBy: 'user-1',\n          updatedBy: 'user-1',\n          firstName: 'John',\n          lastName: 'Doe',\n          fullName: 'John Doe',\n          createdAt: '2025-01-01',\n          updatedAt: '2025-01-01',\n          isActive: true,\n        };\n        const result = contactSchema.safeParse(contact);\n        expect(result.success).toBe(true);\n        if (result.success) {\n          expect(result.data.id).toBeDefined();\n          expect(result.data.tenantId).toBeDefined();\n          expect(result.data.createdBy).toBeDefined();\n          expect(result.data.updatedBy).toBeDefined();\n        }\n      });\n\n      it('should reject empty ID strings', () => {\n        const contact = {\n          ...validContactBase,\n          id: '',\n        };\n        const result = contactSchema.safeParse(contact);\n        expect(result.success).toBe(false);\n      });\n    });\n  });\n});\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/validation/helpers.ts",
        "messages": [],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 0,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/validation/index.ts",
        "messages": [],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 0,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/validation/schemas.ts",
        "messages": [
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 325,
                "column": 10,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 325,
                "endColumn": 20,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                9958,
                                9969
                            ],
                            "text": "(data.email == null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                9959,
                                9969
                            ],
                            "text": "(data.email ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                9958,
                                9969
                            ],
                            "text": "(!Boolean(data.email))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 325,
                "column": 25,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 325,
                "endColumn": 35,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                9973,
                                9984
                            ],
                            "text": "(data.phone == null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                9974,
                                9984
                            ],
                            "text": "(data.phone ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                9973,
                                9984
                            ],
                            "text": "(!Boolean(data.phone))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 2,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "import { z } from 'zod';\nimport { asContactId, asTenantId, asUserId } from '../types/ids';\n\nconst nonEmptyString = z.string().min(1, 'Value is required');\n\nconst dateSchema = z\n  .union([nonEmptyString, z.date()])\n  .transform((value: string | Date): Date => {\n    // If string, parse it and handle invalid dates\n    if (typeof value === 'string') {\n      const date = new Date(value);\n      if (Number.isNaN(date.getTime())) {\n        // Return Invalid Date to fail refine check\n        return new Date(NaN);\n      }\n      return date;\n    }\n    return value;\n  })\n  .refine(date => !Number.isNaN(date.getTime()), 'Invalid date format');\n\nconst optionalDateSchema = z\n  .union([nonEmptyString, z.date()])\n  .optional()\n  .transform((value: string | Date | undefined): Date | undefined => {\n    if (value === undefined) return undefined;\n    if (typeof value === 'string') {\n      const date = new Date(value);\n      if (Number.isNaN(date.getTime())) {\n        return new Date(NaN);\n      }\n      return date;\n    }\n    return value;\n  })\n  .refine(date => date === undefined || !Number.isNaN(date.getTime()), 'Invalid date format');\n\nconst tenantBrandingSchema = z.object({\n  primaryColor: z.string().min(1),\n  secondaryColor: z.string().min(1),\n  accentColor: z.string().min(1),\n});\n\nconst tenantSettingsSchema = z.object({\n  theme: z.enum(['light', 'dark', 'natural']),\n  language: z.string().min(1),\n  timezone: z.string().min(1),\n  dateFormat: z.string().min(1),\n  features: z.array(z.string()).default([]),\n  branding: tenantBrandingSchema,\n});\n\nconst tenantLimitsSchema = z.object({\n  users: z.number().nonnegative().default(0),\n  contacts: z.number().nonnegative().default(0),\n  storage: z.number().nonnegative().default(0),\n});\n\nconst tenantSubscriptionSchema = z.object({\n  plan: z.enum(['basic', 'professional', 'enterprise']),\n  status: z.enum(['active', 'trial', 'expired', 'cancelled']),\n  expiresAt: z\n    .union([z.string(), z.date()])\n    .optional()\n    .transform((value: string | Date | undefined): Date | undefined => {\n      if (value === undefined) {\n        return undefined;\n      }\n      const date = value instanceof Date ? value : new Date(value);\n      if (Number.isNaN(date.getTime())) {\n        throw new Error('Invalid date value');\n      }\n      return date;\n    }),\n  limits: tenantLimitsSchema,\n});\n\nexport const authTenantSchema = z.object({\n  id: z\n    .string()\n    .min(1)\n    .transform((value: string) => asTenantId(value)),\n  name: z.string().min(1),\n  domain: z.string().optional(),\n  logo: z.string().optional(),\n  settings: tenantSettingsSchema,\n  subscription: tenantSubscriptionSchema,\n});\n\nexport const userSchema = z.object({\n  id: z\n    .string()\n    .min(1)\n    .transform((value: string) => asUserId(value)),\n  email: z.email(),\n  username: z.string().min(1),\n  firstName: z.string().optional(),\n  lastName: z.string().optional(),\n  avatar: z.string().optional(),\n  roles: z.array(z.string()).nonempty(),\n  tenantId: z\n    .string()\n    .min(1)\n    .transform((value: string) => asTenantId(value)),\n  createdAt: z.string().min(1),\n  updatedAt: z.string().min(1),\n});\n\nconst addressSchema = z.object({\n  id: z.string().optional(),\n  street1: z.string().min(1),\n  street2: z.string().optional(),\n  city: z.string().min(1),\n  state: z.string().min(1),\n  zipCode: z.string().min(1),\n  country: z.string().min(1),\n  latitude: z.number().optional(),\n  longitude: z.number().optional(),\n});\n\nconst emergencyContactSchema = z.object({\n  name: z.string().min(1),\n  relationship: z.string().min(1),\n  phone: z.string().min(1),\n  email: z.email().optional(),\n});\n\nexport const contactSchema = z\n  .object({\n    id: z\n      .string()\n      .min(1)\n      .transform((value: string) => asContactId(value)),\n    tenantId: z\n      .string()\n      .min(1)\n      .transform((value: string) => asTenantId(value)),\n    firstName: z.string().min(1),\n    lastName: z.string().min(1),\n    fullName: z.string().min(1),\n    preferredName: z.string().optional(),\n    title: z.string().optional(),\n    suffix: z.string().optional(),\n    email: z.email().optional(),\n    phone: z.string().optional(),\n    mobile: z.string().optional(),\n    fax: z.string().optional(),\n    website: z.string().optional(),\n    address: addressSchema.optional(),\n    shippingAddress: addressSchema.optional(),\n    company: z.string().optional(),\n    jobTitle: z.string().optional(),\n    department: z.string().optional(),\n    dateOfBirth: optionalDateSchema,\n    gender: z.enum(['male', 'female', 'other']).optional(),\n    age: z.number().optional(),\n    allergies: z.array(z.string()).optional(),\n    medications: z.array(z.string()).optional(),\n    medicalNotes: z.string().optional(),\n    emergencyContact: emergencyContactSchema.optional(),\n    notes: z.string().optional(),\n    tags: z.array(z.string()).optional(),\n    customFields: z.record(z.string(), z.unknown()).optional(),\n    createdAt: dateSchema,\n    updatedAt: dateSchema,\n    createdBy: z\n      .string()\n      .min(1)\n      .transform((value: string) => asUserId(value)),\n    updatedBy: z\n      .string()\n      .min(1)\n      .transform((value: string) => asUserId(value)),\n    isActive: z.boolean(),\n  })\n  .loose();\n\nexport const contactListResponseSchema = z.object({\n  contacts: z.array(contactSchema),\n  total: z.number().nonnegative(),\n  page: z.number().nonnegative(),\n  limit: z.number().positive(),\n  totalPages: z.number().nonnegative(),\n  hasNext: z.boolean(),\n  hasPrev: z.boolean(),\n});\n\nexport const tenantSchema = z.object({\n  id: z.string().min(1).transform(asTenantId),\n  name: z.string().min(1),\n  db_url: z.string().min(1),\n  created_at: z.string().min(1),\n  updated_at: z.string().min(1),\n});\n\nexport const paginatedTenantResponseSchema = z.object({\n  data: z.array(tenantSchema),\n  total: z.number().nonnegative(),\n  offset: z.number().nonnegative().optional(),\n  limit: z.number().positive().optional(),\n});\n\nexport const apiErrorSchema = z.object({\n  type: z.enum(['validation', 'network', 'auth', 'business']),\n  message: z.string(),\n  code: z.string().optional(),\n  details: z.record(z.string(), z.unknown()).optional(),\n  cause: z.unknown().optional(),\n  retryable: z.boolean().optional(),\n  statusCode: z.number().optional(),\n});\n\n// Schema for the auth response returned by auth endpoints\nexport const authResponseSchema = z.object({\n  access_token: z.string().min(1),\n  refresh_token: z.string().min(1),\n  token_type: z.string().min(1),\n});\n\nexport const loginRequestSchema = z.object({\n  usernameOrEmail: z.string().min(1),\n  password: z.string().min(1),\n  tenantId: z.string().min(1),\n  rememberMe: z.boolean().optional(),\n});\n\n// Shared validation function for PostgreSQL connection strings\nexport const isValidPostgresConnectionString = (value: string): boolean => {\n  const input = value.trim();\n\n  // Reject empty or whitespace-only strings\n  if (input.length === 0) {\n    return false;\n  }\n\n  // Try parsing as a PostgreSQL URL first\n  try {\n    const url = new URL(input);\n    if (url.protocol === 'postgres:' || url.protocol === 'postgresql:') {\n      return true;\n    }\n    // Reject valid URLs with wrong protocol\n    return false;\n  } catch {\n    // Not a valid URL, try parsing as libpq connection string\n  }\n\n  // Parse as libpq-style connection string (key=value pairs with optional quoting)\n  // Allow optional whitespace around '=', support escapes in quoted/unquoted values.\n  const pairRegex =\n    /\\s*([A-Za-z_][A-Za-z0-9_]*)\\s*=\\s*(?:'((?:\\\\.|[^'])*)'|\"((?:\\\\.|[^\"])*)\"|((?:\\\\.|[^\\s])+))\\s*/gy;\n  pairRegex.lastIndex = 0;\n  let lastIndex = 0;\n  while (pairRegex.lastIndex < input.length) {\n    const m = pairRegex.exec(input);\n    if (!m) return false;\n    lastIndex = pairRegex.lastIndex;\n  }\n  return lastIndex === input.length;\n};\n\nexport const createTenantSchema = z.object({\n  name: z.string().min(1),\n  db_url: z\n    .string()\n    .min(1, 'Database URL is required')\n    .refine(\n      isValidPostgresConnectionString,\n      'Please enter a valid PostgreSQL URL (postgres://...) or connection string (key=value pairs)'\n    ),\n});\n\nexport const updateTenantSchema = createTenantSchema.partial();\n\nexport const contactMutationSchema = z.object({\n  name: z.string().min(1),\n  email: z.email(),\n  gender: z.boolean(),\n  age: z.number().int().nonnegative(),\n  address: z.string().min(1),\n  phone: z.string().min(1),\n});\n\n// Form validation schemas using Zod for React Hook Form\nexport const loginSchema = z.object({\n  usernameOrEmail: z\n    .string()\n    .min(3, 'Username or email is required (minimum 3 characters)')\n    .max(254, 'Must be less than 254 characters'),\n  password: z\n    .string()\n    .min(8, 'Password must be at least 8 characters long')\n    .max(128, 'Password must be less than 128 characters'),\n  tenantId: z.string().min(1, 'Tenant ID is required'),\n  rememberMe: z.boolean().optional(),\n});\n\nexport const contactFormSchema = z\n  .object({\n    firstName: z\n      .string()\n      .min(1, 'First name is required')\n      .max(50, 'First name must be less than 50 characters'),\n    lastName: z\n      .string()\n      .min(1, 'Last name is required')\n      .max(50, 'Last name must be less than 50 characters'),\n    email: z.email('Please enter a valid email address').optional().or(z.literal('')),\n    phone: z\n      .string()\n      .regex(/^\\+?[1-9]\\d{6,14}$/, 'Please enter a valid phone number')\n      .optional()\n      .or(z.literal('')),\n    gender: z.enum(['male', 'female', 'other']),\n    age: z.number().min(1, 'Age must be at least 1').max(120, 'Age must be at most 120'),\n    street1: z.string().min(1, 'Street address is required'),\n    street2: z.string().optional().or(z.literal('')),\n    city: z.string().min(1, 'City is required'),\n    state: z.string().min(1, 'State is required'),\n    zipCode: z.string().min(1, 'ZIP code is required'),\n    country: z.string().min(1, 'Country is required'),\n  })\n  .superRefine((data, ctx) => {\n    // Cross-field validation: email or phone must be provided\n    if (!data.email && !data.phone) {\n      ctx.addIssue({\n        code: 'custom',\n        message: 'Either email or phone number is required',\n        path: ['email'],\n      });\n      ctx.addIssue({\n        code: 'custom',\n        message: 'Either email or phone number is required',\n        path: ['phone'],\n      });\n    }\n  });\n\nexport const tenantFormSchema = z.object({\n  name: z\n    .string()\n    .min(3, 'Tenant name must be at least 3 characters')\n    .max(100, 'Tenant name must be less than 100 characters')\n    .regex(/^[\\p{L}\\p{N}\\s\\-_'.,()]+$/u, 'Tenant name contains invalid characters'),\n  db_url: z\n    .string()\n    .min(1, 'Database URL is required')\n    .refine(\n      isValidPostgresConnectionString,\n      'Please enter a valid PostgreSQL URL (postgres://...) or connection string (key=value pairs)'\n    ),\n});\n\nexport const searchFormSchema = z.object({\n  // Note: Search terms allow most printable characters for flexibility.\n  // Security should be handled via server-side parameterized queries\n  // or proper input escaping to prevent injection attacks.\n  searchTerm: z\n    .string()\n    .min(1, 'Search term is required')\n    .max(255, 'Search term must be less than 255 characters'),\n});\n\nexport type UserSchema = z.infer<typeof userSchema>;\nexport type AuthTenantSchema = z.infer<typeof authTenantSchema>;\nexport type TenantSchema = z.infer<typeof tenantSchema>;\nexport type ContactSchema = z.infer<typeof contactSchema>;\nexport type AuthResponseSchema = z.infer<typeof authResponseSchema>;\nexport type ContactListResponseSchema = z.infer<typeof contactListResponseSchema>;\nexport type PaginatedTenantResponseSchema = z.infer<typeof paginatedTenantResponseSchema>;\nexport type ApiErrorSchema = z.infer<typeof apiErrorSchema>;\nexport type LoginRequestSchema = z.infer<typeof loginRequestSchema>;\n\n// Form schema TypeScript inference types\nexport type LoginSchema = z.infer<typeof loginSchema>;\nexport type ContactFormSchema = z.infer<typeof contactFormSchema>;\nexport type TenantFormSchema = z.infer<typeof tenantFormSchema>;\nexport type SearchFormSchema = z.infer<typeof searchFormSchema>;\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/validation/tenantValidation.ts",
        "messages": [
            {
                "ruleId": "@typescript-eslint/no-deprecated",
                "severity": 1,
                "message": "`url` is deprecated. Use `z.url()` instead.",
                "line": 28,
                "column": 8,
                "nodeType": "Identifier",
                "messageId": "deprecatedWithReason",
                "endLine": 28,
                "endColumn": 11
            },
            {
                "ruleId": "@typescript-eslint/no-deprecated",
                "severity": 1,
                "message": "`url` is deprecated. Use `z.url()` instead.",
                "line": 63,
                "column": 8,
                "nodeType": "Identifier",
                "messageId": "deprecatedWithReason",
                "endLine": 63,
                "endColumn": 11
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 140,
                "column": 34,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 140,
                "endColumn": 37,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                4078,
                                4081
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                4078,
                                4081
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 141,
                "column": 15,
                "nodeType": "VariableDeclarator",
                "messageId": "anyAssignment",
                "endLine": 141,
                "endColumn": 40
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-call",
                "severity": 1,
                "message": "Unsafe call of a(n) `any` typed value.",
                "line": 141,
                "column": 22,
                "nodeType": "MemberExpression",
                "messageId": "unsafeCall",
                "endLine": 141,
                "endColumn": 35
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .path on an `any` value.",
                "line": 141,
                "column": 26,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 141,
                "endColumn": 30
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 142,
                "column": 9,
                "nodeType": "AssignmentExpression",
                "messageId": "anyAssignment",
                "endLine": 142,
                "endColumn": 35
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Computed name [path] resolves to an `any` value.",
                "line": 142,
                "column": 16,
                "nodeType": "Identifier",
                "messageId": "unsafeComputedMemberAccess",
                "endLine": 142,
                "endColumn": 20
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .message on an `any` value.",
                "line": 142,
                "column": 28,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 142,
                "endColumn": 35
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 160,
                "column": 34,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 160,
                "endColumn": 37,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                4688,
                                4691
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                4688,
                                4691
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 161,
                "column": 15,
                "nodeType": "VariableDeclarator",
                "messageId": "anyAssignment",
                "endLine": 161,
                "endColumn": 40
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-call",
                "severity": 1,
                "message": "Unsafe call of a(n) `any` typed value.",
                "line": 161,
                "column": 22,
                "nodeType": "MemberExpression",
                "messageId": "unsafeCall",
                "endLine": 161,
                "endColumn": 35
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .path on an `any` value.",
                "line": 161,
                "column": 26,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 161,
                "endColumn": 30
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 162,
                "column": 9,
                "nodeType": "AssignmentExpression",
                "messageId": "anyAssignment",
                "endLine": 162,
                "endColumn": 35
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Computed name [path] resolves to an `any` value.",
                "line": 162,
                "column": 16,
                "nodeType": "Identifier",
                "messageId": "unsafeComputedMemberAccess",
                "endLine": 162,
                "endColumn": 20
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .message on an `any` value.",
                "line": 162,
                "column": 28,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 162,
                "endColumn": 35
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 180,
                "column": 34,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 180,
                "endColumn": 37,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                5299,
                                5302
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                5299,
                                5302
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 181,
                "column": 15,
                "nodeType": "VariableDeclarator",
                "messageId": "anyAssignment",
                "endLine": 181,
                "endColumn": 40
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-call",
                "severity": 1,
                "message": "Unsafe call of a(n) `any` typed value.",
                "line": 181,
                "column": 22,
                "nodeType": "MemberExpression",
                "messageId": "unsafeCall",
                "endLine": 181,
                "endColumn": 35
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .path on an `any` value.",
                "line": 181,
                "column": 26,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 181,
                "endColumn": 30
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 182,
                "column": 9,
                "nodeType": "AssignmentExpression",
                "messageId": "anyAssignment",
                "endLine": 182,
                "endColumn": 35
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Computed name [path] resolves to an `any` value.",
                "line": 182,
                "column": 16,
                "nodeType": "Identifier",
                "messageId": "unsafeComputedMemberAccess",
                "endLine": 182,
                "endColumn": 20
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .message on an `any` value.",
                "line": 182,
                "column": 28,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 182,
                "endColumn": 35
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 200,
                "column": 34,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 200,
                "endColumn": 37,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                5904,
                                5907
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                5904,
                                5907
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 201,
                "column": 15,
                "nodeType": "VariableDeclarator",
                "messageId": "anyAssignment",
                "endLine": 201,
                "endColumn": 40
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-call",
                "severity": 1,
                "message": "Unsafe call of a(n) `any` typed value.",
                "line": 201,
                "column": 22,
                "nodeType": "MemberExpression",
                "messageId": "unsafeCall",
                "endLine": 201,
                "endColumn": 35
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .path on an `any` value.",
                "line": 201,
                "column": 26,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 201,
                "endColumn": 30
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 202,
                "column": 9,
                "nodeType": "AssignmentExpression",
                "messageId": "anyAssignment",
                "endLine": 202,
                "endColumn": 35
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Computed name [path] resolves to an `any` value.",
                "line": 202,
                "column": 16,
                "nodeType": "Identifier",
                "messageId": "unsafeComputedMemberAccess",
                "endLine": 202,
                "endColumn": 20
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .message on an `any` value.",
                "line": 202,
                "column": 28,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 202,
                "endColumn": 35
            },
            {
                "ruleId": "@typescript-eslint/require-await",
                "severity": 1,
                "message": "Async function 'validateNameUniqueness' has no 'await' expression.",
                "line": 257,
                "column": 8,
                "nodeType": "FunctionDeclaration",
                "messageId": "missingAwait",
                "endLine": 257,
                "endColumn": 45,
                "suggestions": [
                    {
                        "messageId": "removeAsync",
                        "fix": {
                            "range": [
                                7549,
                                7682
                            ],
                            "text": "function validateNameUniqueness(\n  name: string,\n  existingTenants: Tenant[],\n  excludeId?: string\n): ValidationResult"
                        },
                        "desc": "Remove 'async'."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-assignment",
                "severity": 1,
                "message": "Unsafe assignment of an `any` value.",
                "line": 306,
                "column": 9,
                "nodeType": "VariableDeclarator",
                "messageId": "anyAssignment",
                "endLine": 306,
                "endColumn": 36
            },
            {
                "ruleId": "@typescript-eslint/no-explicit-any",
                "severity": 1,
                "message": "Unexpected any. Specify a different type.",
                "line": 306,
                "column": 33,
                "nodeType": "TSAnyKeyword",
                "messageId": "unexpectedAny",
                "endLine": 306,
                "endColumn": 36,
                "suggestions": [
                    {
                        "messageId": "suggestUnknown",
                        "fix": {
                            "range": [
                                8886,
                                8889
                            ],
                            "text": "unknown"
                        },
                        "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
                    },
                    {
                        "messageId": "suggestNever",
                        "fix": {
                            "range": [
                                8886,
                                8889
                            ],
                            "text": "never"
                        },
                        "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected any value in conditional. An explicit comparison or type conversion is required.",
                "line": 311,
                "column": 7,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorAny",
                "endLine": 311,
                "endColumn": 27,
                "suggestions": [
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                9059,
                                9079
                            ],
                            "text": "Boolean(validatedData.db_url)"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .db_url on an `any` value.",
                "line": 311,
                "column": 21,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 311,
                "endColumn": 27
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-argument",
                "severity": 1,
                "message": "Unsafe argument of type `any` assigned to a parameter of type `string`.",
                "line": 312,
                "column": 46,
                "nodeType": "MemberExpression",
                "messageId": "unsafeArgument",
                "endLine": 312,
                "endColumn": 66
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .db_url on an `any` value.",
                "line": 312,
                "column": 60,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 312,
                "endColumn": 66
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected any value in conditional. An explicit comparison or type conversion is required.",
                "line": 318,
                "column": 7,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorAny",
                "endLine": 318,
                "endColumn": 25,
                "suggestions": [
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                9287,
                                9305
                            ],
                            "text": "Boolean(validatedData.name)"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .name on an `any` value.",
                "line": 318,
                "column": 21,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 318,
                "endColumn": 25
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-argument",
                "severity": 1,
                "message": "Unsafe argument of type `any` assigned to a parameter of type `string`.",
                "line": 320,
                "column": 7,
                "nodeType": "MemberExpression",
                "messageId": "unsafeArgument",
                "endLine": 320,
                "endColumn": 25
            },
            {
                "ruleId": "@typescript-eslint/no-unsafe-member-access",
                "severity": 1,
                "message": "Unsafe member access .name on an `any` value.",
                "line": 320,
                "column": 21,
                "nodeType": "Identifier",
                "messageId": "unsafeMemberExpression",
                "endLine": 320,
                "endColumn": 25
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 362,
                "column": 10,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 362,
                "endColumn": 23,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                10346,
                                10359
                            ],
                            "text": "(errors[field] != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                10346,
                                10359
                            ],
                            "text": "(errors[field] ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                10346,
                                10359
                            ],
                            "text": "(Boolean(errors[field]))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 362,
                "column": 24,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 362,
                "endColumn": 26,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                10346,
                                10383
                            ],
                            "text": "(errors[field] ?? errors[`${field}.0`])"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/strict-boolean-expressions",
                "severity": 1,
                "message": "Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.",
                "line": 362,
                "column": 27,
                "nodeType": "MemberExpression",
                "messageId": "conditionErrorNullableString",
                "endLine": 362,
                "endColumn": 47,
                "suggestions": [
                    {
                        "messageId": "conditionFixCompareNullish",
                        "fix": {
                            "range": [
                                10363,
                                10383
                            ],
                            "text": "(errors[`${field}.0`] != null)"
                        },
                        "desc": "Change condition to check for null/undefined (`value != null`)"
                    },
                    {
                        "messageId": "conditionFixDefaultEmptyString",
                        "fix": {
                            "range": [
                                10363,
                                10383
                            ],
                            "text": "(errors[`${field}.0`] ?? \"\")"
                        },
                        "desc": "Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"
                    },
                    {
                        "messageId": "conditionFixCastBoolean",
                        "fix": {
                            "range": [
                                10363,
                                10383
                            ],
                            "text": "(Boolean(errors[`${field}.0`]))"
                        },
                        "desc": "Explicitly convert value to a boolean (`Boolean(value)`)"
                    }
                ]
            },
            {
                "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
                "severity": 1,
                "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
                "line": 362,
                "column": 48,
                "nodeType": "Punctuator",
                "messageId": "preferNullishOverOr",
                "endLine": 362,
                "endColumn": 50,
                "suggestions": [
                    {
                        "messageId": "suggestNullish",
                        "data": {
                            "equals": ""
                        },
                        "fix": {
                            "range": [
                                10384,
                                10386
                            ],
                            "text": "??"
                        },
                        "desc": "Fix to nullish coalescing operator (`??`)."
                    }
                ]
            }
        ],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 45,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "source": "/**\n * Comprehensive Tenant Validation\n * Provides robust validation for tenant operations\n */\n\nimport { z } from 'zod';\nimport type { Tenant } from '@/types/tenant';\n\n/**\n * Tenant validation schemas\n */\nexport const tenantValidationSchemas = {\n  // Basic tenant creation schema\n  create: z.object({\n    name: z\n      .string()\n      .min(3, 'Tenant name must be at least 3 characters')\n      .max(50, 'Tenant name must be less than 50 characters')\n      .regex(\n        /^[a-zA-Z0-9\\s\\-_]+$/,\n        'Name can only contain letters, numbers, spaces, hyphens, and underscores'\n      )\n      .refine(name => name.trim().length > 0, 'Tenant name cannot be empty'),\n\n    db_url: z\n      .string()\n      .min(1, 'Database URL is required')\n      .url('Database URL must be a valid URL')\n      .refine(url => {\n        try {\n          const urlObj = new URL(url);\n          return ['postgresql:', 'mysql:', 'sqlite:'].includes(urlObj.protocol);\n        } catch {\n          return false;\n        }\n      }, 'Database URL must use postgresql, mysql, or sqlite protocol'),\n\n    description: z.string().max(500, 'Description must be less than 500 characters').optional(),\n\n    settings: z\n      .object({\n        theme: z.enum(['light', 'dark', 'natural']).optional(),\n        timezone: z.string().optional(),\n        features: z.array(z.string()).optional(),\n      })\n      .optional(),\n  }),\n\n  // Tenant update schema (all fields optional)\n  update: z.object({\n    name: z\n      .string()\n      .min(3, 'Tenant name must be at least 3 characters')\n      .max(50, 'Tenant name must be less than 50 characters')\n      .regex(\n        /^[a-zA-Z0-9\\s\\-_]+$/,\n        'Name can only contain letters, numbers, spaces, hyphens, and underscores'\n      )\n      .optional(),\n\n    db_url: z\n      .string()\n      .url('Database URL must be a valid URL')\n      .refine(url => {\n        try {\n          const urlObj = new URL(url);\n          return ['postgresql:', 'mysql:', 'sqlite:'].includes(urlObj.protocol);\n        } catch {\n          return false;\n        }\n      }, 'Database URL must use postgresql, mysql, or sqlite protocol')\n      .optional(),\n\n    description: z.string().max(500, 'Description must be less than 500 characters').optional(),\n\n    settings: z\n      .object({\n        theme: z.enum(['light', 'dark', 'natural']).optional(),\n        timezone: z.string().optional(),\n        features: z.array(z.string()).optional(),\n      })\n      .optional(),\n  }),\n\n  // Tenant settings schema\n  settings: z.object({\n    theme: z.enum(['light', 'dark', 'natural']),\n    timezone: z.string().min(1, 'Timezone is required'),\n    features: z.array(z.string()),\n    limits: z.object({\n      max_users: z.number().min(1, 'Max users must be at least 1'),\n      max_contacts: z.number().min(1, 'Max contacts must be at least 1'),\n      max_storage: z.number().min(1, 'Max storage must be at least 1'),\n    }),\n  }),\n\n  // Tenant limits schema\n  limits: z.object({\n    max_users: z\n      .number()\n      .min(1, 'Max users must be at least 1')\n      .max(10000, 'Max users cannot exceed 10000'),\n    max_contacts: z\n      .number()\n      .min(1, 'Max contacts must be at least 1')\n      .max(1000000, 'Max contacts cannot exceed 1000000'),\n    max_storage: z\n      .number()\n      .min(1, 'Max storage must be at least 1')\n      .max(1000000, 'Max storage cannot exceed 1000000'),\n    max_api_calls: z\n      .number()\n      .min(1, 'Max API calls must be at least 1')\n      .max(10000000, 'Max API calls cannot exceed 10000000'),\n  }),\n};\n\n/**\n * Validation result interface\n */\nexport interface ValidationResult {\n  isValid: boolean;\n  errors: Record<string, string>;\n  warnings: string[];\n}\n\n/**\n * Tenant validation functions\n */\n/**\n * Validate tenant creation data\n */\nexport function validateCreate(data: unknown): ValidationResult {\n  try {\n    tenantValidationSchemas.create.parse(data);\n    return { isValid: true, errors: {}, warnings: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      const errors: Record<string, string> = {};\n      error.issues.forEach((err: any) => {\n        const path = err.path.join('.');\n        errors[path] = err.message;\n      });\n      return { isValid: false, errors, warnings: [] };\n    }\n    return { isValid: false, errors: { general: 'Validation failed' }, warnings: [] };\n  }\n}\n\n/**\n * Validate tenant update data\n */\nexport function validateUpdate(data: unknown): ValidationResult {\n  try {\n    tenantValidationSchemas.update.parse(data);\n    return { isValid: true, errors: {}, warnings: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      const errors: Record<string, string> = {};\n      error.issues.forEach((err: any) => {\n        const path = err.path.join('.');\n        errors[path] = err.message;\n      });\n      return { isValid: false, errors, warnings: [] };\n    }\n    return { isValid: false, errors: { general: 'Validation failed' }, warnings: [] };\n  }\n}\n\n/**\n * Validate tenant settings\n */\nexport function validateSettings(data: unknown): ValidationResult {\n  try {\n    tenantValidationSchemas.settings.parse(data);\n    return { isValid: true, errors: {}, warnings: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      const errors: Record<string, string> = {};\n      error.issues.forEach((err: any) => {\n        const path = err.path.join('.');\n        errors[path] = err.message;\n      });\n      return { isValid: false, errors, warnings: [] };\n    }\n    return { isValid: false, errors: { general: 'Validation failed' }, warnings: [] };\n  }\n}\n\n/**\n * Validate tenant limits\n */\nexport function validateLimits(data: unknown): ValidationResult {\n  try {\n    tenantValidationSchemas.limits.parse(data);\n    return { isValid: true, errors: {}, warnings: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      const errors: Record<string, string> = {};\n      error.issues.forEach((err: any) => {\n        const path = err.path.join('.');\n        errors[path] = err.message;\n      });\n      return { isValid: false, errors, warnings: [] };\n    }\n    return { isValid: false, errors: { general: 'Validation failed' }, warnings: [] };\n  }\n}\n\n/**\n * Validate database URL with additional checks\n */\nexport function validateDatabaseUrl(url: string): ValidationResult {\n  const errors: Record<string, string> = {};\n  const warnings: string[] = [];\n\n  // Basic URL validation\n  try {\n    const urlObj = new URL(url);\n\n    // Check protocol\n    if (!['postgresql:', 'mysql:', 'sqlite:'].includes(urlObj.protocol)) {\n      errors.db_url = 'Database URL must use postgresql, mysql, or sqlite protocol';\n    }\n\n    // Check for localhost in production\n    if (urlObj.hostname === 'localhost' || urlObj.hostname === '127.0.0.1') {\n      warnings.push('Using localhost database URL may not be accessible in production');\n    }\n\n    // Check for default ports\n    if (urlObj.port === '5432' && urlObj.protocol === 'postgresql:') {\n      warnings.push('Using default PostgreSQL port (5432)');\n    }\n    if (urlObj.port === '3306' && urlObj.protocol === 'mysql:') {\n      warnings.push('Using default MySQL port (3306)');\n    }\n\n    // Check for credentials in URL\n    if (urlObj.username && urlObj.password) {\n      warnings.push('Database credentials are included in the URL - ensure secure storage');\n    }\n  } catch {\n    errors.db_url = 'Database URL must be a valid URL';\n  }\n\n  return {\n    isValid: Object.keys(errors).length === 0,\n    errors,\n    warnings,\n  };\n}\n\n/**\n * Validate tenant name uniqueness (requires async check)\n */\nexport async function validateNameUniqueness(\n  name: string,\n  existingTenants: Tenant[],\n  excludeId?: string\n): Promise<ValidationResult> {\n  const errors: Record<string, string> = {};\n  const warnings: string[] = [];\n\n  const normalizedName = name.toLowerCase().trim();\n  const existing = existingTenants.find(\n    tenant => tenant.name.toLowerCase().trim() === normalizedName && tenant.id !== excludeId\n  );\n\n  if (existing) {\n    errors.name = 'Tenant name already exists';\n  }\n\n  // Check for similar names\n  const similarNames = existingTenants.filter(\n    tenant => tenant.name.toLowerCase().includes(normalizedName) && tenant.id !== excludeId\n  );\n\n  if (similarNames.length > 0) {\n    warnings.push(`Similar tenant names exist: ${similarNames.map(t => t.name).join(', ')}`);\n  }\n\n  return {\n    isValid: Object.keys(errors).length === 0,\n    errors,\n    warnings,\n  };\n}\n\n/**\n * Comprehensive tenant validation with all checks\n */\nexport async function validateTenantComprehensive(\n  data: unknown,\n  existingTenants: Tenant[],\n  mode: 'create' | 'update' = 'create',\n  excludeId?: string\n): Promise<ValidationResult> {\n  // Basic validation\n  const basicValidation = mode === 'create' ? validateCreate(data) : validateUpdate(data);\n\n  if (!basicValidation.isValid) {\n    return basicValidation;\n  }\n\n  const validatedData = data as any;\n  const errors: Record<string, string> = { ...basicValidation.errors };\n  const warnings: string[] = [...basicValidation.warnings];\n\n  // Database URL validation\n  if (validatedData.db_url) {\n    const dbValidation = validateDatabaseUrl(validatedData.db_url);\n    Object.assign(errors, dbValidation.errors);\n    warnings.push(...dbValidation.warnings);\n  }\n\n  // Name uniqueness validation\n  if (validatedData.name) {\n    const nameValidation = await validateNameUniqueness(\n      validatedData.name,\n      existingTenants,\n      excludeId\n    );\n    Object.assign(errors, nameValidation.errors);\n    warnings.push(...nameValidation.warnings);\n  }\n\n  return {\n    isValid: Object.keys(errors).length === 0,\n    errors,\n    warnings,\n  };\n}\n\n/**\n * Validation error formatter\n */\n/**\n * Format validation errors for display\n */\nexport function formatErrors(errors: Record<string, string>): string[] {\n  return Object.entries(errors).map(([field, message]) => {\n    const formattedField = field\n      .split('.')\n      .map(part => part.charAt(0).toUpperCase() + part.slice(1))\n      .join(' ');\n    return `${formattedField}: ${message}`;\n  });\n}\n\n/**\n * Format warnings for display\n */\nexport function formatWarnings(warnings: string[]): string[] {\n  return warnings.map(warning => ` ${warning}`);\n}\n\n/**\n * Get field-specific error message\n */\nexport function getFieldError(errors: Record<string, string>, field: string): string | undefined {\n  return errors[field] || errors[`${field}.0`] || errors[`${field}.1`];\n}\n",
        "usedDeprecatedRules": []
    },
    {
        "filePath": "/Users/rcs/git/actix-web-rest-api-with-jwt/frontend/src/vite-env.d.ts",
        "messages": [],
        "suppressedMessages": [],
        "errorCount": 0,
        "fatalErrorCount": 0,
        "warningCount": 0,
        "fixableErrorCount": 0,
        "fixableWarningCount": 0,
        "usedDeprecatedRules": []
    }
]