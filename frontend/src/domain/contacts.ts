/**
 * Contact Management Domain Logic
 *
 * Pure functions for contact management operations using Railway-Oriented Programming.
 * All functions return Result<T, E> for explicit error handling.
 *
 * This module extracts business logic from the service layer,
 * making it pure, testable, and composable.
 */

import { ok, err } from 'neverthrow';
import type { Result } from '../types/fp';
import type { Contact, Gender } from '../types/contact';
import type { ContactId, UserId, TenantId } from '../types/ids';
import { validateEmailFormat, validatePhoneFormat } from './rules/contactRules';

/**
 * Contact-specific errors
 */
export type ContactError =
  | { type: 'INVALID_DATA'; field: string; reason: string }
  | { type: 'DUPLICATE_CONTACT'; field: string; value: string }
  | { type: 'NOT_FOUND'; contactId: ContactId }
  | { type: 'MERGE_CONFLICT'; reason: string }
  | { type: 'VALIDATION_FAILED'; errors: Record<string, string> }
  | { type: 'UNAUTHORIZED'; message: string };

/**
 * Contact creation data (input DTO)
 */
export interface ContactCreateData {
  firstName: string;
  lastName: string;
  email?: string;
  phone?: string;
  mobile?: string;
  company?: string;
  jobTitle?: string;
  dateOfBirth?: Date;
  gender?: Gender;
  notes?: string;
  tags?: string[];
  customFields?: Record<string, unknown>;
}

/**
 * Contact update data (partial)
 */
export type ContactUpdateData = Partial<ContactCreateData>;

/**
 * Merge strategy for combining contacts
 */
export type MergeStrategy = 'prefer-primary' | 'prefer-secondary' | 'combine';

/**
 * Create a new contact with validation
 *
 * @param data - Contact creation data
 * @param userId - ID of user creating the contact
 * @param tenantId - ID of the tenant
 * @returns Result containing Contact or ContactError
 */
export function createContact(
  data: ContactCreateData,
  userId: UserId,
  tenantId: TenantId
): Result<Contact, ContactError> {
  // Validate required fields
  const validationResult = validateContactData(data);
  if (validationResult.isErr()) {
    return err(validationResult.error);
  }

  try {
    // Generate full name
    const fullName = `${data.firstName} ${data.lastName}`.trim();

    // Calculate age if date of birth provided
    const age = data.dateOfBirth ? calculateAge(data.dateOfBirth) : undefined;

    // Create contact object
    const now = new Date();
    const contact: Contact = {
      id: generateContactId(), // This would be generated by backend in real app
      tenantId,
      firstName: data.firstName,
      lastName: data.lastName,
      fullName,
      email: data.email,
      phone: data.phone,
      mobile: data.mobile,
      company: data.company,
      jobTitle: data.jobTitle,
      dateOfBirth: data.dateOfBirth,
      gender: data.gender,
      age,
      notes: data.notes,
      tags: data.tags ?? [],
      customFields: data.customFields,
      createdAt: now,
      updatedAt: now,
      createdBy: userId,
      updatedBy: userId,
      isActive: true,
    };

    return ok(contact);
  } catch (error) {
    return err({
      type: 'INVALID_DATA',
      field: 'unknown',
      reason: error instanceof Error ? error.message : 'Failed to create contact',
    });
  }
}

/**
 * Update an existing contact
 *
 * @param existingContact - Current contact data
 * @param updateData - Fields to update
 * @param userId - ID of user updating the contact
 * @returns Result containing updated Contact or ContactError
 */
export function updateContact(
  existingContact: Contact,
  updateData: ContactUpdateData,
  userId: UserId
): Result<Contact, ContactError> {
  // Validate update data
  const validationResult = validateContactUpdateData(updateData);
  if (validationResult.isErr()) {
    return err(validationResult.error);
  }

  try {
    const normalizedFirstName = normalizeString(updateData.firstName);
    const normalizedLastName = normalizeString(updateData.lastName);

    const shouldUpdateFullName =
      normalizedFirstName !== undefined || normalizedLastName !== undefined;

    const nextFirstName = normalizedFirstName ?? existingContact.firstName;
    const nextLastName = normalizedLastName ?? existingContact.lastName;

    // Create updated contact
    const updatedContact: Contact = {
      ...existingContact,
      ...updateData,
      // Recalculate derived fields
      fullName: shouldUpdateFullName
        ? `${nextFirstName} ${nextLastName}`.trim()
        : existingContact.fullName,
      age: updateData.dateOfBirth ? calculateAge(updateData.dateOfBirth) : existingContact.age,
      // Update metadata
      updatedAt: new Date(),
      updatedBy: userId,
    };

    return ok(updatedContact);
  } catch (error) {
    return err({
      type: 'INVALID_DATA',
      field: 'unknown',
      reason: error instanceof Error ? error.message : 'Failed to update contact',
    });
  }
}

/**
 * Merge two contacts into one
 *
 * @param primary - Primary contact (base)
 * @param secondary - Secondary contact (to merge)
 * @param strategy - Merge strategy
 * @param userId - ID of user performing the merge
 * @returns Result containing merged Contact or ContactError
 */
export function mergeContacts(
  primary: Contact,
  secondary: Contact,
  strategy: MergeStrategy,
  userId: UserId
): Result<Contact, ContactError> {
  // Validate contacts are from same tenant
  if (primary.tenantId !== secondary.tenantId) {
    return err({
      type: 'MERGE_CONFLICT',
      reason: 'Cannot merge contacts from different tenants',
    });
  }

  // Validate contacts are different
  if (primary.id === secondary.id) {
    return err({
      type: 'MERGE_CONFLICT',
      reason: 'Cannot merge contact with itself',
    });
  }

  try {
    let mergedContact: Contact;

    switch (strategy) {
      case 'prefer-primary':
        mergedContact = {
          ...primary,
          // Only take secondary fields that are missing in primary
          email: pickPreferredString(primary.email, secondary.email),
          phone: pickPreferredString(primary.phone, secondary.phone),
          mobile: pickPreferredString(primary.mobile, secondary.mobile),
          company: pickPreferredString(primary.company, secondary.company),
          jobTitle: pickPreferredString(primary.jobTitle, secondary.jobTitle),
          dateOfBirth: primary.dateOfBirth ?? secondary.dateOfBirth,
          gender: primary.gender ?? secondary.gender,
          notes: combineNotes(primary.notes, secondary.notes, 'prefer-primary'),
          tags: mergeArrays(primary.tags ?? [], secondary.tags ?? []),
          updatedAt: new Date(),
          updatedBy: userId,
        };
        break;

      case 'prefer-secondary':
        mergedContact = {
          ...secondary,
          id: primary.id, // Keep primary ID
          tenantId: primary.tenantId,
          createdAt: primary.createdAt, // Keep original creation time
          createdBy: primary.createdBy,
          email: pickPreferredString(secondary.email, primary.email),
          phone: pickPreferredString(secondary.phone, primary.phone),
          mobile: pickPreferredString(secondary.mobile, primary.mobile),
          company: pickPreferredString(secondary.company, primary.company),
          jobTitle: pickPreferredString(secondary.jobTitle, primary.jobTitle),
          dateOfBirth: secondary.dateOfBirth ?? primary.dateOfBirth,
          gender: secondary.gender ?? primary.gender,
          notes: combineNotes(secondary.notes, primary.notes, 'prefer-primary'),
          tags: mergeArrays(secondary.tags ?? [], primary.tags ?? []),
          updatedAt: new Date(),
          updatedBy: userId,
        };
        break;

      case 'combine':
        mergedContact = {
          ...primary,
          // Combine all non-empty fields
          email: pickPreferredString(primary.email, secondary.email),
          phone: pickPreferredString(primary.phone, secondary.phone),
          mobile: pickPreferredString(primary.mobile, secondary.mobile),
          company: combineFields(primary.company, secondary.company),
          jobTitle: combineFields(primary.jobTitle, secondary.jobTitle),
          dateOfBirth: primary.dateOfBirth ?? secondary.dateOfBirth,
          gender: primary.gender ?? secondary.gender,
          notes: combineNotes(primary.notes, secondary.notes, 'combine'),
          tags: mergeArrays(primary.tags ?? [], secondary.tags ?? []),
          updatedAt: new Date(),
          updatedBy: userId,
        };
        break;
    }

    return ok(mergedContact);
  } catch (error) {
    return err({
      type: 'MERGE_CONFLICT',
      reason: error instanceof Error ? error.message : 'Failed to merge contacts',
    });
  }
}

/**
 * Validate contact creation data
 */
function validateContactData(data: ContactCreateData): Result<ContactCreateData, ContactError> {
  const errors: Record<string, string> = {};

  // Required fields
  if (!isNonEmptyString(data.firstName)) {
    errors.firstName = 'First name is required';
  }

  if (!isNonEmptyString(data.lastName)) {
    errors.lastName = 'Last name is required';
  }

  // Email validation
  if (isNonEmptyString(data.email)) {
    const emailValidation = validateEmailFormat(data.email);
    if (emailValidation.isErr()) {
      errors.email =
        'reason' in emailValidation.error ? emailValidation.error.reason : 'Invalid email format';
    }
  }

  // Phone validation
  if (isNonEmptyString(data.phone)) {
    const phoneValidation = validatePhoneFormat(data.phone);
    if (phoneValidation.isErr()) {
      errors.phone =
        'reason' in phoneValidation.error ? phoneValidation.error.reason : 'Invalid phone format';
    }
  }

  // Date of birth validation
  if (data.dateOfBirth) {
    const age = calculateAge(data.dateOfBirth);
    if (age < 0 || age > 150) {
      errors.dateOfBirth = 'Invalid date of birth';
    }
  }

  if (Object.keys(errors).length > 0) {
    return err({
      type: 'VALIDATION_FAILED',
      errors,
    });
  }

  return ok(data);
}

/**
 * Validate contact update data
 */
function validateContactUpdateData(
  data: ContactUpdateData
): Result<ContactUpdateData, ContactError> {
  const errors: Record<string, string> = {};

  // Email validation - only validate if provided and non-empty
  if (isNonEmptyString(data.email)) {
    const emailValidation = validateEmailFormat(data.email);
    if (emailValidation.isErr()) {
      errors.email =
        'reason' in emailValidation.error ? emailValidation.error.reason : 'Invalid email format';
    }
  }

  // Phone validation - only validate if provided and non-empty
  if (isNonEmptyString(data.phone)) {
    const phoneValidation = validatePhoneFormat(data.phone);
    if (phoneValidation.isErr()) {
      errors.phone =
        'reason' in phoneValidation.error ? phoneValidation.error.reason : 'Invalid phone format';
    }
  }

  // Date of birth validation
  if (data.dateOfBirth) {
    const age = calculateAge(data.dateOfBirth);
    if (age < 0 || age > 150) {
      errors.dateOfBirth = 'Invalid date of birth';
    }
  }

  if (Object.keys(errors).length > 0) {
    return err({
      type: 'VALIDATION_FAILED',
      errors,
    });
  }

  return ok(data);
}

/**
 * Calculate age from date of birth
 */
function calculateAge(dateOfBirth: Date): number {
  const today = new Date();
  const birthDate = new Date(dateOfBirth);
  let age = today.getFullYear() - birthDate.getFullYear();
  const monthDiff = today.getMonth() - birthDate.getMonth();

  if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birthDate.getDate())) {
    age--;
  }

  return age;
}

function isNonEmptyString(value: string | null | undefined): value is string {
  return typeof value === 'string' && value.trim().length > 0;
}

function normalizeString(value?: string | null): string | undefined {
  return isNonEmptyString(value) ? value : undefined;
}

function pickPreferredString(
  primary?: string | null,
  secondary?: string | null
): string | undefined {
  const normalizedPrimary = normalizeString(primary);
  if (normalizedPrimary !== undefined) {
    return normalizedPrimary;
  }

  return normalizeString(secondary);
}

/**
 * Combine notes from two contacts
 */
function combineNotes(
  notes1?: string,
  notes2?: string,
  strategy: 'prefer-primary' | 'combine' = 'combine'
): string | undefined {
  const primaryNotes = normalizeString(notes1);
  const secondaryNotes = normalizeString(notes2);

  if (primaryNotes === undefined && secondaryNotes === undefined) {
    return undefined;
  }

  if (primaryNotes === undefined) {
    return secondaryNotes;
  }

  if (secondaryNotes === undefined) {
    return primaryNotes;
  }

  if (strategy === 'prefer-primary') {
    return primaryNotes;
  }

  return `${primaryNotes}\n\n---\n\n${secondaryNotes}`;
}

/**
 * Combine two optional string fields
 */
function combineFields(field1?: string, field2?: string): string | undefined {
  const first = normalizeString(field1);
  const second = normalizeString(field2);

  if (first === undefined && second === undefined) {
    return undefined;
  }

  if (first === undefined) {
    return second;
  }

  if (second === undefined) {
    return first;
  }

  if (first === second) {
    return first;
  }

  return `${first} / ${second}`;
}

/**
 * Merge two arrays removing duplicates
 */
function mergeArrays<T>(arr1: T[], arr2: T[]): T[] {
  return Array.from(new Set([...arr1, ...arr2]));
}

/**
 * Generate a temporary contact ID (for client-side only)
 * In production, this would be generated by the backend
 */
function generateContactId(): ContactId {
  const timestamp = Date.now().toString(36);
  const randomSegment = Math.random().toString(36).slice(2, 11);
  return `temp_${timestamp}_${randomSegment}` as ContactId;
}

/**
 * Check if contact has required email or phone
 */
export function hasContactInfo(contact: Contact): boolean {
  const hasEmail = isNonEmptyString(contact.email);
  const hasPhone = isNonEmptyString(contact.phone);
  const hasMobile = isNonEmptyString(contact.mobile);

  return hasEmail || hasPhone || hasMobile;
}

/**
 * Check if contact is complete (has all recommended fields)
 */
export function isCompleteContact(contact: Contact): boolean {
  const hasFirstName = isNonEmptyString(contact.firstName);
  const hasLastName = isNonEmptyString(contact.lastName);
  const hasEmail = isNonEmptyString(contact.email);
  const hasPhone = isNonEmptyString(contact.phone);
  const hasCompany = isNonEmptyString(contact.company);

  return hasFirstName && hasLastName && (hasEmail || hasPhone) && hasCompany;
}

/**
 * Format contact for display
 */
export function formatContactDisplay(contact: Contact): string {
  const parts: string[] = [contact.fullName];

  const jobTitle = normalizeString(contact.jobTitle);
  const company = normalizeString(contact.company);
  const email = normalizeString(contact.email);
  const phone = normalizeString(contact.phone);

  if (jobTitle !== undefined && company !== undefined) {
    parts.push(`${jobTitle} at ${company}`);
  } else if (jobTitle !== undefined) {
    parts.push(jobTitle);
  } else if (company !== undefined) {
    parts.push(company);
  }

  if (email !== undefined) {
    parts.push(email);
  }

  if (phone !== undefined) {
    parts.push(phone);
  }

  return parts.join(' • ');
}
