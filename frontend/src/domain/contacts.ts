/**
 * Contact Management Domain Logic
 * 
 * Pure functions for contact management operations using Railway-Oriented Programming.
 * All functions return Result<T, E> for explicit error handling.
 * 
 * This module extracts business logic from the service layer,
 * making it pure, testable, and composable.
 */

import { ok, err, Result } from 'neverthrow';
import type { Contact } from '../types/contact';
import type { ContactId, UserId, TenantId } from '../types/ids';

/**
 * Contact-specific errors
 */
export type ContactError =
  | { type: 'INVALID_DATA'; field: string; reason: string }
  | { type: 'DUPLICATE_CONTACT'; field: string; value: string }
  | { type: 'NOT_FOUND'; contactId: ContactId }
  | { type: 'MERGE_CONFLICT'; reason: string }
  | { type: 'VALIDATION_FAILED'; errors: Record<string, string> }
  | { type: 'UNAUTHORIZED'; message: string };

/**
 * Contact creation data (input DTO)
 */
export interface ContactCreateData {
  firstName: string;
  lastName: string;
  email?: string;
  phone?: string;
  mobile?: string;
  company?: string;
  jobTitle?: string;
  dateOfBirth?: Date;
  gender?: 'male' | 'female';
  notes?: string;
  tags?: string[];
  customFields?: Record<string, any>;
}

/**
 * Contact update data (partial)
 */
export type ContactUpdateData = Partial<ContactCreateData>;

/**
 * Merge strategy for combining contacts
 */
export type MergeStrategy = 'prefer-primary' | 'prefer-secondary' | 'combine';

/**
 * Create a new contact with validation
 * 
 * @param data - Contact creation data
 * @param userId - ID of user creating the contact
 * @param tenantId - ID of the tenant
 * @returns Result containing Contact or ContactError
 */
export function createContact(
  data: ContactCreateData,
  userId: UserId,
  tenantId: TenantId
): Result<Contact, ContactError> {
  // Validate required fields
  const validationResult = validateContactData(data);
  if (validationResult.isErr()) {
    return err(validationResult.error);
  }

  try {
    // Generate full name
    const fullName = `${data.firstName} ${data.lastName}`.trim();

    // Calculate age if date of birth provided
    const age = data.dateOfBirth ? calculateAge(data.dateOfBirth) : undefined;

    // Create contact object
    const now = new Date();
    const contact: Contact = {
      id: generateContactId(), // This would be generated by backend in real app
      tenantId,
      firstName: data.firstName,
      lastName: data.lastName,
      fullName,
      email: data.email,
      phone: data.phone,
      mobile: data.mobile,
      company: data.company,
      jobTitle: data.jobTitle,
      dateOfBirth: data.dateOfBirth,
      gender: data.gender,
      age,
      notes: data.notes,
      tags: data.tags || [],
      customFields: data.customFields,
      createdAt: now,
      updatedAt: now,
      createdBy: userId,
      updatedBy: userId,
      isActive: true,
    };

    return ok(contact);
  } catch (error) {
    return err({
      type: 'INVALID_DATA',
      field: 'unknown',
      reason: error instanceof Error ? error.message : 'Failed to create contact',
    });
  }
}

/**
 * Update an existing contact
 * 
 * @param existingContact - Current contact data
 * @param updateData - Fields to update
 * @param userId - ID of user updating the contact
 * @returns Result containing updated Contact or ContactError
 */
export function updateContact(
  existingContact: Contact,
  updateData: ContactUpdateData,
  userId: UserId
): Result<Contact, ContactError> {
  // Validate update data
  const validationResult = validateContactUpdateData(updateData);
  if (validationResult.isErr()) {
    return err(validationResult.error);
  }

  try {
    // Create updated contact
    const updatedContact: Contact = {
      ...existingContact,
      ...updateData,
      // Recalculate derived fields
      fullName: updateData.firstName || updateData.lastName
        ? `${updateData.firstName || existingContact.firstName} ${updateData.lastName || existingContact.lastName}`.trim()
        : existingContact.fullName,
      age: updateData.dateOfBirth
        ? calculateAge(updateData.dateOfBirth)
        : existingContact.age,
      // Update metadata
      updatedAt: new Date(),
      updatedBy: userId,
    };

    return ok(updatedContact);
  } catch (error) {
    return err({
      type: 'INVALID_DATA',
      field: 'unknown',
      reason: error instanceof Error ? error.message : 'Failed to update contact',
    });
  }
}

/**
 * Merge two contacts into one
 * 
 * @param primary - Primary contact (base)
 * @param secondary - Secondary contact (to merge)
 * @param strategy - Merge strategy
 * @param userId - ID of user performing the merge
 * @returns Result containing merged Contact or ContactError
 */
export function mergeContacts(
  primary: Contact,
  secondary: Contact,
  strategy: MergeStrategy,
  userId: UserId
): Result<Contact, ContactError> {
  // Validate contacts are from same tenant
  if (primary.tenantId !== secondary.tenantId) {
    return err({
      type: 'MERGE_CONFLICT',
      reason: 'Cannot merge contacts from different tenants',
    });
  }

  // Validate contacts are different
  if (primary.id === secondary.id) {
    return err({
      type: 'MERGE_CONFLICT',
      reason: 'Cannot merge contact with itself',
    });
  }

  try {
    let mergedContact: Contact;

    switch (strategy) {
      case 'prefer-primary':
        mergedContact = {
          ...primary,
          // Only take secondary fields that are missing in primary
          email: primary.email || secondary.email,
          phone: primary.phone || secondary.phone,
          mobile: primary.mobile || secondary.mobile,
          company: primary.company || secondary.company,
          jobTitle: primary.jobTitle || secondary.jobTitle,
          dateOfBirth: primary.dateOfBirth || secondary.dateOfBirth,
          gender: primary.gender || secondary.gender,
          notes: combineNotes(primary.notes, secondary.notes, 'prefer-primary'),
          tags: mergeArrays(primary.tags || [], secondary.tags || []),
          updatedAt: new Date(),
          updatedBy: userId,
        };
        break;

      case 'prefer-secondary':
        mergedContact = {
          ...secondary,
          id: primary.id, // Keep primary ID
          tenantId: primary.tenantId,
          createdAt: primary.createdAt, // Keep original creation time
          createdBy: primary.createdBy,
          email: secondary.email || primary.email,
          phone: secondary.phone || primary.phone,
          mobile: secondary.mobile || primary.mobile,
          company: secondary.company || primary.company,
          jobTitle: secondary.jobTitle || primary.jobTitle,
          dateOfBirth: secondary.dateOfBirth || primary.dateOfBirth,
          gender: secondary.gender || primary.gender,
          notes: combineNotes(secondary.notes, primary.notes, 'prefer-primary'),
          tags: mergeArrays(secondary.tags || [], primary.tags || []),
          updatedAt: new Date(),
          updatedBy: userId,
        };
        break;

      case 'combine':
        mergedContact = {
          ...primary,
          // Combine all non-empty fields
          email: primary.email || secondary.email,
          phone: primary.phone || secondary.phone,
          mobile: primary.mobile || secondary.mobile,
          company: combineFields(primary.company, secondary.company),
          jobTitle: combineFields(primary.jobTitle, secondary.jobTitle),
          dateOfBirth: primary.dateOfBirth || secondary.dateOfBirth,
          gender: primary.gender || secondary.gender,
          notes: combineNotes(primary.notes, secondary.notes, 'combine'),
          tags: mergeArrays(primary.tags || [], secondary.tags || []),
          updatedAt: new Date(),
          updatedBy: userId,
        };
        break;
    }

    return ok(mergedContact);
  } catch (error) {
    return err({
      type: 'MERGE_CONFLICT',
      reason: error instanceof Error ? error.message : 'Failed to merge contacts',
    });
  }
}

/**
 * Validate contact creation data
 */
function validateContactData(data: ContactCreateData): Result<ContactCreateData, ContactError> {
  const errors: Record<string, string> = {};

  // Required fields
  if (!data.firstName || data.firstName.trim().length === 0) {
    errors.firstName = 'First name is required';
  }

  if (!data.lastName || data.lastName.trim().length === 0) {
    errors.lastName = 'Last name is required';
  }

  // Email validation
  if (data.email && !isValidEmail(data.email)) {
    errors.email = 'Invalid email format';
  }

  // Phone validation
  if (data.phone && !isValidPhone(data.phone)) {
    errors.phone = 'Invalid phone format';
  }

  // Date of birth validation
  if (data.dateOfBirth) {
    const age = calculateAge(data.dateOfBirth);
    if (age < 0 || age > 150) {
      errors.dateOfBirth = 'Invalid date of birth';
    }
  }

  if (Object.keys(errors).length > 0) {
    return err({
      type: 'VALIDATION_FAILED',
      errors,
    });
  }

  return ok(data);
}

/**
 * Validate contact update data
 */
function validateContactUpdateData(data: ContactUpdateData): Result<ContactUpdateData, ContactError> {
  const errors: Record<string, string> = {};

  // Email validation
  if (data.email !== undefined && data.email !== null && !isValidEmail(data.email)) {
    errors.email = 'Invalid email format';
  }

  // Phone validation
  if (data.phone !== undefined && data.phone !== null && !isValidPhone(data.phone)) {
    errors.phone = 'Invalid phone format';
  }

  // Date of birth validation
  if (data.dateOfBirth) {
    const age = calculateAge(data.dateOfBirth);
    if (age < 0 || age > 150) {
      errors.dateOfBirth = 'Invalid date of birth';
    }
  }

  if (Object.keys(errors).length > 0) {
    return err({
      type: 'VALIDATION_FAILED',
      errors,
    });
  }

  return ok(data);
}

/**
 * Calculate age from date of birth
 */
function calculateAge(dateOfBirth: Date): number {
  const today = new Date();
  const birthDate = new Date(dateOfBirth);
  let age = today.getFullYear() - birthDate.getFullYear();
  const monthDiff = today.getMonth() - birthDate.getMonth();
  
  if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birthDate.getDate())) {
    age--;
  }
  
  return age;
}

/**
 * Validate email format
 */
function isValidEmail(email: string): boolean {
  const emailRegex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;
  return emailRegex.test(email);
}

/**
 * Validate phone format (simple validation)
 */
function isValidPhone(phone: string): boolean {
  const phoneRegex = /^\+?[1-9]\d{1,14}$/;
  return phoneRegex.test(phone.replace(/[\s-()]/g, ''));
}

/**
 * Combine notes from two contacts
 */
function combineNotes(notes1?: string, notes2?: string, strategy: 'prefer-primary' | 'combine' = 'combine'): string | undefined {
  if (!notes1 && !notes2) return undefined;
  if (!notes1) return notes2;
  if (!notes2) return notes1;
  
  if (strategy === 'prefer-primary') {
    return notes1;
  }
  
  return `${notes1}\n\n---\n\n${notes2}`;
}

/**
 * Combine two optional string fields
 */
function combineFields(field1?: string, field2?: string): string | undefined {
  if (!field1 && !field2) return undefined;
  if (!field1) return field2;
  if (!field2) return field1;
  if (field1 === field2) return field1;
  return `${field1} / ${field2}`;
}

/**
 * Merge two arrays removing duplicates
 */
function mergeArrays<T>(arr1: T[], arr2: T[]): T[] {
  return Array.from(new Set([...arr1, ...arr2]));
}

/**
 * Generate a temporary contact ID (for client-side only)
 * In production, this would be generated by the backend
 */
function generateContactId(): ContactId {
  return `temp_${Date.now()}_${Math.random().toString(36).substr(2, 9)}` as ContactId;
}

/**
 * Check if contact has required email or phone
 */
export function hasContactInfo(contact: Contact): boolean {
  return !!(contact.email || contact.phone || contact.mobile);
}

/**
 * Check if contact is complete (has all recommended fields)
 */
export function isCompleteContact(contact: Contact): boolean {
  return !!(
    contact.firstName &&
    contact.lastName &&
    (contact.email || contact.phone) &&
    contact.company
  );
}

/**
 * Format contact for display
 */
export function formatContactDisplay(contact: Contact): string {
  const parts: string[] = [contact.fullName];
  
  if (contact.jobTitle && contact.company) {
    parts.push(`${contact.jobTitle} at ${contact.company}`);
  } else if (contact.jobTitle) {
    parts.push(contact.jobTitle);
  } else if (contact.company) {
    parts.push(contact.company);
  }
  
  if (contact.email) {
    parts.push(contact.email);
  }
  
  if (contact.phone) {
    parts.push(contact.phone);
  }
  
  return parts.join(' • ');
}
